generated_code,is_quality_issue,quality_info,MultipleVariableDeclarations,AvoidReassigningParameters,ForLoopCanBeForeach
"class Solution {     public int[] twoSum(int[] nums, int target) {         Map<Integer, Integer> map = new HashMap<>();         for (int i = 0; i < nums.length; i++) {             int complement = target - nums[i];             if (map.containsKey(complement)) {                 return new int[] { map.get(complement), i };             }             map.put(nums[i], i);         }         throw new IllegalArgumentException(""No two sum solution"");     } }",0,,0,0,0
class Solution {     public boolean isPalindrome(int x) {         // Checking for negative numbers and numbers with a last digit of zero.         if (x < 0 || (x % 10 == 0 && x != 0)) {             return false;         }          int reversed = 0;         // Reversing the second half of the number and comparing it with the first half.         while (x > reversed) {             reversed = reversed * 10 + x % 10;             x /= 10;         }          return x == reversed || x == reversed / 10;     } },1,"009-palindrome-number/Solution.java:12:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'x'
",0,1,0
"class Solution {     public int romanToInt(String s) {         int result = 0;         Map<Character, Integer> map = new HashMap<>();         map.put('I', 1);         map.put('V', 5);         map.put('X', 10);         map.put('L', 50);         map.put('C', 100);         map.put('D', 500);         map.put('M', 1000);         for (int i = 0; i < s.length(); i++) {             if (i > 0 && map.get(s.charAt(i)) > map.get(s.charAt(i-1))) {                 result += map.get(s.charAt(i)) - 2 * map.get(s.charAt(i-1));             } else {                 result += map.get(s.charAt(i));             }         }         return result;     } }",0,,0,0,0
"class Solution {     public String longestCommonPrefix(String[] strs) {         if (strs == null || strs.length == 0) {             return """";         }          // We start with the first string and look for the longest common prefix         String prefix = strs[0];         for (int i = 1; i < strs.length; i++) {             String current = strs[i];             // If the prefix is not found in the string, we keep removing the last character and retry             while (current.indexOf(prefix) != 0) {                 prefix = prefix.substring(0, prefix.length() - 1);             }         }         return prefix;     } }",0,,0,0,0
class Solution {     public boolean isValid(String s) {         Stack<Character> stack = new Stack<Character>();         for (char c : s.toCharArray()) {             if (c == '(' || c == '[' || c == '{')                 stack.push(c);             else if (c == ')' && !stack.isEmpty() && stack.peek() == '(')                 stack.pop();             else if (c == ']' && !stack.isEmpty() && stack.peek() == '[')                 stack.pop();             else if (c == '}' && !stack.isEmpty() && stack.peek() == '{')                 stack.pop();             else                 return false;         }         return stack.isEmpty();     } },0,,0,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public ListNode mergeTwoLists(ListNode list1, ListNode list2) {         ListNode dummy = new ListNode(-1);         ListNode prev = dummy;                  while(list1 != null && list2 != null) {             if(list1.val <= list2.val) {                 prev.next = list1;                 list1 = list1.next;             } else {                 prev.next = list2;                 list2 = list2.next;             }             prev = prev.next;         }                  if(list1 != null) {             prev.next = list1;         }                  if(list2 != null) {             prev.next = list2;         }                  return dummy.next;     } }",1,"021-merge-two-sorted-lists/ListNode.java:19:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'list1'
021-merge-two-sorted-lists/ListNode.java:22:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'list2'
",0,1,0
class Solution {     public int removeDuplicates(int[] nums) {         if (nums.length == 0) {             return 0;         }         int i = 0;         for (int j = 1; j < nums.length; j++) {             if (nums[j] != nums[i]) {                 i++;                 nums[i] = nums[j];             }         }         return i + 1;     } },0,,0,0,0
"class Solution {     public int removeElement(int[] nums, int val) {         int k = 0; // current index of the new array         for (int i = 0; i < nums.length; i++) {             if (nums[i] != val) {                 nums[k++] = nums[i];             }         }         return k;     } }",1,"027-remove-element/Solution.java:4:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int strStr(String haystack, String needle) {         if (needle == null || needle.length() == 0) {             return 0;         }          if (haystack == null || haystack.length() == 0) {             return -1;         }          int n = haystack.length();         int m = needle.length();          for (int i = 0; i <= n - m; i++) {             int j = 0;              while (j < m && haystack.charAt(i + j) == needle.charAt(j)) {                 j++;             }              if (j == m) {                 return i;             }         }          return -1;     } }",0,,0,0,0
"class Solution {     public int searchInsert(int[] nums, int target) {         int start = 0, end = nums.length - 1;         while (start <= end) {             int mid = start + (end - start) / 2;             if (nums[mid] == target) {                 return mid;             }             if (nums[mid] < target) {                 start = mid + 1;             } else {                 end = mid - 1;             }         }         return start;     } }",1,"035-search-insert-position/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int lengthOfLastWord(String s) {         String[] split = s.split("" ""); // split the string by space         if (split.length == 0) { // edge case for empty string             return 0;         }         String lastWord = split[split.length - 1]; // get the last word         return lastWord.length();     } }",0,,0,0,0
"class Solution {     public int[] plusOne(int[] digits) {         int n = digits.length;                  // Incrementing the least significant digit by 1         digits[n - 1]++;          // Checking if the digit is less than or equal to 9, if it is return digits as it is         if (digits[n - 1] <= 9) {             return digits;         }                  // Reversing the digits array and updating each digit, adding carry as needed.         int carry = 1;         for (int i = 0; i < n; i++) {             int sum = carry + digits[n - 1 - i];             digits[n - 1 - i] = sum % 10;             carry = sum / 10;         }                  // If there is a carry, we need to create a new array         if (carry == 1) {             int[] result = new int[n + 1];             result[0] = carry;             for (int i = 1; i <= n; i++) {                 result[i] = digits[i - 1];             }             digits = result;         }                  return digits;     } }",1,"066-plus-one/Solution.java:25:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
066-plus-one/Solution.java:28:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'digits'
",0,1,0
"class Solution {     public String addBinary(String a, String b) {         StringBuilder sb = new StringBuilder();         int i = a.length() - 1, j = b.length() - 1, carry = 0;         while (i >= 0 || j >= 0) {             int sum = carry;             if (i >= 0) sum += a.charAt(i--) - '0';             if (j >= 0) sum += b.charAt(j--) - '0';             sb.append(sum % 2);             carry = sum / 2;         }         if (carry != 0) sb.append(carry);         return sb.reverse().toString();     } }",1,"067-add-binary/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int mySqrt(int x) {         if (x == 0 || x == 1)             return x;                  int low = 0, high = x, ans = 0;                  while (low <= high) {             int mid = low + (high - low) / 2;                          if (mid == x / mid)                 return mid;             else if (mid < x / mid) {                 low = mid + 1;                 ans = mid;             } else {                 high = mid - 1;             }         }         return ans;     } }",1,"069-sqrtx/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
class Solution {     public int climbStairs(int n) {         if (n == 1) return 1;                  int[] dp = new int[n+1];         dp[1] = 1;         dp[2] = 2;                  for (int i=3; i<=n; i++) {             dp[i] = dp[i-1] + dp[i-2];         }                  return dp[n];     } },0,,0,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public ListNode deleteDuplicates(ListNode head) {         if (head == null) {             return null;         }         ListNode current = head;         while (current.next != null) {             if (current.val == current.next.val) {                 current.next = current.next.next;             } else {                 current = current.next;             }         }         return head;     } }",0,,0,0,0
"class Solution {     public void merge(int[] nums1, int m, int[] nums2, int n) {         int i = m - 1; // assign the last index of the first array, i.e. nums1         int j = n - 1; // assign the last index of second array, i.e. nums2         int k = m + n - 1; // assign the last index of the merged array                  while(j >= 0) {             if(i >= 0 && nums1[i] > nums2[j]) {                 nums1[k--] = nums1[i--];             } else {                 nums1[k--] = nums2[j--];             }         }     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public List<Integer> inorderTraversal(TreeNode root) {         List<Integer> result = new ArrayList<>();         if (root == null) return result;                  Stack<TreeNode> stack = new Stack<>();         TreeNode curr = root;                  while (curr != null || !stack.empty()) {             while (curr != null) {                 stack.push(curr);                 curr = curr.left;             }             curr = stack.pop();             result.add(curr.val);             curr = curr.right;         }                  return result;     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public boolean isSameTree(TreeNode p, TreeNode q) {         // If both trees are null, they are the same         if (p == null && q == null) {             return true;         }         // If only one of the trees is null, they are not the same         if (p == null || q == null) {             return false;         }         // If the values are not equal, they are not the same         if (p.val != q.val) {             return false;         }         // Recursively check the left and right subtrees         return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);     } }",0,,0,0,0
"import java.util.*;  class Solution {     public List<String> commonChars(String[] words) {         List<String> result = new ArrayList<>();         if (words == null || words.length == 0) {             return result;         }         int[] minFreq = new int[26];         Arrays.fill(minFreq, Integer.MAX_VALUE);          for (String word : words) {             int[] curFreq = new int[26];             int wordLength = word.length();              for (int i = 0; i < wordLength; i++) {                 char ch = word.charAt(i);                 curFreq[ch - 'a']++;             }              for (int i =0; i < 26; i++) {                 minFreq[i] = Math.min(minFreq[i], curFreq[i]);             }         }          for (int i =0; i < 26; i++) {             for (int j = 0; j < minFreq[i]; j++) {                 char ch = (char) (i + 'a');                 result.add(String.valueOf(ch));             }         }          return result;     } }",0,,0,0,0
"class Solution {     public int largestSumAfterKNegations(int[] nums, int k) {         Arrays.sort(nums); // sort the array         int i = 0;         while (k > 0 && i < nums.length && nums[i] < 0) { // check if the number is negative             nums[i] = -nums[i]; // negate the number             i++; // move to the next number             k--; // decrement the value of k         }         Arrays.sort(nums); // sort the array again to get the largest sum         if (k % 2 == 1) {             nums[0] = -nums[0]; // if k is odd, negate the smallest number         }         int sum = 0;         for (int num : nums) { // calculate the sum of array             sum += num;         }         return sum;     } }",1,"1005-maximize-sum-of-array-after-k-negations/Solution.java:8:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'k'
",0,1,0
"class Solution {     public int bitwiseComplement(int n) {         if(n==0) return 1; //edge case         int num = n, bit = 1;         while(num!=0){             n ^= bit; //xor operation between the number and the bit             bit <<= 1; //left shift the bit by one place             num >>= 1; //right shift the number by one place         }         return n;     } }",1,"1009-complement-of-base-10-integer/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1009-complement-of-base-10-integer/Solution.java:6:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
",1,1,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public boolean isSymmetric(TreeNode root) {         if(root == null) return true;         return checkSymmetric(root.left, root.right);     }          public boolean checkSymmetric(TreeNode left, TreeNode right) {         if(left == null && right == null) return true;         if(left == null || right == null) return false;         if(left.val != right.val) return false;         return checkSymmetric(left.left, right.right) && checkSymmetric(left.right, right.left);     } }",1,"101-symmetric-tree/TreeNode.java:18:	SimplifyBooleanReturns:	This if statement can be replaced by `return {condition} || {elseBranch};`
",0,0,0
class Solution {     public boolean canThreePartsEqualSum(int[] arr) {                  int sum = 0;         for(int i=0; i< arr.length; i++){             sum += arr[i];         }                  if(sum % 3 != 0){             return false;         }                  int i = 0;         int j = arr.length-1;         int leftSum = 0;         int rightSum = 0;         int target = sum/3;                  while(i<j){             if(leftSum!=target){                 leftSum += arr[i++];             }             if(rightSum!=target){                 rightSum += arr[j--];             }             if(leftSum == target && rightSum == target){                 return true;             }         }                  return false;     } },1,"1013-partition-array-into-three-parts-with-equal-sum/Solution.java:5:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public List<Boolean> prefixesDivBy5(int[] nums) {         List<Boolean> answer = new ArrayList<Boolean>();         int remainder = 0;         for (int i = 0; i < nums.length; i++) {             remainder = ((remainder << 1) + nums[i]) % 5;             answer.add(remainder == 0);         }         return answer;     } }   // Driver Code public class Main {     public static void main(String[] args) {         Solution sol = new Solution();         int[] nums = {1, 0, 1, 0, 1};         List<Boolean> answer = sol.prefixesDivBy5(nums);         System.out.println(answer);     } }   /*      Expected output:      [false, false, false, true, false] */",1,"1018-binary-prefix-divisible-by-5/Main.java:14:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
1018-binary-prefix-divisible-by-5/Main.java:5:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
1018-binary-prefix-divisible-by-5/Main.java:14:	UseUtilityClass:	This utility class has a non-private constructor
",0,0,1
class Solution {     public String removeOuterParentheses(String s) {         StringBuilder sb = new StringBuilder();         int count = 0;         for (char c : s.toCharArray()) {             if (c == '(' && count++ > 0) sb.append(c);             if (c == ')' && --count > 0) sb.append(c);         }         return sb.toString();     } },1,"1021-remove-outermost-parentheses/Solution.java:6:	AssignmentInOperand:	Avoid assignments in operands
1021-remove-outermost-parentheses/Solution.java:7:	AssignmentInOperand:	Avoid assignments in operands
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public int sumRootToLeaf(TreeNode root) {         return dfs(root, 0);     }          private int dfs(TreeNode node, int sum) {         if (node == null) {             return 0;         }         sum = 2 * sum + node.val;         if (node.left == null && node.right == null) {             return sum;         }         return dfs(node.left, sum) + dfs(node.right, sum);     } }",1,"1022-sum-of-root-to-leaf-binary-numbers/TreeNode.java:25:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'sum'
",0,1,0
"class Solution {     public boolean divisorGame(int n) {         // Alice starts first         // return true if n is even, since Alice can always choose x=1 and get an odd number         // then Bob will always get an odd number and the next even number         // Since Alice starts first, she will always end up with the number 2 and win the game         // return false if n is odd, since Alice will get an odd number after the first move          return n % 2 == 0;     } }",0,,0,0,0
"class Solution {          public int[][] allCellsDistOrder(int rows, int cols, int rCenter, int cCenter) {                  // Create an array to hold the result         int[][] result = new int[rows * cols][2];                  // Initialize the array index         int index = 0;                  // Loop through all the cells in the matrix         for (int i = 0; i < rows; i++) {             for (int j = 0; j < cols; j++) {                                  // Calculate the manhattan distance from the target cell                 int distance = Math.abs(i - rCenter) + Math.abs(j - cCenter);                                  // Store the row and column indices along with their distance                 result[index][0] = i;                 result[index][1] = j;                 result[index][2] = distance;                                  // Increment the index                 index++;             }         }                  // Sort the result based on their distance from the target cell         Arrays.sort(result, (a, b) -> a[2] - b[2]);                  // Copy the result to a new array to exclude the distance         int[][] output = new int[rows * cols][2];         for (int i = 0; i < rows * cols; i++) {             output[i][0] = result[i][0];             output[i][1] = result[i][1];         }                  // Return the output array         return output;     } }",0,,0,0,0
"class Solution {     public boolean isBoomerang(int[][] points) {         int x1 = points[0][0], y1 = points[0][1];         int x2 = points[1][0], y2 = points[1][1];         int x3 = points[2][0], y3 = points[2][1];         return (y2-y1)*(x3-x2) != (y3-y2)*(x2-x1);  // if slope is not equal, not in straight line     } }",1,"1037-valid-boomerang/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1037-valid-boomerang/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1037-valid-boomerang/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public int maxDepth(TreeNode root) {         if(root == null) return 0;         int leftDepth = maxDepth(root.left);         int rightDepth = maxDepth(root.right);         return Math.max(leftDepth, rightDepth) + 1;     } }",0,,0,0,0
"class Solution {     public int lastStoneWeight(int[] stones) {         // We can use a priority queue to keep track of the heaviest stones         PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());         for (int stone : stones) {             maxHeap.offer(stone);         }                  // Smash stones until there is at most one left         while (maxHeap.size() > 1) {             int y = maxHeap.poll();             int x = maxHeap.poll();             if (x != y) {                 maxHeap.offer(y - x);             }         }                  // Return the weight of the last remaining stone, or 0 if there are no stones left         return maxHeap.isEmpty() ? 0 : maxHeap.peek();     } }",0,,0,0,0
"class Solution {     public String removeDuplicates(String s) {         StringBuilder sb = new StringBuilder();         int n = s.length();         int j = 0;         char[] chars = s.toCharArray();         for(int i = 0; i < n; i++, j++) {             chars[j] = chars[i];             if(j > 0 && chars[j - 1] == chars[j])                 j = j - 2;         }         return new String(chars, 0, j);     } }",1,"1047-remove-all-adjacent-duplicates-in-string/Solution.java:3:	UnusedLocalVariable:	Avoid unused local variables such as 'sb'.
",0,0,0
"class Solution {     public int heightChecker(int[] heights) {         int[] expected = Arrays.copyOf(heights, heights.length);         Arrays.sort(expected);         int mismatchCount = 0;         for (int i = 0; i < heights.length; i++) {             if (heights[i] != expected[i]) {                 mismatchCount++;             }         }         return mismatchCount;     } }",0,,0,0,0
"class Solution {     public String gcdOfStrings(String str1, String str2) {                  // If strings are equal, return the string itself         if(str1.equals(str2)){             return str1;         }                  // If the length of first string is less than second, swap         if(str1.length() < str2.length()){             String temp = str1;             str1 = str2;             str2 = temp;         }                  // Check if second string divides the first string completely         if(str1.startsWith(str2) && gcdOfStrings(str1.substring(str2.length()), str2).equals(str2)){             return str2;  //If yes, return the second string         }                  return """"; //Otherwise, return an empty string     } }",1,"1071-greatest-common-divisor-of-strings/Solution.java:12:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'str1'
1071-greatest-common-divisor-of-strings/Solution.java:13:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'str2'
",0,1,0
"class Solution {     public String[] findOcurrences(String text, String first, String second) {         //Split text to get each word         String[] words = text.split("" "");         //Resulting list to store occurrences         List<String> resultList = new ArrayList<>();                  //Iterate through words comparing each set of 3 words         for(int i=0; i<words.length-2; i++){             if(words[i].equals(first) && words[i+1].equals(second)){                 resultList.add(words[i+2]);             }         }                  //Convert list to array and return         return resultList.toArray(new String[0]);     } }",0,,0,0,0
"class Solution {     public String[] findOcurrences(String text, String first, String second) {         //Split text to get each word         String[] words = text.split("" "");         //Resulting list to store occurrences         List<String> resultList = new ArrayList<>();                  //Iterate through words comparing each set of 3 words         for(int i=0; i<words.length-2; i++){             if(words[i].equals(first) && words[i+1].equals(second)){                 resultList.add(words[i+2]);             }         }                  //Convert list to array and return         return resultList.toArray(new String[0]);     } }",0,,0,0,0
class Solution {     public void duplicateZeros(int[] arr) {         int n = arr.length;         for (int i = 0; i < n; i++) {             //check if value at arr[i] is zero             if (arr[i] == 0) {                 //shift elements of array to right                 for (int j = n - 1; j > i; j--) {                     arr[j] = arr[j - 1];                 }                 //insert a zero at i+1 index                 i++;                 if (i < n) {                     arr[i] = 0;                 }             }         }     } },1,"1089-duplicate-zeros/Solution.java:4:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
1089-duplicate-zeros/Solution.java:8:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {          // helper function to check if tree is height-balanced or not     private boolean isBalancedHelper(TreeNode root, int[] height) {                  // check if root node is null         if(root == null) {             height[0] = 0;             return true;         }                  // check if left subtree is height-balanced or not         int[] leftHeight = new int[1];         boolean isLeftBalanced = isBalancedHelper(root.left, leftHeight);                  // check if right subtree is height-balanced or not         int[] rightHeight = new int[1];         boolean isRightBalanced = isBalancedHelper(root.right, rightHeight);                  // Height of current node is max height of left and right subtree + 1         height[0] = Math.max(leftHeight[0], rightHeight[0]) + 1;                  // If both left and right subtrees are height balanced and the difference between their height is less than or equal to 1, then return true. Otherwise return false.         if(isLeftBalanced && isRightBalanced && Math.abs(leftHeight[0] - rightHeight[0]) <= 1) {             return true;         }                  return false;     }          public boolean isBalanced(TreeNode root) {                  int[] height = new int[1];         return isBalancedHelper(root, height);     } }",1,"110-balanced-binary-tree/TreeNode.java:39:	SimplifyBooleanReturns:	This if statement can be replaced by `return {condition};`
",0,0,0
"class Solution {     public int[] distributeCandies(int candies, int num_people) {         int[] result = new int[num_people];         int i = 0, currCandies = 1;         while (candies > 0) {             if (i == num_people) {                 i = 0;             }             if (currCandies <= candies) {                 result[i] += currCandies;                 candies -= currCandies;             } else {                 result[i] += candies;                 candies = 0;             }             currCandies++;             i++;         }         return result;     } }",1,"1103-distribute-candies-to-people/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1103-distribute-candies-to-people/Solution.java:11:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'candies'
",1,1,0
"class Solution {     public String defangIPaddr(String address) {         return address.replace(""."", ""[.]"");     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public int minDepth(TreeNode root) {         if(root == null){             return 0;         }                  // Initialize the minimum depth to be 1         int minDepth = 1;         Queue<TreeNode> queue = new LinkedList<>();         queue.offer(root);                  while(!queue.isEmpty()){             int levelSize = queue.size();             for(int i = 0; i < levelSize; i++){                 TreeNode current = queue.poll();                 if(current.left == null && current.right == null){                     // If we reach a leaf node, return the minimum depth                     return minDepth;                 }                 if(current.left != null){                     queue.offer(current.left);                 }                 if(current.right != null){                     queue.offer(current.right);                 }             }             // Increment the minimum depth at each level             minDepth++;         }                  return minDepth;     } }",0,,0,0,0
class Foo {      private volatile boolean firstDone;     private volatile boolean secondDone;     private Object lock;      public Foo() {         lock = new Object();         firstDone = false;         secondDone = false;     }      public void first(Runnable printFirst) throws InterruptedException {         printFirst.run();         synchronized(lock) {             firstDone = true;             lock.notifyAll();         }     }      public void second(Runnable printSecond) throws InterruptedException {         synchronized(lock) {             while(!firstDone) {                 lock.wait();             }             printSecond.run();             secondDone = true;             lock.notifyAll();         }     }      public void third(Runnable printThird) throws InterruptedException {         synchronized(lock) {             while(!secondDone) {                 lock.wait();             }             printThird.run();         }     } },1,"1114-print-in-order/Foo.java:7:5: Redundant 'public' modifier. [RedundantModifier]
1114-print-in-order/Foo.java:3:	AvoidUsingVolatile:	Use of modifier volatile is not recommended.
1114-print-in-order/Foo.java:4:	AvoidUsingVolatile:	Use of modifier volatile is not recommended.
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public boolean hasPathSum(TreeNode root, int targetSum) {         if (root == null) {             return false;         }         if (root.left == null && root.right == null) {             return root.val == targetSum;         }         int newTargetSum = targetSum - root.val;         return hasPathSum(root.left, newTargetSum) || hasPathSum(root.right, newTargetSum);     } }",0,,0,0,0
"class Solution {     public int[] relativeSortArray(int[] arr1, int[] arr2) {         Map<Integer, Integer> frequencyCount = new HashMap<>();         for(int num : arr1) {             frequencyCount.put(num, frequencyCount.getOrDefault(num, 0) + 1);         }                  int[] result = new int[arr1.length];         int index = 0;         for(int num : arr2) {             int count = frequencyCount.get(num);             while(count > 0) {                 result[index++] = num;                 count--;             }             frequencyCount.remove(num);         }                  List<Integer> remainingNumbers = new ArrayList<>(frequencyCount.keySet());         Collections.sort(remainingNumbers);                  for(int num : remainingNumbers) {             int count = frequencyCount.get(num);             while(count > 0) {                 result[index++] = num;                 count--;             }         }                  return result;     } }",0,,0,0,0
"class Solution {     public int numEquivDominoPairs(int[][] dominoes) {         int count = 0;         Map<String, Integer> map = new HashMap<String, Integer>();                  for(int i=0; i<dominoes.length; i++){             Arrays.sort(dominoes[i]); //sorting dominoes[i] array to keep same elements in same order             String str = dominoes[i][0] + "" "" + dominoes[i][1];              map.put(str, map.getOrDefault(str, 0) + 1); //putting the counts of element pairs in map         }                  for(int val : map.values()){             count += (val*(val-1))/2; //calculating total number of pairs         }                  return count; //returning the total count     } }",1,"1128-number-of-equivalent-domino-pairs/Solution.java:6:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
1128-number-of-equivalent-domino-pairs/Solution.java:13:	UselessParentheses:	Useless parentheses.
",0,0,1
class Solution {     public int tribonacci(int n) {         if (n == 0) return 0;         if (n == 1 || n == 2) return 1;                  int[] dp = new int[n+1];         dp[0] = 0;         dp[1] = 1;         dp[2] = 1;                  for (int i = 3; i <= n; i++) {             dp[i] = dp[i-1] + dp[i-2] + dp[i-3];         }                  return dp[n];     } }   // Time Complexity: O(n) // Space Complexity: O(n),0,,0,0,0
"class Solution {     public int dayOfYear(String date) {         int[] daysInMonth = new int[] {31,28,31,30,31,30,31,31,30,31,30,31};                  String[] dateArr = date.split(""-"");         int year = Integer.parseInt(dateArr[0]);         int month = Integer.parseInt(dateArr[1]);         int day = Integer.parseInt(dateArr[2]);                  int days = day;                  for(int i=0; i<month-1; i++) {             days += daysInMonth[i];         }                  if(month>2 && isLeapYear(year)) {             days++;         }                  return days;     }          private boolean isLeapYear(int year) {         if(year%100==0) {             return year%400==0;         }                  return year%4==0;     } }",0,,0,0,0
"class Solution {     public int countCharacters(String[] words, String chars) {         int[] charCount = new int[26];         for (char c : chars.toCharArray()) {             charCount[c - 'a']++;         }         int totalLength = 0;         for (String word : words) {             int[] tempCharCount = charCount.clone(); // Make a copy of the character count array for each word             boolean isGood = true;             for (char c : word.toCharArray()) {                 if (tempCharCount[c - 'a'] == 0) {                     isGood = false;                     break;                 }                 tempCharCount[c - 'a']--;             }             if (isGood) {                 totalLength += word.length();             }         }         return totalLength;     } }",0,,0,0,0
"class Solution {     public int numPrimeArrangements(int n) {         final int MOD = 1000000007;         int primeCount = countPrimes(n);         int nonPrimeCount = n - primeCount;         long ans = 1;         for (int i = 2; i <= primeCount; i++) {             ans = (ans * i) % MOD;         }         for (int i = 2; i <= nonPrimeCount; i++) {             ans = (ans * i) % MOD;         }         return (int) ans;     }          private int countPrimes(int n) {         if (n <= 1) {             return 0;         }         boolean[] isPrime = new boolean[n + 1];         Arrays.fill(isPrime, true);         for (int i = 2; i * i <= n; i++) {             if (isPrime[i]) {                 for (int j = i * i; j <= n; j += i) {                     isPrime[j] = false;                 }             }         }         int count = 0;         for (int i = 2; i <= n; i++) {             if (isPrime[i]) {                 count++;             }         }         return count;     } }",1,"1175-prime-arrangements/Solution.java:8:	UselessParentheses:	Useless parentheses.
1175-prime-arrangements/Solution.java:11:	UselessParentheses:	Useless parentheses.
1175-prime-arrangements/Solution.java:20:	LinguisticNaming:	Linguistics Antipattern - The variable 'isPrime' indicates linguistically it is a boolean, but it is 'boolean[]'
",0,0,0
class Solution {     public List<List<Integer>> generate(int numRows) {         List<List<Integer>> triangle = new ArrayList<>();         //Edge case checking for numRows = 0         if(numRows == 0) {             return triangle;         }                  triangle.add(new ArrayList<>());         triangle.get(0).add(1); //Adding the first element of the first list                  for(int i=1; i<numRows; i++) {             List<Integer> row = new ArrayList<>();             List<Integer> prevRow = triangle.get(i-1); //To get the previous row elements             row.add(1); //Adding the first element of each row                          for(int j=1; j<i; j++) { //Loop to calculate the middle elements of each row                 int sum = prevRow.get(j-1) + prevRow.get(j);                 row.add(sum);             }             row.add(1); //Adding the last element of each row             triangle.add(row); //Adding the row to triangle list         }         return triangle;     } },0,,0,0,0
"class Solution {     public int distanceBetweenBusStops(int[] distance, int start, int destination) {         int n = distance.length;         int clockwiseDistance = 0;         int counterclockwiseDistance = 0;         int i = start;         while (i != destination) {             clockwiseDistance += distance[i];             i = (i + 1) % n;         }         i = start;         while (i != destination) {             i = (i - 1 + n) % n;             counterclockwiseDistance += distance[i];         }         return Math.min(clockwiseDistance, counterclockwiseDistance);     } }",0,,0,0,0
"class Solution {     public String dayOfTheWeek(int day, int month, int year) {         String[] daysOfWeek = {""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday"", ""Friday"", ""Saturday""};         int[] monthCodes = {0, 3, 3, 6, 1, 4, 6, 2, 5, 0, 3, 5}; // January to December         int[] centuryCodes = {6, 4, 2, 0}; // 1700s, 1800s, 1900s, 2000s         int centuryCode = centuryCodes[(year / 100) - 17];         int yearCode = ((year % 100) + (year % 100 / 4)) % 7;         int monthCode = monthCodes[month - 1];         int leapYearCode = 0;         if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {             if (month == 1 || month == 2) {                 leapYearCode = 1;             }         }         int dayOfWeekCode = (centuryCode + yearCode + monthCode + day - leapYearCode) % 7;         return daysOfWeek[dayOfWeekCode];     } }",1,"1185-day-of-the-week/Solution.java:11:	CollapsibleIfStatements:	This if statement could be combined with its parent
",0,0,0
"class Solution {     public int maxNumberOfBalloons(String text) {         int[] freq = new int[26];                  for(char c : text.toCharArray()){             freq[c-'a']++;         }                  int min = Math.min(freq[0], Math.min(freq[1], Math.min(freq[11]/2, Math.min(freq[14]/2, freq[13]))));                  return min;     } }  ",1,"1189-maximum-number-of-balloons/Solution.java:9:	UnnecessaryLocalBeforeReturn:	Consider simply returning the value vs storing it in local variable 'min'
",0,0,0
import java.util.*;  class Solution {     public List<Integer> getRow(int rowIndex) {         List<Integer> result = new ArrayList<>();          // First row will always be [1]         result.add(1);          // Check for edge case         if (rowIndex == 0) {             return result;         }          // Generate the rows iteratively         for (int i = 1; i <= rowIndex; i++) {             List<Integer> row = new ArrayList<>();             row.add(1);              for (int j = 1; j < i; j++) {                 row.add(result.get(j - 1) + result.get(j));             }              row.add(1);             result = row;         }          return result;     } },0,,0,0,0
"import java.util.ArrayList; import java.util.Arrays; import java.util.List;  class Solution {     public List<List<Integer>> minimumAbsDifference(int[] arr) {         Arrays.sort(arr);              //first, sort the given array in ascending order         int minDiff = Integer.MAX_VALUE;         for (int i = 0; i < arr.length - 1; i++) {      //find the minimum absolute difference             minDiff = Math.min(minDiff, arr[i+1] - arr[i]);         }         List<List<Integer>> result = new ArrayList<List<Integer>>();         for (int i = 0; i < arr.length - 1; i++) {             if (arr[i+1] - arr[i] == minDiff) {        //check if the difference between two adjacent elements is equal to minimum absolute difference                 List<Integer> pair = new ArrayList<Integer>();                 pair.add(arr[i]);                 pair.add(arr[i+1]);                 result.add(pair);             }         }         return result;     } }",1,"1200-minimum-absolute-difference/Solution.java:12:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new ArrayList<>()`
1200-minimum-absolute-difference/Solution.java:15:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new ArrayList<>()`
",0,0,0
"class Solution {     public boolean uniqueOccurrences(int[] arr) {         // Create a HashMap to store the frequency of each number in arr         Map<Integer, Integer> frequency = new HashMap<>();                  // Loop through the array and increment frequency of each number         for(int num : arr) {             frequency.put(num, frequency.getOrDefault(num, 0) + 1);         }                  // Create a HashSet to store unique frequencies         Set<Integer> uniqueFreq = new HashSet<>();                  // Loop through the frequency map         for(int freq : frequency.values()) {             // If the frequency already exists, return false             if(uniqueFreq.contains(freq)) {                 return false;             }             uniqueFreq.add(freq);         }                  // If we made it through the loop without returning false, return true         return true;     } }",0,,0,0,0
class Solution {     public int maxProfit(int[] prices) {         int minPrice = Integer.MAX_VALUE;         int maxProfit = 0;         for (int i = 0; i < prices.length; i++) {             if (prices[i] < minPrice) {                 minPrice = prices[i];             } else if (prices[i] - minPrice > maxProfit) {                 maxProfit = prices[i] - minPrice;             }         }         return maxProfit;     } },1,"121-best-time-to-buy-and-sell-stock/Solution.java:5:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int minCostToMoveChips(int[] position) {         int even = 0, odd = 0;         for (int chip : position) {             if (chip % 2 == 0) {                 even++;             } else {                 odd++;             }         }         return Math.min(even, odd);     } }",1,"1217-minimum-cost-to-move-chips-to-the-same-position/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
class Solution {     public int balancedStringSplit(String s) {         int count = 0;         int balance = 0;         for(char c : s.toCharArray()){             if(c == 'L') balance++;             else balance--;             if(balance == 0) count++;         }         return count;     } },0,,0,0,0
"class Solution {     public boolean checkStraightLine(int[][] coordinates) {         if(coordinates.length <= 2) // if there are only 2 points, then it's a straight line by default             return true;                  for(int i=2; i<coordinates.length; i++) {             // check if the slope of the line between the first two points is equal to the slope of the line between the first point and the current point             if((coordinates[1][1]-coordinates[0][1])*(coordinates[i][0]-coordinates[0][0]) !=                 (coordinates[i][1]-coordinates[0][1])*(coordinates[1][0]-coordinates[0][0]))                 return false;         }                  return true;     } }",0,,0,0,0
"class Solution {     public boolean isPalindrome(String s) {         // Convert the String to lowercase and remove non-alphanumeric characters         s = s.toLowerCase().replaceAll(""[^a-z0-9]"", """");          // Check if the String is a palindrome         int left = 0;         int right = s.length() - 1;         while (left < right) {             if (s.charAt(left) != s.charAt(right)) {                 return false;             }             left++;             right--;         }         return true;     } }",1,"125-valid-palindrome/Solution.java:4:	AvoidReassigningParameters:	Avoid reassigning parameters such as 's'
125-valid-palindrome/Solution.java:4:	UseLocaleWithCaseConversions:	When doing a String.toLowerCase()/toUpperCase() call, use a Locale
",0,1,0
"class Solution {     public int oddCells(int m, int n, int[][] indices) {         int[][] matrix = new int[m][n];         int count = 0;         for(int[] index: indices){             for(int i=0; i<n; i++){                 matrix[index[0]][i]++;                 if(matrix[index[0]][i]%2==1) count++;                 else count--;             }             for(int i=0; i<m; i++){                 matrix[i][index[1]]++;                 if(matrix[i][index[1]]%2==1) count++;                 else count--;             }         }         return count;     } }",0,,0,0,0
"import java.util.List; import java.util.ArrayList;  class Solution {     public List<List<Integer>> shiftGrid(int[][] grid, int k) {         int m = grid.length;         int n = grid[0].length;         int[] temp = new int[m * n];          // store values from grid in temp array         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 int index = (i * n + j + k) % (m * n);                 temp[index] = grid[i][j];             }         }          // create new grid from temp array values         List<List<Integer>> newGrid = new ArrayList<>();         for (int i = 0; i < m; i++) {             List<Integer> row = new ArrayList<>();             for (int j = 0; j < n; j++) {                 int index = i * n + j;                 row.add(temp[index]);             }             newGrid.add(row);         }          return newGrid;     } }",0,,0,0,0
"class Solution {     public int minTimeToVisitAllPoints(int[][] points) {         int totalTime = 0;                  for (int i = 0; i < points.length - 1; i++) {             int[] currentPoint = points[i];             int[] nextPoint = points[i+1];                          int xDiff = Math.abs(currentPoint[0] - nextPoint[0]);             int yDiff = Math.abs(currentPoint[1] - nextPoint[1]);                          totalTime += Math.max(xDiff, yDiff);         }                  return totalTime;     } }",0,,0,0,0
"class Solution {     public String tictactoe(int[][] moves) {         char[][] grid = new char[3][3]; // initialize a 3x3 grid                  // alternatively we could use the following 2D array to represent the grid:         // int[][] grid = new int[3][3]; // 0 for empty, 1 for player A, 2 for player B                  char currentPlayer = 'A'; // player A always starts                  for (int i = 0; i < moves.length; i++) {             int row = moves[i][0];             int col = moves[i][1];                          // place current player's mark on the selected cell             grid[row][col] = currentPlayer;                          // check if current player has won             if (checkWin(grid, currentPlayer)) {                 return """" + currentPlayer; // convert char to String             }                          // switch to next player             currentPlayer = (currentPlayer == 'A') ? 'B' : 'A';         }                  // if all cells are filled and no winner is found, it's a draw         if (isGridFull(grid)) {             return ""Draw"";         }                  // otherwise there are still moves left to play         return ""Pending"";     }          // helper method to check if a player has won     private boolean checkWin(char[][] grid, char player) {         // check rows         for (int i = 0; i < 3; i++) {             if (grid[i][0] == player && grid[i][1] == player && grid[i][2] == player) {                 return true;             }         }                  // check columns         for (int j = 0; j < 3; j++) {             if (grid[0][j] == player && grid[1][j] == player && grid[2][j] == player) {                 return true;             }         }                  // check diagonals         if (grid[0][0] == player && grid[1][1] == player && grid[2][2] == player) {             return true;         }         if (grid[0][2] == player && grid[1][1] == player && grid[2][0] == player) {             return true;         }                  // no win found         return false;     }          // helper method to check if the grid is full     private boolean isGridFull(char[][] grid) {         for (int i = 0; i < 3; i++) {             for (int j = 0; j < 3; j++) {                 if (grid[i][j] == '\u0000') { // '\u0000' is the default value for a char                     return false; // at least one cell is empty                 }             }         }         return true; // all cells are filled     } }",1,"1275-find-winner-on-a-tic-tac-toe-game/Solution.java:10:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
1275-find-winner-on-a-tic-tac-toe-game/Solution.java:19:	AddEmptyString:	Do not add empty strings
1275-find-winner-on-a-tic-tac-toe-game/Solution.java:36:	NPathComplexity:	The method 'checkWin(char[][], char)' has an NPath complexity of 400, current threshold is 200
1275-find-winner-on-a-tic-tac-toe-game/Solution.java:55:	SimplifyBooleanReturns:	This if statement can be replaced by `return {condition};`
",0,0,1
class Solution {     public int subtractProductAndSum(int n) {         int prod = 1;         int sum = 0;         while (n > 0) {             int digit = n % 10;             prod *= digit;             sum += digit;             n /= 10;         }         return prod - sum;     } },1,"1281-subtract-the-product-and-sum-of-digits-of-an-integer/Solution.java:9:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
",0,1,0
class Solution {     public int findSpecialInteger(int[] arr) {         int n = arr.length;         int freq = n/4;         int count = 0;         for(int i=0; i<n; i++){             if(arr[i] == arr[i+freq]){                 count++;                 if(count > freq){                     return arr[i];                 }             }             else{                 count = 0;             }         }         return -1;     } },1,"1287-element-appearing-more-than-25-in-sorted-array/Solution.java:12:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public int getDecimalValue(ListNode head) {         int value = 0;         while (head != null) {             value = value << 1;             value += head.val;             head = head.next;         }         return value;     } }",1,"1290-convert-binary-number-in-a-linked-list-to-integer/ListNode.java:17:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'head'
",0,1,0
class Solution {     public int findNumbers(int[] nums) {         int count = 0;         for(int num: nums){             int digits = 0;             while(num > 0){                 num = num/10;                 digits++;             }             if(digits%2 == 0){                 count++;             }         }         return count;     } }  // Time Complexity: O(nlogn) // Space Complexity: O(1),0,,0,0,0
"class Solution {     public int[] replaceElements(int[] arr) {         int n = arr.length;         int[] result = new int[n];          int max = 0;         for(int i=n-1; i>=0; i--){             if(i == n-1){                 max = arr[i];                 result[i] = -1;             }else{                 int temp = max;                 max = Math.max(max, arr[i]);                 result[i] = temp;             }         }         return result;     } }",0,,0,0,0
class Solution {     public int[] sumZero(int n) {         int[] result = new int[n];         int sum = 0;         for (int i = 0; i < n - 1; i++) {             result[i] = i + 1;             sum += result[i];         }         result[n - 1] = -sum;         return result;     } },0,,0,0,0
"class Solution {     public String freqAlphabets(String s) {         StringBuilder result = new StringBuilder();         int i = 0;         while(i<s.length()){             if(i+2<s.length() && s.charAt(i+2)=='#'){ //checking if there are two digits followed by a hash sign                 int num = Integer.parseInt(s.substring(i,i+2)); //converting the two digits to an integer                 result.append((char)('j'+num-10)); //mapping the integer to a corresponding lowercase character                 i += 3;             }             else{ //if there is only one digit or no hash sign                 int num = Integer.parseInt(s.substring(i,i+1)); //converting the digit to an integer                 result.append((char)('a'+num-1)); //mapping the integer to a corresponding lowercase character                 i += 1;              }         }         return result.toString();     } }",1,"1309-decrypt-string-from-alphabet-to-integer-mapping/Solution.java:10:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
class Solution {     public int[] decompressRLElist(int[] nums) {         List<Integer> result = new ArrayList<>();         for (int i = 0; i < nums.length; i += 2) {             int freq = nums[i];             int val = nums[i+1];             for (int j = 0; j < freq; j++) {                 result.add(val);             }         }         int[] decompressed = new int[result.size()];         for (int i = 0; i < decompressed.length; i++) {             decompressed[i] = result.get(i);         }         return decompressed;     } },0,,0,0,0
"class Solution {     public int[] getNoZeroIntegers(int n) {         int a = 1, b = n - 1;         while (true) {             if (hasNoZero(a) && hasNoZero(b)) {                 return new int[]{a, b};             }             a++;             b--;         }     }      private boolean hasNoZero(int n) {         while (n > 0) {             int digit = n % 10;             if (digit == 0) {                 return false;             }             n /= 10;         }         return true;     } }",1,"1317-convert-integer-to-the-sum-of-two-no-zero-integers/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1317-convert-integer-to-the-sum-of-two-no-zero-integers/Solution.java:19:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
",1,1,0
"class Solution {     public int maximum69Number (int num) {         // Convert int to int array, digit by digit         int[] arr = String.valueOf(num).chars().map(c -> c-'0').toArray();         // Try to find the first 6 from left and change it to 9         for(int i=0; i<arr.length; i++){             if(arr[i] == 6){                 arr[i] = 9;                 break;             }         }         // Convert int array back to int         int res = 0;         for(int i=0; i<arr.length; i++){             res = res*10 + arr[i];         }         return res;     } }",1,"1323-maximum-69-number/Solution.java:14:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int[] arrayRankTransform(int[] arr) {         int n = arr.length;         // Create a copy of the array and sort it in ascending order.         int[] sortedArr = arr.clone();         Arrays.sort(sortedArr);         // Create a map to keep track of the rank of each element.         Map<Integer, Integer> rankMap = new HashMap<>();         int rank = 1;         for (int i = 0; i < n; i++) {             // Assign the rank only if the element has not been assigned a rank before.             rankMap.putIfAbsent(sortedArr[i], rank++);         }         // Traverse the original array and replace each element with its rank.         for (int i = 0; i < n; i++) {             arr[i] = rankMap.get(arr[i]);         }         return arr;     } }",0,,0,0,0
"class Solution {     public int removePalindromeSub(String s) {         if (s.length() == 0) { // if s is empty, no removal necessary             return 0;         } else if (isPalindrome(s)) { // if s is already a palindrome, only one removal necessary             return 1;         } else { // otherwise, two removals necessary: one for all 'a's and one for all 'b's             return 2;         }     }          // method to check if a string is a palindrome     private boolean isPalindrome(String s) {         int i = 0;         int j = s.length() - 1;         while (i < j) {             if (s.charAt(i) != s.charAt(j)) {                 return false;             }             i++;             j--;         }         return true;     } }",0,,0,0,0
"class Solution {     public int[] kWeakestRows(int[][] mat, int k) {         int[] soldierCount = new int[mat.length]; // stores number of soldiers in each row         for (int i = 0; i < mat.length; i++) {             int count = 0;             for (int j = 0; j < mat[i].length; j++) {                 if (mat[i][j] == 1) {                     count++;                 } else {                     break;                 }             }             soldierCount[i] = count;         }                  int[] result = new int[k];         boolean[] visited = new boolean[mat.length]; // to keep track of already visited rows         for (int i = 0; i < k; i++) {             int minIndex = 0;             for (int j = 1; j < mat.length; j++) {                 if (!visited[j] && (soldierCount[j] < soldierCount[minIndex] || (soldierCount[j] == soldierCount[minIndex] && j < minIndex))) {                     minIndex = j;                 }             }             visited[minIndex] = true;             result[i] = minIndex;         }                  return result;     } }",0,,0,0,0
class Solution {     public int numberOfSteps(int num) {         int steps = 0;         while(num > 0) {             if(num % 2 == 0) {                 num /= 2;             } else {                 num -= 1;             }             steps += 1;         }         return steps;     } },1,"1342-number-of-steps-to-reduce-a-number-to-zero/Solution.java:6:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'num'
",0,1,0
class Solution {     public boolean checkIfExist(int[] arr) {         Set<Integer> set = new HashSet<>();                  for (int i = 0; i < arr.length; i++) {             if (set.contains(arr[i] * 2) || (arr[i] % 2 == 0 && set.contains(arr[i] / 2))) {                 return true;             }             set.add(arr[i]);         }                  return false;     } },1,"1346-check-if-n-and-its-double-exist/Solution.java:5:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
class Solution {     public int countNegatives(int[][] grid) {         int m = grid.length;         int n = grid[0].length;         int count = 0; // Initialize count of negative numbers                  // Start from top-right corner         int row = 0;         int col = n-1;                  while(row<m && col>=0){             if(grid[row][col] < 0){                 count += (m-row); // All elements below are also negative since rows are sorted                 col--;             }             else{                 row++;             }         }                  return count;     } },1,"1351-count-negative-numbers-in-a-sorted-matrix/Solution.java:15:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
"class Solution {     public int[] sortByBits(int[] arr) {         Integer[] integers = new Integer[arr.length];         for(int i = 0; i < arr.length; i++) {             integers[i] = arr[i];         }         Arrays.sort(integers, new Comparator<Integer>() {             @Override             public int compare(Integer o1, Integer o2) {                 int a = Integer.bitCount(o1);                 int b = Integer.bitCount(o2);                 if(a == b) {                     return o1 - o2;                 }                 return a - b;             }         });         for(int i = 0; i < arr.length; i++) {             arr[i] = integers[i];         }         return arr;     }     }",1,"1356-sort-integers-by-the-number-of-1-bits/Solution.java:4:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
1356-sort-integers-by-the-number-of-1-bits/Solution.java:18:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
",0,0,0
class Solution {     public int singleNumber(int[] nums) {         int result = 0;         for (int i = 0; i < nums.length; i++) {             result ^= nums[i];         }         return result;     } },1,"136-single-number/Solution.java:4:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int daysBetweenDates(String date1, String date2) {         try {             // Convert the strings to Date objects             SimpleDateFormat format = new SimpleDateFormat(""yyyy-MM-dd"");             Date d1 = format.parse(date1);             Date d2 = format.parse(date2);                          // Calculate the difference between the dates in days             long diff = Math.abs(d1.getTime() - d2.getTime());             long diffDays = TimeUnit.DAYS.convert(diff, TimeUnit.MILLISECONDS);                          return (int) diffDays;                      } catch (ParseException e) {             e.printStackTrace();             return -1; // In case of error, return a negative value         }     } }",0,,0,0,0
class Solution {     public int[] smallerNumbersThanCurrent(int[] nums) {         int[] count = new int[101];         for(int i=0; i<nums.length; i++){             count[nums[i]]++;         }                  for(int i=1; i<=100; i++){             count[i]+=count[i-1];         }                  int[] result = new int[nums.length];         for(int i=0; i<nums.length; i++){             if(nums[i]==0){                  result[i]=0;                 continue;             }             result[i]=count[nums[i]-1];         }         return result;     } },1,"1365-how-many-numbers-are-smaller-than-the-current-number/Solution.java:4:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
class Solution {     public String sortString(String s) {         StringBuilder sb = new StringBuilder();         int[] freq = new int[26];         for(char c : s.toCharArray())             freq[c - 'a']++;         boolean reverse = false;         int count = s.length();         while(count > 0) {             if(reverse) {                 for(int i = 25; i >= 0; i--) {                     if(freq[i] > 0) {                         sb.append((char)(i + 'a'));                         freq[i]--;                         count--;                     }                 }             } else {                 for(int i = 0; i < 26; i++) {                     if(freq[i] > 0) {                         sb.append((char)(i + 'a'));                         freq[i]--;                         count--;                     }                 }             }             reverse = !reverse;         }         return sb.toString();     } },0,,0,0,0
class Solution {     public String generateTheString(int n) {         StringBuilder sb = new StringBuilder();         for(int i=0; i<n-1; i++) {             sb.append('a');         }         if(n % 2 == 0) {             sb.append('b');         } else {             sb.append('a');         }         return sb.toString();     } },0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode(int x) { val = x; }  * }  */  class Solution {     public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {         if (original == null || original == target) {             return cloned;         }         TreeNode left = getTargetCopy(original.left, cloned.left, target);         if (left != null) {             return left;         }         TreeNode right = getTargetCopy(original.right, cloned.right, target);         if (right != null) {             return right;         }         return null;     } }",0,,0,0,0
"import java.util.ArrayList; import java.util.List;  class Solution {   public List<Integer> luckyNumbers(int[][] matrix) {     List<Integer> result = new ArrayList<>();     int m = matrix.length;     int n = matrix[0].length;          // Find the minimum value in each row     int[] minRow = new int[m];     for (int i = 0; i < m; i++) {       int min = Integer.MAX_VALUE;       for (int j = 0; j < n; j++) {         min = Math.min(min, matrix[i][j]);       }       minRow[i] = min;     }          // Find the maximum value in each column     int[] maxCol = new int[n];     for (int i = 0; i < n; i++) {       int max = Integer.MIN_VALUE;       for (int j = 0; j < m; j++) {         max = Math.max(max, matrix[j][i]);       }       maxCol[i] = max;     }          // Check if any element is both a row minimum and a column maximum     for (int i = 0; i < m; i++) {       for (int j = 0; j < n; j++) {         if (matrix[i][j] == minRow[i] && matrix[i][j] == maxCol[j]) {           result.add(matrix[i][j]);         }       }     }          return result;   } }",0,,0,0,0
"class Solution {     public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {         int dist = arr1.length;         for (int i = 0; i < arr1.length; i++) {             for (int j = 0; j < arr2.length; j++) {                 if (Math.abs(arr1[i] - arr2[j]) <= d) {                     dist--;                     break;                 }             }         }         return dist;     } }",1,"1385-find-the-distance-value-between-two-arrays/Solution.java:4:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
1385-find-the-distance-value-between-two-arrays/Solution.java:5:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int[] createTargetArray(int[] nums, int[] index) {         int[] target = new int[nums.length];         // loop over nums array         for(int i = 0; i < nums.length; i++){             // find the index where the current value will be inserted             int idx = index[i];             // shift the values to right from the given index             for(int j = nums.length-1; j > idx; j--){                 target[j] = target[j-1];             }             // insert the value             target[idx] = nums[i];         }         return target;     } }",1,"1389-create-target-array-in-the-given-order/Solution.java:5:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
1389-create-target-array-in-the-given-order/Solution.java:9:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
",0,0,0
"class Solution {     public int findLucky(int[] arr) {         Map<Integer, Integer> freqMap = new HashMap<>(); // create a HashMap to keep the frequency of each number          // loop through the array and update the HashMap         for (int num : arr) {             freqMap.put(num, freqMap.getOrDefault(num, 0) + 1); // get the current frequency, add 1 and update         }          int maxLucky = -1; // initally, set the maximum lucky number as -1         // loop through the HashMap and find the maximum lucky number         for (int num : freqMap.keySet()) {             if (freqMap.get(num) == num && num > maxLucky) { // if the frequency of the number is equal to the number itself and it is greater than the maximum lucky number found so far                 maxLucky = num; // update the maximum lucky number             }         }          return maxLucky; // return the maximum lucky number found     } }",0,,0,0,0
"class Solution {     public int countLargestGroup(int n) {         Map<Integer, Integer> map = new HashMap<>();         int maxCount = 0;         for (int i = 1; i <= n; i++) {             int sum = getDigitSum(i);             int count = map.getOrDefault(sum, 0) + 1;             map.put(sum, count);             maxCount = Math.max(maxCount, count);         }         int count = 0;         for (int key : map.keySet()) {             if (map.get(key) == maxCount) {                 count++;             }         }         return count;     }          private int getDigitSum(int num) {         int sum = 0;         while (num > 0) {             sum += num % 10;             num /= 10;         }         return sum;     } }",1,"1399-count-largest-group/Solution.java:24:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'num'
",0,1,0
import java.util.*;  class Solution {     public List<Integer> minSubsequence(int[] nums) {         List<Integer> result = new ArrayList<>();         int sum = 0;         int subSum = 0;                  // Calculate the sum of all elements in the array         for (int i = 0; i < nums.length; i++) {             sum += nums[i];         }                  // Sort the array in non-increasing order         Arrays.sort(nums);         reverse(nums);                  // Check for subsequence         for (int i = 0; i < nums.length; i++) {             subSum += nums[i];             result.add(nums[i]);                          if (subSum > sum - subSum) {                 return result;             }         }                  return result;     }          private void reverse(int[] nums) {         int i = 0;         int j = nums.length - 1;                  while (i < j) {             int temp = nums[i];             nums[i] = nums[j];             nums[j] = temp;             i++;             j--;         }     } },1,"1403-minimum-subsequence-in-non-increasing-order/Solution.java:10:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
1403-minimum-subsequence-in-non-increasing-order/Solution.java:19:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
import java.util.ArrayList; import java.util.List;  class Solution {     public List<String> stringMatching(String[] words) {         List<String> result = new ArrayList<>();         for (int i = 0; i < words.length; i++) {             for (int j = 0; j < words.length; j++) {                 if (i != j && words[i].contains(words[j])) {                     result.add(words[j]);                     break;                 }             }         }         return result;     } },0,,0,0,0
"/**  * Definition for singly-linked list.  * class ListNode {  *     int val;  *     ListNode next;  *     ListNode(int x) {  *         val = x;  *         next = null;  *     }  * }  */ public class Solution {     public boolean hasCycle(ListNode head) {         if(head ==null){             return false;         }         ListNode slow=head, fast=head.next;         while(slow != fast){             if(fast== null|| fast.next==null){                 return false;             }             slow=slow.next;             fast=fast.next.next;         }         return true;     } }(currentUser=sumantc)",1,"141-linked-list-cycle/Solution.java	-	ParseException: Parse exception in file '141-linked-list-cycle/Solution.java': Encountered ""("" at line 27, column 2.
",0,0,0
"class Solution {     public int minStartValue(int[] nums) {         int minSum = 0;         int sum = 0;         for (int num : nums) {             sum += num;             minSum = Math.min(minSum, sum);         }         return 1 - minSum;     } }",0,,0,0,0
"class Solution {     public String reformat(String s) {         // Separate letters and digits         List<Character> letters = new ArrayList<>();         List<Character> digits = new ArrayList<>();         for (char c : s.toCharArray()) {             if (Character.isLetter(c)) {                 letters.add(c);             } else {                 digits.add(c);             }         }                  // Check if it is possible to reformat the string         int diff = letters.size() - digits.size();         if (Math.abs(diff) > 1) {             return """";         }                  // Merge the two lists while maintaining the order         List<Character> result = new ArrayList<>();         Iterator<Character> it1 = letters.iterator();         Iterator<Character> it2 = digits.iterator();         if (diff == 1) { // if the number of letters is greater than the number of digits             while (it1.hasNext() || it2.hasNext()) {                 if (it1.hasNext()) {                     result.add(it1.next());                 }                 if (it2.hasNext()) {                     result.add(it2.next());                 }             }         } else if (diff == -1) { // if the number of digits is greater than the number of letters             while (it2.hasNext() || it1.hasNext()) {                 if (it2.hasNext()) {                     result.add(it2.next());                 }                 if (it1.hasNext()) {                     result.add(it1.next());                 }             }         } else { // if the numbers of letters and digits are equal             while (it1.hasNext() && it2.hasNext()) {                 result.add(it1.next());                 result.add(it2.next());             }         }                  // Convert the list to a string         StringBuilder sb = new StringBuilder();         for (char c : result) {             sb.append(c);         }         return sb.toString();     } }",0,,0,0,0
"class Solution {     public int maxScore(String s) {         int maxScore = Integer.MIN_VALUE;         int n = s.length();         int countZero = 0, countOne = 0;                  // Count the number of ones in the given string         for(int i = 0; i < n; i++){             if(s.charAt(i) == '1'){                 countOne++;             }         }                  // Calculate the maximum score at each index         for(int i = 0; i < n - 1; i++){             if(s.charAt(i) == '0'){                 countZero++;             }             else{                 countOne--;             }             maxScore = Math.max(maxScore, countZero + countOne);         }               return maxScore;     } }",1,"1422-maximum-score-after-splitting-a-string/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1422-maximum-score-after-splitting-a-string/Solution.java:18:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",1,0,0
"import java.util.*;  class Solution {     public List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {         List<Boolean> result = new ArrayList<Boolean>();         int maxCandies = 0;         for (int i = 0; i < candies.length; i++) {             maxCandies = Math.max(maxCandies, candies[i]); // finding the maximum number of candies among all kids         }                  for (int i = 0; i < candies.length; i++) {             if (candies[i] + extraCandies >= maxCandies) { // checking if ith kid can have the greatest number of candies                 result.add(true);             } else {                 result.add(false);             }         }         return result;     } }",1,"1431-kids-with-the-greatest-number-of-candies/Solution.java:5:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new ArrayList<>()`
1431-kids-with-the-greatest-number-of-candies/Solution.java:7:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
1431-kids-with-the-greatest-number-of-candies/Solution.java:11:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"import java.util.HashMap; import java.util.List;  class Solution {     public String destCity(List<List<String>> paths) {         HashMap<String, String> map = new HashMap<>();                  // Traverse through the paths list and store the start and end city in a hash map         for(List<String> path : paths){             String startCity = path.get(0);             String endCity = path.get(1);             map.put(startCity, endCity);         }                  // Traverse through the map and check for the destination city which is not in the start city          for(String endCity : map.values()){             if(!map.containsKey(endCity)){                 return endCity;             }         }         return """";     } }",1,"1436-destination-city/Solution.java:6:	LooseCoupling:	Avoid using implementation types like 'HashMap'; use the interface instead
",0,0,0
"class Solution {     public boolean kLengthApart(int[] nums, int k) {         for (int i = 0; i < nums.length; i++) {             // Check if the current index contains 1             if (nums[i] == 1) {                 int j = i + 1;                 // Iterate until either k distance is reached or end of the array is reached                 while (j < nums.length && j - i < k) {                     // Check if there is another 1 within k distance                     if (nums[j] == 1) {                         return false;                     }                     j++;                 }                 i = j - 1;                 // Set the index to i + k as there can't be any 1 within this distance             }         }         return true;     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */  class Solution {     public List<Integer> preorderTraversal(TreeNode root) {         List<Integer> result = new ArrayList<Integer>();         if (root == null) {             return result;         }         Stack<TreeNode> stack = new Stack<TreeNode>();         stack.push(root);         while (!stack.empty()) {             TreeNode node = stack.pop();             result.add(node.val);             if (node.right != null) {                 stack.push(node.right);             }             if (node.left != null) {                 stack.push(node.left);             }         }         return result;     } }",0,,0,0,0
"class Solution {     public int maxPower(String s) {         int maxPower = 1;         // initially max power is 1         int currentPower = 1;     // initially current substring power is 1         for (int i = 1; i < s.length(); i++) {             if (s.charAt(i) == s.charAt(i - 1)) {   // if current character is same as previous then increment power                 currentPower++;             } else {                 maxPower = Math.max(maxPower, currentPower); // else update max power and reset current power to 1                 currentPower = 1;             }         }         return Math.max(maxPower, currentPower);  // return max of maxPower and currentPower as last substring may also be a max power substring     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public List<Integer> postorderTraversal(TreeNode root) {         List<Integer> result = new ArrayList<>();         if (root == null)             return result;          Stack<TreeNode> stack = new Stack<>();         stack.push(root);          while (!stack.isEmpty()) {             TreeNode node = stack.pop();             result.add(0, node.val);              if (node.left != null)                 stack.push(node.left);              if (node.right != null)                 stack.push(node.right);         }          return result;     } }",0,,0,0,0
"class Solution {     public int busyStudent(int[] startTime, int[] endTime, int queryTime) {         int count = 0;         int n = startTime.length;         for (int i = 0; i < n; i++) {             if (queryTime >= startTime[i] && queryTime <= endTime[i]) {                 count++;             }         }         return count;     } }",0,,0,0,0
"class Solution {     public int isPrefixOfWord(String sentence, String searchWord) {         // Split the sentence into words         String[] words = sentence.split("" "");                  // Iterate through each word and check if it has the searchWord as prefix         for (int i = 0; i < words.length; i++) {             String word = words[i];             if (word.startsWith(searchWord)) {                 return i + 1; // Return minimum index (1-indexed)             }         }                  return -1; // Return -1 if searchWord is not a prefix of any word     } }",1,"1455-check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/Solution.java:2:	LinguisticNaming:	Linguistics Antipattern - The method 'isPrefixOfWord' indicates linguistically it returns a boolean, but it returns 'int'
",0,0,0
"class Solution {     public boolean canBeEqual(int[] target, int[] arr) {         if(target.length == 1 && arr.length == 1) {             return target[0] == arr[0];         }         Arrays.sort(target);         Arrays.sort(arr);         for(int i=0; i<target.length; i++) {             if(target[i]!=arr[i]) {                 return false;             }         }         return true;     } }",0,,0,0,0
class Solution {     public int maxProduct(int[] nums) {         int max1 = 0;         int max2 = 0;                  for(int i=0; i<nums.length; i++){             if(nums[i]>max1){                 max2=max1;                 max1=nums[i];             }             else if(nums[i]>max2){             max2=nums[i];         }     }         return (max1-1)*(max2-1);     } },1,"1464-maximum-product-of-two-elements-in-an-array/Solution.java:10:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1464-maximum-product-of-two-elements-in-an-array/Solution.java:6:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int[] shuffle(int[] nums, int n) {         int[] result = new int[nums.length];         int j = 0;         for(int i = 0; i < n; i++) {             result[j++] = nums[i];             result[j++] = nums[n + i];         }         return result;     } }",0,,0,0,0
class Solution {     public int[] finalPrices(int[] prices) {         int n = prices.length;         int[] ans = new int[n];         for(int i=0;i<n;i++){             int currPrice = prices[i];             int discount = 0;             for(int j=i+1;j<n;j++){                 if(prices[j]<=currPrice){                     discount = prices[j];                     break;                 }             }             ans[i] = currPrice-discount;         }         return ans;     } }  //Time Complexity: O(n^2) //Space Complexity: O(n),0,,0,0,0
class Solution {     public int[] runningSum(int[] nums) {         int[] runningSum = new int[nums.length]; //creating new array to store running sum values                  runningSum[0] = nums[0]; //setting the first element of runningSum array as the first element of nums array                  for(int i=1; i<nums.length; i++){             runningSum[i] = runningSum[i-1] + nums[i]; //calculating running sum by adding previous running sum and current value of nums array         }                  return runningSum; //returning the array of running sum values     } } ,0,,0,0,0
"class Solution {     public int xorOperation(int n, int start) {         int[] nums = new int[n];         int xorResult = 0;                  // populating the array with values         for (int i = 0; i < n; i++) {             nums[i] = start + 2 * i;         }                  // finding the bitwise XOR of all elements         for (int i = 0; i < n; i++) {             xorResult ^= nums[i];         }                  return xorResult;     } }",0,,0,0,0
"class Solution {     public double average(int[] salary) {         int minSalary = Integer.MAX_VALUE;         int maxSalary = Integer.MIN_VALUE;         int sumSalary = 0;         for (int i = 0; i < salary.length; i++) {             minSalary = Math.min(minSalary, salary[i]);             maxSalary = Math.max(maxSalary, salary[i]);             sumSalary += salary[i];         }         return (double)(sumSalary - minSalary - maxSalary) / (salary.length - 2);     } }",1,"1491-average-salary-excluding-the-minimum-and-maximum-salary/Solution.java:6:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public boolean isPathCrossing(String path) {         int x = 0, y = 0;         Set<String> visited = new HashSet<>();         visited.add(""0,0"");         for (char c : path.toCharArray()) {             if (c == 'N') y++;             else if (c == 'S') y--;             else if (c == 'E') x++;             else if (c == 'W') x--;             String pos = x + "","" + y;             if (visited.contains(pos)) return true;             visited.add(pos);         }         return false;     } }",1,"1496-path-crossing/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
public class Solution {     public boolean canMakeArithmeticProgression(int[] arr) {         Arrays.sort(arr);         int diff = arr[1] - arr[0];         for (int i = 2; i < arr.length; i++) {             if(arr[i] - arr[i-1] != diff) {                 return false;             }         }         return true;     } },0,,0,0,0
"class Solution {     public String reformatDate(String date) {         Map<String, String> monthMap = new HashMap<>(); // Map to store month abbreviations and numbers         monthMap.put(""Jan"", ""01"");         monthMap.put(""Feb"", ""02"");         monthMap.put(""Mar"", ""03"");         monthMap.put(""Apr"", ""04"");         monthMap.put(""May"", ""05"");         monthMap.put(""Jun"", ""06"");         monthMap.put(""Jul"", ""07"");         monthMap.put(""Aug"", ""08"");         monthMap.put(""Sep"", ""09"");         monthMap.put(""Oct"", ""10"");         monthMap.put(""Nov"", ""11"");         monthMap.put(""Dec"", ""12"");                  String[] tokens = date.split("" ""); // splitting the input string         String year = tokens[2]; // year is the last element         String month = monthMap.get(tokens[1]); // month is the second last element in the tokens array, get the respective number from monthMap         String day = tokens[0].substring(0, tokens[0].length()-2); // day is the first element, remove the 'th' or 'st' or 'nd' or 'rd' suffix                  // Add leading zero for day if it is less than 10         if(day.length() < 2) {             day = ""0"" + day;         }                  return year + ""-"" + month + ""-"" + day; // return formatted date string     } }",0,,0,0,0
"class Solution {     public int numIdenticalPairs(int[] nums) {         int goodPairs = 0;         for (int i = 0; i < nums.length - 1; i++) {             for (int j = i + 1; j < nums.length; j++) {                 if (nums[i] == nums[j]) {                     goodPairs++;                 }             }         }         return goodPairs;     } }  // The above code implementation uses nested loops to compare every pair of integers in the array and increments a counter when a pair of equal integers is found. Finally, it returns the count of all good pairs found.",0,,0,0,0
"class Solution {     public int numWaterBottles(int numBottles, int numExchange) {         int total = numBottles;         int empty = numBottles;         while (empty >= numExchange) { //as long as we have enough empty bottles to exchange for full ones             int temp = empty / numExchange; //calculate the number of full bottles we can get from exchanges             total += temp; //add those full bottles to the running total             empty -= temp * numExchange; //calculate how many empty bottles remain after the exchanges             empty += temp; //add the full bottles we received from exchanges to the empty bottle count         }         return total;     } }",0,,0,0,0
"class Solution {     public int countOdds(int low, int high) {         // if both low and high are odd or both are even, then formula to get the count is (high - low) / 2         if (low % 2 == high % 2) {             return (high - low) / 2 + (low % 2);         }         // if low is even and high is odd, then formula to get the count is (high - low + 1) / 2         return (high - low + 1) / 2;     } }",0,,0,0,0
"class Solution {     public String restoreString(String s, int[] indices) {         char[] shuffled = new char[s.length()]; // create a char array to hold the shuffled string         for(int i=0; i<s.length(); i++) {             shuffled[indices[i]] = s.charAt(i); // shuffle the char at index i to its new index         }         return new String(shuffled); // return the shuffled string     } }",1,"1528-shuffle-string/Solution.java:7:	StringInstantiation:	Avoid instantiating String objects; this is usually unnecessary.
",0,0,0
"class Solution {     public int countGoodTriplets(int[] arr, int a, int b, int c) {         int n = arr.length;         int count = 0;         for(int i=0; i<n-2; i++){             for(int j=i+1; j<n-1; j++){                 for(int k=j+1; k<n; k++){                     if(Math.abs(arr[i]-arr[j]) <= a && Math.abs(arr[j]-arr[k]) <= b &&                         Math.abs(arr[i]-arr[k]) <= c){                         count++;                     }                 }             }         }         return count;     } } ",0,,0,0,0
"class Solution {     public int findKthPositive(int[] arr, int k) {          int i = 0, j = 1; // i represents index in arr and j represents positive integers          while (k > 0) { // while k missing positives remaining              if (i < arr.length && j == arr[i]) { // if j is not missing because it is present in given arr                  i++; // move i to next position              } else { // j is missing                  k--; // decrement k as we have found j missing              }              if (k == 0) { // if we have found kth missing                  return j; // return j as answer              }              j++; // move to next positive integer          }          return -1; // unreachable     } }",1,"1539-kth-missing-positive-number/Solution.java:3:10: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1539-kth-missing-positive-number/Solution.java:8:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'k'
",1,1,0
class Solution {     public String makeGood(String s) {         Stack<Character> stack = new Stack<>();         for(char c: s.toCharArray()){             if(!stack.isEmpty() && Math.abs(c - stack.peek()) == 32) stack.pop();             else stack.push(c);         }         StringBuilder sb = new StringBuilder();         while(!stack.isEmpty()) sb.append(stack.pop());         return sb.reverse().toString();      } },0,,0,0,0
"class Solution {     public boolean threeConsecutiveOdds(int[] arr) {                  // Iterate through the array to check three consecutive odd numbers         for (int i = 0; i < arr.length - 2; i++) {             if (arr[i] % 2 == 1 && arr[i+1] % 2 == 1 && arr[i+2] % 2 == 1) {                 return true;  // If three consecutive odd numbers are found, return true             }         }                  return false;  // If no three consecutive odd numbers are found, return false     } }",0,,0,0,0
"class Solution {     public String thousandSeparator(int n) {         String s = Integer.toString(n);         char[] arr = s.toCharArray();         StringBuilder sb = new StringBuilder();         int len = arr.length;         int k = 0;         for(int i=len-1; i>=0; i--){             k++;             sb.append(arr[i]);             if(k%3==0 && i!=0) sb.append(""."");         }         return sb.reverse().toString();     } }",1,"1556-thousand-separator/Solution.java:11:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
",0,0,0
"import java.util.*;  class Solution {     public List<Integer> mostVisited(int n, int[] rounds) {         List<Integer> mostVisitedSectors = new ArrayList<>();         int start = rounds[0];         int end = rounds[rounds.length - 1];                  if (end >= start) {             for (int i = start; i <= end; i++) {                 mostVisitedSectors.add(i);             }         } else {             for (int i = 1; i <= end; i++) {                 mostVisitedSectors.add(i);             }             for (int i = start; i <= n; i++) {                 mostVisitedSectors.add(i);             }         }                  return mostVisitedSectors;     } }",0,,0,0,0
"class Solution {     public boolean containsPattern(int[] arr, int m, int k) {         if (arr.length < m * k) { // if total length of sub-arrays is less than the required length             return false; // then return false as we cannot form required sub-arrays         }          for (int i = 0; i <= arr.length - m * k; i++) { // iterate through arr             boolean foundPattern = true; // initialize flag to true             for (int j = i; j < i + m * k; j++) { // check each sub-array of length m                 if (arr[j] != arr[j - m * (j / m)]) { // check subarrays are same                     foundPattern = false; // set flag to false if sub-array not same                     break; // break out of inner loop as pattern not found                 }             }             if (foundPattern) return true; // if flag still true, then pattern found         }         return false; // pattern not found     } }",0,,0,0,0
public class Solution {     public int diagonalSum(int[][] mat) {         int n = mat.length;         int sum = 0;         for (int i = 0; i < n; i++) {             sum += mat[i][i]; // add primary diagonal element             sum += mat[i][n - i - 1]; // add secondary diagonal element         }         if (n % 2 != 0) { // if odd number of rows/columns             sum -= mat[n/2][n/2]; // subtract middle element which is part of both diagonals         }         return sum;     } },0,,0,0,0
class Solution {     public String modifyString(String s) {         char[] charArr = s.toCharArray(); //convert the string to character array                  for(int i=0;i<charArr.length;i++)         {             if(charArr[i] == '?')             {                 char prev = i == 0? '#' : charArr[i-1]; //get previous character                 char next = i == charArr.length-1? '#' : charArr[i+1]; //get next character                                  for(char j='a';j<='z';j++)                 {                     if(j != prev && j!= next) //check if j doesn't make a consecutive repeat                     {                         charArr[i] = j; //replace '?' with j                         break;                     }                 }             }         }                  return String.valueOf(charArr); //convert the character array back to string and return     } },1,"1576-replace-all-s-to-avoid-consecutive-repeating-characters/Solution.java:6:9: '{' at column 9 should be on the previous line. [LeftCurly]
1576-replace-all-s-to-avoid-consecutive-repeating-characters/Solution.java:8:13: '{' at column 13 should be on the previous line. [LeftCurly]
1576-replace-all-s-to-avoid-consecutive-repeating-characters/Solution.java:13:17: '{' at column 17 should be on the previous line. [LeftCurly]
1576-replace-all-s-to-avoid-consecutive-repeating-characters/Solution.java:15:21: '{' at column 21 should be on the previous line. [LeftCurly]
",0,0,0
class Solution {     public int numSpecial(int[][] mat) {         int m = mat.length;         int n = mat[0].length;         int[] rowOnes = new int[m];         int[] colOnes = new int[n];          // Count the number of ones in each row and column         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 if (mat[i][j] == 1) {                     rowOnes[i]++;                     colOnes[j]++;                 }             }         }          // Count the number of special positions         int count = 0;         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 if (mat[i][j] == 1 && rowOnes[i] == 1 && colOnes[j] == 1) {                     count++;                 }             }         }                  return count;     } },0,,0,0,0
"class Solution {     public int sumOddLengthSubarrays(int[] arr) {         int sum = 0;         int n = arr.length;         for (int i = 0; i < n; i++) {             // Count number of odd-length subarrays that include arr[i]             int left = i + 1, right = n - i;             int oddLeft = (left + 1) / 2, oddRight = (right + 1) / 2;             int evenLeft = left / 2, evenRight = right / 2;             sum += arr[i] * (oddLeft * oddRight + evenLeft * evenRight);         }         return sum;     } }",1,"1588-sum-of-all-odd-length-subarrays/Solution.java:7:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1588-sum-of-all-odd-length-subarrays/Solution.java:8:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1588-sum-of-all-odd-length-subarrays/Solution.java:9:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public String reorderSpaces(String text) {         int countSpaces = 0;         String[] words = text.trim().split(""\\s+"");         for(char c: text.toCharArray()) {             if(c == ' ') {                 countSpaces++;             }         }         int n = words.length;         if(n == 1) {             return words[0] + "" "".repeat(countSpaces);         }         int count = countSpaces / (n - 1);         int extra = countSpaces % (n - 1);         StringBuilder sb = new StringBuilder();         for(int i = 0; i < n; i++) {             sb.append(words[i]);             if(i != n - 1) {                 sb.append("" "".repeat(count));                 if(i < extra) {                     sb.append("" "");                 }             }         }         sb.append("" "".repeat(countSpaces - (count + 1) * (n - 1) - extra));         return sb.toString();     } }",1,"1592-rearrange-spaces-between-words/Solution.java:22:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
",0,0,0
"class Solution {     public int minOperations(String[] logs) {         int depth = 0;         for (String log : logs) {             if (log.equals(""../"")) {                 depth = Math.max(0, depth - 1); // Ensure not going above the root folder             } else if (!log.equals(""./"")) {                 depth++;             }         }         return depth;     } }",1,"1598-crawler-log-folder/Solution.java:5:	LiteralsFirstInComparisons:	Position literals first in String comparisons
1598-crawler-log-folder/Solution.java:7:	LiteralsFirstInComparisons:	Position literals first in String comparisons
",0,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode(int x) {  *         val = x;  *         next = null;  *     }  * }  */ public class Solution {     public ListNode getIntersectionNode(ListNode headA, ListNode headB) {         int len1 = 0, len2 = 0;         ListNode curr1 = headA, curr2 = headB;         // Calculate the length of both linked lists         while (curr1 != null) {             curr1 = curr1.next;             len1++;         }         while (curr2 != null) {             curr2 = curr2.next;             len2++;         }         // Reset curr1 and curr2 to the head of A and B respectively         curr1 = headA;         curr2 = headB;         // Move the head of the longer linked list by the difference in lengths         if (len1 > len2) {             int diff = len1 - len2;             while (diff > 0) {                 curr1 = curr1.next;                 diff--;             }         } else if (len2 > len1) {             int diff = len2 - len1;             while (diff > 0) {                 curr2 = curr2.next;                 diff--;             }         }         // Traverse both linked lists at the same time until they intersect         while (curr1 != curr2) {             curr1 = curr1.next;             curr2 = curr2.next;         }         return curr1;     } }",1,"160-intersection-of-two-linked-lists/ListNode.java:14:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
160-intersection-of-two-linked-lists/ListNode.java:15:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class ParkingSystem {          private int bigSlots;     private int mediumSlots;     private int smallSlots;      public ParkingSystem(int big, int medium, int small) {         this.bigSlots = big;         this.mediumSlots = medium;         this.smallSlots = small;     }          public boolean addCar(int carType) {         if(carType == 1) {             if(bigSlots > 0) {                 bigSlots--;                 return true;             }         } else if(carType == 2) {             if(mediumSlots > 0) {                 mediumSlots--;                 return true;             }                      } else if(carType == 3) {             if(smallSlots > 0) {                 smallSlots--;                 return true;             }         }                  return false;     } }",1,"1603-design-parking-system/ParkingSystem.java:7:5: Redundant 'public' modifier. [RedundantModifier]
1603-design-parking-system/ParkingSystem.java:26:	CollapsibleIfStatements:	This if statement could be combined with its parent
",0,0,0
class Solution {     public int specialArray(int[] nums) {         int n = nums.length;         for (int x = 0; x <= n; x++) {             int count = 0;             for (int i = 0; i < n; i++) {                 if (nums[i] >= x) {                     count++;                 }             }             if (count == x) {                 return x;             }         }         return -1;     } },0,,0,0,0
"class Solution {     public int maxDepth(String s) {         int depth = 0; // initial depth         int maxDepth = 0; // max depth at any given time         for (char c : s.toCharArray()) { // iterating the string character by character             if (c == '(') {                 depth++; // if it's opening parenthesis, increment depth             } else if (c == ')') {                 depth--; // if it's closing parenthesis, decrement depth             }             if (depth > maxDepth) {                 maxDepth = depth; // if current depth is greater than max depth, update max depth             }         }         return maxDepth; // return max depth     } }",0,,0,0,0
class Solution {     public double trimMean(int[] arr) {         Arrays.sort(arr);         int len = arr.length;         int remove = len / 20;         double sum = 0;         for(int i = remove; i < len - remove; i++){             sum += arr[i];         }         return sum / (len - 2 * remove);     } },0,,0,0,0
"class Solution {     public int maxLengthBetweenEqualCharacters(String s) {         int ans = -1;         for(int i=0;i<s.length();i++){             char ch = s.charAt(i);             int index = s.lastIndexOf(ch);             if(index!=i)                 ans = Math.max(ans,index-i-1);         }         return ans;     } }",0,,0,0,0
"class Solution {     public char slowestKey(int[] releaseTimes, String keysPressed) {         int longestDuration = releaseTimes[0];         char longestDurationKey = keysPressed.charAt(0);                  for (int i = 1; i < releaseTimes.length; i++) {             int duration = releaseTimes[i] - releaseTimes[i-1];             if (duration > longestDuration || (duration == longestDuration && keysPressed.charAt(i) > longestDurationKey)) {                 longestDuration = duration;                 longestDurationKey = keysPressed.charAt(i);             }         }                  return longestDurationKey;     } }",0,,0,0,0
"import java.util.*;  class Solution {     public int[] frequencySort(int[] nums) {         // Create a hash map to count the frequency of each value         Map<Integer, Integer> freqMap = new HashMap<>();         for (int num : nums) {             freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);         }                  // Create a list of values and sort it by frequency and value         List<Integer> valList = new ArrayList<>(freqMap.keySet());         Collections.sort(valList, (a, b) -> {             int freqDiff = freqMap.get(a) - freqMap.get(b);             if (freqDiff != 0) {                 return freqDiff; // Sort by frequency in increasing order             } else {                 return b - a; // Sort by value in decreasing order             }         });                  // Create the sorted array from the sorted list         int[] sorted = new int[nums.length];         int i = 0;         for (int val : valList) {             int freq = freqMap.get(val);             while (freq > 0) {                 sorted[i++] = val;                 freq--;             }         }         return sorted;     } }",1,"1636-sort-array-by-increasing-frequency/Solution.java:6:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
1636-sort-array-by-increasing-frequency/Solution.java:15:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",0,0,0
"class Solution {     public boolean canFormArray(int[] arr, int[][] pieces) {         // Create a hashmap of the array elements and their indices         Map<Integer, Integer> map = new HashMap<>();         for (int i = 0; i < arr.length; i++) {             map.put(arr[i], i);         }                  // Iterate over the pieces and check if they can be formed from the array         for (int[] piece : pieces) {             int index = -1;             for (int num : piece) {                 if (!map.containsKey(num)) {                     return false; // If the number doesn't exist in the array, return false                 }                 if (index != -1 && map.get(num) != index + 1) {                     return false; // If the numbers in the piece aren't consecutive, return false                 }                 index = map.get(num); // Update the index for the next number in the piece             }         }         return true; // If all the pieces can be formed from the array, return true     } }",0,,0,0,0
"class Solution {     public int getMaximumGenerated(int n) {         if (n == 0) {             return 0;         }         int[] nums = new int[n + 1];         nums[1] = 1;         int maxNum = 1;         for (int i = 2; i <= n; i++) {             if (i % 2 == 0) {                 nums[i] = nums[i / 2];             } else {                 nums[i] = nums[i / 2] + nums[i / 2 + 1];             }             maxNum = Math.max(maxNum, nums[i]);         }         return maxNum;     } }",1,"1646-get-maximum-in-generated-array/Solution.java:9:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
",0,0,0
"class Solution {     public int[] decrypt(int[] code, int k) {         int n = code.length;         int[] decrypted = new int[n];         if (k == 0) {             return decrypted;         }         int start, end, sum, sign;         for (int i = 0; i < n; i++) {             start = (i + 1) % n;             end = (i + k) % n;             if (k > 0) {                 sign = 1;             } else {                 sign = -1;             }             if (end < start) {                 sum = sign * (Arrays.stream(code, start, n).sum() + Arrays.stream(code, 0, end + n + 1).sum());             } else {                 sum = sign * Arrays.stream(code, start, end + 1).sum();             }             decrypted[i] = sum;         }         return decrypted;     } }",1,"1652-defuse-the-bomb/Solution.java:8:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"import java.util.ArrayList; import java.util.List;  class OrderedStream {      private final String[] stream;     private int ptr;      public OrderedStream(int n) {         this.stream = new String[n];         this.ptr = 0;     }      public List<String> insert(int idKey, String value) {         List<String> chunk = new ArrayList<>();          // Set the value in the stream array         stream[idKey - 1] = value;          // Check if all the previous values have been added to the chunk         while (ptr < stream.length && stream[ptr] != null) {             chunk.add(stream[ptr]);             ptr++;         }          return chunk;     } }",1,"1656-design-an-ordered-stream/OrderedStream.java:9:5: Redundant 'public' modifier. [RedundantModifier]
",0,0,0
"class Solution {     public boolean arrayStringsAreEqual(String[] word1, String[] word2) {         // Concatenate all the strings in both arrays using StringBuilder         StringBuilder sb1 = new StringBuilder();         for (String s : word1) {             sb1.append(s);         }         StringBuilder sb2 = new StringBuilder();         for (String s : word2) {             sb2.append(s);         }         // Compare the resulting strings from both StringBuilder objects         return sb1.toString().equals(sb2.toString());     } }",0,,0,0,0
"class Solution {     public int maxRepeating(String sequence, String word) {         int maxK = 0;         StringBuilder sb = new StringBuilder(word);         while (sequence.contains(sb)) {             maxK++;             sb.append(word);         }         return maxK;     } }",0,,0,0,0
class Solution {     public int maximumWealth(int[][] accounts) {         int maxWealth = 0;         for (int i = 0; i < accounts.length; i++) {             int wealth = 0;             for (int j = 0; j < accounts[i].length; j++) {                 wealth += accounts[i][j];             }             if (wealth > maxWealth) {                 maxWealth = wealth;             }         }         return maxWealth;     } },1,"1672-richest-customer-wealth/Solution.java:4:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public String interpret(String command) {         StringBuilder sb = new StringBuilder();         for(int i=0;i<command.length();i++){             char c = command.charAt(i);             if(c == 'G') sb.append('G');             else if(c =='(' && command.charAt(i+1) == ')'){                 sb.append('o');                 i += 1;             }             else if(c =='(' && command.charAt(i+1) =='a'){                 sb.append(""al"");                 i += 3;             }         }         return sb.toString();     } }",1,"1678-goal-parser-interpretation/Solution.java:10:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
class Solution {     public String convertToTitle(int columnNumber) {         StringBuilder sb = new StringBuilder();         while(columnNumber>0){             columnNumber--;             sb.append((char)('A'+columnNumber%26));             columnNumber /= 26;         }         return sb.reverse().toString();     } },1,"168-excel-sheet-column-title/Solution.java:5:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'columnNumber'
",0,1,0
"class Solution {     public int countConsistentStrings(String allowed, String[] words) {         int count = 0;         Set<Character> allowedSet = new HashSet<>();                  // create a set of all characters in allowed string         for (char c : allowed.toCharArray()) {             allowedSet.add(c);         }                  // check each word in the array         for (String word : words) {             boolean consistent = true;             // check each character in the word             for (char c : word.toCharArray()) {                 if (!allowedSet.contains(c)) {                     // if the character is not in allowed set, word is not consistent                     consistent = false;                     break;                 }             }             if (consistent) {                 // if word is consistent, increment count                 count++;             }         }                  return count;     } }",0,,0,0,0
class Solution {     public int numberOfMatches(int n) {         int matches = 0;         while (n > 1) {             if (n % 2 == 0) {                 matches += n / 2;                 n /= 2;             } else {                 matches += (n - 1) / 2;                 n = (n - 1) / 2 + 1;             }         }         return matches;     } },1,"1688-count-of-matches-in-tournament/Solution.java:7:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
",0,1,0
class Solution {     public int majorityElement(int[] nums) {         int count = 0;         int candidate = nums[0];         for (int num : nums) {             if (count == 0) {                 candidate = num;             }             count += num == candidate ? 1 : -1;         }         return candidate;     } },0,,0,0,0
"class Solution {     public String reformatNumber(String number) {         // Remove all spaces and dashes from the string         String digits = number.replaceAll(""[\\s-]"", """");                  // Determine the number of digits in the string         int n = digits.length();                  // Create a StringBuilder to store the formatted phone number         StringBuilder sb = new StringBuilder();                  // Loop through the digits and group them in sets of three until there are 4 or fewer digits left         for (int i = 0; i < n; i++) {             sb.append(digits.charAt(i));             if ((i + 1) % 3 == 0 && i < n - 1) {                 sb.append(""-"");             }         }                  // If there are 2 or 4 digits remaining, split them into blocks of length 2         if (n % 3 == 2) {             sb.replace(sb.length() - 2, sb.length(), ""-"" + digits.substring(n - 2));         } else if (n % 3 == 1) {             sb.replace(sb.length() - 3, sb.length(), ""-"" + digits.substring(n - 2));             sb.insert(sb.length() - 4, ""-"");         }                  // Return the formatted phone number         return sb.toString();     } }",1,"1694-reformat-phone-number/Solution.java:16:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
",0,0,0
"class Solution {     public int countStudents(int[] students, int[] sandwiches) {         int circularCounter = 0;         int squareCounter = 0;          // Count number of students prefering circular and square sandwiches         for(int student : students){             if(student == 0){                 circularCounter++;             } else {                 squareCounter++;             }         }          // Check if the top sandwich preference matches the one         // of the student at the front of the queue         int i = 0;         while(i < sandwiches.length){              if(sandwiches[i] == students[0]){                 // If both match, remove that student from queue                 // and that sandwich from the stack                 students = Arrays.copyOfRange(students, 1, students.length);                 sandwiches = Arrays.copyOfRange(sandwiches, 1, sandwiches.length);                 // Reset the counter for the sandwiches preference                 // of the remaining students                 if(students.length > 0){                     if(students[0] == 0){                         circularCounter--;                     } else {                         squareCounter--;                     }                 }             } else {                 // If the sandwich preference does not match, move                 // that student to the end of the queue                 int temp = students[0];                 students = Arrays.copyOfRange(students, 1, students.length);                 students = Arrays.copyOf(students, students.length + 1);                 students[students.length - 1] = temp;             }              if(circularCounter == 0 || squareCounter == 0){                 // If there are no sandwiches left for a particular                 // preference, break the loop and return the remaining                 // number of students in the queue                 return students.length;             }              i++;         }          // If all sandwiches have been taken by students in the queue, return 0         return 0;     } }",1,"1700-number-of-students-unable-to-eat-lunch/Solution.java:23:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'students'
1700-number-of-students-unable-to-eat-lunch/Solution.java:24:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'sandwiches'
",0,1,0
"class Solution {     public boolean halvesAreAlike(String s) {                  String vowels = ""aeiouAEIOU"";                  int vowelCount = 0;                  // Counting vowels in first half         for(int i=0; i<s.length()/2; i++){             if(vowels.indexOf(s.charAt(i)) != -1)                 vowelCount++;         }                  // Subtracting the count of vowels in second half         for(int i=s.length()/2; i<s.length(); i++){             if(vowels.indexOf(s.charAt(i)) != -1)                 vowelCount--;         }                  return (vowelCount == 0);     } }",1,"1704-determine-if-string-halves-are-alike/Solution.java:20:	UselessParentheses:	Useless parentheses.
",0,0,0
class Solution {     public int titleToNumber(String columnTitle) {         int result = 0;         for (int i = 0; i < columnTitle.length(); i++) {             result = result * 26 + (columnTitle.charAt(i) - 'A' + 1);         }         return result;     } },1,"171-excel-sheet-column-number/Solution.java:5:	UselessParentheses:	Useless parentheses.
",0,0,0
"class Solution {     public int maximumUnits(int[][] boxTypes, int truckSize) {         // sort the boxTypes array in descending order by numberOfUnitsPerBoxi         Arrays.sort(boxTypes, (a, b) -> b[1] - a[1]);                  int totalUnits = 0;                  // loop through the sorted boxTypes array         for (int[] box : boxTypes) {             // check if the number of boxes of this type is greater than the truckSize remaining             if (truckSize > box[0]) {                 truckSize -= box[0];                 totalUnits += box[0] * box[1];             } else {                 // if the number of boxes of this type is less than or equal to the truckSize remaining                 totalUnits += truckSize * box[1];                 break;             }         }                  return totalUnits;     } }",1,"1710-maximum-units-on-a-truck/Solution.java:12:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'truckSize'
",0,1,0
class Solution {     public int totalMoney(int n) {         int totalMoney = 0;         int weeks = n/7;         int remainingDays = n%7;                  for(int i=1; i<=weeks; i++) {             totalMoney += 28 + (i-1)*7;         }                  int mondayMoney = weeks*(weeks-1)/2;         totalMoney += (remainingDays*(remainingDays+1))/2 + weeks*remainingDays + mondayMoney;                  return totalMoney;     } },1,"1716-calculate-money-in-leetcode-bank/Solution.java:12:	UselessParentheses:	Useless parentheses.
",0,0,0
"class Solution {     public int[] decode(int[] encoded, int first) {         int[] arr = new int[encoded.length + 1];         arr[0] = first; // First element of original array         for (int i = 0; i < encoded.length; i++) {             arr[i+1] = arr[i] ^ encoded[i]; // XOR operation         }         return arr;     } }   /* Example Usage:    Solution sol = new Solution();    int[] encoded = {1,2,3};    int first = 1;    int[] decoded = sol.decode(encoded, first); // returns [1,0,2,1] */",0,,0,0,0
"class Solution {     public int countGoodRectangles(int[][] rectangles) {         int maxLen = 0;         int count = 0;         for(int i=0;i<rectangles.length;i++){             int minLen = Math.min(rectangles[i][0],rectangles[i][1]); //Finding the smallest side length of each rectangle             if(minLen > maxLen){ //Checking if the smallest side length of the rectangle is greater than the previous max length                 maxLen = minLen; //Updating the max length                 count = 1; //Resetting the count to 1, as we have found a new max length             }             else if(minLen == maxLen){ //If the smallest side length of the rectangle is equal to the current max length                 count++; //Incrementing the count             }         }         return count; //Returning the count of rectangles that can make a square with a side length of maxLen     } }",1,"1725-number-of-rectangles-that-can-form-the-largest-square/Solution.java:10:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1725-number-of-rectangles-that-can-form-the-largest-square/Solution.java:5:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int largestAltitude(int[] gain) {         int highestAltitude = 0;         int currentAltitude = 0;                  for(int i=0; i<gain.length; i++) {             currentAltitude += gain[i];             highestAltitude = Math.max(highestAltitude, currentAltitude);         }                  return highestAltitude;     } }",1,"1732-find-the-highest-altitude/Solution.java:6:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
class Solution {     public String maximumTime(String time) {         char[] timeArr = time.toCharArray(); // convert string to char array         // set the hours' tens digit to 2 if the hours' unit digit is greater than 3 and the hours' tens digit is unknown         if (timeArr[0] == '?' && timeArr[1] != '?' && timeArr[1] > '3') {             timeArr[0] = '1';         } else if (timeArr[0] == '?' && timeArr[1] != '?' && timeArr[1] <= '3') {             timeArr[0] = '2';         }         // set the hours' unit digit to 9 if the hours' tens digit is 2 and the hours' unit digit is unknown         if (timeArr[1] == '?' && timeArr[0] == '2') {             timeArr[1] = '3';         } else if (timeArr[1] == '?') {             timeArr[1] = '9';         }         // set the minutes' tens digit to 5 if the minutes' unit digit is greater than 5 and the minutes' tens digit is unknown         if (timeArr[3] == '?' && timeArr[4] != '?' && timeArr[4] > '5') {             timeArr[3] = '5';         } else if (timeArr[3] == '?') {             timeArr[3] = '5';         }         // set the minutes' unit digit to 9 if the minutes' unit digit is unknown         if (timeArr[4] == '?') {             timeArr[4] = '9';         }         return new String(timeArr);     } },1,"1736-latest-time-by-replacing-hidden-digits/Solution.java:2:	NPathComplexity:	The method 'maximumTime(String)' has an NPath complexity of 280, current threshold is 200
1736-latest-time-by-replacing-hidden-digits/Solution.java:26:	StringInstantiation:	Avoid instantiating String objects; this is usually unnecessary.
",0,0,0
"class Solution {     public int countBalls(int lowLimit, int highLimit) {         int[] boxes = new int[46]; // maximum limit is 9 + 9 + 9 + 9 + 9 = 45                  for (int i = lowLimit; i <= highLimit; i++) {             int sum = 0;             int num = i;             while (num > 0) {                 sum += num % 10;                 num /= 10;             }             boxes[sum]++;         }                  int maxBalls = 0;         for (int i = 0; i < 46; i++) {             if (boxes[i] > maxBalls) {                 maxBalls = boxes[i];             }         }                  return maxBalls;     } }",0,,0,0,0
class Solution {     public int sumOfUnique(int[] nums) {         int[] frequency = new int[101]; // initialize an array of size 101 to keep count of each element frequency         for (int i = 0; i < nums.length; i++) {             frequency[nums[i]]++; // increment frequency of each element in nums         }         int sum = 0;         for (int i = 1; i <= 100; i++) {             if (frequency[i] == 1) { // check which elements appear only once in nums                 sum += i; // add the unique elements to sum             }         }         return sum;     } },1,"1748-sum-of-unique-elements/Solution.java:4:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
class Solution {     public boolean check(int[] nums) {         int n = nums.length;         for(int i=1;i<n;i++){             if(nums[i]<nums[i-1]){                 int count = 0;                 for(int j=i;j<n;j++){                     if(nums[j]<nums[j-1]){                         count++;                     } else {                         break;                     }                 }                 for(int j=0;j<i-1;j++){                     if(nums[j+1]<nums[j]){                         count++;                     } else {                         break;                     }                 }                 return count==n-1;             }         }         return true;      } },0,,0,0,0
"class Solution {     public int minOperations(String s) {         int evenCount = 0, oddCount = 0, len = s.length();         char[] chars = s.toCharArray();         for (int i = 0; i < len; i++) {             if (i % 2 == 0 && chars[i] == '1') evenCount++;  // count for ""01010101..."" pattern             if (i % 2 == 1 && chars[i] == '0') evenCount++;  // count for ""10101010..."" pattern             if (i % 2 == 0 && chars[i] == '0') oddCount++;   // count for ""10101010..."" pattern             if (i % 2 == 1 && chars[i] == '1') oddCount++;   // count for ""01010101..."" pattern         }         return Math.min(evenCount, oddCount);     } }",1,"1758-minimum-changes-to-make-alternating-binary-string/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public String longestNiceSubstring(String s) {         String result = """";         for(int i = 0; i < s.length(); i++){             for(int j = i + 1; j <= s.length(); j++){                 String sub = s.substring(i, j);                 if(isNice(sub) && sub.length() > result.length()){                     result = sub;                 }             }         }         return result;     }          private boolean isNice(String s){         Set<Character> upperCase = new HashSet<>();         Set<Character> lowerCase = new HashSet<>();         for(char ch : s.toCharArray()){             if(Character.isUpperCase(ch)){                 upperCase.add(ch);             }             else{                 lowerCase.add(ch);             }         }         for(char ch : upperCase){             char correspondingLower = Character.toLowerCase(ch);             if(!lowerCase.contains(correspondingLower)){                 return false;             }         }         for(char ch : lowerCase){             char correspondingUpper = Character.toUpperCase(ch);             if(!upperCase.contains(correspondingUpper)){                 return false;             }         }         return true;     } }",1,"1763-longest-nice-substring/Solution.java:21:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
"class Solution {     public String mergeAlternately(String word1, String word2) {         int i = 0, j = 0;         StringBuilder sb = new StringBuilder();         while (i < word1.length() && j < word2.length()) {             sb.append(word1.charAt(i++));             sb.append(word2.charAt(j++));         }         while (i < word1.length()) {             sb.append(word1.charAt(i++));         }         while (j < word2.length()) {             sb.append(word2.charAt(j++));         }         return sb.toString();     } }",1,"1768-merge-strings-alternately/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1768-merge-strings-alternately/Solution.java:6:	ConsecutiveAppendsShouldReuse:	StringBuffer (or StringBuilder).append is called consecutively without reusing the target variable.
",1,0,0
"class Solution {     public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {         int count = 0;         int keyIndex = 0;         if(ruleKey.equals(""color"")) {             keyIndex = 1;         }         else if(ruleKey.equals(""name"")) {             keyIndex = 2;         }         for(List<String> item : items) {             if(item.get(keyIndex).equals(ruleValue)) {                 count++;             }         }         return count;     } }   // This code assumes that the input is of type `List<List<String>>`. If the input is given as a regular 2D string array `items`, the function signature will change to: `public int countMatches(String[][] items, String ruleKey, String ruleValue)`.",1,"1773-count-items-matching-a-rule/Solution.java:7:9: '}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1773-count-items-matching-a-rule/Solution.java:5:	LiteralsFirstInComparisons:	Position literals first in String comparisons
1773-count-items-matching-a-rule/Solution.java:8:	LiteralsFirstInComparisons:	Position literals first in String comparisons
",0,0,0
"import java.util.*;  public class Solution {     public int nearestValidPoint(int x, int y, int[][] points) {         int minDist = Integer.MAX_VALUE;         int minIndex = -1;          for (int i = 0; i < points.length; i++) {             int[] point = points[i];             if (point[0] == x || point[1] == y) {                 int dist = Math.abs(point[0] - x) + Math.abs(point[1] - y);                 if (dist < minDist) {                     minDist = dist;                     minIndex = i;                 }             }         }          return minIndex;     } }",1,"1779-find-nearest-point-that-has-the-same-x-or-y-coordinate/Solution.java:1:	UnnecessaryImport:	Unused import 'java.util.*'
",0,0,0
class Solution {     public boolean checkOnesSegment(String s) {         boolean onesSegment = false;         for(int i=0; i<s.length()-1; i++){             if(s.charAt(i)=='0' && s.charAt(i+1)=='1' && onesSegment==false){                 onesSegment = true;             }             else if(s.charAt(i)=='1' && s.charAt(i+1)=='0' && onesSegment==true){                 onesSegment = false;             }             else if(s.charAt(i)=='0' && s.charAt(i+1)=='1' && onesSegment==true){                 return false;             }         }         return true;     } },1,"1784-check-if-binary-string-has-at-most-one-segment-of-ones/Solution.java:5:69: Expression can be simplified. [SimplifyBooleanExpression]
1784-check-if-binary-string-has-at-most-one-segment-of-ones/Solution.java:7:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1784-check-if-binary-string-has-at-most-one-segment-of-ones/Solution.java:8:74: Expression can be simplified. [SimplifyBooleanExpression]
1784-check-if-binary-string-has-at-most-one-segment-of-ones/Solution.java:10:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1784-check-if-binary-string-has-at-most-one-segment-of-ones/Solution.java:11:74: Expression can be simplified. [SimplifyBooleanExpression]
1784-check-if-binary-string-has-at-most-one-segment-of-ones/Solution.java:5:	SimplifyBooleanExpressions:	Avoid unnecessary comparisons in boolean expressions
1784-check-if-binary-string-has-at-most-one-segment-of-ones/Solution.java:8:	SimplifyBooleanExpressions:	Avoid unnecessary comparisons in boolean expressions
1784-check-if-binary-string-has-at-most-one-segment-of-ones/Solution.java:11:	SimplifyBooleanExpressions:	Avoid unnecessary comparisons in boolean expressions
",0,0,0
"class Solution {     public boolean areAlmostEqual(String s1, String s2) {         // If the two strings are already equal, return true.         if (s1.equals(s2)) {             return true;         }                  //Check if the length of the strings is 1 or if the length of the strings is greater than 2.         if (s1.length() != s2.length() || s1.length() == 1 || s2.length() == 1) {             return false;         }                  int firstIndex = -1;         int secondIndex = -1;                  //Loop through the strings and find indices where they differ.         for (int i = 0; i < s1.length(); i++) {             if (s1.charAt(i) != s2.charAt(i)) {                 if (firstIndex == -1) {                     firstIndex = i;                 } else if (secondIndex == -1) {                     secondIndex = i;                 } else {                     return false;                 }                 }         }                  //Check if the two differing characters can be swapped in s2 to make s1.         if (secondIndex != -1) {             if (s1.charAt(firstIndex) == s2.charAt(secondIndex) && s1.charAt(secondIndex) == s2.charAt(firstIndex)) {                 return true;             } else {                 return false;             }         }                  //Check if there is only one differing character between s1 and s2.         if (firstIndex != -1 && secondIndex == -1) {             return false;         }                  return true;     } }",1,"1790-check-if-one-string-swap-can-make-strings-equal/Solution.java:31:13: Conditional logic can be removed. [SimplifyBooleanReturn]
1790-check-if-one-string-swap-can-make-strings-equal/Solution.java:2:	NPathComplexity:	The method 'areAlmostEqual(String, String)' has an NPath complexity of 480, current threshold is 200
1790-check-if-one-string-swap-can-make-strings-equal/Solution.java:31:	SimplifyBooleanReturns:	This if statement can be replaced by `return {condition};`
1790-check-if-one-string-swap-can-make-strings-equal/Solution.java:39:	SimplifyBooleanReturns:	This if statement can be replaced by `return !{condition};`
",0,0,0
class Solution {     public int findCenter(int[][] edges) {         int[] count = new int[edges.length+2]; // create a count array         for(int[] edge: edges){             count[edge[0]]++; // increment the count of first node in the edge             count[edge[1]]++; // increment the count of second node in the edge         }         for(int i=0;i<count.length;i++){             if(count[i]==edges.length)                 return i; // return the node with count equals to length of edges         }         return -1;     } },0,,0,0,0
"class Solution {     public int secondHighest(String s) {         int largest = -1, secondLargest = -1;         for(char c : s.toCharArray()){             if(Character.isDigit(c)){                 int num = Character.getNumericValue(c);                 if(num > largest){                     secondLargest = largest;                     largest = num;                 }                 else if(num < largest && num > secondLargest){                     secondLargest = num;                 }             }         }         return secondLargest;     } }   // Note: if no second largest number found, then the default value -1 will be returned.",1,"1796-second-largest-digit-in-a-string/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1796-second-largest-digit-in-a-string/Solution.java:10:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",1,0,0
"class Solution {     public int maxAscendingSum(int[] nums) {         int maxSum = nums[0];  //initialize the variable to take the sum          int currentSum = nums[0];  //initialize the variable to track current sum of the array elements                  for(int i=1; i<nums.length; i++){             if(nums[i] > nums[i-1]){  //checks if the current element is greater than previous element                 currentSum += nums[i];  //if current element is greater, add it to current sum             }             else{                 currentSum = nums[i];  //if not, consider the current element itself as a new sequence             }             maxSum = Math.max(maxSum, currentSum);  //update the maxSum with the maximum value of currentSum and maxSum         }         return maxSum;  //return the maximum sum of ascending subarray     } }",1,"1800-maximum-ascending-subarray-sum/Solution.java:9:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
"class Solution {     public int numDifferentIntegers(String word) {         HashSet<String> set = new HashSet<>(); // create a HashSet to store unique integers                  // replace non-digit characters with space and split into an array of strings         String[] arr = word.replaceAll(""[^0-9]+"", "" "").split(""\\s+"");                  // loop through the array, remove leading zeros and add to the HashSet         for (String s : arr) {             set.add(s.replaceFirst(""^0*"", """"));         }                  return set.size(); // return the size of the HashSet     } }",0,,0,0,0
class Solution {     public boolean squareIsWhite(String coordinates) {         char column = coordinates.charAt(0);         char row = coordinates.charAt(1);                  if ((column == 'a' || column == 'c' || column == 'e' || column == 'g') && (row == '1' || row == '3' || row == '5' || row == '7')) {             return false;         }                  if ((column == 'b' || column == 'd' || column == 'f' || column == 'h') && (row == '2' || row == '4' || row == '6' || row == '8')) {             return false;         }                  return true;     } },1,"1812-determine-color-of-a-chessboard-square/Solution.java:10:	SimplifyBooleanReturns:	This if statement can be replaced by `return !{condition};`
",0,0,0
"class Solution {     public String truncateSentence(String s, int k) {         String[] words = s.split("" ""); // split sentence into array of words         StringBuilder sb = new StringBuilder(); // to store truncated sentence         for (int i = 0; i < k; i++) { // iterate over first k words             sb.append(words[i]).append("" ""); // add word and space to StringBuilder         }         return sb.toString().trim(); // convert StringBuilder to String and trim trailing space     } }",1,"1816-truncate-sentence/Solution.java:6:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
",0,0,0
class Solution {     public int arraySign(int[] nums) {         int product = 1;         for (int num : nums) {             product *= num; // calculate the product of all values         }         if (product > 0) {             return 1; // product is positive         } else if (product < 0) {             return -1; // product is negative         } else {             return 0; // product is zero         }     } }   /* Time Complexity: O(n) Space Complexity: O(1) */,0,,0,0,0
"class Solution {     public int minOperations(int[] nums) {         int operations = 0;         for (int i = 1; i < nums.length; i++) {             if (nums[i] <= nums[i - 1]) {                 operations += nums[i - 1] - nums[i] + 1;                 nums[i] = nums[i - 1] + 1;             }         }         return operations;     } }  /*Explanation: We iterate through the array starting at the second element and compare it with the previous element.  If it is smaller, we calculate the difference and add 1 to get the number of operations needed to make this element larger than the previous element.  We then increment the current element to ensure that it is strictly increasing. We return the total number of operations required.*/",0,,0,0,0
class Solution {     public boolean checkIfPangram(String sentence) {         boolean[] letters = new boolean[26]; //to keep track of presence of each letter         int count = 0; //to count how many letters are present          for (char c : sentence.toCharArray()) { //iterating through each character of sentence             if (!letters[c - 'a']) { //if that letter is not present yet                 letters[c - 'a'] = true; //mark it as present                 count++; //increment count of letters present             }             if (count == 26) { //if all 26 letters are present                 return true; //return true             }         }          return false; //if all 26 letters are not present     } },0,,0,0,0
"class Solution {     public int sumBase(int n, int k) {         int sum = 0;         while(n!=0){             sum += n%k;             n = n/k;         }         return sum;     } }",1,"1837-sum-of-digits-in-base-k/Solution.java:6:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
",0,1,0
"class Solution {     public String replaceDigits(String s) {         char[] arr = s.toCharArray();         for(int i=1; i<arr.length; i+=2){             arr[i] = shift(arr[i-1], arr[i]);         }         return String.valueOf(arr);     }          public char shift(char c, char x){         return (char)(c + (x - '0'));     } }",1,"1844-replace-all-digits-with-characters/Solution.java:11:	UselessParentheses:	Useless parentheses.
",0,0,0
"class Solution {     public int getMinDistance(int[] nums, int target, int start) {         int minValue = Integer.MAX_VALUE;         int result = 0;         for(int i=0; i<nums.length; i++) {             if(nums[i] == target) {                 int absoluteValue = Math.abs(i-start);                 if(absoluteValue < minValue) {                     result = absoluteValue;                     minValue = absoluteValue;                 }             }         }         return result;     } }",0,,0,0,0
class Solution {     public int maximumPopulation(int[][] logs) {         int[] years = new int[101]; // array to store population count for each year (1950-2050)         for (int[] log : logs) {             for (int i = log[0]; i < log[1]; i++) { // count population for each year in the log range                 years[i - 1950]++;             }         }         int maxPopulation = years[0]; // initialize maximum population as the first year         int maxYear = 1950; // initialize maximum population year as 1950         for (int i = 1; i < years.length; i++) {             if (years[i] > maxPopulation) { // if population of current year is greater than maxPopulation                 maxPopulation = years[i]; // update maximum population                 maxYear = i + 1950; // update maximum population year             }         }         return maxYear;     } },0,,0,0,0
"class Solution {     public String sortSentence(String s) {         String[] words = s.split("" "");         String[] sorted = new String[words.length];         for (String word : words) {             int index = Integer.parseInt(word.substring(word.length() - 1));             sorted[index - 1] = word.substring(0, word.length() - 1);         }         return String.join("" "", sorted);     } }",0,,0,0,0
import java.util.*;  class Solution {     public int subsetXORSum(int[] nums) {         int res = 0;         for (int mask = 0; mask < (1 << nums.length); mask++) {             int xor = 0;             for (int i = 0; i < nums.length; i++) {                 if ((mask & (1 << i)) != 0) {                     xor ^= nums[i];                 }             }             res += xor;         }         return res;     } } ,1,"1863-sum-of-all-subset-xor-totals/Solution.java:1:	UnnecessaryImport:	Unused import 'java.util.*'
",0,0,0
"class Solution {     public boolean checkZeroOnes(String s) {         int maxOnes = 0, maxZeros = 0, currentOnes = 0, currentZeros = 0;                  for(int i = 0; i < s.length(); i++) {             char c = s.charAt(i);                          // If character is '1', increment current ones and check if it is greater than the maximum             if(c == '1') {                 currentOnes++;                 maxOnes = Math.max(maxOnes, currentOnes);             } else {                 // If character is '0', increment current zeros and check if it is greater than the maximum                 currentZeros++;                 maxZeros = Math.max(maxZeros, currentZeros);             }         }                  // If the number of ones is greater than the number of zeros, return true         return maxOnes > maxZeros;     } }",1,"1869-longer-contiguous-segments-of-ones-than-zeros/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
class Solution {     public int countGoodSubstrings(String s) {         int count = 0;         for(int i=0; i<=s.length()-3; i++) {             char c1 = s.charAt(i);             char c2 = s.charAt(i+1);             char c3 = s.charAt(i+2);             if(c1 != c2 && c2 != c3 && c3 != c1) {                 count++;             }         }         return count;     } },0,,0,0,0
"class Solution {     public boolean isSumEqual(String firstWord, String secondWord, String targetWord) {                  int sum1 = 0; //sum of firstWord letters         int sum2 = 0; //sum of secondWord letters         int target = 0; //sum of targetWord letters                  //calculating the sum of letters in firstWord         for(int i=0;i<firstWord.length();i++){             sum1 = sum1*10 + (firstWord.charAt(i) - 'a');         }                  //calculating the sum of letters in secondWord         for(int i=0;i<secondWord.length();i++){             sum2 = sum2*10 + (secondWord.charAt(i) - 'a');         }                  //calculating the sum of letters in targetWord         for(int i=0;i<targetWord.length();i++){             target = target*10 + (targetWord.charAt(i) - 'a');         }                  //checking if summation of sum1 and sum2 is equal to target         return (sum1+sum2)==target;     } }",1,"1880-check-if-word-equals-summation-of-two-words/Solution.java:10:	UselessParentheses:	Useless parentheses.
1880-check-if-word-equals-summation-of-two-words/Solution.java:15:	UselessParentheses:	Useless parentheses.
1880-check-if-word-equals-summation-of-two-words/Solution.java:20:	UselessParentheses:	Useless parentheses.
",0,0,0
"public class Solution {     public boolean findRotation(int[][] mat, int[][] target) {         int n = mat.length;         for(int k = 0; k < 4; k++) {             rotate(mat);             if(equals(mat, target, n)) {                 return true;             }         }         return false;     }          private void rotate(int[][] mat){         int n = mat.length;         for(int i = 0; i < n / 2; i++) {             for(int j = i; j < n - 1 - i; j++) {                 int temp = mat[i][j];                 mat[i][j] = mat[n - 1 - j][i];                 mat[n - 1 - j][i] = mat[n - 1 - i][n - 1 - j];                 mat[n - 1 - i][n - 1 - j] = mat[j][n - 1 - i];                 mat[j][n - 1 - i] = temp;             }         }     }          private boolean equals(int[][] mat, int[][] target, int n) {         for(int i = 0; i < n; i++) {             for(int j = 0; j < n; j++) {                 if(mat[i][j] != target[i][j]) {                     return false;                 }             }         }         return true;     } }",0,,0,0,0
"class Solution {     public boolean isCovered(int[][] ranges, int left, int right) {         boolean[] covered = new boolean[right - left + 1]; // to check if all numbers are covered         for(int[] range : ranges) {             for(int i=left;i<=right;i++) { // check if i is covered by any range                 if(i>=range[0] && i<=range[1]) {                     covered[i-left] = true; // mark as covered                 }             }         }         for(boolean b : covered) { // check if any number is not covered             if(!b) {                 return false;             }         }         return true; // all numbers are covered     } }",0,,0,0,0
class Solution {     public boolean makeEqual(String[] words) {           int[] frequencyMap = new int[26];         for (String word : words) {             // Calculate frequency of each character             for (char c : word.toCharArray()) {                 frequencyMap[c - 'a']++;             }         }         // Check if frequency of each character is divisible by words.length         for (int frequency : frequencyMap) {             if (frequency % words.length != 0) {                 return false;             }         }         return true;     } },0,,0,0,0
public class Solution {     // you need treat n as an unsigned value     public int reverseBits(int n) {         int result = 0;         for (int i = 0; i < 32; i++) {             result += n & 1;             n >>>= 1;   // Unsigned shift right operator             if (i < 31)                  result <<= 1;         }         return result;     } },1,"190-reverse-bits/Solution.java:7:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
",0,1,0
"class Solution {     public String largestOddNumber(String num) {         int n = num.length();         for (int i = n - 1; i >= 0; i--) {             int digit = num.charAt(i) - '0';             if (digit % 2 != 0) {                 return num.substring(0, i+1);             }         }         return """";     } }",0,,0,0,0
class Solution {     public boolean canBeIncreasing(int[] nums) {         int count = 0;                  for (int i = 1; i < nums.length; i++) {             if (nums[i] <= nums[i - 1]) {                 count++;                 if (count > 1) {                     return false;                 }                 if (i > 1 && nums[i] <= nums[i - 2]) {                     nums[i] = nums[i - 1];                 }             }         }                  return true;     } } ,0,,0,0,0
"public class Solution {     // you need to treat n as an unsigned value     public int hammingWeight(int n) {         int count = 0;                  for (int i = 0; i < 32; i++) {             count += n & 1;             n >>= 1;         }                  return count;     } }  //To optimize the function, we can use the bitwise operation to count the number of 1's without the need for a loop.",1,"191-number-of-1-bits/Solution.java:8:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
",0,1,0
"class Solution {     public int maxProductDifference(int[] nums) {         int n = nums.length;                  // Sorting the array in ascending order         Arrays.sort(nums);                  // Calculating product of first two and last two elements         int productDifference = (nums[n-1] * nums[n-2]) - (nums[0] * nums[1]);                  return productDifference;     } }  /* Test Cases: Input: nums = [5,6,2,7,4] Output: 34  Input: nums = [4,2,5,9,7,4,8] Output: 64  Time Complexity: O(n log n) Space Complexity: O(1) */",1,"1913-maximum-product-difference-between-two-pairs/Solution.java:9:	UnnecessaryLocalBeforeReturn:	Consider simply returning the value vs storing it in local variable 'productDifference'
",0,0,0
class Solution {     public int[] buildArray(int[] nums) {         // Create a result array of the same length as nums         int[] ans = new int[nums.length];                  // Fill the result array with the values from nums at their corresponding index         for (int i = 0; i < nums.length; i++) {             ans[i] = nums[nums[i]];         }                  // Return the result array         return ans;     } },0,,0,0,0
class Solution {     public int countTriples(int n) {         int count = 0;         for(int a=1;a<=n;a++){             for(int b=1;b<=n;b++){                 double c = Math.sqrt(a*a+b*b); //Calculate square root of a*a+b*b to check if c is an integer                  if(c<=n && c==Math.floor(c)) { //Check if the value of c is an integer and lies within the given range                     count++;                 }             }         }         return count;     } },0,,0,0,0
"class Solution {     public int[] getConcatenation(int[] nums) {         int[] ans = new int[2 * nums.length];         for (int i = 0; i < nums.length; i++) {             ans[i] = nums[i];             ans[i + nums.length] = nums[i];         }         return ans;     } }  //To test the Solution class Main {     public static void main(String[] args) {         int[] nums1 = {1, 2, 1};         Solution solution = new Solution();         int[] ans1 = solution.getConcatenation(nums1);         System.out.println(""Ans1: "");         for (int i : ans1) {             System.out.print(i + "" "");         }         int[] nums2 = {1, 3, 2, 1};         int[] ans2 = solution.getConcatenation(nums2);         System.out.println(""\nAns2: "");         for (int i : ans2) {             System.out.print(i + "" "");         }     } }",1,"1929-concatenation-of-array/Solution.java:13:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
1929-concatenation-of-array/Solution.java:13:	UseUtilityClass:	This utility class has a non-private constructor
",0,0,0
"class Solution {     public int canBeTypedWords(String text, String brokenLetters) {         // Split the input string into individual words         String[] words = text.split("" "");                  int count = 0;         // Loop through each word in the array         for (String word : words) {             boolean canTypeWord = true;             // Check if any character in the word is in the brokenLetters string             for (char c : word.toCharArray()) {                 if (brokenLetters.indexOf(c) >= 0) {                     canTypeWord = false;                     break;                 }             }             // Increment the count if the word can be fully typed             if (canTypeWord) {                 count++;             }         }         return count;     } }",1,"1935-maximum-number-of-words-you-can-type/Solution.java:2:	LinguisticNaming:	Linguistics Antipattern - The method 'canBeTypedWords' indicates linguistically it returns a boolean, but it returns 'int'
",0,0,0
class Solution {     public boolean areOccurrencesEqual(String s) {         int[] charCount = new int[26]; // to store the count of each lowercase letter                  // count the frequency of each letter in the given string         for (int i = 0; i < s.length(); i++) {             char c = s.charAt(i);             charCount[c - 'a']++;         }                  int frequency = -1;         // check if all letters have the same frequency         for (int count : charCount) {             if (count == 0) {                 continue; // skip if the current letter is not present             }             if (frequency == -1) {                 frequency = count; // initialize frequency with the count of the first letter             } else if (count != frequency) {                 return false; // return false if frequency doesn't match for any letter             }         }                  return true;     } },0,,0,0,0
"class Solution {     public int getLucky(String s, int k) {         StringBuilder sb = new StringBuilder();         for (char c : s.toCharArray()) {             sb.append((int) (c - 'a' + 1));         }         String num = sb.toString();         for (int i = 0; i < k; i++) {             int sum = 0;             for (char c : num.toCharArray()) {                 sum += (int) (c - '0');             }             num = Integer.toString(sum);                     }         return Integer.parseInt(num);     } }",1,"1945-sum-of-digits-of-string-after-convert/Solution.java:5:	UnnecessaryCast:	Unnecessary cast (int)
1945-sum-of-digits-of-string-after-convert/Solution.java:11:	UnnecessaryCast:	Unnecessary cast (int)
",0,0,0
class Solution {     public boolean isThree(int n) {         int divisors = 0;         for(int i = 1; i <= n; i++) {             if(n % i == 0) {                 divisors++;             }         }         return divisors == 3;     } } ,0,,0,0,0
"// Importing required libraries import java.util.*;  // Main Solution class class Solution {     // Function to make a fancy string     public String makeFancyString(String s) {         int n = s.length();         // If length is less than 3         if (n < 3) {             return s;         }         // Converting string to character array         char[] charArr = s.toCharArray();         // Looping through the character array         for (int i = 2, j = 2; i < n; i++) {             // If last two characters don't match current character             if (charArr[j - 2] != charArr[i]) {                 charArr[j++] = charArr[i];             }         }         // Returning final string         return new String(charArr, 0, j);     } }",1,"1957-delete-characters-to-make-fancy-string/Solution.java:2:	UnnecessaryImport:	Unused import 'java.util.*'
1957-delete-characters-to-make-fancy-string/Solution.java:16:	ForLoopVariableCount:	Too many control variables in the for statement
",0,0,0
"class Solution {     public boolean isPrefixString(String s, String[] words) {         int n = words.length;         int i = 0;         int j = 0;         while (i < n && j < s.length()) {             if (s.charAt(j) != words[i].charAt(0)) {                 return false;             }             int k = 0;             while (j < s.length() && k < words[i].length()                    && s.charAt(j) == words[i].charAt(k)) {                 j++;                 k++;             }             if (k != words[i].length()) {                 return false;             }             i++;         }         return j == s.length() && i <= n;     } }",0,,0,0,0
"class Solution {     public int numOfStrings(String[] patterns, String word) {         int count = 0;         for(String pattern : patterns) {             if(word.contains(pattern)) {   //checks if the pattern exists as a substring in the word                 count++;                    // increases the count by 1 if the pattern is present             }         }         return count;                       // returns the final count value     } }",0,,0,0,0
"class Solution {     public boolean validPath(int n, int[][] edges, int source, int destination) {         Map<Integer, List<Integer>> graph = new HashMap<>();         for (int[] edge : edges) {             int u = edge[0];             int v = edge[1];             List<Integer> neighborsU = graph.getOrDefault(u, new ArrayList<>());             List<Integer> neighborsV = graph.getOrDefault(v, new ArrayList<>());             neighborsU.add(v);             neighborsV.add(u);             graph.put(u, neighborsU);             graph.put(v, neighborsV);         }         boolean[] visited = new boolean[n];         Queue<Integer> queue = new LinkedList<>();         queue.offer(source);         while (!queue.isEmpty()) {             int curr = queue.poll();             if (curr == destination) {                 return true;             }             visited[curr] = true;             List<Integer> neighbors = graph.getOrDefault(curr, new ArrayList<>());             for (int neighbor : neighbors) {                 if (!visited[neighbor]) {                     queue.offer(neighbor);                 }             }         }         return false;     } }",0,,0,0,0
"class Solution {     public int minTimeToType(String word) {         int seconds = 0;         char curr = 'a';         for (int i = 0; i < word.length(); i++) {             char c = word.charAt(i);             int diff = Math.abs(c - curr); // calculate difference between current character and target             seconds += Math.min(diff, 26 - diff); // choose shortest distance between clockwise and counterclockwise             curr = c; // set current character as target for next iteration         }         return seconds + word.length(); // add time to type each character     } }",0,,0,0,0
"class Solution {     public int findGCD(int[] nums) {         int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;          // Find the smallest and largest numbers         for (int i = 0; i < nums.length; i++) {             min = Math.min(min, nums[i]);             max = Math.max(max, nums[i]);         }          // Find the GCD           int gcd = 1;         for (int i = 1; i <= min && i <= max; i++) {             if ((min % i == 0) && (max % i == 0)) {                 gcd = i;             }         }          return gcd;     } }",1,"1979-find-greatest-common-divisor-of-array/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1979-find-greatest-common-divisor-of-array/Solution.java:6:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",1,0,1
"class Solution {     public int minimumDifference(int[] nums, int k) {         Arrays.sort(nums);         int minDiff = Integer.MAX_VALUE;         for (int i = 0; i <= nums.length - k; i++) {             int diff = nums[i + k - 1] - nums[i];             minDiff = Math.min(minDiff, diff);         }         return minDiff;     } }",0,,0,0,0
class Solution {     public int findMiddleIndex(int[] nums) {         int rightSum = 0;         for (int num : nums) {             rightSum += num;         }                  int leftSum = 0;         for (int i = 0; i < nums.length; i++) {             rightSum -= nums[i];                          if (leftSum == rightSum) {                 return i;             }                          leftSum += nums[i];         }                  return -1;     } },0,,0,0,0
Class Solution {     public int countQuadruplets(int[] nums) {              int count = 0;         for (int i = 0; i < nums.length; i++) {             for (int j = i + 1; j < nums.length; j++) {                 for (int k = j + 1; k < nums.length; k++) {                     for (int l = k + 1; l < nums.length; l++) {                         if (nums[i] + nums[j] + nums[k] == nums[l]) {                             count++;                         }                     }                 }             }         }         return count;     } },1,"1995-count-special-quadruplets/Solution.java	-	ParseException: Parse exception in file '1995-count-special-quadruplets/Solution.java': Encountered <IDENTIFIER: ""Class""> at line 1, column 1.
",0,0,0
"class Solution {     public String reversePrefix(String word, char ch) {         int indexCh = word.indexOf(ch);         if(indexCh == -1) {             // character not found in string, return original string             return word;         } else {             // character found in string, reverse substring from 0 to indexCh             String reversed = new StringBuilder(word.substring(0, indexCh + 1)).reverse().toString();             return reversed + word.substring(indexCh + 1);         }     } }",0,,0,0,0
"class Solution {     public int countKDifference(int[] nums, int k) {         int count = 0;         for (int i = 0; i < nums.length; i++) {             for (int j = i + 1; j < nums.length; j++) {                 if (Math.abs(nums[i] - nums[j]) == k) {                     count++;                 }             }         }         return count;     } }  /*Driver public class Main {     public static void main(String[] args) {         int[] nums = {1,2,2,1};         int k = 1;         Solution obj = new Solution();         int result = obj.countKDifference(nums, k);         System.out.println(result);     } }*/ ",0,,0,0,0
"class Solution {     public int finalValueAfterOperations(String[] operations) {         int x = 0; //initial value         for (String op : operations) {             if (op.equals(""++X"") || op.equals(""X++"")) {                 x++;             } else {                 x--;             }         }         return x;     } }",1,"2011-final-value-of-variable-after-performing-operations/Solution.java:5:	LiteralsFirstInComparisons:	Position literals first in String comparisons
2011-final-value-of-variable-after-performing-operations/Solution.java:5:	LiteralsFirstInComparisons:	Position literals first in String comparisons
",0,0,0
"class Solution {     public int maximumDifference(int[] nums) {         int n = nums.length;         int maxDiff = -1;         int minVal = nums[0];         for (int i = 1; i < n; i++) {             maxDiff = Math.max(maxDiff, nums[i] - minVal);             minVal = Math.min(minVal, nums[i]);         }         return maxDiff > 0 ? maxDiff : -1;     } }",0,,0,0,0
class Solution {     public boolean isHappy(int n) {         Set<Integer> seen = new HashSet<>(); // This set will keep track of all numbers seen so far                  while (n != 1) { // Keep repeating until n is 1 or if n is already in seen set             int current = n;             int sum = 0;             while (current != 0) { // get the sum of the squares of its digits                 sum += (current % 10) * (current % 10);                 current /= 10;             }             n = sum;             if (seen.contains(n)) { // check if number is already seen                 return false;             }             seen.add(n); // add number to seen set         }         return true; // number is happy     } },1,"202-happy-number/Solution.java:9:	UselessParentheses:	Useless parentheses.
202-happy-number/Solution.java:12:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
",0,1,0
"class Solution {     public int[][] construct2DArray(int[] original, int m, int n) {         int len = original.length;         if (m * n != len) { // check if the 2D array can be constructed with all elements from original             return new int[0][0]; // impossible to create a 2D array         }         int[][] ans = new int[m][n];         int idx = 0; // pointer to elements in the original array         // insert elements from original into the 2D array row by row         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 ans[i][j] = original[idx++];             }         }         return ans;     } }",0,,0,0,0
class Solution {     public int minimumMoves(String s) {         int count = 0;         for (int i = 0; i < s.length(); i++) {             if (s.charAt(i) == 'X') {                 count++;                 i += 2; // Move index to skip 3 consecutive characters             }         }         return count;     } },0,,0,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public ListNode removeElements(ListNode head, int val) {         // remove starting nodes with val         while(head!=null && head.val==val){             head = head.next;         }         // check if head is null         if(head==null){             return null;         }         // remove other nodes with val using previous reference         ListNode prev = head;         ListNode current = head.next;         while(current!=null){             if(current.val==val){                 prev.next = current.next;             }else{                 prev = current;             }             current = current.next;         }         return head;     } }",1,"203-remove-linked-list-elements/ListNode.java:15:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'head'
",0,1,0
"import java.util.*;  class Solution {     public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {         List<Integer> result = new ArrayList<>();         Map<Integer, Integer> map = new HashMap<>();          for (int num : nums1) {             map.put(num, map.getOrDefault(num, 0) | 1);         }          for (int num : nums2) {             map.put(num, map.getOrDefault(num, 0) | 2);         }          for (int num : nums3) {             map.put(num, map.getOrDefault(num, 0) | 4);         }          for (Map.Entry<Integer, Integer> entry : map.entrySet()) {             final int key = entry.getKey();             final int value = entry.getValue();             if (Integer.bitCount(value) >= 2) {                 result.add(key);             }         }          return result;     } }",1,"2032-two-out-of-three/Solution.java:6:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
",0,0,0
"class Solution {     public int minMovesToSeat(int[] seats, int[] students) {         Arrays.sort(seats);         Arrays.sort(students);         int n = seats.length;         int minMoves = 0;         for (int i = 0; i < n; i++) {             minMoves += Math.abs(seats[i] - students[i]);         }         return minMoves;     } }",0,,0,0,0
"class Solution {     public boolean areNumbersAscending(String s) {         int prevNum = -1;         String[] tokens = s.split("" "");         for (String token : tokens) {             if (Character.isDigit(token.charAt(0))) {                 int num = Integer.parseInt(token);                 if (num <= prevNum) {                     return false;                 }                 prevNum = num;             }         }         return true;     } }",0,,0,0,0
"class Solution {     public int countValidWords(String sentence) {         String[] tokens = sentence.split(""\\s+"");         int count = 0;         for (String token : tokens) {             if (isValidWord(token)) {                 count++;             }         }         return count;     }          private boolean isValidWord(String token) {         int n = token.length();         if (n == 0) {             return false;         }         if (!Character.isLetter(token.charAt(0))) {             return false;         }         if (token.charAt(n - 1) == ',' || token.charAt(n - 1) == '.' || token.charAt(n - 1) == '!') {             if (n == 1) {                 return false;             }             int hyphenCount = 0;             for (int i = 1; i < n - 1; i++) {                 char c = token.charAt(i);                 if (c == '-') {                     hyphenCount++;                     if (i == 1 || i == n - 2 || !Character.isLetter(token.charAt(i - 1)) || !Character.isLetter(token.charAt(i + 1))) {                         return false;                     }                 } else if (!Character.isLetter(c) && c != '.') {                     return false;                 }             }             return hyphenCount <= 1;         } else {             return false;         }     } }",0,,0,0,0
"class Solution {     public boolean isIsomorphic(String s, String t) {         if(s.length() != t.length()) // If two strings have different lengths             return false;         Map<Character, Character> map = new HashMap<>(); // Create a map to store character mapping         Set<Character> set = new HashSet<>(); // Create a set to check for one-to-one mapping         for(int i=0; i<s.length(); i++) {             char c1 = s.charAt(i);             char c2 = t.charAt(i);             if(map.containsKey(c1)) { // If character mapping is already present                 if(map.get(c1) != c2) // If one-to-one mapping has failed                     return false;             }             else { // If character mapping is not present                 if(set.contains(c2)) // Check if current character has already mapped                     return false;                 map.put(c1, c2); // Add the mapping                 set.add(c2); // Add the current character to set             }         }         return true; // If no issues found, return true     } }",1,"205-isomorphic-strings/Solution.java:13:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
"class Solution {     public String kthDistinct(String[] arr, int k) {         //create a HashMap to keep count of the occurrences of each string in the array         HashMap<String, Integer> countMap = new HashMap<>();         for (String str: arr) {             countMap.put(str, countMap.getOrDefault(str, 0) + 1);         }                  int distinctCount = 0;         //traverse the array in the order it appears and find the kth distinct string         for (String str: arr) {             if (countMap.get(str) == 1) {                 distinctCount++;                 if (distinctCount == k) {                     return str;                 }             }         }         //if there are fewer than k distinct strings, return an empty string         return """";     } }",0,,0,0,0
"class Solution {     public int smallestEqual(int[] nums) {         for(int i = 0; i < nums.length; i++) {             if(i % 10 == nums[i]) {  // check if i mod 10 equals to current nums element                 return i;   // return the first index satisfying the condition             }         }         return -1;  // if no index satisfies the condition, return -1     } }",0,,0,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public ListNode reverseList(ListNode head) {         ListNode prev = null;         ListNode curr = head;         ListNode next = null;                  while (curr != null) {             next = curr.next;             curr.next = prev;             prev = curr;             curr = next;         }                  return prev;     } }",1,"206-reverse-linked-list/ListNode.java:15:	UnusedAssignment:	The initializer for variable 'next' is never used (overwritten on line 18)
",0,0,0
class Solution {     public int countVowelSubstrings(String word) {         int count = 0;         for (int i = 0; i < word.length(); i++) {             if (isVowel(word.charAt(i))) {                 int vowelsCount = 1;                 for (int j = i + 1; j < word.length(); j++) {                     if (isVowel(word.charAt(j))) {                         vowelsCount++;                         if (vowelsCount == 5) {                             count++;                             break;                         }                     } else {                         break;                     }                 }             }         }         return count;     }          private boolean isVowel(char c) {         return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';     } },0,,0,0,0
"class Solution {     public boolean checkAlmostEquivalent(String word1, String word2) {         int[] freq1 = new int[26];         int[] freq2 = new int[26];                  // Calculate frequencies of each letter in word1         for (char c : word1.toCharArray()) {             freq1[c - 'a']++;         }                  // Calculate frequencies of each letter in word2         for (char c : word2.toCharArray()) {             freq2[c - 'a']++;         }                  // Calculate differences between frequencies of each letter from 'a' to 'z' between word1 and word2         int diffCount = 0;         for (int i = 0; i < 26; i++) {             if (Math.abs(freq1[i] - freq2[i]) > 3) {                 diffCount++;             }         }                  // Check if the differences are at most 3         return diffCount <= 3;     } }",0,,0,0,0
"class Solution {     public int timeRequiredToBuy(int[] tickets, int k) {         int n = tickets.length;         int[] remaining = new int[n];         System.arraycopy(tickets, 0, remaining, 0, n);          int time = 0;         while (remaining[k] > 0) {             int bought = 0;             for (int i = 0; i < n && remaining[k] > 0; i++) {                 if (remaining[i] > 0) {                     remaining[i]--;                     bought++;                 }             }             time += bought;         }         return time;     } }",0,,0,0,0
"class Solution {     public int maxDistance(int[] colors) {         int maxDistance = 0;         for (int i = 0; i < colors.length; i++) {             for (int j = i + 1; j < colors.length; j++) {                 if (colors[i] != colors[j]) {                     maxDistance = Math.max(maxDistance, Math.abs(i - j));                 }             }         }         return maxDistance;     } }",0,,0,0,0
"class Solution {     public int countWords(String[] words1, String[] words2) {         int count = 0;         Map<String, Integer> freq1 = new HashMap<>();         Map<String, Integer> freq2 = new HashMap<>();                  /* populate frequency map for words1 */         for(String word : words1) {             freq1.put(word, freq1.getOrDefault(word, 0) + 1);             }                  /* populate frequency map for words2 and compute count */         for(String word : words2) {             if(freq1.containsKey(word) && freq1.get(word) == 1 && !freq2.containsKey(word)) {                 count++;                 freq2.put(word, 1);             } else {                 freq2.put(word, freq2.getOrDefault(word, 0) + 1);             }         }                  /* check for words in words1 that appeared exactly once */         for(String word : words1) {             if(freq1.containsKey(word) && freq1.get(word) == 1 && !freq2.containsKey(word)) {                 count++;             }         }                  return count;     } }",0,,0,0,0
"import java.util.ArrayList; import java.util.Arrays; import java.util.List;  class Solution {     public List<Integer> targetIndices(int[] nums, int target) {         List<Integer> targetIndices = new ArrayList<>();          // Sort the given array in a non-decreasing order         Arrays.sort(nums);          // search all the indices where nums[i] == target         for (int i = 0; i < nums.length; i++) {             if (nums[i] == target) {                 targetIndices.add(i);             }         }         return targetIndices;     } }",0,,0,0,0
"import java.util.ArrayList; import java.util.Arrays; import java.util.List;  class Solution {     public int[] findEvenNumbers(int[] digits) {         List<String> allNumbers = new ArrayList<>(); // to store all possible numbers         StringBuilder sb = new StringBuilder(); // for generating all possible combinations                  boolean[] used = new boolean[digits.length]; // to keep track of used digits                  generateNumbers(digits, used, sb, allNumbers);                  int[] ans = new int[allNumbers.size()]; // to store the final answer                  int i = 0;                  // loop through all possible numbers and check if it's even and has no leading zeros         for(String num : allNumbers) {             if(num.charAt(0) != '0' && (num.charAt(num.length()-1) - '0') % 2 == 0) {                 ans[i++] = Integer.parseInt(num);             }         }                  return Arrays.copyOf(ans, i);     }          public void generateNumbers(int[] digits, boolean[] used, StringBuilder sb, List<String> allNumbers) {         if(sb.length() == 3) {             allNumbers.add(sb.toString());             return;         }                  for(int i=0; i<digits.length; i++) {             if(!used[i]) {                 used[i] = true;                 sb.append(digits[i]);                 generateNumbers(digits, used, sb, allNumbers);                 used[i] = false;                 sb.deleteCharAt(sb.length()-1);             }         }     } }",0,,0,0,0
"class Solution {     public int[] maxSubsequence(int[] nums, int k) {         int n = nums.length;         int[] maxAt = new int[n];         int[] posAt = new int[n];          int last = n - 1;         maxAt[last] = nums[last];         posAt[last] = last;          for (int i = last - 1; i >= 0; --i)             if (maxAt[i + 1] > 0) {                 maxAt[i] = maxAt[i + 1] + nums[i];                 posAt[i] = posAt[i + 1];             } else {                 maxAt[i] = nums[i];                 posAt[i] = i;             }          int[] res = new int[k];         int curr = 0;         for (int i = 0, j = 0; i < k;) {             int end = n - k + i;             if (posAt[j] > end)                 ++j;             else {                 res[curr++] = nums[posAt[j]];                 ++i;                 j = posAt[j] + 1;             }         }          return res;     } }",1,"2099-find-subsequence-of-length-k-with-the-largest-sum/Solution.java:22:	ForLoopVariableCount:	Too many control variables in the for statement
",0,0,0
class Solution {     public int countPoints(String rings) {         int n = rings.length() / 2; // number of rings         int[][] rods = new int[10][3]; // array to store the rods and their counts                  // loop through each ring and update the array accordingly         for (int i = 0; i < n; i++) {             char color = rings.charAt(2*i);             int rod = Character.getNumericValue(rings.charAt(2*i+1));             if (color == 'R') rods[rod][0]++;             else if (color == 'G') rods[rod][1]++;             else if (color == 'B') rods[rod][2]++;         }                  int count = 0; // count of rods with all three colors         for (int i = 0; i < 10; i++) {             if (rods[i][0] > 0 && rods[i][1] > 0 && rods[i][2] > 0) {                 count++;             }         }                  return count;     } },0,,0,0,0
"class Solution {     public String firstPalindrome(String[] words) {         for (String word : words) {             if (isPalindrome(word)) {                 return word;             }         }         return """";     }      private boolean isPalindrome(String word) {         for (int i = 0; i < word.length() / 2; i++) {             if (word.charAt(i) != word.charAt(word.length() - 1 - i)) {                 return false;             }         }         return true;     } }",0,,0,0,0
"class Solution {     public int mostWordsFound(String[] sentences) {         int maxWords = 0;         for (String sentence : sentences) {             int words = sentence.split("" "").length;             maxWords = Math.max(maxWords, words);         }         return maxWords;     } }",0,,0,0,0
class Solution {     public boolean isSameAfterReversals(int num) {         int reversed1 = reverse(num);         int reversed2 = reverse(reversed1);                  return reversed2 == num;     }          private int reverse(int num) {         int reversed = 0;                  while (num > 0) {             int digit = num % 10;             reversed = reversed * 10 + digit;             num /= 10;         }                  return reversed;     } },1,"2119-a-number-after-a-double-reversal/Solution.java:15:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'num'
",0,1,0
"class Solution {     public boolean checkString(String s) {         boolean foundB = false;         for(char c : s.toCharArray()) {             // If we see 'b' before seeing any 'a', return false             if(c == 'b' && !foundB)                 return false;             // If we see 'a' after seeing 'b', return false             if(c == 'a' && foundB)                 return false;             // Set foundB to true when we see the first 'b'             if(c == 'b' && !foundB)                 foundB = true;         }         return true;     } }",0,,0,0,0
"class Solution {     public String capitalizeTitle(String title) {         if (title == null || title.length() == 0) {             return title;         }                  StringBuilder sb = new StringBuilder();         String[] words = title.split("" "");         for (int i = 0; i < words.length; i++) {             String word = words[i];             if (word.length() <= 2) {                 sb.append(word.toLowerCase());             } else {                 sb.append(word.substring(0, 1).toUpperCase()).append(word.substring(1).toLowerCase());             }             if (i < words.length - 1) {                 sb.append("" "");             }         }         return sb.toString();     } }",1,"2129-capitalize-the-title/Solution.java:12:	UseLocaleWithCaseConversions:	When doing a String.toLowerCase()/toUpperCase() call, use a Locale
2129-capitalize-the-title/Solution.java:14:	UseLocaleWithCaseConversions:	When doing a String.toLowerCase()/toUpperCase() call, use a Locale
2129-capitalize-the-title/Solution.java:14:	UseLocaleWithCaseConversions:	When doing a String.toLowerCase()/toUpperCase() call, use a Locale
2129-capitalize-the-title/Solution.java:17:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
",0,0,0
class Solution {     public boolean checkValid(int[][] matrix) {         int n = matrix.length;         boolean[] seenInRow = new boolean[n];         boolean[] seenInCol = new boolean[n];          for (int i = 0; i < n; i++) {             for (int j = 0; j < n; j++) {                 int num = matrix[i][j];                 if (num < 1 || num > n || seenInRow[i] || seenInCol[j]) {                     return false;                 }                 seenInRow[i] = seenInCol[j] = true;                             }         }         return true;     } },1,"2133-check-if-every-row-and-column-contains-all-numbers/Solution.java:13:45: Inner assignments should be avoided. [InnerAssignment]
",0,0,0
"class Solution {     public String[] divideString(String s, int k, char fill) {         int groups = (s.length() + k - 1) / k;  // calculate number of groups needed         String[] result = new String[groups];         int idx = 0;         for (int i = 0; i < s.length(); i += k) {             if (i + k <= s.length()) {                 result[idx++] = s.substring(i, i + k);  // add full group to result             } else {                 int fillCount = i + k - s.length();  // calculate how many fill chars needed                 String fillString = new String(new char[fillCount]).replace('\0', fill);  // create fill string                 result[idx++] = s.substring(i) + fillString;  // add last group to result with fill chars             }         }         return result;     } }",1,"2138-divide-a-string-into-groups-of-size-k/Solution.java:11:	StringInstantiation:	Avoid instantiating String objects; this is usually unnecessary.
",0,0,0
class Solution {     public int minimumCost(int[] cost) {         Arrays.sort(cost); // sort the array in ascending order         int n = cost.length;         int ans = 0;         for (int i = n - 1; i >= 0; i -= 2) {             ans += cost[i];             if (i - 1 >= 0) {                 ans += cost[i - 1];             }         }         return ans;     } },0,,0,0,0
class Solution {     public int countElements(int[] nums) {         int count = 0;         Arrays.sort(nums); // sort the array         for (int i = 1; i < nums.length - 1; i++) { //loop starts from 1st index because there is no element strictly less the 1st element and similarly it ends at n-2             if (nums[i] > nums[0] && nums[i] < nums[nums.length - 1]) { //check if element is strictly smaller than largest and strictly greater than smallest element                 if (nums[i] != nums[i - 1] && nums[i] != nums[i + 1]) { // check if left and right elements are not same as the current element                     count++;                 }             }         }         return count;     } },1,"2148-count-elements-with-strictly-smaller-and-greater-elements/Solution.java:7:	CollapsibleIfStatements:	This if statement could be combined with its parent
",0,0,0
"class Solution {     public int findFinalValue(int[] nums, int original) {         // Keep searching while original is found in nums         while (contains(nums, original)) {             // Multiply original by 2             original *= 2;         }         // Return final value of original         return original;     }          // Helper function to check if a given number is present in an array     private boolean contains(int[] nums, int num) {         for (int n : nums) {             if (n == num) {                 return true;             }         }         return false;     } } ",1,"2154-keep-multiplying-found-values-by-two/Solution.java:6:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'original'
",0,1,0
"class Solution {     public int minimumSum(int num) {         // convert int to string to easily access digits         String strNum = String.valueOf(num);                  // initialize variables to hold digits and minimum sum         int[] digits = new int[4];         int minSum = Integer.MAX_VALUE;                  // convert string to array of digits         for (int i = 0; i < 4; i++) {             digits[i] = Character.getNumericValue(strNum.charAt(i));         }                  // iterate through all possible splits of num         for (int i = 1; i < 4; i++) {             for (int j = i+1; j < 4; j++) {                 // create new1 and new2                 int new1 = 0;                 for (int k = 0; k < i; k++) {                     new1 = new1*10 + digits[k];                 }                 int new2 = 0;                 for (int k = i; k < j; k++) {                     new2 = new2*10 + digits[k];                 }                 // check for leading zeros                 if (String.valueOf(new1).length() != i || String.valueOf(new2).length() != j-i) {                     continue;                 }                 for (int k = j; k < 4; k++) {                     new2 = new2*10 + digits[k];                 }                 // update minimum sum if necessary                 minSum = Math.min(minSum, new1+new2);             }         }         return minSum;     } }",0,,0,0,0
class Solution {     public int[] sortEvenOdd(int[] nums) {                  // Sorting the values at odd positions in non-increasing order         for (int i = 1; i < nums.length; i += 2) {     // loop through odd indices             for (int j = i + 2; j < nums.length; j += 2) {     // loop through remaining odd indices                 if (nums[i] < nums[j]) {        // condition for non-increasing sort                     int temp = nums[i];    // swap the elements                     nums[i] = nums[j];                     nums[j] = temp;                 }             }         }                  // Sorting the values at even positions in non-decreasing order         for (int i = 0; i < nums.length; i += 2) {     // loop through even indices             for (int j = i + 2; j < nums.length; j += 2) {     // loop through remaining even indices                 if (nums[i] > nums[j]) {        // condition for non-decreasing sort                     int temp = nums[i];    // swap the elements                     nums[i] = nums[j];                     nums[j] = temp;                 }             }         }                  return nums;    // returning the modified array     } },0,,0,0,0
"class Solution {     public int countOperations(int num1, int num2) {         int count = 0;         while (num1 != 0 && num2 != 0) {             if (num1 >= num2) {                 num1 -= num2;             } else {                 num2 -= num1;             }             count++;         }         return count;     } }",1,"2169-count-operations-to-obtain-zero/Solution.java:6:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'num1'
2169-count-operations-to-obtain-zero/Solution.java:8:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'num2'
",0,1,0
"class Solution {     public boolean containsDuplicate(int[] nums) {         //create a hashset to store unique values         HashSet<Integer> uniqueNums = new HashSet<>();                  //iterate through the array         for(int num : nums){             //add each element to the hashset             //if the value already exists in the hashset, return true             if(!uniqueNums.add(num)){                 return true;             }         }         //if the for loop completes and no duplicates are found, return false         return false;     } }",0,,0,0,0
"class Solution {     public int countPairs(int[] nums, int k) {         int n = nums.length;         int count = 0;                  Map<Integer, Integer> freqMap = new HashMap<>();         for (int i = 0; i < n; i++) {             freqMap.put(nums[i], freqMap.getOrDefault(nums[i], 0) + 1);         }                  for (int i = 0; i < n; i++) {             int num = nums[i];             int freq = freqMap.get(num);                          freqMap.put(num, freq - 1);                          for (int j = i + 1; j < n; j++) {                 if (num == nums[j] && ((i * j) % k == 0)) {                     count++;                 }             }                          freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);         }                  return count;     } }",1,"2176-count-equal-and-divisible-pairs-in-an-array/Solution.java:18:	UselessParentheses:	Useless parentheses.
",0,0,0
"class Solution {     public int countEven(int num) {         int count = 0; //initialize count         for (int i = 1; i <= num; i++) { //iterate through all numbers from 1 to num             int digitSum = 0;             int n = i;             while (n > 0) { //calculate digit sum of current number                 digitSum += n % 10;                 n /= 10;             }             if (digitSum % 2 == 0) { //if digit sum is even, increment count                 count++;             }         }         return count;     } }",0,,0,0,0
"class Solution {     public int prefixCount(String[] words, String pref) {         int count = 0;         // loop through all the words in the given array         for (String word : words) {             // check if the word starts with the given prefix             if (word.startsWith(pref)) {                 count++;             }         }         return count;     } }  // test the above code public class Main {     public static void main(String[] args) {         Solution obj = new Solution();         String[] words = {""pay"", ""attention"", ""practice"", ""attend""};         String pref = ""at"";         System.out.println(obj.prefixCount(words, pref)); // Output: 2          words = new String[]{""leetcode"", ""win"", ""loops"", ""success""};         pref = ""code"";         System.out.println(obj.prefixCount(words, pref)); // Output: 0     } }",1,"2185-counting-words-with-a-given-prefix/Main.java:16:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
2185-counting-words-with-a-given-prefix/Main.java:16:	UseUtilityClass:	This utility class has a non-private constructor
",0,0,0
"class Solution {     public boolean containsNearbyDuplicate(int[] nums, int k) {         Map<Integer, Integer> map = new HashMap<>();         for (int i = 0; i < nums.length; i++) {             if (map.containsKey(nums[i]) && Math.abs(map.get(nums[i]) - i) <= k)                 return true;             map.put(nums[i], i);         }         return false;     } }",0,,0,0,0
"class Solution {     public int mostFrequent(int[] nums, int key) {         int maxCount = 0; // variable to store the maximum count         int target = 0; // variable to store the target with maximum count                  // loop through the array         for (int i = 0; i < nums.length - 1; i++) {             // check if the current element is equal to the key             if(nums[i] == key) {                 int count = 0; // variable to store the count of occurrences of the target                                  // loop through the remaining elements after the key                 for (int j = i + 1; j < nums.length; j++) {                     // check if the current element is equal to the target                     if(nums[j] == nums[i+1]) {                         count++; // increment the count if the target is found                     }                 }                                  // check if the count for the current target is greater than the maximum count                 if (count > maxCount) {                     maxCount = count; // update the maximum count                     target = nums[i+1]; // update the target with maximum count                 }             }         }                  return target; // return the target with maximum count     } } ",0,,0,0,0
"import java.util.ArrayList; import java.util.Collections; import java.util.List;  class Solution {     public List<String> cellsInRange(String s) {                  // Extracting the start and end columns and rows from the input         int c1 = s.charAt(0) - 'A' + 1;         int r1 = Integer.parseInt(s.substring(1, 2));         int c2 = s.charAt(3) - 'A' + 1;         int r2 = Integer.parseInt(s.substring(4));                  List<String> result = new ArrayList<String>();                  // Looping through each cell in the range and adding it to the result         for (int i = c1; i <= c2; i++) {             for (int j = r1; j <= r2; j++) {                 result.add((char)(i + 64) + Integer.toString(j));             }         }                  // Sorting the result in non-decreasing order first by columns and then by rows         Collections.sort(result, (a, b) -> {             if (a.charAt(0) > b.charAt(0)) {                 return 1;             } else if (a.charAt(0) < b.charAt(0)) {                 return -1;             } else {                 return Integer.compare(Integer.parseInt(a.substring(1)), Integer.parseInt(b.substring(1)));             }         });                  return result;     } }",1,"2194-cells-in-a-range-on-an-excel-sheet/Solution.java:14:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new ArrayList<>()`
",0,0,0
"import java.util.*;  class Solution {     public List<Integer> findKDistantIndices(int[] nums, int key, int k) {         List<Integer> result = new ArrayList<>();         for (int i = 0; i < nums.length; i++) {             if (nums[i] == key) {                 for (int j = Math.max(0, i - k); j <= Math.min(i + k, nums.length - 1); j++) {                     if (nums[j] == key) {                         result.add(i);                         break;                     }                 }             }         }         return result;     } }",0,,0,0,0
"class Solution {     public boolean divideArray(int[] nums) {         Map<Integer, Integer> freq = new HashMap<>();         for(int num: nums) {             freq.put(num, freq.getOrDefault(num, 0) + 1);         }         for(int f: freq.values()) {             if(f % 2 != 0) {                 return false;             }         }         return true;     } }",0,,0,0,0
class Solution {     public int countHillValley(int[] nums) {         int count = 0;         for(int i=1; i<nums.length-1; i++) {             if((nums[i] > nums[i-1] && nums[i] > nums[i+1]) || (nums[i] < nums[i-1] && nums[i] < nums[i+1])) {                 int j = i;                 // check if adjacent indices also belong to same hill/valley                 while(j<nums.length-1 && nums[j]==nums[j+1]) {                     j++;                 }                 // increment count only once for the same hill/valley                 if(j>i && (nums[i] > nums[i-1] && nums[i] > nums[j]) || (nums[i] < nums[i-1] && nums[i] < nums[j])) {                     count++;                 }                 i = j;             }         }         return count;     } },1,"2210-count-hills-and-valleys-in-an-array/Solution.java:12:	UselessParentheses:	Useless parentheses.
",0,0,0
"import java.util.*;  class Solution {     public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {                  List<Integer> list1 = new ArrayList<Integer>(); // list to store distinct integers from nums1 which are not present in nums2         List<Integer> list2 = new ArrayList<Integer>(); // list to store distinct integers from nums2 which are not present in nums1                  // create hash sets for nums1 and nums2 to count the frequency of each integer         Map<Integer, Integer> freq1 = new HashMap<Integer, Integer>();         Map<Integer, Integer> freq2 = new HashMap<Integer, Integer>();                  for(int i=0;i<nums1.length;i++){             if(!freq1.containsKey(nums1[i])){                 freq1.put(nums1[i], 1);             }             else{                 freq1.put(nums1[i], freq1.get(nums1[i])+1);             }         }                  for(int i=0;i<nums2.length;i++){             if(!freq2.containsKey(nums2[i])){                 freq2.put(nums2[i], 1);             }             else{                 freq2.put(nums2[i], freq2.get(nums2[i])+1);             }         }                  // add distinct integers from nums1 not present in nums2 to list1         for(int i=0;i<nums1.length;i++){             if(!freq2.containsKey(nums1[i])){                 list1.add(nums1[i]);             }         }                  // add distinct integers from nums2 not present in nums1 to list2         for(int i=0;i<nums2.length;i++){             if(!freq1.containsKey(nums2[i])){                 list2.add(nums2[i]);             }         }                  List<List<Integer>> answer = new ArrayList<List<Integer>>(); // create a list answer to store list1 and list2         answer.add(list1);         answer.add(list2);                  return answer;     } }",1,"2215-find-the-difference-of-two-arrays/Solution.java:16:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2215-find-the-difference-of-two-arrays/Solution.java:25:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2215-find-the-difference-of-two-arrays/Solution.java:6:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new ArrayList<>()`
2215-find-the-difference-of-two-arrays/Solution.java:7:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new ArrayList<>()`
2215-find-the-difference-of-two-arrays/Solution.java:10:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
2215-find-the-difference-of-two-arrays/Solution.java:10:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new HashMap<>()`
2215-find-the-difference-of-two-arrays/Solution.java:11:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
2215-find-the-difference-of-two-arrays/Solution.java:11:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new HashMap<>()`
2215-find-the-difference-of-two-arrays/Solution.java:13:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
2215-find-the-difference-of-two-arrays/Solution.java:14:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
2215-find-the-difference-of-two-arrays/Solution.java:22:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
2215-find-the-difference-of-two-arrays/Solution.java:23:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
2215-find-the-difference-of-two-arrays/Solution.java:32:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
2215-find-the-difference-of-two-arrays/Solution.java:39:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
2215-find-the-difference-of-two-arrays/Solution.java:45:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new ArrayList<>()`
",0,0,1
"class Solution {     public int minBitFlips(int start, int goal) {         int count = 0;         int current = start;         for (int i = 0; i < 32; i++) { // we assume the integers have 32 bits             boolean currentBitSet = ((current >> i) & 1) == 1;             boolean goalBitSet = ((goal >> i) & 1) == 1;             if (currentBitSet != goalBitSet) { // if the bits differ, we need to flip                 if (i + 1 > 32 - i - 1) { // edge case: we can't flip bits starting from i, since there aren't enough bits left                     return -1;                 }                 count++; // flip the current bit, and all bits to the right of it                 for (int j = i; j < 32; j++) {                     boolean bitSet = ((current >> j) & 1) == 1;                     if (bitSet) {                         current -= (1 << j); // flip the bit                     } else {                         current += (1 << j); // flip the bit                     }                 }             }         }         return count;     } }",0,,0,0,0
"class Solution {     public int convertTime(String current, String correct) {         int currHour = Integer.parseInt(current.substring(0,2));         int currMin = Integer.parseInt(current.substring(3));                  int corrHour = Integer.parseInt(correct.substring(0,2));         int corrMin = Integer.parseInt(correct.substring(3));                  int hourDiff = corrHour - currHour; // difference in hours         int totalDiff = hourDiff * 60 + corrMin - currMin; // difference in total minutes                  int ops = 0;                  while (totalDiff > 0) {             if (totalDiff >= 60) { // add 60 minutes                 ops++;                 totalDiff -= 60;             } else if (totalDiff >= 15) { // add 15 minutes                 ops++;                 totalDiff -= 15;             } else if (totalDiff >= 5) { // add 5 minutes                 ops++;                 totalDiff -= 5;             } else { // add 1 minute                 ops++;                 totalDiff--;             }         }                  return ops;     } }",0,,0,0,0
"class Solution {     public int largestInteger(int num) {         // Convert num to a string to easily access individual digits         String s = String.valueOf(num);         char[] digits = s.toCharArray();                  // Create two lists for odd and even digits         List<Integer> odds = new ArrayList<>();         List<Integer> evens = new ArrayList<>();                  // Fill the lists with their respective digits         for (char digit : digits) {             int n = digit - '0';             if (n % 2 == 0) {                 evens.add(n);             } else {                 odds.add(n);             }         }                  // Sort the lists in descending order         Collections.sort(odds, Collections.reverseOrder());         Collections.sort(evens, Collections.reverseOrder());                  int i = 0;  // Pointer for odds list         int j = 0;  // Pointer for evens list                  // Create a new array to store the swapped digits         int[] newDigits = new int[digits.length];                  // Iterate through the digits and swap if possible         for (int k = 0; k < digits.length; k++) {             int n = digits[k] - '0';             if (n % 2 == 0) {                 if (j < evens.size() && evens.get(j) > n) {                     newDigits[k] = evens.get(j);                     j++;                 } else {                     newDigits[k] = n;                 }             } else {                 if (i < odds.size() && odds.get(i) > n) {                     newDigits[k] = odds.get(i);                     i++;                 } else {                     newDigits[k] = n;                 }             }         }                  // Convert the new array back to an integer         int result = 0;         for (int digit : newDigits) {             result = result * 10 + digit;         }                  return result;     } }",0,,0,0,0
"class Solution {     public int sum(int num1, int num2) {         return num1 + num2;     } }  //Testing the solution class Test {     public static void main(String[] args) {         Solution solution = new Solution();         int result1 = solution.sum(12, 5);         int result2 = solution.sum(-10, 4);         System.out.println(result1); //Expected output is 17         System.out.println(result2); //Expected output is -6     } }",1,"2235-add-two-integers/Solution.java:8:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
2235-add-two-integers/Solution.java:8:	TestClassWithoutTestCases:	The class 'Test' might be a test class, but it contains no test cases.
2235-add-two-integers/Solution.java:8:	UseUtilityClass:	This utility class has a non-private constructor
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public boolean checkTree(TreeNode root) {         if (root == null) {             return false;         }         int leftVal = root.left != null ? root.left.val : 0;         int rightVal = root.right != null ? root.right.val : 0;         if (root.val == leftVal + rightVal) {             return true;         }         return false;     } }",1,"2236-root-equals-sum-of-children/TreeNode.java:23:	SimplifyBooleanReturns:	This if statement can be replaced by `return {condition};`
",0,0,0
class Solution {     public int findClosestNumber(int[] nums) {         int closest = nums[0]; // initialize closest as the first element         for (int i = 1; i < nums.length; i++) { // iterate over the elements in the array             if (Math.abs(nums[i]) < Math.abs(closest) // if the current element is closer to 0                     || (Math.abs(nums[i]) == Math.abs(closest) && nums[i] > closest)) { // or if it is equidistant but larger than closest                 closest = nums[i]; // update closest with the current element             }         }         return closest; // return the number closest to 0 with the largest value     } },0,,0,0,0
"class Solution {     public String digitSum(String s, int k) {         while (s.length() > k) { // continue until length of string s is less than or equal to k             String newStr = """";             for (int i = 0; i < s.length(); i += k) { // divide string s into consecutive groups of size k                 String group = s.substring(i, Math.min(i + k, s.length())); // get the group                 int sum = 0;                 for (int j = 0; j < group.length(); j++) { // calculate the digit sum of the group                     sum += Character.getNumericValue(group.charAt(j)); // convert char to integer and sum up the digits                 }                 newStr += sum; // append the sum to the new string             }             s = newStr; // set the new string as the current string         }         return s; // return the final string after all rounds have been completed     } } ",1,"2243-calculate-digit-sum-of-a-string/Solution.java:11:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
2243-calculate-digit-sum-of-a-string/Solution.java:13:	AvoidReassigningParameters:	Avoid reassigning parameters such as 's'
",0,1,0
"import java.util.*;  class Solution {     public List<Integer> intersection(int[][] nums) {         // create a map to keep track of frequency of each number in each row         Map<Integer, Integer> freqMap = new HashMap<>();         for (int i = 0; i < nums.length; i++) {             for (int j = 0; j < nums[i].length; j++) {                 if (!freqMap.containsKey(nums[i][j])) {                     freqMap.put(nums[i][j], 1);                 } else {                     freqMap.put(nums[i][j], freqMap.get(nums[i][j]) + 1);                 }             }         }                  // create a list to store the numbers present in every row         List<Integer> result = new ArrayList<>();         for (Map.Entry<Integer, Integer> entry: freqMap.entrySet()) {             if (entry.getValue() == nums.length) {                 result.add(entry.getKey());             }         }                  // sort the list in ascending order         Collections.sort(result);         return result;     } }",1,"2248-intersection-of-multiple-arrays/Solution.java:6:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
2248-intersection-of-multiple-arrays/Solution.java:7:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
2248-intersection-of-multiple-arrays/Solution.java:9:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",0,0,1
import java.util.Queue; import java.util.LinkedList;  class MyStack {     private Queue<Integer> queue1;     private Queue<Integer> queue2;     private int top;      public MyStack() {         queue1 = new LinkedList<Integer>();         queue2 = new LinkedList<Integer>();     }      public void push(int x) {         queue1.offer(x);         top = x;     }      public int pop() {         while (queue1.size() > 1) {             top = queue1.remove();             queue2.offer(top);         }         int result = queue1.remove();         Queue<Integer> temp = queue1;         queue1 = queue2;         queue2 = temp;         return result;     }      public int top() {         return top;     }      public boolean empty() {         return queue1.isEmpty();     } },1,"225-implement-stack-using-queues/MyStack.java:9:5: Redundant 'public' modifier. [RedundantModifier]
225-implement-stack-using-queues/MyStack.java:7:	AvoidFieldNameMatchingMethodName:	Field top has the same name as a method
225-implement-stack-using-queues/MyStack.java:10:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new LinkedList<>()`
225-implement-stack-using-queues/MyStack.java:11:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new LinkedList<>()`
",0,0,0
"class Solution {     public int countPrefixes(String[] words, String s) {         int count = 0;         for (String word : words) {             if (s.startsWith(word)) {                 count++;             }         }         return count;     } }",0,,0,0,0
"class Solution {     public String removeDigit(String number, char digit) {         int n = number.length();         int idx = number.indexOf(digit); // Find the first occurrence of digit in number         if (idx == n-1) { // If digit is the last character in number             return number.substring(0,n-1); // Remove the last character and return the resulting string         }         String option1 = number.substring(0,idx) + number.substring(idx+1); // Remove the first occurrence of digit         String option2 = number.substring(0,n-1) + number.charAt(n-2); // Remove the last occurrence of digit         // Compute the decimal values of the two options         long val1 = Long.parseLong(option1);         long val2 = Long.parseLong(option2);         if (val1 > val2) { // Return the larger option as a string             return Long.toString(val1);         } else {             return Long.toString(val2);         }     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */  class Solution {     public TreeNode invertTree(TreeNode root) {         if (root == null) {             return null;         }                  TreeNode left = invertTree(root.left);         TreeNode right = invertTree(root.right);                  root.left = right;         root.right = left;                  return root;     } }",0,,0,0,0
"class Solution {     public String largestGoodInteger(String num) {         String result = """";         for(int i=0; i<num.length()-2; i++){             char current = num.charAt(i);             if(current==num.charAt(i+1) && current==num.charAt(i+2)){                 result = String.valueOf(current) + String.valueOf(current) + String.valueOf(current);             }         }         return result;     } }",1,"2264-largest-3-same-digit-number-in-string/Solution.java:7:	UselessStringValueOf:	No need to call String.valueOf to append to a string.
2264-largest-3-same-digit-number-in-string/Solution.java:7:	UselessStringValueOf:	No need to call String.valueOf to append to a string.
",0,0,0
"class Solution {     public int divisorSubstrings(int num, int k) {         int count = 0;         String numString = Integer.toString(num);         for(int i = 0; i <= numString.length() - k; i++) {             String sub = numString.substring(i, i+k);             int subInt = Integer.parseInt(sub);             if(subInt != 0 && num % subInt == 0) {                 count++;             }         }         return count;     } }",0,,0,0,0
"import java.util.ArrayList; import java.util.HashMap; import java.util.List;  class Solution {     public List<String> removeAnagrams(String[] words) {         List<String> result = new ArrayList<>();         HashMap<String, Integer> map = new HashMap<>();          for (String word : words) {             // Sorting each word to group anagrams together             char[] chars = word.toCharArray();             Arrays.sort(chars);             String sortedWord = new String(chars);                          // Counting frequency of each sorted word             map.put(sortedWord, map.getOrDefault(sortedWord, 0) + 1);         }          for (String word : words) {             char[] chars = word.toCharArray();             Arrays.sort(chars);             String sortedWord = new String(chars);              // Adding the first occurrence of each sorted word             if (map.get(sortedWord) == 1) {                 result.add(word);             }              // Removing duplicates of the same sorted word             map.put(sortedWord, map.get(sortedWord) - 1);         }          return result;     } }",1,"2273-find-resultant-array-after-removing-anagrams/Solution.java:8:	LooseCoupling:	Avoid using implementation types like 'HashMap'; use the interface instead
2273-find-resultant-array-after-removing-anagrams/Solution.java:14:	StringInstantiation:	Avoid instantiating String objects; this is usually unnecessary.
2273-find-resultant-array-after-removing-anagrams/Solution.java:23:	StringInstantiation:	Avoid instantiating String objects; this is usually unnecessary.
",0,0,0
"class Solution {     public int percentageLetter(String s, char letter) {         int count = 0;         for (int i = 0; i < s.length(); i++) {             if (s.charAt(i) == letter) {                 count++;             }         }         int percent = (count * 100) / s.length();         return percent;     } }  // Sample Input: s = ""foobar"", letter = ""o""  // Sample Output: 33",1,"2278-percentage-of-letter-in-string/Solution.java:9:	UnnecessaryLocalBeforeReturn:	Consider simply returning the value vs storing it in local variable 'percent'
2278-percentage-of-letter-in-string/Solution.java:9:	UselessParentheses:	Useless parentheses.
",0,0,0
"import java.util.*;  class Solution {     public List<String> summaryRanges(int[] nums) {         List<String> ranges = new ArrayList<>();         int n = nums.length;         if(n == 0) return ranges;          int start = nums[0], end = nums[0];         for(int i=1; i<n; i++) {             if(nums[i] == end+1) {                 end++;             } else {                 if(start == end) {                     ranges.add(start+"""");                 } else {                     ranges.add(start+""->""+end);                 }                 start = end = nums[i];             }         }         if(start == end) {             ranges.add(start+"""");         } else {             ranges.add(start+""->""+end);         }         return ranges;     } }",1,"228-summary-ranges/Solution.java:9:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
228-summary-ranges/Solution.java:19:29: Inner assignments should be avoided. [InnerAssignment]
228-summary-ranges/Solution.java:15:	AddEmptyString:	Do not add empty strings
228-summary-ranges/Solution.java:23:	AddEmptyString:	Do not add empty strings
",1,0,0
"class Solution {     public boolean digitCount(String num) {         int n = num.length();         for(int i=0; i<n; i++) {             int count = 0;             for(int j=0; j<n; j++) {                 if(num.charAt(i) == num.charAt(j)) {                     count++;                 }             }             if(count != num.charAt(i) - '0') {                 return false;             }         }         return true;     } }   /* The above code first calculates the count of each digit at every index of string num.    The count of each digit at the index i in string num is compared with the actual number of     occurrences of the digit using the formula num.charAt(i) - '0'.     If they are unequal, the function returns false, else it returns true. */",0,,0,0,0
"class Solution {     public int rearrangeCharacters(String s, String target) {         //initialize a count array to store the frequency of each character of target in s         int[] count = new int[26];         for (char c : target.toCharArray()) {             count[c - 'a']++;         }         //initialize a variable to store the maximum number of copies of target that can be formed         int maxCopies = 0;         //iterate through s with a sliding window of size target         for (int i = 0; i <= s.length() - target.length(); i++) {             //create a temporary count array to store the frequency of each character in the current window             int[] tempCount = new int[26];             for (int j = i; j < i + target.length(); j++) {                 tempCount[s.charAt(j) - 'a']++;             }             //compare the frequency of characters in the temporary count array with the frequency of characters in the target count array             boolean valid = true;             for (int j = 0; j < 26; j++) {                 if (tempCount[j] < count[j]) {                     valid = false;                     break;                 }             }             //if the current window can form a copy of target, increment the maximum number of copies             if (valid) {                 maxCopies++;             }         }         return maxCopies;     } }",0,,0,0,0
"class Solution {     public int minMaxGame(int[] nums) {         int n = nums.length;         while (n > 1) {             int[] newNums = new int[n / 2];             for (int i = 0; i < n / 2; i++) {                 newNums[i] = i % 2 == 0 ? Math.min(nums[2 * i], nums[2 * i + 1])                         : Math.max(nums[2 * i], nums[2 * i + 1]);             }             n = n / 2;             nums = newNums;         }         return nums[0];     } }",1,"2293-min-max-game/Solution.java:11:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'nums'
",0,1,0
"class Solution {     public static boolean strongPasswordCheckerII(String password) {         boolean hasLowerCase = false, hasUpperCase = false, hasDigit = false, hasSpecialChar = false;         int countArr[] = new int[3];         char[] passwordArr = password.toCharArray();         for(char c : passwordArr) {             if(Character.isLowerCase(c)) hasLowerCase = true;             else if(Character.isUpperCase(c)) hasUpperCase = true;             else if(Character.isDigit(c)) hasDigit = true;             else if(isSpecialChar(c)) hasSpecialChar = true;                          int repLen = getRepLen(c,passwordArr), idx = repLen/3;             if(repLen>2) {                 countArr[2] += idx;                 if(repLen%3==2) countArr[1]++;             }             if(idx>0) countArr[repLen%3]++;         }                  int totalMissing = (!hasLowerCase?1:0)+(!hasUpperCase?1:0)+(!hasDigit?1:0)+(!hasSpecialChar?1:0);                  if(password.length()<6) return Math.max(6-password.length(), totalMissing)<=countArr[0];         if(password.length()<=20) return totalMissing<=countArr[1];                  //password length > 20         int deleteCount = password.length()-20, delCount = 0;         countArr[0] = Math.max(countArr[0]-deleteCount, 0);         for(int i=1;i<3;i++) {             delCount = Math.min(countArr[i], (deleteCount+1)/2);             countArr[i] -= delCount*2;             countArr[i-1] = Math.max(countArr[i-1]-deleteCount, 0);             deleteCount -= delCount*2;         }         if(deleteCount>0) {             countArr[0] -= deleteCount;         }                  int replaceCount = 0;         for(int i=0;i<3;i++) {             replaceCount += (countArr[i]*((i+1)*2))/3;         }                  return totalMissing+Math.max(replaceCount, countArr[0])<=countArr[2];     }          private static boolean isSpecialChar(char c) {         String specialCharStr = ""!@#$%^&*()-+"";         return specialCharStr.indexOf(c)!=-1;     }          private static int getRepLen(char c, char[] passwordArr) {         int maxRepLen = 0, len = 0;         char prev = ' ';         for(char p : passwordArr) {             if(p==c) {                 len++;                 if(len%3==0 && len>maxRepLen) maxRepLen = len;                 prev = p;             } else if(prev==c) {                 len = 1;                 if(len%3==0 && len>maxRepLen) maxRepLen = len;                 prev = p;             } else {                 len = 0;                 prev = p;             }         }         return maxRepLen;     } }",1,"2299-strong-password-checker-ii/Solution.java:1:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
2299-strong-password-checker-ii/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2299-strong-password-checker-ii/Solution.java:4:21: Array brackets at illegal position. [ArrayTypeStyle]
2299-strong-password-checker-ii/Solution.java:12:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2299-strong-password-checker-ii/Solution.java:26:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2299-strong-password-checker-ii/Solution.java:52:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2299-strong-password-checker-ii/Solution.java:1:	UseUtilityClass:	This utility class has a non-private constructor
2299-strong-password-checker-ii/Solution.java:2:	NPathComplexity:	The method 'strongPasswordCheckerII(String)' has an NPath complexity of 15872, current threshold is 200
2299-strong-password-checker-ii/Solution.java:20:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
2299-strong-password-checker-ii/Solution.java:20:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
2299-strong-password-checker-ii/Solution.java:20:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
2299-strong-password-checker-ii/Solution.java:20:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
2299-strong-password-checker-ii/Solution.java:26:	UnusedAssignment:	The initializer for variable 'delCount' is never used (overwritten on line 29)
2299-strong-password-checker-ii/Solution.java:40:	UselessParentheses:	Useless parentheses.
2299-strong-password-checker-ii/Solution.java:40:	UselessParentheses:	Useless parentheses.
",1,0,0
"class Solution {     public double calculateTax(int[][] brackets, int income) {         double tax = 0;         int lowerBound = 0, i = 0;         while (income > 0) {             int upperBound = brackets[i][0];             int percent = brackets[i][1];             int taxableIncome = Math.min(upperBound - lowerBound, income);             tax += taxableIncome * percent / 100.0;             lowerBound = upperBound;             income -= taxableIncome;             i++;         }         return tax;     } }",1,"2303-calculate-amount-paid-in-taxes/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2303-calculate-amount-paid-in-taxes/Solution.java:11:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'income'
",1,1,0
"class Solution {     public String greatestLetter(String s) {         int[] lowercase = new int[26];  // to keep track of lowercase letters         int[] uppercase = new int[26];  // to keep track of uppercase letters                  // iterate through the string and fill the arrays         for (char c : s.toCharArray()) {             if (Character.isLowerCase(c)) lowercase[c-'a']++;             else if (Character.isUpperCase(c)) uppercase[c-'A']++;         }                  // iterate through the arrays in reverse order to get the greatest letter         for (int i=25; i>=0; i--) {             if (lowercase[i]>0 && uppercase[i]>0)                 return Character.toString((char)(i+'A'));         }                  return """";  // no letter found in both cases     } }",0,,0,0,0
class Solution {     public boolean isPowerOfTwo(int n) {         if(n<=0) return false;         return (n&(n-1))==0;     } },1,"231-power-of-two/Solution.java:3:	SimplifyBooleanReturns:	This if statement can be replaced by `return !{condition} || {elseBranch};`
",0,0,0
class Solution {     public int countAsterisks(String s) {         int count = 0;         boolean insidePair = false;         for (int i = 0; i < s.length(); i++) {             char c = s.charAt(i);             if (c == '|') {                 insidePair = !insidePair;             } else if (c == '*' && !insidePair) {                 count++;             }         }         return count;     } } ,0,,0,0,0
"class XMatrix {     public boolean checkXMatrix(int[][] grid) {        // Check if diagonals elements are non-zero        for(int i=0;i<grid.length;i++)           if(grid[i][i] == 0 || grid[i][grid.length-1-i] == 0)               return false;                // Check if other elements are zero        for(int i=0;i<grid.length;i++)            for(int j=0;j<grid[i].length;j++)                if(i!=j && j!=grid.length-1-i && grid[i][j]!=0)                    return false;         // If both conditions satisfy, return true        return true;     } }",0,,0,0,0
import java.util.Stack;  class MyQueue {     private Stack<Integer> stack1;     private Stack<Integer> stack2;      public MyQueue() {         stack1 = new Stack<>();         stack2 = new Stack<>();     }      public void push(int x) {         while (!stack1.isEmpty()) {             stack2.push(stack1.pop());         }         stack1.push(x);         while (!stack2.isEmpty()) {             stack1.push(stack2.pop());         }     }      public int pop() {         return stack1.pop();     }      public int peek() {         return stack1.peek();     }      public boolean empty() {         return stack1.isEmpty();     } },1,"232-implement-queue-using-stacks/MyQueue.java:7:5: Redundant 'public' modifier. [RedundantModifier]
232-implement-queue-using-stacks/MyQueue.java:4:	LooseCoupling:	Avoid using implementation types like 'Stack'; use the interface instead
232-implement-queue-using-stacks/MyQueue.java:4:	ReplaceVectorWithList:	Consider replacing this Vector with the newer java.util.List
232-implement-queue-using-stacks/MyQueue.java:5:	LooseCoupling:	Avoid using implementation types like 'Stack'; use the interface instead
232-implement-queue-using-stacks/MyQueue.java:5:	ReplaceVectorWithList:	Consider replacing this Vector with the newer java.util.List
232-implement-queue-using-stacks/MyQueue.java:8:	ReplaceVectorWithList:	Consider replacing this Vector with the newer java.util.List
232-implement-queue-using-stacks/MyQueue.java:9:	ReplaceVectorWithList:	Consider replacing this Vector with the newer java.util.List
",0,0,0
"class Solution {     public String decodeMessage(String key, String message) {         Map<Character, Character> substitutionTable = new HashMap<>();         int idx = 0;         String alphabet = ""abcdefghijklmnopqrstuvwxyz"";                  // Generate substitution table         for (int i = 0; i < key.length(); i++) {             char c = key.charAt(i);             if (c != ' ' && !substitutionTable.containsKey(c)) {                 substitutionTable.put(c, alphabet.charAt(idx));                 idx++;             }         }                  StringBuilder result = new StringBuilder();                  // Decode message         for (int i = 0; i < message.length(); i++) {             char c = message.charAt(i);             if (c == ' ') {                 result.append(' ');             } else {                 result.append(substitutionTable.get(c));             }         }                  return result.toString();     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public boolean evaluateTree(TreeNode root) {         if (root == null) {             return false; // or true, depending on the requirements         }         if (root.left == null && root.right == null) {             return root.val == 1;         }         boolean left = evaluateTree(root.left);         boolean right = evaluateTree(root.right);         switch (root.val) {             case 2: // OR                 return left || right;             case 3: // AND                 return left && right;             default:                 return false; // or true, depending on the requirements         }     } }",0,,0,0,0
class Solution {     public int fillCups(int[] amount) {         // Initialize the total time to fill all cups to zero         int totalTime = 0;                  // Loop until all cups are filled         while (amount[0] > 0 || amount[1] > 0 || amount[2] > 0) {             // Check if we can fill up 2 cups of different types             if ((amount[0] >= 1 && amount[1] >= 1) || (amount[1] >= 1 && amount[2] >= 1) || (amount[0] >= 1 && amount[2] >= 1)) {                 // Fill up 2 cups of different types                 if (amount[0] >= 1 && amount[1] >= 1) {                     amount[0]--;                     amount[1]--;                 } else if (amount[1] >= 1 && amount[2] >= 1) {                     amount[1]--;                     amount[2]--;                 } else {                     amount[0]--;                     amount[2]--;                 }             } else {                 // Fill up 1 cup of any type                 if (amount[0] >= 1) {                     amount[0]--;                 } else if (amount[1] >= 1) {                     amount[1]--;                 } else {                     amount[2]--;                 }             }             // Increment the total time by 1 second             totalTime++;         }         // Return the total time to fill all cups         return totalTime;     } },0,,0,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public boolean isPalindrome(ListNode head) {         if(head == null || head.next == null) return true; // If list is empty or has only one element, then it is always a palindrome.                  ListNode slow = head;         ListNode fast = head;                  // Finding the middle of linked list         while(fast!= null && fast.next != null){             slow = slow.next;             fast = fast.next.next;          }                  ListNode prev = null;         ListNode curr = slow;         ListNode temp = null;                  // Reversing second half of linked list         while(curr != null){             temp = curr.next;             curr.next = prev;             prev = curr;             curr = temp;          }                  while(prev!= null){             if(prev.val != head.val) return false;  // If a particular value in reversed second half is not equals first half, then it is not a palindrome.             prev = prev.next;             head = head.next;         }                  return true;     } }",1,"234-palindrome-linked-list/ListNode.java:26:	UnusedAssignment:	The initializer for variable 'temp' is never used (overwritten on line 30)
234-palindrome-linked-list/ListNode.java:39:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'head'
",0,1,0
"class Solution {     public int[] numberOfPairs(int[] nums) {         int[] answer = new int[2];         HashMap<Integer, Integer> map = new HashMap<Integer, Integer>(); //to keep count of each number         for(int i=0;i<nums.length;i++){             int num = nums[i];             if(map.containsKey(num)){ //if number exists in map, it forms a pair with the previous occurrence                 int count = map.get(num)+1;                  map.put(num, count); //update the count                 if(count == 2){ //if the count is 2, a new pair has been formed                     answer[0]++;                     map.put(num, 0); //reset the count                 }             } else {                 map.put(num, 1);             }         }         answer[1] = map.size() - answer[0]; //counting the number of leftover integers         return answer;     } }",1,"2341-maximum-number-of-pairs-in-array/Solution.java:5:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public String bestHand(int[] ranks, char[] suits) {         // check if flush         boolean isFlush = true;         for(int i=1;i<suits.length;i++){             if(suits[i]!=suits[0]){                 isFlush = false;                 break;             }         }         if(isFlush) return ""Flush"";                  // check for three of a kind         for(int i=0;i<ranks.length;i++){             int count = 1;             for(int j=i+1;j<ranks.length;j++){                 if(ranks[i]==ranks[j]){                     count++;                 }             }             if(count==3) return ""Three of a Kind"";         }                  // check for pair         for(int i=0;i<ranks.length;i++){             int count = 1;             for(int j=i+1;j<ranks.length;j++){                 if(ranks[i]==ranks[j]){                     count++;                 }             }             if(count==2) return ""Pair"";         }                  return ""High Card"";     } }",1,"2347-best-poker-hand/Solution.java:2:	NPathComplexity:	The method 'bestHand(int[], char[])' has an NPath complexity of 294, current threshold is 200
",0,0,0
"class Solution {     public char repeatedCharacter(String s) {         // create a HashSet to store letters that have been seen         HashSet<Character> seen = new HashSet<>();                  // iterate through each character in the string         for (char c : s.toCharArray()) {             // if the character has been seen before, return it             if (seen.contains(c)) {                 return c;             } else {                 // add the character to the HashSet if it hasn't been seen before                 seen.add(c);             }         }                  // the loop should never reach this point         // but if it does, return null or throw an exception         return null;     } }",0,,0,0,0
class Solution {     public int minimumOperations(int[] nums) {         int count = 0;         while(true) {             int minNonZero = Integer.MAX_VALUE;             int index = -1;             for(int i=0; i<nums.length; i++) {                 if(nums[i] > 0 && nums[i] < minNonZero) {                     minNonZero = nums[i];                     index = i;                 }             }             if(index == -1) {                 return count;             }             count++;             for(int i=0; i<nums.length; i++) {                 if(nums[i] > 0) {                     nums[i] -= minNonZero;                 }             }         }     } },0,,0,0,0
"class Solution {     public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {         HashMap<Integer, Integer> map = new HashMap<>();         // iterate through items1 and add the values and weights to the map         for(int[] item: items1) {             map.put(item[0], map.getOrDefault(item[0], 0) + item[1]);         }                  // iterate through items2 and add the values and weights to the existing map if the items already exist         // otherwise, add the new items to the map         for(int[] item: items2) {             if(map.containsKey(item[0])) {                 map.put(item[0], map.get(item[0]) + item[1]);             } else {                 map.put(item[0], item[1]);             }         }                  List<List<Integer>> ret = new ArrayList<>();         // convert the map to the required 2D array format and add it to the ret list         for(int key: map.keySet()) {             ret.add(Arrays.asList(key, map.get(key)));         }         // sort the ret list in ascending order by value         Collections.sort(ret, (a,b) -> a.get(0) - b.get(0));                  return ret;     } }",0,,0,0,0
"class Solution {     public int arithmeticTriplets(int[] nums, int diff) {         int n = nums.length;         int[] dp = new int[n];         Map<Integer, Integer> map = new HashMap<>();         int ans = 0;                  for (int i = 0; i < n; i++) {             int complement1 = nums[i] - diff;             int complement2 = nums[i] - (2 * diff);                          if (map.containsKey(complement1)) {                 dp[i] += map.get(complement1);             }             if (map.containsKey(complement2)) {                 dp[i] -= map.get(complement2);             }             ans += dp[i];             map.put(nums[i], map.getOrDefault(nums[i], 0) + dp[i] + 1);         }                  return ans;     } }",0,,0,0,0
class Solution {     public int[][] largestLocal(int[][] grid) {         int n = grid.length;         int[][] maxLocal = new int[n-2][n-2];         for (int i = 1; i < n-1; i++) {             for (int j = 1; j < n-1; j++) {                 int max = Integer.MIN_VALUE;                 for (int k = -1; k <= 1; k++) {                     for (int l = -1; l <= 1; l++) {                         int value = grid[i+k][j+l];                         if (value > max) {                             max = value;                         }                     }                 }                 maxLocal[i-1][j-1] = max;             }         }         return maxLocal;     } },0,,0,0,0
"class Solution {     public int minimumRecolors(String blocks, int k) {         int n = blocks.length();         int minRecolors = Integer.MAX_VALUE;         for (int i = 0; i <= n - k; i++) {             int numBlack = 0;             for (int j = i; j < i + k; j++) {                 if (blocks.charAt(j) == 'B') {                     numBlack++;                 }             }             int numRecolors = k - numBlack;             if (numRecolors < minRecolors) {                 minRecolors = numRecolors;             }         }         return minRecolors;     } }",0,,0,0,0
"class Solution {     public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {         int n = energy.length;         int[] dp = new int[initialEnergy + 1];         Arrays.fill(dp, Integer.MAX_VALUE);         dp[initialEnergy] = 0;          for (int i = 0; i < n; i++) {             for (int e = initialEnergy - energy[i]; e >= 0; e--) {                 if (dp[e] != Integer.MAX_VALUE && dp[e] + 1 < dp[e + energy[i]]) {                     dp[e + energy[i]] = dp[e] + 1;                 }             }         }          for (int e = initialEnergy; e >= 0; e--) {             if (dp[e] <= initialExperience) {                 return dp[e];             }         }          return -1; // It is impossible to win     } }",0,,0,0,0
"class Solution {     public int[] answerQueries(int[] nums, int[] queries) {         int[] answer = new int[queries.length]; //initialize the answer array                  for(int i=0; i<queries.length; i++) {             int q = queries[i];             int count = 0;             int sum = 0;             for(int j=0; j<nums.length; j++) {                 sum += nums[j]; //add the current element to the sum                 if(sum <= q) {                     count++; //increase the count if the sum is within the query limit                 } else {                     sum -= nums[j-count]; //remove the last added element from sum                     //and decrease the count to move ahead to the next subsequence                     count--;                 }             }             answer[i] = count; //store the maximum subsequence length for this query         }                  return answer; //return the final answer array     } }",0,,0,0,0
class Solution {     public boolean findSubarrays(int[] nums) {         int n = nums.length;         // Check for every pair of subarrays         for (int i = 0; i < n-1; i++) {             for (int j = i+1; j < n-1; j++) {                 // Check if sum of subarrays are equal                 if (nums[i]+nums[i+1] == nums[j]+nums[j+1]) {                     // Check if the subarrays have different indices                     if (i != j && i+1 != j && j+1 != i) {                         return true;                     }                 }             }         }         return false;     } }  // Note: This solution has a time complexity of O(n^2) and may not be efficient for very large arrays.,1,"2395-find-subarrays-with-equal-sum/Solution.java:10:	CollapsibleIfStatements:	This if statement could be combined with its parent
",0,0,0
"class Solution {     public boolean checkDistances(String s, int[] distance) {         int n = s.length();         for(int i=0; i<26; i++) {             char ch = (char) (i+'a');             int idx = s.indexOf(ch);             if(idx == -1) continue;             while(idx < n) {                 int nextIdx = s.indexOf(ch, idx+1);                 if(nextIdx == -1) break;                 if(nextIdx-idx != distance[i]) return false;                 idx = nextIdx;             }         }         return true;     } }",0,,0,0,0
"class Solution {     public int mostFrequentEven(int[] nums) {         Map<Integer, Integer> map = new HashMap<>();         int maxFreq = 0;         int mostFrequentEven = -1;         for (int num : nums) {             if (num % 2 == 0) {                 int freq = map.getOrDefault(num, 0) + 1;                 map.put(num, freq);                 if (freq > maxFreq) {                     maxFreq = freq;                     mostFrequentEven = num;                 } else if (freq == maxFreq && num < mostFrequentEven) {                     mostFrequentEven = num;                 }             }         }         return mostFrequentEven;     } }",0,,0,0,0
"class Solution {     public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {         int[] daysInMonth = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};                  // Alice's date range         int aliceStartMonth = Integer.parseInt(arriveAlice.substring(0, 2));         int aliceStartDay = Integer.parseInt(arriveAlice.substring(3));         int aliceEndMonth = Integer.parseInt(leaveAlice.substring(0, 2));         int aliceEndDay = Integer.parseInt(leaveAlice.substring(3));                    // Bob's date range         int bobStartMonth = Integer.parseInt(arriveBob.substring(0, 2));         int bobStartDay = Integer.parseInt(arriveBob.substring(3));         int bobEndMonth = Integer.parseInt(leaveBob.substring(0, 2));         int bobEndDay = Integer.parseInt(leaveBob.substring(3));                    int totalDays = 0;                  // checking for overlapping dates         for(int month = 1; month <= 12; month++) {             int daysInCurrentMonth = daysInMonth[month - 1];             if(month == 2 && isLeapYear()) daysInCurrentMonth = 29; // checking for leap year                          int aliceStart = month == aliceStartMonth ? aliceStartDay : 1;             int aliceEnd = month == aliceEndMonth ? aliceEndDay : daysInCurrentMonth;             int bobStart = month == bobStartMonth ? bobStartDay : 1;             int bobEnd = month == bobEndMonth ? bobEndDay : daysInCurrentMonth;                          int overlappingDays = Math.max(0, Math.min(aliceEnd, bobEnd) - Math.max(aliceStart, bobStart) + 1);             totalDays += overlappingDays;         }                  return totalDays;     }          // helper method to check for leap year     private boolean isLeapYear() {         int year = 2021; // year is not a leap year         return year % 400 == 0 || (year % 100 != 0 && year % 4 == 0);     } }",1,"2409-count-days-spent-together/Solution.java:2:	UseObjectForClearerAPI:	Rather than using a lot of String arguments, consider using a container object for those values.
",0,0,0
"class Solution {     public int smallestEvenMultiple(int n) {         int multiple = 2; //initializing multiple as 2         while (true) {             if (multiple % n == 0) { //checking if multiple is divisible by n                 return multiple;             }             multiple += 2; //incrementing multiple by 2 in each iteration, as we need multiple of 2 also         }     } }  /*Explanation:    * the function takes input n    * we initialize a variable multiple as 2    * we run an infinite loop to check if multiple is divisible by n    * if yes, return the multiple    * otherwise, increment the multiple by 2 in each iteration*/",0,,0,0,0
"class Solution {     public String[] sortPeople(String[] names, int[] heights) {         int n = names.length;         // Create a class to store name and height         class Person {             String name;             int height;              Person(String name, int height) {                 this.name = name;                 this.height = height;             }         }         // Create an array of Person and initialize it         Person[] persons = new Person[n];         for (int i = 0; i < n; i++) {             persons[i] = new Person(names[i], heights[i]);         }         // Sort the array in decreasing order of height         Arrays.sort(persons, (a, b) -> b.height - a.height);         // Create a new array of names in sorted order         String[] sortedNames = new String[n];         for (int i = 0; i < n; i++) {             sortedNames[i] = persons[i].name;         }         return sortedNames;     } }",1,"2418-sort-the-people/Solution.java:6:20: Variable 'name' must be private and have accessor methods. [VisibilityModifier]
2418-sort-the-people/Solution.java:7:17: Variable 'height' must be private and have accessor methods. [VisibilityModifier]
2418-sort-the-people/Solution.java:9:27: 'name' hides a field. [HiddenField]
2418-sort-the-people/Solution.java:9:37: 'height' hides a field. [HiddenField]
",0,0,0
"class Solution {     public boolean isAnagram(String s, String t) {         if (s.length() != t.length()) { // if the lengths are not same then t cannot be anagram of s             return false;         }         int[] charCount = new int[26]; // create an array to store count of each lowercase alphabet in s         for (int i = 0; i < s.length(); i++) {             charCount[s.charAt(i) - 'a']++; // increment corresponding alphabet count             charCount[t.charAt(i) - 'a']--; // decrement corresponding alphabet count         }         for (int count : charCount) {             if (count != 0) { // if the count of any alphabet is non-zero, then s and t cannot be anagrams                 return false;             }         }         return true; // s and t are anagrams     } }",0,,0,0,0
"class Solution {     public boolean equalFrequency(String word) {         int[] freq = new int[26]; // array to store the frequency of each letter         int maxFreq = 0; // variable to keep track of the most frequent letter                  // calculate the frequency of each letter in the word and keep track of the most frequent letter         for (char c : word.toCharArray()) {             freq[c - 'a']++;             maxFreq = Math.max(maxFreq, freq[c - 'a']);         }                  int countMaxFreq = 0; // variable to count how many letters have the max frequency         int countOthers = 0; // variable to count how many letters have a frequency different than the max                  // loop through the frequency array to count the number of letters with max frequency         for (int f : freq) {             if (f == maxFreq) {                 countMaxFreq++;             } else if (f != 0) { // count the number of letters with a frequency different than the max                 countOthers++;             }         }                  // check the different possible cases based on the counts         if (countMaxFreq == word.length() || countMaxFreq == word.length() - 1) {             return true; // all letters have the same frequency or one letter can be removed to make them all equal         } else if (countMaxFreq == 1 && countOthers == word.length() - maxFreq) {             return true; // only one letter has the max frequency and all other letters have a frequency different than the max         }                  return false; // none of the cases above apply     } }",0,,0,0,0
"class Solution {     public int commonFactors(int a, int b) {         int count = 0;         int n = Math.min(a, b); // consider the minimum value between a and b          for(int i=1; i<=n; i++) {             if(a % i == 0 && b % i == 0) {                  // check whether i is a common factor of both a and b                 count++; // increase the count             }         }          return count;     } }  // test the code for the given examples class Main {     public static void main(String[] args) {         Solution solution = new Solution();         System.out.println(solution.commonFactors(12, 6)); // expected output: 4         System.out.println(solution.commonFactors(25, 30)); // expected output: 2     } }",1,"2427-number-of-common-factors/Solution.java:18:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
2427-number-of-common-factors/Solution.java:18:	UseUtilityClass:	This utility class has a non-private constructor
",0,0,0
"class Solution {     public int hardestWorker(int n, int[][] logs) {         int[] times = new int[n];         for (int i = 0; i < logs.length; i++) {             int id = logs[i][0];             int time = logs[i][1];             if (i > 0) {                 int prevTime = logs[i-1][1];                 times[id] += time - prevTime;             } else {                 times[id] += time;             }         }                  int maxTime = 0, hardestWorker = 0;         for (int i = 0; i < n; i++) {             if (times[i] > maxTime) {                 maxTime = times[i];                 hardestWorker = i;             }         }         return hardestWorker;     } }",1,"2432-the-employee-that-worked-on-the-longest-task/Solution.java:15:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int countTime(String time) {         int count = 0;         for (int hour = 0; hour < 24; hour++) {             for (int minute = 0; minute < 60; minute++) {                 boolean valid = true;                 String hourStr = String.format(""%02d"", hour);                 String minuteStr = String.format(""%02d"", minute);                 for (int i = 0; i < time.length(); i++) {                     char ch = time.charAt(i);                     if (ch == '?') {                         if (i == 0) {                             if (time.charAt(1) == '?' || time.charAt(1) - '0' < 4) {                                 hourStr = hourStr.substring(0, 1) + '0';                                 if (hourStr.charAt(0) == '0' && hourStr.charAt(1) > '9') {                                     valid = false;                                     break;                                 }                             } else {                                 hourStr = hourStr.substring(0, 1) + '1';                                 if (hourStr.charAt(0) == '2' && hourStr.charAt(1) > '3') {                                     valid = false;                                     break;                                 }                             }                         } else if (i == 1) {                             if (time.charAt(0) == '?' || time.charAt(0) == '2') {                                 hourStr = hourStr.substring(0, 0) + '0';                                 if (hourStr.charAt(0) == '0' && hourStr.charAt(1) > '9') {                                     valid = false;                                     break;                                 }                             } else {                                 hourStr = hourStr.substring(0, 0) + '1';                                 if (hourStr.charAt(0) == '2' && hourStr.charAt(1) > '3') {                                     valid = false;                                     break;                                 }                             }                         } else if (i == 3) {                             minuteStr = minuteStr.substring(0, 1) + '0';                             if (minuteStr.charAt(0) == '0' && minuteStr.charAt(1) > '9') {                                 valid = false;                                 break;                             }                         } else if (i == 4) {                             minuteStr = minuteStr.substring(0, 0) + '0';                             if (minuteStr.charAt(0) == '0' && minuteStr.charAt(1) > '9') {                                 valid = false;                                 break;                             }                         }                     } else if (ch != ':' && ch != hourStr.charAt(i) && ch != minuteStr.charAt(i)) {                         valid = false;                         break;                     }                 }                 if (valid) {                     count++;                 }             }         }         return count;     } }",0,,0,0,0
"class Solution {     public int findMaxK(int[] nums) {         Set<Integer> numSet = new HashSet<>();         int maxK = -1; // initialize to -1                  for(int i=0; i<nums.length; i++) {             int currNum = nums[i];             if(numSet.contains(-currNum)) {                 maxK = Math.max(maxK, Math.abs(currNum)); // update maxK if currNum is bigger             }             numSet.add(currNum);         }                  return maxK;     } }",1,"2441-largest-positive-integer-that-exists-with-its-negative/Solution.java:6:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public boolean haveConflict(String[] event1, String[] event2) {         String[] e1StartTimeArr = event1[0].split("":"");         String[] e1EndTimeArr = event1[1].split("":"");                  String[] e2StartTimeArr = event2[0].split("":"");         String[] e2EndTimeArr = event2[1].split("":"");                  int e1StartHr = Integer.parseInt(e1StartTimeArr[0]);         int e1StartMin = Integer.parseInt(e1StartTimeArr[1]);         int e1EndHr = Integer.parseInt(e1EndTimeArr[0]);         int e1EndMin = Integer.parseInt(e1EndTimeArr[1]);                  int e2StartHr = Integer.parseInt(e2StartTimeArr[0]);         int e2StartMin = Integer.parseInt(e2StartTimeArr[1]);         int e2EndHr = Integer.parseInt(e2EndTimeArr[0]);         int e2EndMin = Integer.parseInt(e2EndTimeArr[1]);                  if(e1EndHr < e2StartHr || e2EndHr < e1StartHr)             return false;                  if(e1EndHr == e2StartHr && e1EndMin < e2StartMin || e2EndHr == e1StartHr && e2EndMin < e1StartMin)             return false;                  return true;     } }",1,"2446-determine-if-two-events-have-conflict/Solution.java:22:	SimplifyBooleanReturns:	This if statement can be replaced by `return !{condition};`
",0,0,0
"class Solution {     public String oddString(String[] words) {         int n = words[0].length(); // all the strings have the same length         for(int i=0;i<n-1;i++){ // checking the difference between all letters of the string             int diff = words[0].charAt(i+1) - words[0].charAt(i); // difference array of the first string             for(int j=1;j<words.length;j++){                 int currDiff = words[j].charAt(i+1) - words[j].charAt(i); // difference array of the current string being checked                 if(currDiff!=diff) return words[j]; // if odd difference array, return the corresponding string             }         }         return """"; // if no odd difference array exists     } }",0,,0,0,0
class Solution {     public int averageValue(int[] nums) {         int sum = 0;         int count = 0;                  for (int num : nums) {             if (num % 2 == 0 && num % 3 == 0) {                 sum += num;                 count++;             }         }                  if (count == 0) {             return 0;         } else {             return sum / count;         }     } },0,,0,0,0
class Solution {     public int[] applyOperations(int[] nums) {         int n = nums.length;         for(int i=0; i<n-1; i++) {             if(nums[i] == nums[i+1]) {                 nums[i] *= 2;                 nums[i+1] = 0;             }         }         int[] result = new int[n];         int index = 0;         for(int i=0; i<n; i++) {             if(nums[i] != 0) {                 result[index++] = nums[i];             }         }         return result;     } },0,,0,0,0
"class Solution {     public int distinctAverages(int[] nums) {         Set<Double> set = new HashSet<>();         int n = nums.length;         Arrays.sort(nums);         for (int i = 0, j = n-1; i < j; i++, j--) {             double avg = (nums[i]+nums[j])/2.0;             set.add(avg);         }         return set.size();     } }",1,"2465-number-of-distinct-averages/Solution.java:6:	ForLoopVariableCount:	Too many control variables in the for statement
",0,0,0
"class Solution {     public double[] convertTemperature(double celsius) {         double kelvin = celsius + 273.15; // Convert Celsius to Kelvin         double fahrenheit = celsius * 1.8 + 32.0; // Convert Celsius to Fahrenheit         return new double[] {kelvin, fahrenheit}; // Return the results as an array     } } ",0,,0,0,0
class Solution {     public int unequalTriplets(int[] nums) {         int n = nums.length;         int count = 0;         for(int i=0;i<n-2;i++){             for(int j=i+1;j<n-1;j++){                 if(nums[i]==nums[j])                     continue;                 for(int k=j+1;k<n;k++){                     if(nums[k]==nums[i] || nums[k]==nums[j])                         continue;                     count++;                 }             }         }         return count;     } }   // Time Complexity: O(n^3) // Space Complexity: O(1),0,,0,0,0
class Solution {     public int numberOfCuts(int n) {         if (n <= 0) {             return 0;         } else if (n == 1) {             return 0;         } else if (n == 2) {             return 1;         } else if (n == 3) {             return 2;         } else {             int numCuts = 0;             if (n % 2 == 0) {                 numCuts = n / 2;             } else {                 numCuts = n;             }             return numCuts;         }     } },1,"2481-minimum-cuts-to-divide-a-circle/Solution.java:12:	UnusedAssignment:	The initializer for variable 'numCuts' is never used (overwritten on lines 14 and 16)
",0,0,0
"class Solution {     public int pivotInteger(int n) {         // Calculate the sum of integers from 1 to n         int totalSum = n * (n + 1) / 2;          // Find the pivot integer (if it exists)         int leftSum = 0;         for (int i = 1; i <= n; i++) {             leftSum += i;             int rightSum = totalSum - leftSum;             if (leftSum == rightSum) {                 return i;             }         }          // If we didn't find a pivot integer, return -1         return -1;     } }",0,,0,0,0
"class Solution {     public boolean isCircularSentence(String sentence) {         String[] words = sentence.split("" "");         int n = words.length;         for(int i=0; i<n; i++){             char first = words[i].charAt(0);             char last = words[i].charAt(words[i].length()-1);             if(first >= 'a' && first <= 'z')                 first = Character.toUpperCase(first);              if(last >= 'a' && last <= 'z')                 last = Character.toUpperCase(last);              words[i] = first + words[i].substring(1);              for(int j=0; j<n && i != j; j++){                 if(last == words[j].charAt(0)){                     char nextFirst = words[j].charAt(0);                     char nextLast = words[j].charAt(words[j].length()-1);                      if(nextFirst >= 'a' && nextFirst <= 'z')                         nextFirst = Character.toUpperCase(nextFirst);                      if(nextLast >= 'a' && nextLast <= 'z')                         nextLast = Character.toUpperCase(nextLast);                      words[j] = nextFirst + words[j].substring(1);                      if(nextLast == words[i].charAt(0))                         return true;                 }             }         }          return false;     } }",0,,0,0,0
"class Solution {     public int maximumValue(String[] strs) {         int maxValue = 0;         for (String str : strs) {             int value = 0;             for (char c : str.toCharArray()) {                 if (Character.isDigit(c)) {                     value = value * 10 + Character.getNumericValue(c);                 } else {                     value = str.length();                     break;                 }             }             maxValue = Math.max(maxValue, value);         }         return maxValue;     } } ",0,,0,0,0
class Solution {     public int deleteGreatestValue(int[][] grid) {         int numRows = grid.length;         int numCols = grid[0].length;         int answer = 0;          for (int j = 0; j < numCols; j++) {             int max = Integer.MIN_VALUE;             int maxRow = -1;              // Find the maximum value in this column             for (int i = 0; i < numRows; i++) {                 if (grid[i][j] > max) {                     max = grid[i][j];                     maxRow = i;                 }             }              // Remove the maximum value from its row and add it to the answer             answer += max;             grid[maxRow][j] = 0;              // Remove all other occurrences of the maximum value in this column             for (int i = 0; i < numRows; i++) {                 if (grid[i][j] == max) {                     grid[i][j] = 0;                 }             }         }          return answer;     } },0,,0,0,0
"class Solution {     public int similarPairs(String[] words) {         int count = 0;         for(int i=0; i<words.length; i++){             for(int j=i+1; j<words.length; j++){                 if(isSimilar(words[i], words[j])){                     count++;                 }             }         }         return count;     }          private boolean isSimilar(String s1, String s2){         if(s1.length() != s2.length()){             return false;         }         int[] arr = new int[26];         for(int i=0; i<s1.length(); i++){             arr[s1.charAt(i) - 'a']++;             arr[s2.charAt(i) - 'a']--;         }         for(int i=0; i<26; i++){             if(arr[i] != 0){                 return false;             }         }         return true;     } }",0,,0,0,0
"class Solution {     public int captureForts(int[] forts) {         int n = forts.length;         int maxCaptured = 0;         for(int i = 0; i < n; i++) {             if(forts[i] == 1) { // if the current fort is under your command                 for(int j = 0; j < n; j++) {                     if(forts[j] == 0 && i != j) { // if the current position is an enemy fort                         boolean canCapture = true;                         for(int k = Math.min(i,j)+1; k < Math.max(i,j); k++) {                             if(forts[k] != 0) { // if there's a fort in the way, cannot capture                                 canCapture = false;                                 break;                             }                         }                         if(canCapture) {                             int captured = 0;                             for(int k = Math.min(i,j)+1; k < Math.max(i,j); k++) {                                 if(forts[k] == 0) { // capture any enemy fort in the way                                     forts[k] = 1;                                     captured++;                                 }                             }                             maxCaptured = Math.max(maxCaptured, captured);                         }                     }                 }             }         }         return maxCaptured;     } }",1,"2511-maximum-enemy-forts-that-can-be-captured/Solution.java:11:	AvoidDeeplyNestedIfStmts:	Deeply nested if..then statements are hard to read
2511-maximum-enemy-forts-that-can-be-captured/Solution.java:16:	AvoidDeeplyNestedIfStmts:	Deeply nested if..then statements are hard to read
",0,0,0
"class Solution {     public int closetTarget(String[] words, String target, int startIndex) {         //first search for target in the array         int n = words.length;         int targetIndex = -1;         for (int i = 0; i < n; i++) {             if (words[i].equals(target)) {                 targetIndex = i;                 break;             }         }         if (targetIndex == -1) {             return -1;         }         //now calculate the shortest distance to the target         int distance = Math.abs(targetIndex - startIndex);         int circularDistance = (n - distance) % n;         return Math.min(distance, circularDistance);     } }",0,,0,0,0
"Here's the Java code implementation of the problem:   class Solution {     public int countDigits(int num) {         int count = 0;         int n = num;         while (n != 0) {             int digit = n % 10;             if (digit != 0 && num % digit == 0) {                 count++;             }             n /= 10;         }         return count;     } }  Explanation: - Initialize a count variable to 0 - Create a copy of the input number num and store it in variable n - Use a while loop to iterate until n becomes 0 - For each iteration, get the rightmost digit of n using the modulus operator and store it in variable digit - Check if digit is not 0 and num is divisible by digit. If it is, increment the count variable - Divide n by 10 to remove the rightmost digit - After the while loop, return the count variable.",1,"2520-count-the-digits-that-divide-a-number/Solution.java	-	TokenMgrError: Lexical error in file '2520-count-the-digits-that-divide-a-number/Solution.java' at line 1, column 7: "" "" (32), after : ""\'s"" (in lexical state DEFAULT)
",0,0,0
"class Solution {     public String categorizeBox(int length, int width, int height, int mass) {         int volume = length * width * height;         if (length >= 104 || width >= 104 || height >= 104 || volume >= 1_000_000_000) {             if (mass >= 100) {                 return ""Both"";             } else {                 return ""Bulky"";             }         } else if (mass >= 100) {             return ""Heavy"";         } else {             return ""Neither"";         }     } }",0,,0,0,0
"class Solution {     public int maximumCount(int[] nums) {         int pos = 0;         int neg = 0;         for(int i = 0; i < nums.length; i++){             if(nums[i] == 0){                 continue;             }             else if(nums[i] < 0){                 neg++;             }             else{                 pos++;             }         }         return Math.max(pos, neg);     } }",1,"2529-maximum-count-of-positive-integer-and-negative-integer/Solution.java:8:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2529-maximum-count-of-positive-integer-and-negative-integer/Solution.java:11:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2529-maximum-count-of-positive-integer-and-negative-integer/Solution.java:5:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
class Solution {     public int differenceOfSum(int[] nums) {         int elementSum = 0;         int digitSum = 0;         for(int num : nums) {             elementSum += num;             while(num > 0){                 digitSum += num % 10;                 num /= 10;             }         }         return Math.abs(elementSum - digitSum);     } },0,,0,0,0
"class Solution {     public int getCommon(int[] nums1, int[] nums2) {         int i = 0, j = 0;         int n1 = nums1.length, n2 = nums2.length;                  while (i < n1 && j < n2) {             // If the current element in nums1 is less than the current             // element in nums2, move the pointer in nums1 to the next element             if (nums1[i] < nums2[j]) {                 i++;             }              // If the current element in nums2 is less than the current             // element in nums1, move the pointer in nums2 to the next element             else if (nums2[j] < nums1[i]) {                 j++;             }             // If the current elements in both arrays are equal, we return             // the common element             else {                 return nums1[i];             }         }         // If we reach here, there is no common element in the arrays         return -1;     } }",1,"2540-minimum-common-value/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2540-minimum-common-value/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2540-minimum-common-value/Solution.java:11:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2540-minimum-common-value/Solution.java:16:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",1,0,0
class Solution {     public int alternateDigitSum(int n) {         int sum = 0;         boolean positive = true;                  String numString = Integer.toString(n);         int numOfDigits = numString.length();                  for (int i = 0; i < numOfDigits; i++) {             int digit = Character.getNumericValue(numString.charAt(i));                          if (i == 0) {                 sum += digit;             } else if (positive) {                 sum += digit;                 positive = false;             } else {                 sum -= digit;                 positive = true;             }         }                  return sum;     } },0,,0,0,0
class Solution {     public int distinctIntegers(int n) {         Set<Integer> set = new HashSet<>();         set.add(n);                  for(int i=1; i<=109; i++){             Set<Integer> temp = new HashSet<>();             for(int num : set){                 for(int j=1; j<=n; j++){                     if(num % j == 1){                         temp.add(j);                     }                 }             }             set.addAll(temp);         }                  return set.size();     } },0,,0,0,0
class Solution {     public int[] separateDigits(int[] nums) {         // initialize an ArrayList to store the separated digits         ArrayList<Integer> separatedDigits = new ArrayList<>();                  // loop through each integer in the nums array         for (int i = 0; i < nums.length; i++) {             // convert the integer to a string to easily access its digits             String numAsString = String.valueOf(nums[i]);             // loop through each character in the string representation of the integer             for (int j = 0; j < numAsString.length(); j++) {                 // convert the character to an integer and add it to the separatedDigits ArrayList                 separatedDigits.add(Character.getNumericValue(numAsString.charAt(j)));             }         }                  // convert the ArrayList to an array of integers         int[] answer = new int[separatedDigits.size()];         for (int i = 0; i < separatedDigits.size(); i++) {             answer[i] = separatedDigits.get(i);         }                  return answer;     } },1,"2553-separate-the-digits-in-an-array/Solution.java:7:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public long pickGifts(int[] gifts, int k) {         int n = gifts.length;         long ans = 0;         for (int i = 0; i < k; i++) {             int index = 0;             for (int j = 1; j < n; j++) {                 if (gifts[j] > gifts[index]) {                     index = j;                 }             }             int x = (int) Math.sqrt(gifts[index]);             ans += gifts[index] - x;             gifts[index] = x;         }         for (int i = 0; i < n; i++) {             ans += gifts[i];         }         return ans;     } }",0,,0,0,0
"class Solution {     public long findTheArrayConcVal(int[] nums) {         long concatValue = 0;         while(nums.length > 0){             if(nums.length > 1){                 int first = nums[0];                 int last = nums[nums.length-1];                 String concatStr = Integer.toString(first) + Integer.toString(last);                 concatValue += Long.parseLong(concatStr);                 nums = Arrays.copyOfRange(nums, 1, nums.length-1);             } else {                 concatValue += nums[0];                 nums = Arrays.copyOfRange(nums, 1, nums.length);             }         }         return concatValue;     } }",1,"2562-find-the-array-concatenation-value/Solution.java:10:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'nums'
",0,1,0
"public class Solution {     public int minMaxDifference(int num) {         String s = String.valueOf(num); // convert num to String         int max = num, min = num;         for (int i = 0; i < s.length(); i++) {             for (int j = 0; j <= 9; j++) { // try all possible digits                 String str = s.substring(0, i) + j + s.substring(i + 1); // remap digit i to j                 int val = Integer.parseInt(str);                 if (val > max) max = val;                 if (val < min) min = val;             }         }         return max - min;     } }",1,"2566-maximum-difference-by-remapping-a-digit/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"import java.util.*;  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */  class Solution {     public List<String> binaryTreePaths(TreeNode root) {         List<String> result = new ArrayList<>();         if (root == null) {             return result;         }         traverse(root, String.valueOf(root.val), result);         return result;     }          private void traverse(TreeNode node, String path, List<String> result) {         if (node.left == null && node.right == null) {             result.add(path);             return;         }                if (node.left != null) {             traverse(node.left, path + ""->"" + String.valueOf(node.left.val), result);         }         if (node.right != null) {             traverse(node.right, path + ""->"" + String.valueOf(node.right.val), result);         }     } }",1,"257-binary-tree-paths/TreeNode.java:35:	UselessStringValueOf:	No need to call String.valueOf to append to a string.
257-binary-tree-paths/TreeNode.java:38:	UselessStringValueOf:	No need to call String.valueOf to append to a string.
",0,0,0
"class Solution {     public int[][] mergeArrays(int[][] nums1, int[][] nums2) {         int size = nums1.length + nums2.length;         int[][] result = new int[size][2];                  int i = 0, j = 0, k = 0;         while (i < nums1.length && j < nums2.length) {             if (nums1[i][0] < nums2[j][0]) {                 result[k][0] = nums1[i][0];                 result[k][1] = nums1[i][1];                 i++;             } else if (nums1[i][0] > nums2[j][0]) {                 result[k][0] = nums2[j][0];                 result[k][1] = nums2[j][1];                 j++;             } else {                 result[k][0] = nums1[i][0];                 result[k][1] = nums1[i][1] + nums2[j][1];                 i++;                 j++;             }             k++;         }                  while (i < nums1.length) {             result[k][0] = nums1[i][0];             result[k][1] = nums1[i][1];             i++;             k++;         }                  while (j < nums2.length) {             result[k][0] = nums2[j][0];             result[k][1] = nums2[j][1];             j++;             k++;         }                  return result;     } }",1,"2570-merge-two-2d-arrays-by-summing-values/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
class Solution {     public int[] leftRigthDifference(int[] nums) {         int n = nums.length;         int[] leftSum = new int[n];         int[] rightSum = new int[n];          // calculate left sum         for (int i = 1; i < n; i++) {             leftSum[i] = leftSum[i-1] + nums[i-1];         }          // calculate right sum         for (int i = n-2; i >= 0; i--) {             rightSum[i] = rightSum[i+1] + nums[i+1];         }          // calculate answer         int[] answer = new int[n];         for (int i = 0; i < n; i++) {             answer[i] = Math.abs(leftSum[i] - rightSum[i]);         }          return answer;     } },0,,0,0,0
import java.util.Arrays;  class Solution {     public int splitNum(int num) {         // Convert the integer to a string and sort the characters         char[] numChars = String.valueOf(num).toCharArray();         Arrays.sort(numChars);          // Create arrays to store the count of each digit in num1 and num2         int[] num1Counts = new int[numChars.length / 2];         int[] num2Counts = new int[numChars.length / 2];          // Split the digits between num1 and num2         for (int i = 0; i < numChars.length; i++) {             if (i < numChars.length / 2) {                 num1Counts[i] = Character.getNumericValue(numChars[i]);             } else {                 num2Counts[i - numChars.length / 2] = Character.getNumericValue(numChars[i]);             }         }          // Calculate the sum of num1 and num2         int sum = 0;         for (int i = 0; i < num1Counts.length; i++) {             sum += num1Counts[i] + num2Counts[i];         }          return sum;     } },0,,0,0,0
"class Solution {     public int addDigits(int num) {         while (num >= 10) { // continue until num has only one digit             int sum = 0;             while (num > 0) { // add all the digits in num                 sum += num % 10;                 num /= 10;             }             num = sum; // set num to the sum of its digits         }         return num; // return the final num value     } }  class Solution {     public int addDigits(int num) {         if (num == 0) {             return 0;         }         if (num % 9 == 0) {             return 9;         }         return num % 9; // if num is not zero or a multiple of 9, return the remainder when divided by 9     } }",1,"258-add-digits/Solution.java:7:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'num'
",0,1,0
"class Solution {     public int passThePillow(int n, int time) {         // Initially the pillow is with first person         int current = 1;         // Variable to keep track of the current direction of passing the pillow         boolean forward = true;          // Loop through each second of passing the pillow         for(int i=0; i<time; i++) {             // If passing the pillow in forward direction, and not reached the end of the line             if(forward && current < n) {                 current++; // pass the pillow to the next person in forward direction             }             // If passing the pillow in forward direction, and reached the end of the line             else if(forward && current == n) {                 forward = false; // change the direction of passing the pillow                 current--; // pass the pillow in reverse direction             }             // If passing the pillow in reverse direction, and not reached the beginning of the line             else if(!forward && current > 1) {                 current--; // pass the pillow to the previous person in reverse direction             }             // If passing the pillow in reverse direction, and reached the beginning of the line             else if(!forward && current == 1) {                 forward = true; // change the direction of passing the pillow                 current++; // pass the pillow in forward direction             }         }         return current; // return the index of the person holding the pillow after given time     } }",1,"2582-pass-the-pillow/Solution.java:12:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2582-pass-the-pillow/Solution.java:17:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2582-pass-the-pillow/Solution.java:21:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
"class Solution {     public int vowelStrings(String[] words, int left, int right) {         int count = 0;  // Initialize the count of vowel strings         for (int i = left; i <= right; i++) {             char first = words[i].charAt(0);  // First character of the word             char last = words[i].charAt(words[i].length() - 1);  // Last character of the word                          // Condition to check if the first and last characters are vowels              if ((first == 'a' || first == 'e' || first == 'i' || first == 'o' || first == 'u') &&                     (last == 'a' || last == 'e' || last == 'i' || last == 'o' || last == 'u')) {                 count++;  // Increment the count if the word is a vowel string             }         }         return count;  // Return the count of vowel strings     } }",0,,0,0,0
"class Solution {     public int distMoney(int money, int children) {         int maxEights = money / 8;         int remainingMoney = money - maxEights * 8;         int minOnes = children - maxEights;         if (minOnes < 0) {             return -1;         }         if (remainingMoney == 0 && minOnes > 0) {             return -1;         }         if (remainingMoney == 4 && minOnes > 1) {             return -1;         }         return maxEights;     } }",1,"2591-distribute-money-to-maximum-children/Solution.java:4:	PrematureDeclaration:	Declaration of 'remainingMoney' can be moved closer to its usages
",0,0,0
"class Solution {     public int[] evenOddBit(int n) {         // converting the integer n to its binary representation         String binary = Integer.toBinaryString(n);                  int even = 0, odd = 0;                  // looping through the binary string to count even and odd indices with value 1         for(int i = 0; i < binary.length(); i++) {             if(i % 2 == 0 && binary.charAt(i) == '1') {                 even++;             }             else if(i % 2 == 1 && binary.charAt(i) == '1') {                 odd++;             }         }                  // creating and returning the answer array         int[] answer = {even, odd};         return answer;     } }",1,"2595-number-of-even-and-odd-bits/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2595-number-of-even-and-odd-bits/Solution.java:12:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2595-number-of-even-and-odd-bits/Solution.java:19:	UnnecessaryLocalBeforeReturn:	Consider simply returning the value vs storing it in local variable 'answer'
",1,0,0
"class Solution {     public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {         int[] arr= new int[k];                  //filling the array with 1 for positive and 0 for negative integer         for(int i=0; i<k; ++i){             if(numOnes>0){                 arr[i]=1;                 numOnes--;             }else if(numNegOnes>0){                 arr[i]=-1;                 numNegOnes--;             }else{                 arr[i]=0;             }         }                  Arrays.sort(arr);                  //Remove the negative values         for(int i=0; i<arr.length && arr[i]<0 && numZeros>0; i++){             arr[i] = 0;             numZeros--;         }                  //satisfy remaining zeros         for(int i=0; i<arr.length && numZeros>0; ++i){             if(arr[i]==0){                 arr[i]=1;                 numZeros--;             }         }                  int sum=0;         for(int i=0; i<k; ++i){             sum+= arr[i];         }                  return sum;     } }",1,"2600-k-items-with-the-maximum-sum/Solution.java:9:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'numOnes'
2600-k-items-with-the-maximum-sum/Solution.java:12:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'numNegOnes'
2600-k-items-with-the-maximum-sum/Solution.java:23:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'numZeros'
",0,1,0
"class Solution {     public int minNumber(int[] nums1, int[] nums2) {         Set<Integer> set1 = new HashSet<>();         Set<Integer> set2 = new HashSet<>();         for(int num: nums1){             set1.add(num);         }         for(int num: nums2){             set2.add(num);         }          int min = Integer.MAX_VALUE;         for(int num: set1){             if(set2.contains(num)){                 min = Math.min(num, min);             }         }         for(int num: set2){             if(set1.contains(num)){                 min = Math.min(num, min);             }         }          return min;     } }",0,,0,0,0
"class Solution {     public int findTheLongestBalancedSubstring(String s) {         int maxLen = 0;         int zeroCount = 0;         int oneCount = 0;         for(int i=0; i<s.length(); i++){             if(s.charAt(i) == '0'){                 zeroCount++;             }else{                 oneCount++;             }             if(zeroCount == oneCount){                 maxLen = Math.max(maxLen, zeroCount+oneCount);             }else if(oneCount > zeroCount){                 zeroCount = oneCount = 0;             }         }         zeroCount = oneCount = 0;         for(int i=s.length()-1; i>=0; i--){             if(s.charAt(i) == '0'){                 zeroCount++;             }else{                 oneCount++;             }             if(zeroCount == oneCount){                 maxLen = Math.max(maxLen, zeroCount+oneCount);             }else if(zeroCount > oneCount){                 zeroCount = oneCount = 0;             }         }         return maxLen;     } }",1,"2609-find-the-longest-balanced-substring-of-a-binary-string/Solution.java:15:38: Inner assignments should be avoided. [InnerAssignment]
2609-find-the-longest-balanced-substring-of-a-binary-string/Solution.java:18:30: Inner assignments should be avoided. [InnerAssignment]
2609-find-the-longest-balanced-substring-of-a-binary-string/Solution.java:28:38: Inner assignments should be avoided. [InnerAssignment]
",0,0,0
"class Solution {     public int diagonalPrime(int[][] nums) {         // Initialize the maximum prime found so far to 0         int maxPrime = 0;                  // Loop through each diagonal and check if the number is prime and larger than the current maxPrime         for (int i = 0; i < nums.length; i++) {             int num1 = nums[i][i];             int num2 = nums[i][nums.length - i - 1];             if (isPrime(num1) && num1 > maxPrime) {                 maxPrime = num1;             }             if (isPrime(num2) && num2 > maxPrime) {                 maxPrime = num2;             }         }                  // Return the largest prime found, or 0 if no prime was found         return maxPrime;     }          // Helper method to check if a number is prime     private boolean isPrime(int num) {         if (num <= 1) {             return false;         }         for (int i = 2; i <= Math.sqrt(num); i++) {             if (num % i == 0) {                 return false;             }         }         return true;     } }",0,,0,0,0
class Solution {     public boolean isUgly(int n) {         if(n == 0) return false;         while(n % 2 == 0) {             n /= 2;         }         while(n % 3 == 0) {             n /= 3;         }         while(n % 5 == 0) {             n /= 5;         }         return n == 1;     } },1,"263-ugly-number/Solution.java:5:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
",0,1,0
class Solution {     public int missingNumber(int[] nums) {         // initialization         int n = nums.length;         int sum = n * (n + 1) / 2;         int actualSum = 0;          // sum up all the numbers in the array         for (int num : nums) {             actualSum += num;         }          // return the difference between expected sum and actual sum         return sum - actualSum;     } },0,,0,0,0
/* The isBadVersion API is defined in the parent class VersionControl.       boolean isBadVersion(int version); */  public class Solution extends VersionControl {     public int firstBadVersion(int n) {         int left = 1;         int right = n;         while (left < right) {             int mid = left + (right - left) / 2;             if (isBadVersion(mid)) {                 right = mid;             } else {                 left = mid + 1;             }         }         return left;     } },0,,0,0,0
class Solution {     public void moveZeroes(int[] nums) {         int i = 0; // index to track non-zero element         for(int j = 0; j < nums.length; j++) {             if(nums[j] != 0) {                 // swapping the non-zero element with the previous first zero element                 int temp = nums[i];                 nums[i] = nums[j];                 nums[j] = temp;                 i++;             }         }     } } ,0,,0,0,0
"class Solution {     public boolean wordPattern(String pattern, String s) {                  // Split the string into individual words         String[] words = s.split("" "");                  // Check if the number of words and pattern length are equal         if(words.length != pattern.length()){             return false;         }                  // Create two maps to store the mapping of the pattern characters to words         Map<Character, String> patternToWords = new HashMap<>();         Map<String, Character> wordsToPattern = new HashMap<>();                  // Loop through the pattern and words to check if they follow the same pattern         for(int i=0; i<pattern.length(); i++){             char c = pattern.charAt(i);             String word = words[i];                          // Check if the current pattern character is already mapped to a different word             if(patternToWords.containsKey(c) && !patternToWords.get(c).equals(word)){                 return false;             }                          // Check if the current word is already mapped to a different pattern character             if(wordsToPattern.containsKey(word) && wordsToPattern.get(word) != c){                 return false;             }                          // If the mappings are valid, add them to the maps             patternToWords.put(c, word);             wordsToPattern.put(word, c);         }                  // At the end, if all the mappings are valid, return true         return true;     } }",0,,0,0,0
"class Solution {     public boolean canWinNim(int n) {         // If the number of stones in the heap is a multiple of 4, it is not possible to win         // Since, in each turn, the player can remove only 1 to 3 stones         // So, if we take 4 stones, no matter what the player removes, the next player can remove the remaining stones and win.         return n % 4 != 0;     } }",0,,0,0,0
"class NumArray {     private int[] nums;      public NumArray(int[] nums) {         this.nums = nums;         for (int i = 1; i < nums.length; i++) {             nums[i] += nums[i-1];         }     }          public int sumRange(int left, int right) {         if (left == 0) {             return nums[right];         }         return nums[right] - nums[left-1];     } }",1,"303-range-sum-query-immutable/NumArray.java:4:5: Redundant 'public' modifier. [RedundantModifier]
303-range-sum-query-immutable/NumArray.java:4:27: 'nums' hides a field. [HiddenField]
303-range-sum-query-immutable/NumArray.java:5:	ArrayIsStoredDirectly:	The user-supplied array 'nums' is stored directly.
",0,0,0
"class Solution {     public boolean isPowerOfThree(int n) {         if(n<=0) return false; //n should be greater than 0              while(n%3==0){              n/=3; //divide n by 3 until n%3 is 0         }         return n==1; //if n is a power of 3, then n would become 1 after above operation     } }",1,"326-power-of-three/Solution.java:5:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
",0,1,0
class Solution {     public int[] countBits(int n) {         int[] ans = new int[n+1];         for(int i=0;i<=n;i++){             ans[i] = ans[i>>1] + (i&1);         }         return ans;     } } ,0,,0,0,0
class Solution {     public boolean isPowerOfFour(int n) {         if(n <= 0){             return false;         }         while(n > 1){             if(n % 4 != 0){                 return false;             }             n = n / 4;         }         return true;     } },1,"342-power-of-four/Solution.java:10:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
",0,1,0
class Solution {     public void reverseString(char[] s) {         int left = 0;         int right = s.length - 1;          while (left < right) {             char temp = s[left];             s[left] = s[right];             s[right] = temp;             left++;             right--;         }     } },0,,0,0,0
"class Solution {     public String reverseVowels(String s) {         // convert the string into a character array         char[] sArr = s.toCharArray();                  // initialize left and right pointers         int left = 0, right = sArr.length - 1;                  // initialize vowels hashset         HashSet<Character> vowels = new HashSet<>();         vowels.add('a');         vowels.add('e');         vowels.add('i');         vowels.add('o');         vowels.add('u');         vowels.add('A');         vowels.add('E');         vowels.add('I');         vowels.add('O');         vowels.add('U');                  // swap vowels from both ends until they meet         while (left < right) {             // check if left and right pointers are vowels             while (left < right && !vowels.contains(sArr[left])) {                 left++;             }             while (left < right && !vowels.contains(sArr[right])) {                 right--;             }                          // swap the vowels from both ends             char temp = sArr[left];             sArr[left] = sArr[right];             sArr[right] = temp;                          // move the pointers towards the center             left++;             right--;         }                  // convert the character array back into a string and return it         return new String(sArr);     } }",1,"345-reverse-vowels-of-a-string/Solution.java:7:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
345-reverse-vowels-of-a-string/Solution.java:43:	StringInstantiation:	Avoid instantiating String objects; this is usually unnecessary.
",1,0,0
"import java.util.*;  class Solution {     public int[] intersection(int[] nums1, int[] nums2) {         Set<Integer> numSet1 = new HashSet<>();         for (int num : nums1) {             numSet1.add(num);         }         Set<Integer> intersection = new HashSet<>();         for (int num : nums2) {             if (numSet1.contains(num)) {                 intersection.add(num);             }         }         int[] result = new int[intersection.size()];         int i = 0;         for (int num : intersection) {             result[i++] = num;         }         return result;     } }",0,,0,0,0
"class Solution {     public int[] intersect(int[] nums1, int[] nums2) {         // create a hashmap to store the frequency of each number in nums1         Map<Integer, Integer> map = new HashMap<>();         for(int num : nums1){             map.put(num, map.getOrDefault(num, 0) + 1);         }                  List<Integer> intersection = new ArrayList<>();         // iterate through all numbers in nums2         for(int num : nums2){             // check if the number is in the map and its frequency is greater than 0             if(map.containsKey(num) && map.get(num) > 0){                 intersection.add(num); // add the number to the intersection list                 map.put(num, map.get(num) - 1); // reduce the frequency in the map             }         }                  // convert the intersection list to an array and return it         int[] result = new int[intersection.size()];         for(int i = 0; i < intersection.size(); i++){             result[i] = intersection.get(i);         }         return result;     } }",0,,0,0,0
"class Solution {     public boolean isPerfectSquare(int num) {         if (num == 1) return true;                  long left = 1, right = num/2;                  while (left <= right) {             long mid = left + (right - left)/2;             long guess = mid * mid;                          if (guess == num) return true;             else if (guess > num) right = mid - 1;             else left = mid + 1;         }                  return false;     } }",1,"367-valid-perfect-square/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public boolean isPerfectSquare(int num) {         if (num == 1) return true;                  long left = 1, right = num/2;                  while (left <= right) {             long mid = left + (right - left)/2;             long guess = mid * mid;                          if (guess == num) return true;             else if (guess > num) right = mid - 1;             else left = mid + 1;         }                  return false;     } }",0,,0,0,0
"class Solution {     public boolean canConstruct(String ransomNote, String magazine) {         int[] letters = new int[26]; // create an array to store frequency count of each letter         for(char c: magazine.toCharArray()){              letters[c - 'a']++; // increment the count of the letter in magazine         }                   for(char c: ransomNote.toCharArray()){             if(letters[c - 'a']-- == 0){ // if letter doesn't exist in magazine or frequency count becomes 0 (letter fully used up), return false                 return false;             }         }         return true;     } }",1,"383-ransom-note/Solution.java:9:	AssignmentInOperand:	Avoid assignments in operands
",0,0,0
"class Solution {     public int firstUniqChar(String s) {         int[] count = new int[26]; // Create an array to store the frequency of each character         // Traverse through the string and update the frequency of each character         for (int i = 0; i < s.length(); i++) {             count[s.charAt(i) - 'a']++;         }         // Traverse through the string again and return the index of the first non-repeating character         for (int i = 0; i < s.length(); i++) {             if (count[s.charAt(i) - 'a'] == 1) {                 return i;             }         }         return -1; // If there is no non-repeating character, return -1     } }",0,,0,0,0
"class Solution {     public char findTheDifference(String s, String t) {         int[] count = new int[26];         for(char c: s.toCharArray()) {             count[c - 'a']++;         }         for(char c: t.toCharArray()) {             if(count[c - 'a'] == 0) {                 return c;             }             count[c - 'a']--;         }         return ' ';     } }",0,,0,0,0
"class Solution {     public boolean isSubsequence(String s, String t) {         int m = s.length();         int n = t.length();         int i=0;         int j=0;         while(i<m && j<n){             // If both character are same, move both pointers             if(s.charAt(i) == t.charAt(j)){                 i++;                 j++;             }             // If character are not same, move only pointer of t             else{                 j++;             }         }         // If all characters of s are checked successfully         // means s is subsequence of t         if(i == m){             return true;         }         // s is not subsequence of t         else{             return false;         }     } }",1,"392-is-subsequence/Solution.java:12:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
392-is-subsequence/Solution.java:20:9: Conditional logic can be removed. [SimplifyBooleanReturn]
392-is-subsequence/Solution.java:22:9: '}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
392-is-subsequence/Solution.java:20:	SimplifyBooleanReturns:	This if statement can be replaced by `return {condition};`
",0,0,0
"import java.util.ArrayList; import java.util.List;  class Solution {          public List<String> readBinaryWatch(int turnedOn) {                  List<String> result = new ArrayList<>();                  for(int hour = 0; hour < 12; hour++) {             for(int minute = 0; minute < 60; minute++) {                                  // count set bits in hour and minute                 if(Integer.bitCount(hour) + Integer.bitCount(minute) == turnedOn) {                                          // add formatted time to result                     result.add(String.format(""%d:%02d"", hour, minute));                 }             }         }                  return result;     }      }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public int sumOfLeftLeaves(TreeNode root) {         if(root == null)             return 0;         int sum = 0;         if(root.left != null && root.left.left == null && root.left.right == null)             sum += root.left.val;         sum += sumOfLeftLeaves(root.left);         sum += sumOfLeftLeaves(root.right);         return sum;     } }",0,,0,0,0
"class Solution {     public String toHex(int num) {         if(num == 0) return ""0""; //special case for 0         StringBuilder sb = new StringBuilder();         while(num != 0){             int digit = num & 15; //use bitmask to get last four digits             char hexDigit;             if(digit < 10){                 hexDigit = (char)('0' + digit); //0-9 representation             }             else{                 hexDigit = (char)('a' + digit - 10); //a-f representation             }             sb.insert(0, hexDigit); //add digit to front of string             num >>>= 4; //shift num four bits         }         return sb.toString();     } }",1,"405-convert-a-number-to-hexadecimal/Solution.java:10:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
405-convert-a-number-to-hexadecimal/Solution.java:15:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'num'
",0,1,0
class Solution {     public int longestPalindrome(String s) {         int[] charCount = new int[128]; // array to store count of characters                  // count the occurrences of each character         for(int i=0; i<s.length(); i++) {             charCount[s.charAt(i)]++;         }                  int palindromeLength = 0;         boolean hasOddCharacter = false;                  // calculate the length of the longest palindrome by adding         // the count of pairs of characters and one odd character         for(int count: charCount) {             if(count % 2 == 0) {                 palindromeLength += count;             } else {                 hasOddCharacter = true;                 palindromeLength += count - 1;             }         }                  // add one odd character to the palindrome length if present         if(hasOddCharacter) {             palindromeLength++;         }                  return palindromeLength;     } },0,,0,0,0
"import java.util.ArrayList; import java.util.List;  class Solution {     public List<String> fizzBuzz(int n) {         List<String> answer = new ArrayList<>();         for (int i = 1; i <= n; i++) {             if (i % 3 == 0 && i % 5 == 0) {                 answer.add(""FizzBuzz"");             } else if (i % 3 == 0) {                 answer.add(""Fizz"");             } else if (i % 5 == 0) {                 answer.add(""Buzz"");             } else {                 answer.add(Integer.toString(i));             }         }         return answer;     } }",0,,0,0,0
class Solution {     public int thirdMax(int[] nums) {         Integer max1 = null;         Integer max2 = null;         Integer max3 = null;                  for(Integer num: nums){             if(num.equals(max1) || num.equals(max2) || num.equals(max3)){                 continue;             }             if(max1 == null || num > max1){                 max3 = max2;                 max2 = max1;                 max1 = num;             }             else if(max2 == null || num > max2){                 max3 = max2;                 max2 = num;             }             else if(max3 == null || num > max3){                 max3 = num;             }         }         return max3 != null ? max3 : max1;     } },1,"414-third-maximum-number/Solution.java:15:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
414-third-maximum-number/Solution.java:19:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
"class Solution {     public String addStrings(String num1, String num2) {         //initialize variables         int carry = 0; //if the sum is greater than 9, set carry to 1         int i = num1.length()-1; //loop through num1 from right to left         int j = num2.length()-1; //loop through num2 from right to left         StringBuilder sb = new StringBuilder(); //to store the result                  //loop through both numbers from right to left, until i and j both are greater than or equal to 0         while(i >= 0 || j >= 0) {             int sum = carry; //initialize sum with previous carry                          if(i >= 0) //if still digits in num1                 sum += num1.charAt(i--) - '0'; //subtract ASCII value of '0' from the corresponding digit in num1 to get its int value                          if(j >= 0) //if still digits in num2                 sum += num2.charAt(j--) - '0'; //subtract ASCII value of '0' from the corresponding digit in num2 to get its int value                          sb.append(sum % 10); //append ones place digit to result             carry = sum / 10; //set carry based on tens place digit         }                  if(carry != 0) sb.append(carry); //if carry is still there, append to result                  return sb.reverse().toString(); //reverse the result and convert to string     } }",0,,0,0,0
class Solution {     public int countSegments(String s) {         if (s == null || s.length() == 0) {             return 0;         }         int count = 0;         boolean inSegment = false;         for (char c : s.toCharArray()) {             if (c != ' ') {                 if (!inSegment) {                     inSegment = true;                 }             } else {                 if (inSegment) {                     count++;                     inSegment = false;                 }             }         }         if (inSegment) {             count++;         }         return count;     } },1,"434-number-of-segments-in-a-string/Solution.java:9:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",0,0,0
class Solution {     public int arrangeCoins(int n) {         int count = 0;         int i = 1;         while(n >= i){             n -= i;             count ++;             i++;         }         return count;     } },1,"441-arranging-coins/Solution.java:6:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
",0,1,0
import java.util.List; import java.util.ArrayList;  class Solution {     public List<Integer> findDisappearedNumbers(int[] nums) {         List<Integer> result = new ArrayList<>();         for (int i = 0; i < nums.length; i++) {             int index = Math.abs(nums[i]) - 1;             if (nums[index] > 0) {                 nums[index] = -nums[index];             }         }         for (int i = 0; i < nums.length; i++) {             if (nums[i] > 0) {                 result.add(i + 1);             }         }         return result;     } },1,"448-find-all-numbers-disappeared-in-an-array/Solution.java:7:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int findContentChildren(int[] g, int[] s) {         Arrays.sort(g);         Arrays.sort(s);         int content = 0;    // counter for content children         int i = 0, j = 0;   // pointers for iterating over arrays                  while (i < g.length && j < s.length) {             if (g[i] <= s[j]) {   // if cookie is large enough for child                 content++;          // increment content children counter                 i++;                // move to next child                 j++;                // move to next cookie             } else {            // if cookie is too small for child                 j++;                // move to next cookie             }         }                  return content;     } }",1,"455-assign-cookies/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public boolean repeatedSubstringPattern(String s) {         int n = s.length();         for (int i = n / 2; i >= 1; i--) {             if (n % i == 0) {                 int repeats = n / i;                 String substr = s.substring(0, i);                 StringBuilder sb = new StringBuilder();                 for (int j = 0; j < repeats; j++) {                     sb.append(substr);                 }                 if (sb.toString().equals(s)) {                     return true;                 }             }         }         return false;     } }",0,,0,0,0
"class Solution {     public int hammingDistance(int x, int y) {         int xor = x ^ y;         int count = 0;         while (xor != 0) {             if (xor % 2 == 1) {                 count++;             }             xor = xor >> 1;         }         return count;     } }",0,,0,0,0
class Solution {     public int islandPerimeter(int[][] grid) {         int perimeter = 0;         for (int i = 0; i < grid.length; i++) {             for (int j = 0; j < grid[0].length; j++) {                 if (grid[i][j] == 1) {                     // check left                     if (j == 0 || grid[i][j-1] == 0) {                         perimeter++;                     }                     // check right                     if (j == grid[0].length-1 || grid[i][j+1] == 0) {                         perimeter++;                     }                     // check top                     if (i == 0 || grid[i-1][j] == 0) {                         perimeter++;                     }                     // check bottom                     if (i == grid.length-1 || grid[i+1][j] == 0) {                         perimeter++;                     }                 }             }         }         return perimeter;     } },0,,0,0,0
class Solution {     public int findComplement(int num) {         int bitCount = Integer.toBinaryString(num).length(); // Counting number of bits in the binary representation of num         int complement = ((1 << bitCount) - 1) ^ num; // Creating a mask of same bit count as num and XORing it with num to get the complement         return complement;     } },1,"476-number-complement/Solution.java:4:	UnnecessaryLocalBeforeReturn:	Consider simply returning the value vs storing it in local variable 'complement'
",0,0,0
"class Solution {     public String licenseKeyFormatting(String s, int k) {         s = s.replaceAll(""-"", """").toUpperCase();         int len = s.length();         StringBuilder sb = new StringBuilder();         for (int i = len - 1; i >= 0; i--) {             sb.append(s.charAt(i));             if ((len - i) % k == 0) {                 sb.append(""-"");             }         }         if (sb.length() > 0 && sb.charAt(sb.length() - 1) == '-') {             sb.deleteCharAt(sb.length() - 1);         }         return sb.reverse().toString();     } }",1,"482-license-key-formatting/Solution.java:3:	AvoidReassigningParameters:	Avoid reassigning parameters such as 's'
482-license-key-formatting/Solution.java:3:	UseLocaleWithCaseConversions:	When doing a String.toLowerCase()/toUpperCase() call, use a Locale
482-license-key-formatting/Solution.java:9:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
",0,1,0
"class Solution {     public int findMaxConsecutiveOnes(int[] nums) {         int maxCount = 0;         int currentCount = 0;         for(int i=0; i<nums.length;i++){             if(nums[i] == 1){                 currentCount++;             } else {                 maxCount = Math.max(maxCount, currentCount);                 currentCount = 0;             }         }         return Math.max(maxCount, currentCount);     } }",1,"485-max-consecutive-ones/Solution.java:5:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int[] constructRectangle(int area) {         int sqrt = (int) Math.sqrt(area);         while (area % sqrt != 0) {             sqrt--;         }         return new int[] {area / sqrt, sqrt};     } }",0,,0,0,0
"class Solution {     public int findPoisonedDuration(int[] timeSeries, int duration) {         if (timeSeries == null || timeSeries.length == 0 || duration == 0) {             return 0;         }         int poisonedDuration = duration;         int previousAttackTime = timeSeries[0];         for (int i = 1; i < timeSeries.length; i++) {             int currentAttackTime = timeSeries[i];             if (previousAttackTime + duration > currentAttackTime) {                 // Current attack happens while Ashe is already poisoned, so only                 // add the time from previous attack until the end of the current                 // poison duration.                 poisonedDuration += duration - (currentAttackTime - previousAttackTime);             } else {                 // Current attack happens after the previous poison effect has ended.                 poisonedDuration += duration;             }             previousAttackTime = currentAttackTime;         }         return poisonedDuration;     } }",0,,0,0,0
"class Solution {     public int[] nextGreaterElement(int[] nums1, int[] nums2) {         //initialize a hashmap to store the next greater element for each element in nums2         Map<Integer, Integer> map = new HashMap<>();         //initialize a stack to keep track of the elements that have not found their next greater element yet         Stack<Integer> stack = new Stack<>();                  //iterate through nums2         for(int num : nums2) {             //while the stack is not empty and the current element is greater than the top element of the stack             //set the top element's next greater element to be the current element and pop it out of the stack             while(!stack.isEmpty() && num > stack.peek()) {                 map.put(stack.pop(), num);             }             //push the current element onto the stack             stack.push(num);         }                  //initialize an array to store the result         int[] res = new int[nums1.length];         //iterate through nums1         for(int i = 0; i < nums1.length; i++) {             //look for the index of the element in nums2             int index = getIndex(nums2, nums1[i]);             //if the index is not found, set the result to be -1             if(index == -1) {                 res[i] = -1;             } else {                 //otherwise look for the element's next greater element in the hashmap                 res[i] = map.getOrDefault(nums2[index], -1);             }         }                  return res;     }          private int getIndex(int[] nums, int target) {         //iterate through nums and look for the index of the target element         for(int i = 0; i < nums.length; i++) {             if(nums[i] == target) {                 return i;             }         }         //if the target element is not found, return -1         return -1;     } }",0,,0,0,0
"class Solution {     public String[] findWords(String[] words) {         String[] keyboard = {""qwertyuiop"", ""asdfghjkl"", ""zxcvbnm""};         List<String> validWords = new ArrayList<>();         for(String word : words) {             int row = -1;             boolean valid = true;             for(char c : word.toLowerCase().toCharArray()) {                 boolean found = false;                 for(int i = 0; i < keyboard.length; i++) {                     if(keyboard[i].indexOf(c) != -1) {                         if(row != -1 && i != row) {                             valid = false;                             break;                         }                         row = i;                         found = true;                         break;                     }                 }                 if(!found) {                     valid = false;                     break;                 }             }             if(valid) {                 validWords.add(word);             }         }         return validWords.toArray(new String[0]);     } }",1,"500-keyboard-row/Solution.java:8:	UseLocaleWithCaseConversions:	When doing a String.toLowerCase()/toUpperCase() call, use a Locale
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     private int maxCount = 0;     private int count = 0;     private int prevVal;     private List<Integer> modes;      public int[] findMode(TreeNode root) {         maxCount = 0;         count = 0;         prevVal = 0;         modes = new ArrayList<>();          traverse(root);          int[] result = new int[modes.size()];         for (int i = 0; i < modes.size(); i++) {             result[i] = modes.get(i);         }         return result;     }      private void traverse(TreeNode node) {         if (node == null) {             return;         }          traverse(node.left);          if (node.val != prevVal) {             count = 1;         } else {             count++;         }          if (count > maxCount) {             maxCount = count;             modes.clear();             modes.add(node.val);         } else if (count == maxCount) {             modes.add(node.val);         }          prevVal = node.val;          traverse(node.right);     } }",1,"501-find-mode-in-binary-search-tree/TreeNode.java:44:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",0,0,0
"class Solution {     public String convertToBase7(int num) {         if(num == 0) return ""0""; // If num is 0, return ""0"" as base 7          StringBuilder sb = new StringBuilder(); // Create an empty StringBuilder          boolean isNegative = false; // Check if the given num is negative or not         if(num < 0) { num = -num; isNegative = true; } // If num is negative, convert it to positive and set isNegative flag to true          while(num > 0) {             sb.append(num % 7); // Append the remainder of num/7 to the StringBuilder             num /= 7; // Divide num by 7         }          if(isNegative) sb.append(""-""); // If num was negative, append ""-"" to the StringBuilder         sb.reverse(); // Reverse the StringBuilder          return sb.toString(); // Return the String as base 7 representation     } }",1,"504-base-7/Solution.java:8:21: '{' at column 21 should have line break after. [LeftCurly]
504-base-7/Solution.java:8:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'num'
504-base-7/Solution.java:15:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
",0,1,0
"class Solution {     public String[] findRelativeRanks(int[] score) {         int n = score.length;         String[] answer = new String[n];                  // Create a map to store the scores and their corresponding indices         Map<Integer, Integer> indexMap = new HashMap<>();         for (int i = 0; i < n; i++) {             indexMap.put(score[i], i);         }                  // Sort the scores in reverse order         Arrays.sort(score);         int rank = 1;         for (int i = n - 1; i >= 0; i--) {             int index = indexMap.get(score[i]);             if (rank == 1) {                 answer[index] = ""Gold Medal"";             } else if (rank == 2) {                 answer[index] = ""Silver Medal"";             } else if (rank == 3) {                 answer[index] = ""Bronze Medal"";             } else {                 answer[index] = String.valueOf(rank);             }             rank++;         }                  return answer;     } }",0,,0,0,0
class Solution {     public boolean checkPerfectNumber(int num) {         if(num == 1) return false;         int sum = 1;         for(int i=2;i<=Math.sqrt(num);i++){             if(num%i == 0){                 sum += i;                 if(i != num/i) sum += num/i;             }         }         return sum == num;     } },0,,0,0,0
class Solution {     public int fib(int n) {         if(n<=1) return n;         int dp[]=new int[n+1];         dp[0]=0; dp[1]=1;         for(int i=2;i<=n;i++){             dp[i]=dp[i-1]+dp[i-2];         }         return dp[n];     } },1,"509-fibonacci-number/Solution.java:4:15: Array brackets at illegal position. [ArrayTypeStyle]
",0,0,0
class Solution {     public boolean detectCapitalUse(String word) {         if(word.length() == 1) {             return true;         }                  boolean isUpperCase = Character.isUpperCase(word.charAt(0)) && Character.isUpperCase(word.charAt(1));         for(int i=2; i<word.length(); i++) {             if(isUpperCase && !Character.isUpperCase(word.charAt(i))) {                 return false;             } else if(!isUpperCase && Character.isUpperCase(word.charAt(i))) {                 return false;             }         }         return true;     } },0,,0,0,0
"class Solution {     public int findLUSlength(String a, String b) {         if(a.equals(b)) return -1;         return Math.max(a.length(), b.length());     } }  ",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public int getMinimumDifference(TreeNode root) {         int minDiff = Integer.MAX_VALUE;         Stack<TreeNode> stack = new Stack<>();         TreeNode curr = root, prev = null;         while(curr != null || !stack.isEmpty()) {             while(curr != null) {                 stack.push(curr);                 curr = curr.left;             }             curr = stack.pop();             if(prev != null) {                 minDiff = Math.min(minDiff, curr.val - prev.val);             }             prev = curr;             curr = curr.right;         }         return minDiff;     } }",1,"530-minimum-absolute-difference-in-bst/TreeNode.java:20:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"public class Solution {     public String reverseStr(String s, int k) {         char[] arr = s.toCharArray();         int n = s.length();         for (int i = 0; i < n; i += 2 * k) {             int start = i;             int end = Math.min(i + k - 1, n - 1);             reverse(arr, start, end);         }         return new String(arr);     }          private void reverse(char[] arr, int start, int end) {         while (start < end) {             char temp = arr[start];             arr[start++] = arr[end];             arr[end--] = temp;         }     } }",1,"541-reverse-string-ii/Solution.java:10:	StringInstantiation:	Avoid instantiating String objects; this is usually unnecessary.
541-reverse-string-ii/Solution.java:16:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'start'
541-reverse-string-ii/Solution.java:17:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'end'
",0,1,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     private int diameter;          public int diameterOfBinaryTree(TreeNode root) {         diameter = 0;         if (root == null) {             return diameter;         }         computeDiameter(root);         return diameter;     }          private int computeDiameter(TreeNode node) {         if (node == null) {             return 0;         }                  int leftHeight = computeDiameter(node.left);         int rightHeight = computeDiameter(node.right);                  diameter = Math.max(diameter, leftHeight + rightHeight);                  return Math.max(leftHeight, rightHeight) + 1;     }     }",0,,0,0,0
class Solution {     public boolean checkRecord(String s) {         int absentCount = 0;         int lateCount = 0;         for (int i = 0; i < s.length(); i++) {             char c = s.charAt(i);             if (c == 'A') {                 absentCount++;                 lateCount = 0; // Reset consecutive late count             } else if (c == 'L') {                 lateCount++;             } else {                 lateCount = 0; // Reset consecutive late count             }             if (absentCount >= 2 || lateCount >= 3) {                 return false;             }         }         return true;     } },0,,0,0,0
"class Solution {     public String reverseWords(String s) {         StringBuilder sb = new StringBuilder();  // to build the answer string         String[] words = s.split("" "");   // split the string into words                  for (String word : words) {             StringBuilder temp = new StringBuilder(word);             sb.append(temp.reverse());   // reverse each word and append to the answer string             sb.append("" "");   // append a space after each word         }                  sb.deleteCharAt(sb.length() - 1);  // remove the extra space at the end         return sb.toString();   // return the answer     } }",1,"557-reverse-words-in-a-string-iii/Solution.java:8:	ConsecutiveAppendsShouldReuse:	StringBuffer (or StringBuilder).append is called consecutively without reusing the target variable.
557-reverse-words-in-a-string-iii/Solution.java:9:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
",0,0,0
"// Definition for a Node. class Node {     public int val;     public List<Node> children;      public Node() {}      public Node(int _val) {         val = _val;     }      public Node(int _val, List<Node> _children) {         val = _val;         children = _children;     } }  class Solution {     public int maxDepth(Node root) {         if(root == null){             return 0;         }         int max = 0;         for(Node node: root.children){             int height = maxDepth(node);             if(height > max){                 max = height;             }         }         return max + 1;     } }",1,"559-maximum-depth-of-n-ary-tree/Node.java:3:16: Variable 'val' must be private and have accessor methods. [VisibilityModifier]
559-maximum-depth-of-n-ary-tree/Node.java:4:23: Variable 'children' must be private and have accessor methods. [VisibilityModifier]
559-maximum-depth-of-n-ary-tree/Node.java:6:5: Redundant 'public' modifier. [RedundantModifier]
559-maximum-depth-of-n-ary-tree/Node.java:8:5: Redundant 'public' modifier. [RedundantModifier]
559-maximum-depth-of-n-ary-tree/Node.java:12:5: Redundant 'public' modifier. [RedundantModifier]
559-maximum-depth-of-n-ary-tree/Node.java:6:	UncommentedEmptyConstructor:	Document empty constructor
",0,0,0
"class Solution {     public int arrayPairSum(int[] nums) {         Arrays.sort(nums); // Sort the array first         int sum = 0;         for (int i = 0; i < nums.length; i += 2) {             sum += Math.min(nums[i], nums[i+1]); // Add the minimum of each pair to the sum         }         return sum; // Return the maximum possible sum     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     int tiltSum = 0;      public int findTilt(TreeNode root) {         findSum(root);         return tiltSum;     }      public int findSum(TreeNode root) {         if (root == null) {             return 0;         }          int leftSum = findSum(root.left);         int rightSum = findSum(root.right);         int tilt = Math.abs(leftSum - rightSum);         tiltSum += tilt;          return leftSum + rightSum + root.val;     } }",1,"563-binary-tree-tilt/TreeNode.java:17:9: Variable 'tiltSum' must be private and have accessor methods. [VisibilityModifier]
",0,0,0
"class Solution {     public int[][] matrixReshape(int[][] mat, int r, int c) {         int m = mat.length;         int n = mat[0].length;                  if(m*n != r*c) { //reshape operation is not possible             return mat;          }                  //create a new matrix with r rows and c columns         int[][] reshapedMat = new int[r][c];                  //fill the elements of the reshaped matrix in row-traversing order         for(int i=0; i<m*n; i++) {             reshapedMat[i/c][i%c] = mat[i/n][i%n];         }                  return reshapedMat;     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public boolean isSubtree(TreeNode root, TreeNode subRoot) {         if(root == null) {    // base case             return false;         }         if(isSameTree(root, subRoot)) {     // if both trees are same, then return true             return true;         }         // recursively search the left and right subtree of the root node         return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);     }          // function to check if two trees are same or not     public boolean isSameTree(TreeNode root1, TreeNode root2) {         if(root1 == null && root2 == null) {              return true;         }         if(root1 == null || root2 == null) {              return false;         }         if(root1.val != root2.val) {             return false;         }         return isSameTree(root1.left, root2.left) && isSameTree(root1.right, root2.right);     } }",0,,0,0,0
class Solution {     public int distributeCandies(int[] candyType) {         HashSet<Integer> set = new HashSet<>();         int n = candyType.length;         for(int i = 0; i < n; i++){             set.add(candyType[i]);         }                  int size = set.size();         int ans = n / 2;         if(ans <= size){             return ans;         }                  return size;     } },0,,0,0,0
"/* // Definition for a Node. class Node {     public int val;     public List<Node> children;      public Node() {}      public Node(int _val) {         val = _val;     }      public Node(int _val, List<Node> _children) {         val = _val;         children = _children;     } }; */  class Solution {     public List<Integer> preorder(Node root) {         List<Integer> res = new ArrayList<>();         if(root == null) return res;                  Stack<Node> stack = new Stack<>();         stack.push(root);                  while(!stack.isEmpty()){             Node currNode = stack.pop();             res.add(currNode.val);                          for(int i = currNode.children.size() - 1; i >= 0; i--){                 stack.push(currNode.children.get(i));             }         }                  return res;     } }",0,,0,0,0
"import java.util.*;  // Definition for a Node. class Node {     public int val;     public List<Node> children;      public Node() {}      public Node(int _val) {         val = _val;     }      public Node(int _val, List<Node> _children) {         val = _val;         children = _children;     } };  class Solution {     public List<Integer> postorder(Node root) {         List<Integer> result = new ArrayList<Integer>();         if (root == null) {             return result;         }          // Traverse each child recursively         for (Node child : root.children) {             result.addAll(postorder(child));         }          // Add the root node value         result.add(root.val);         return result;     } } ",1,"590-n-ary-tree-postorder-traversal/Node.java:5:16: Variable 'val' must be private and have accessor methods. [VisibilityModifier]
590-n-ary-tree-postorder-traversal/Node.java:6:23: Variable 'children' must be private and have accessor methods. [VisibilityModifier]
590-n-ary-tree-postorder-traversal/Node.java:8:5: Redundant 'public' modifier. [RedundantModifier]
590-n-ary-tree-postorder-traversal/Node.java:10:5: Redundant 'public' modifier. [RedundantModifier]
590-n-ary-tree-postorder-traversal/Node.java:14:5: Redundant 'public' modifier. [RedundantModifier]
590-n-ary-tree-postorder-traversal/Node.java:8:	UncommentedEmptyConstructor:	Document empty constructor
590-n-ary-tree-postorder-traversal/Node.java:18:	UnnecessarySemicolon:	Unnecessary semicolon
590-n-ary-tree-postorder-traversal/Node.java:22:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new ArrayList<>()`
",0,0,0
"class Solution {     public int findLHS(int[] nums) {         HashMap<Integer, Integer> map = new HashMap<>();         int maxLen = 0;         for(int num : nums) {             map.put(num, map.getOrDefault(num, 0) + 1); // Store frequency of numbers in the hashmap         }         for(int key : map.keySet()) {             if(map.containsKey(key + 1)) { // If the key exists with a difference of 1                 maxLen = Math.max(maxLen, map.get(key) + map.get(key + 1)); // Get sum of frequency of keys and update maxLen             }         }         return maxLen;     } }",0,,0,0,0
"class Solution {     public int maxCount(int m, int n, int[][] ops) {         if (ops.length == 0) {             return m * n;         }         int minX = Integer.MAX_VALUE;         int minY = Integer.MAX_VALUE;         for (int[] op : ops) {             minX = Math.min(minX, op[0]);             minY = Math.min(minY, op[1]);         }         return minX * minY;     } }",0,,0,0,0
"class Solution {     public String[] findRestaurant(String[] list1, String[] list2) {         // Create a HashMap to store the strings from list1 as keys and their indexes as values         Map<String, Integer> map = new HashMap<>();         for (int i = 0; i < list1.length; i++) {             map.put(list1[i], i);         }                  // Initialize minimum index sum and a list to store common strings with least index sum         int minIndexSum = Integer.MAX_VALUE;         List<String> resultList = new ArrayList<>();                  // Iterate through list2, checking if the string is in list1 and its index sum is less than the current minimum         for (int j = 0; j < list2.length; j++) {             if (map.containsKey(list2[j])) {                 int indexSum = j + map.get(list2[j]);                 if (indexSum < minIndexSum) {                     // If a new minimum index sum is encountered, clear the list and add the current string                     minIndexSum = indexSum;                     resultList.clear();                     resultList.add(list2[j]);                 } else if (indexSum == minIndexSum) {                     // If the current string has the same index sum as the current minimum, add it to the list                     resultList.add(list2[j]);                 }             }         }                  // Convert the list to an array and return         return resultList.toArray(new String[resultList.size()]);     } }",0,,0,0,0
"class Solution {   public boolean canPlaceFlowers(int[] flowerbed, int n) {     int count = 0;     for (int i = 0; i < flowerbed.length && count < n; i++) {       if (flowerbed[i] == 0) {         int next = (i == flowerbed.length - 1) ? 0 : flowerbed[i + 1];         int prev = (i == 0) ? 0 : flowerbed[i - 1];         if (next == 0 && prev == 0) {           flowerbed[i] = 1;           count++;         }       }     }     return count == n;   } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public String tree2str(TreeNode root) {         if(root == null) {             return """";         }                   if(root.left == null && root.right == null) {             return root.val + """";         }                  if(root.right == null) {             return root.val + ""("" + tree2str(root.left) + "")"";         }                  return root.val + ""("" + tree2str(root.left) + "")("" + tree2str(root.right) + "")"";     } }",1,"606-construct-string-from-binary-tree/TreeNode.java:23:	AddEmptyString:	Do not add empty strings
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {         // If either tree is null, return the other tree         if (root1 == null) return root2;         if (root2 == null) return root1;                  // Merge the root nodes by adding their values         TreeNode newNode = new TreeNode(root1.val + root2.val);                  // Recursively merge the left subtrees         newNode.left = mergeTrees(root1.left, root2.left);                  // Recursively merge the right subtrees         newNode.right = mergeTrees(root1.right, root2.right);                  // Return the merged tree         return newNode;     } }",0,,0,0,0
"class Solution {     public int maximumProduct(int[] nums) {         if (nums == null || nums.length < 3) {             return 0;         }                  Arrays.sort(nums);         int n = nums.length;         int lastTwoProduct = nums[n-1] * nums[n-2];         int maxProduct = lastTwoProduct * nums[n-3];         if (nums[0] < 0 && nums[1] < 0) {             int firstTwoProduct = nums[0] * nums[1];             maxProduct = Math.max(maxProduct, firstTwoProduct * nums[n-1]);         }         return maxProduct;     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public List<Double> averageOfLevels(TreeNode root) {         List<Double> result = new ArrayList<>();         if (root == null) {             return result;         }         Queue<TreeNode> queue = new LinkedList<>();         queue.offer(root);         while (!queue.isEmpty()) {             int levelSize = queue.size();             double levelSum = 0;             for (int i = 0; i < levelSize; i++) {                 TreeNode node = queue.poll();                 levelSum += node.val;                 if (node.left != null) {                     queue.offer(node.left);                 }                 if (node.right != null) {                     queue.offer(node.right);                 }             }             double levelAvg = levelSum / levelSize;             result.add(levelAvg);         }         return result;     } }",0,,0,0,0
"class Solution {     public double findMaxAverage(int[] nums, int k) {         double maxAvg = 0;         double currentAvg = 0;                  for (int i = 0; i < k; i++) {             currentAvg += nums[i];         }                  maxAvg = currentAvg/k;                  for (int i = k; i < nums.length; i++) {             currentAvg += nums[i] - nums[i-k];             maxAvg = Math.max(maxAvg, currentAvg/k);         }                  return maxAvg;     } }  /* Explanation:  We first calculate the average of first k elements. Then we run a loop from k to n elements, and calculate the average of that k-element subarray by subtracting first element and adding last element. During every loop we save the maximum average value. Finally return the maximum average value. */",1,"643-maximum-average-subarray-i/Solution.java:3:	UnusedAssignment:	The initializer for variable 'maxAvg' is never used (overwritten on line 10)
",0,0,0
class Solution {     public int[] findErrorNums(int[] nums) {         int n = nums.length;         int[] freq = new int[n+1];         int[] result = new int[2];         for (int i = 0; i < n; i++) {             freq[nums[i]]++;             if (freq[nums[i]] == 2) {                 result[0] = nums[i];             }         }         for (int i = 1; i <= n; i++) {             if (freq[i] == 0) {                 result[1] = i;                 break;             }         }         return result;     } },0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public boolean findTarget(TreeNode root, int k) {         Set<Integer> set = new HashSet<>();         Queue<TreeNode> queue = new LinkedList<>();         queue.add(root);         while(!queue.isEmpty()){             TreeNode node = queue.poll();             if(set.contains(k - node.val)){                 return true;             }             set.add(node.val);             if(node.left != null){                 queue.add(node.left);             }             if(node.right != null){                 queue.add(node.right);             }         }         return false;     } }",0,,0,0,0
class Solution {     public boolean judgeCircle(String moves) {         int x = 0;         int y = 0;         for(char c : moves.toCharArray()){             if(c == 'R') x++;             else if(c == 'L') x--;             else if(c == 'U') y++;             else if(c == 'D') y--;         }         return x == 0 && y == 0;     } },0,,0,0,0
"class Solution {     public int[][] imageSmoother(int[][] img) {         int m = img.length, n = img[0].length;         int[][] ans = new int[m][n];         int[][] directions = {{-1,-1}, {-1,0}, {-1,1}, {0,-1}, {0,0}, {0,1}, {1,-1}, {1,0}, {1,1}}; // all 9 directions                  for (int i=0; i<m; i++) {             for (int j=0; j<n; j++) {                 int sum = 0, count = 0;                 for (int[] dir : directions) {                     int r = i + dir[0];                     int c = j + dir[1];                     if (r >= 0 && r < m && c >= 0 && c < n) { // checking if it is within the bounds                         sum += img[r][c];                         count++;                     }                 }                 ans[i][j] = (int) Math.floor(sum / count);             }         }         return ans;     } }",1,"661-image-smoother/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
661-image-smoother/Solution.java:9:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     private int min = Integer.MAX_VALUE; // to store the minimum value     private int secondMin = Integer.MAX_VALUE; // to store the second minimum value          public int findSecondMinimumValue(TreeNode root) {         // if there is no node or only one node in the tree then second minimum value doesn't exist         if(root == null || (root.left == null && root.right == null)) return -1;                  findMin(root); // find the minimum value         findSecondMin(root); // find the second minimum value                  return secondMin == Integer.MAX_VALUE ? -1 : secondMin; // return -1 if second minimum doesn't exist     }          // recursive function to find the minimum value in the tree     private void findMin(TreeNode root) {         if(root == null) return;                  min = Math.min(min, root.val); // update the minimum value with the root value                  findMin(root.left);         findMin(root.right);     }          // recursive function to find the second minimum value in the tree     private void findSecondMin(TreeNode root) {         if(root == null) return;                  // if root is greater than min and less than or equal to secondMin then update secondMin with root value         if(root.val > min && root.val <= secondMin) {             if(root.val != min) {                  secondMin = root.val;             } else {                 findSecondMin(root.left);                 findSecondMin(root.right);             }         }     } }",1,"671-second-minimum-node-in-a-binary-tree/TreeNode.java:46:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",0,0,0
"class Solution {     public int findLengthOfLCIS(int[] nums) {         int maxLength = 0;         int curLength = 1;  // Tracks the length of the current increasing subsequence                  for (int i = 1; i < nums.length; i++) {             if (nums[i] > nums[i - 1]) {  // If the current element is greater than the previous one, the subsequence is still increasing                 curLength++;             } else {  // Otherwise, the increasing subsequence has ended                 maxLength = Math.max(maxLength, curLength);  // Update the maximum length if necessary                 curLength = 1;  // Reset the current length for the next subsequence             }         }                  return Math.max(maxLength, curLength);  // Check the final subsequence in case it is the longest     } }",0,,0,0,0
"class Solution {     public boolean validPalindrome(String s) {         int left = 0, right = s.length()-1;         while(left < right) {             if(s.charAt(left) != s.charAt(right)) {                 return isPalindrome(s, left+1, right) || isPalindrome(s, left, right-1);             }             left++;             right--;         }         return true;     }          private boolean isPalindrome(String s, int left, int right) {         while(left < right) {             if(s.charAt(left) != s.charAt(right)) {                 return false;             }             left++;             right--;         }         return true;     } }",1,"680-valid-palindrome-ii/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
680-valid-palindrome-ii/Solution.java:19:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'left'
680-valid-palindrome-ii/Solution.java:20:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'right'
",1,1,0
"class Solution {     public int calPoints(String[] operations) {         Stack<Integer> stack = new Stack<>();         int sum = 0;         for (String op : operations) {             if (op.equals(""C"")) {                 sum -= stack.pop();             } else if (op.equals(""D"")) {                 int val = stack.peek() * 2;                 sum += val;                 stack.push(val);             } else if (op.equals(""+"")) {                 int val1 = stack.pop();                 int val2 = stack.peek();                 stack.push(val1);                 int val = val1 + val2;                 sum += val;                 stack.push(val);             } else {                 int val = Integer.parseInt(op);                 sum += val;                 stack.push(val);             }         }         return sum;     } }",1,"682-baseball-game/Solution.java:6:	LiteralsFirstInComparisons:	Position literals first in String comparisons
682-baseball-game/Solution.java:8:	LiteralsFirstInComparisons:	Position literals first in String comparisons
682-baseball-game/Solution.java:12:	LiteralsFirstInComparisons:	Position literals first in String comparisons
",0,0,0
"class Solution {     public boolean hasAlternatingBits(int n) {         int previousBit = n & 1; // Get the rightmost bit         n >>= 1; // Right shift the number by 1 to get the next bit         while (n > 0) {             int currentBit = n & 1; // Get the next bit             if (currentBit == previousBit) {                 return false; // If two adjacent bits are same, it is not alternating             }             previousBit = currentBit; // Update the previous bit to current bit             n >>= 1; // Right shift the number by 1 to get the next bit         }         return true; // If all adjacent bits are alternating, return true     } }",1,"693-binary-number-with-alternating-bits/Solution.java:4:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
",0,1,0
class Solution {     public int countBinarySubstrings(String s) {         int currGroupLen = 1;         int prevGroupLen = 0;         int count = 0;          for(int i=1; i<s.length(); i++) {             if(s.charAt(i) == s.charAt(i-1)) {                 currGroupLen++;             } else {                 prevGroupLen = currGroupLen;                 currGroupLen = 1;             }             if(prevGroupLen >= currGroupLen) {                 count++;             }         }         return count;     } },0,,0,0,0
"class Solution {     public int findShortestSubArray(int[] nums) {         Map<Integer, Integer> freqMap = new HashMap<>();         Map<Integer, Integer> firstSeen = new HashMap<>();         int degree = 0;         int minLength = Integer.MAX_VALUE;                  for (int i = 0; i < nums.length; i++) {             int num = nums[i];             freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);             firstSeen.putIfAbsent(num, i);             if (freqMap.get(num) > degree) {                 degree = freqMap.get(num);                 minLength = i - firstSeen.get(num) + 1;             } else if (freqMap.get(num) == degree) {                 minLength = Math.min(minLength, i - firstSeen.get(num) + 1);             }         }                  return minLength;     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public TreeNode searchBST(TreeNode root, int val) {         if(root == null || root.val == val) { // base case             return root;         }         if(val < root.val) { // search in left subtree             return searchBST(root.left, val);         } else { // search in right subtree             return searchBST(root.right, val);         }     } }",0,,0,0,0
"import java.util.PriorityQueue;  class KthLargest {          private PriorityQueue<Integer> pq;     private int k;      public KthLargest(int k, int[] nums) {         this.k = k;         pq = new PriorityQueue<>(k);         for (int num : nums) {             add(num);         }     }          public int add(int val) {         if (pq.size() < k) {             pq.offer(val);         } else if (val > pq.peek()) {             pq.poll();             pq.offer(val);         }         return pq.peek();     } }  /**  * Your KthLargest object will be instantiated and called as such:  * KthLargest obj = new KthLargest(k, nums);  * int param_1 = obj.add(val);  */",1,"703-kth-largest-element-in-a-stream/KthLargest.java:8:5: Redundant 'public' modifier. [RedundantModifier]
703-kth-largest-element-in-a-stream/KthLargest.java:8:27: 'k' hides a field. [HiddenField]
703-kth-largest-element-in-a-stream/KthLargest.java:5:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
703-kth-largest-element-in-a-stream/KthLargest.java:12:	ConstructorCallsOverridableMethod:	Overridable method called during object construction: KthLargest.add(int)
",0,0,0
"class Solution {     public int search(int[] nums, int target) {         int left = 0;         int right = nums.length - 1;                  while(left <= right){             int mid = left + (right - left) / 2; //calculate middle index                          if(nums[mid] == target){ //if middle element is target return index                 return mid;             }             else if(nums[mid] < target){ //if middle element is smaller than target then search right half                 left = mid + 1;             }             else{ //else search left half                 right = mid - 1;             }         }                  return -1; //target is not in the array     } }",1,"704-binary-search/Solution.java:11:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
704-binary-search/Solution.java:14:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
class Node {     int val;     Node next;          public Node(int val) {         this.val = val;     } }  class MyHashSet {     Node[] table;     int size;          public MyHashSet() {         table = new Node[10000];         size = 0;     }          public void add(int key) {         if (!contains(key)) {             int index = key % table.length;             Node node = new Node(key);             node.next = table[index];             table[index] = node;             size++;             if (size == table.length) {                 doubleSize();             }         }     }          public void remove(int key) {         int index = key % table.length;         Node prev = null;         Node current = table[index];         while (current != null) {             if (current.val == key) {                 if (prev == null) {                     table[index] = current.next;                 } else {                     prev.next = current.next;                 }                 size--;                 return;             }             prev = current;             current = current.next;         }     }          public boolean contains(int key) {         int index = key % table.length;         Node current = table[index];         while (current != null) {             if (current.val == key) {                 return true;             }             current = current.next;         }         return false;     }          private void doubleSize() {         Node[] oldTable = table;         table = new Node[2 * oldTable.length];         size = 0;         for (Node node : oldTable) {             while (node != null) {                 add(node.val);                 node = node.next;             }         }     } } ,1,"705-design-hashset/Node.java:2:9: Variable 'val' must be private and have accessor methods. [VisibilityModifier]
705-design-hashset/Node.java:3:10: Variable 'next' must be private and have accessor methods. [VisibilityModifier]
705-design-hashset/Node.java:5:5: Redundant 'public' modifier. [RedundantModifier]
705-design-hashset/Node.java:5:21: 'val' hides a field. [HiddenField]
705-design-hashset/Node.java:11:12: Variable 'table' must be private and have accessor methods. [VisibilityModifier]
705-design-hashset/Node.java:12:9: Variable 'size' must be private and have accessor methods. [VisibilityModifier]
705-design-hashset/Node.java:14:5: Redundant 'public' modifier. [RedundantModifier]
",0,0,0
"class MyHashMap {     private final int SIZE = 10000; // size of the underlying array     private Node[] table; // the underlying array      public MyHashMap() { // constructor         this.table = new Node[SIZE]; // instantiate the array     }          public void put(int key, int value) {         int hash = getHash(key); // get the hash value         Node current = table[hash]; // get the current node          if (current == null) { // if the current node is null             table[hash] = new Node(key, value); // create a new node         } else {             while (true) { // loop until the key is found or a null node is reached                 if (current.key == key) { // if the key exists                     current.value = value; // update the value                     return;                 }                          if (current.next == null) // if the next node is null                     break; // exit the loop                  current = current.next; // move to the next node             }                          current.next = new Node(key, value); // create a new node         }     }          public int get(int key) {         int hash = getHash(key); // get the hash value         Node current = table[hash]; // get the current node                  while (current != null) { // loop until a null node is reached             if (current.key == key) // if the key exists                 return current.value; // return the corresponding value                          current = current.next; // move to the next node         }                  return -1; // if the key does not exist     }          public void remove(int key) {         int hash = getHash(key); // get the hash value         Node current = table[hash]; // get the current node                  if (current == null) // if the current node is null             return;                  if (current.key == key) { // if the key exists in the first node             table[hash] = current.next; // remove the first node             return;         }                  while (current.next != null) { // loop until the key is found or a null node is reached             if (current.next.key == key) { // if the key exists in the next node                 current.next = current.next.next; // remove the next node                 return;             }                          current = current.next; // move to the next node         }        }          private int getHash(int key) { // hash function         return key % SIZE;     }          private class Node { // inner class for linked list nodes         int key;         int value;         Node next;          public Node(int key, int value) { // constructor             this.key = key;             this.value = value;         }     } }",1,"706-design-hashmap/MyHashMap.java:5:5: Redundant 'public' modifier. [RedundantModifier]
706-design-hashmap/MyHashMap.java:73:13: Variable 'key' must be private and have accessor methods. [VisibilityModifier]
706-design-hashmap/MyHashMap.java:74:13: Variable 'value' must be private and have accessor methods. [VisibilityModifier]
706-design-hashmap/MyHashMap.java:75:14: Variable 'next' must be private and have accessor methods. [VisibilityModifier]
706-design-hashmap/MyHashMap.java:77:9: Redundant 'public' modifier. [RedundantModifier]
706-design-hashmap/MyHashMap.java:77:25: 'key' hides a field. [HiddenField]
706-design-hashmap/MyHashMap.java:77:34: 'value' hides a field. [HiddenField]
706-design-hashmap/MyHashMap.java:2:	FinalFieldCouldBeStatic:	This final field could be made static
",0,0,0
"class Solution {     public String toLowerCase(String s) {         char[] chars = s.toCharArray(); // convert string to char array         for (int i = 0; i < chars.length; i++) { // loop through the char array             if (Character.isUpperCase(chars[i])) { // check if character is uppercase                 chars[i] = Character.toLowerCase(chars[i]); // convert character to lowercase             }         }         return String.valueOf(chars); // convert char array back to string and return     } }  // Test the above code public class Main {     public static void main(String[] args) {         Solution solution = new Solution();         String s1 = ""Hello"";         String s2 = ""here"";         String s3 = ""LOVELY"";         System.out.println(solution.toLowerCase(s1)); // Output: ""hello""         System.out.println(solution.toLowerCase(s2)); // Output: ""here""         System.out.println(solution.toLowerCase(s3)); // Output: ""lovely""     } }",1,"709-to-lower-case/Main.java:14:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
709-to-lower-case/Main.java:14:	UseUtilityClass:	This utility class has a non-private constructor
",0,0,0
"class Solution {     public boolean isOneBitCharacter(int[] bits) {         int i = 0;         while (i < bits.length - 1) { // Iterate until only one bit is left             if (bits[i] == 1) { // If the current bit is 1, it must be followed by a two-bit character                 i += 2;             } else { // If the current bit is 0, it can only be a one-bit character                 i += 1;             }         }         return i == bits.length - 1; // If the index of the last bit is reached, then it is a one-bit character     } }",0,,0,0,0
class Solution {     public int pivotIndex(int[] nums) {         int sum = 0;         int leftSum = 0;         for (int num : nums) {             sum += num;         }         for (int i = 0; i < nums.length; i++) {             if (leftSum == sum - leftSum - nums[i]) {                 return i;             }             leftSum += nums[i];         }         return -1;     } },0,,0,0,0
"class Solution {     public List<Integer> selfDividingNumbers(int left, int right) {         List<Integer> result = new ArrayList<>();                  for(int i = left; i <= right; i++){             if(isSelfDividing(i)){                 result.add(i);             }         }                  return result;     }          public boolean isSelfDividing(int num){         int temp = num;         while(temp > 0){             int digit = temp % 10;             temp /= 10;             if(digit == 0 || num % digit != 0){                 return false;             }         }         return true;     } }",0,,0,0,0
"class Solution {     public int[][] floodFill(int[][] image, int sr, int sc, int color) {         int currColor = image[sr][sc];         if (currColor == color) {             return image;         }         dfs(image, sr, sc, currColor, color);         return image;     }          private void dfs(int[][] image, int row, int col, int currColor, int newColor) {         if (row < 0 || col < 0 || row >= image.length || col >= image[0].length              || image[row][col] != currColor) {             return;         }         image[row][col] = newColor;         dfs(image, row-1, col, currColor, newColor);         dfs(image, row+1, col, currColor, newColor);         dfs(image, row, col-1, currColor, newColor);         dfs(image, row, col+1, currColor, newColor);     } }",0,,0,0,0
"class Solution {     public static char nextGreatestLetter(char[] letters, char target) {         int start = 0, end = letters.length - 1;         while(start <= end) {             int mid = start + (end - start) / 2;             if(target >= letters[mid])                 start = mid + 1;             else                 end = mid - 1;         }         return start < letters.length ? letters[start] : letters[0];     } }",1,"744-find-smallest-letter-greater-than-target/Solution.java:1:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
744-find-smallest-letter-greater-than-target/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
744-find-smallest-letter-greater-than-target/Solution.java:1:	UseUtilityClass:	This utility class has a non-private constructor
",1,0,0
"class Solution {     public int minCostClimbingStairs(int[] cost) {         int n = cost.length;         int[] dp = new int[n];         dp[0] = cost[0];         dp[1] = cost[1];         for (int i = 2; i < n; i++) {             dp[i] = cost[i] + Math.min(dp[i - 1], dp[i - 2]);         }         return Math.min(dp[n - 1], dp[n - 2]);     } }",0,,0,0,0
class Solution {     public int dominantIndex(int[] nums) {         int maxIndex = 0;         for(int i = 1; i < nums.length; i++) {             if(nums[i] > nums[maxIndex]) {                 maxIndex = i;             }         }         for(int i = 0; i < nums.length; i++) {             if(i != maxIndex && nums[maxIndex] < nums[i] * 2) {                 return -1;             }         }         return maxIndex;     } },0,,0,0,0
"class Solution {     public String shortestCompletingWord(String licensePlate, String[] words) {         // Count the frequency of each character in the license plate         int[] charCount = new int[26];         for (char c : licensePlate.toCharArray()) {             if (Character.isLetter(c)) {                 // Ignore case by converting to lowercase                 charCount[Character.toLowerCase(c) - 'a']++;             }         }                  String shortestWord = """";         for (String word : words) {             // Check if the word contains all the characters in the license plate             int[] wordCount = new int[26];             boolean isValid = true;             for (char c : word.toCharArray()) {                 wordCount[Character.toLowerCase(c) - 'a']++;             }             for (int i = 0; i < 26; i++) {                 if (charCount[i] != 0 && wordCount[i] < charCount[i]) {                     isValid = false;                     break;                 }             }             // Check if this is the shortest valid word so far             if (isValid && (shortestWord.equals("""") || word.length() < shortestWord.length())) {                 shortestWord = word;             }         }         return shortestWord;     } }",1,"748-shortest-completing-word/Solution.java:27:	LiteralsFirstInComparisons:	Position literals first in String comparisons
",0,0,0
"class Solution {     public int countPrimeSetBits(int left, int right) {         int count = 0;         for (int i = left; i <= right; i++) {             int numBits = getNumBits(i);             if (isPrime(numBits)) {                 count++;             }         }         return count;     }          private int getNumBits(int num) {         int count = 0;         while (num > 0) {             if (num % 2 == 1) {                 count++;             }             num /= 2;         }         return count;     }          private boolean isPrime(int num) {         if (num < 2) {             return false;         }         for (int i = 2; i <= Math.sqrt(num); i++) {             if (num % i == 0) {                 return false;             }         }         return true;     } }",1,"762-prime-number-of-set-bits-in-binary-representation/Solution.java:19:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'num'
",0,1,0
"class Solution {     public boolean isToeplitzMatrix(int[][] matrix) {         int rows = matrix.length;         int cols = matrix[0].length;         // check diagonals starting from the first row         for (int i = 0; i < cols; i++) {             if(!checkDiagonal(matrix, rows, cols, 0, i)) {                 return false;             }         }         // check diagonals starting from the first column         for (int i = 1; i < rows; i++) {             if(!checkDiagonal(matrix, rows, cols, i, 0)) {                 return false;             }         }         return true;     }          private boolean checkDiagonal(int[][] matrix, int rows, int cols, int i, int j) {         int val = matrix[i][j];         while (i < rows && j < cols) {             if (matrix[i][j] != val) {                 return false;             }             i++;             j++;         }         return true;     } }",1,"766-toeplitz-matrix/Solution.java:26:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'i'
766-toeplitz-matrix/Solution.java:27:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'j'
",0,1,0
"class Solution {     public int numJewelsInStones(String jewels, String stones) {         int count = 0;                  for (char c : stones.toCharArray()) {             if (jewels.indexOf(c) != -1) {                 count++;             }         }                  return count;     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     //initialize a global variable with a large value     //This variable will keep track of the minimum difference between nodes     private int minDiff = Integer.MAX_VALUE;     //keep track of the previously visited node     private TreeNode prev = null;          public int minDiffInBST(TreeNode root) {         //call the inorder traversal method         inorder(root);         //return the minimum difference         return minDiff;     }          private void inorder(TreeNode node) {         if (node == null) {             return;         }                  //process the left subtree         inorder(node.left);                  if (prev != null) {             //calculate the difference between the current node and the previous node             minDiff = Math.min(minDiff, node.val - prev.val);         }         //update the previous node to be the current node         prev = node;                  //process the right subtree         inorder(node.right);     } }",0,,0,0,0
"class Solution {     public boolean rotateString(String s, String goal) {         if (s.length() != goal.length()) { // length mismatch             return false;         }         if (s.equals(goal)) { // already equal             return true;         }         // check if goal is a rotation of s         for (int i = 0; i < s.length(); i++) {             String rotated = s.substring(i) + s.substring(0, i); // shift s by i positions             if (rotated.equals(goal)) {                 return true;             }         }         return false; // no rotation matches goal     } }",0,,0,0,0
"class Solution {     public int uniqueMorseRepresentations(String[] words) {                  String[] morseCode = new String[]{"".-"",""-..."",""-.-."",""-.."",""."",""..-."",""--."",                                            ""...."","".."","".---"",""-.-"","".-.."",""--"",""-."",                                            ""---"","".--."",""--.-"","".-."",""..."",""-"",""..-"",                                            ""...-"","".--"",""-..-"",""-.--"",""--..""};                  Set<String> transformations = new HashSet<>();                  for(String word : words){             StringBuilder sb = new StringBuilder();             for(char c : word.toCharArray()){                 sb.append(morseCode[c - 'a']);             }             transformations.add(sb.toString());         }                  return transformations.size();     } }",0,,0,0,0
"class Solution {     public int[] numberOfLines(int[] widths, String s) {         int lines = 1;         int pixels = 0;         for (char c : s.toCharArray()) {             int width = widths[c - 'a'];             if (pixels + width > 100) {                 lines++;                 pixels = width;             } else {                 pixels += width;             }         }         return new int[] {lines, pixels};     } }",0,,0,0,0
"public class Solution {     public double largestTriangleArea(int[][] points) {         double maxArea = 0;         for(int i = 0; i < points.length; i++) {             for(int j = i + 1; j < points.length; j++) {                 for(int k = j + 1; k < points.length; k++) {                     double area = calculateArea(points[i], points[j], points[k]);                     maxArea = Math.max(maxArea, area);                 }             }         }         return maxArea;     }          private double calculateArea(int[] pointA, int[] pointB, int[] pointC) {         double area = Math.abs(pointA[0] * (pointB[1] - pointC[1]) +                                 pointB[0] * (pointC[1] - pointA[1]) +                                 pointC[0] * (pointA[1] - pointB[1])) / 2.0;         return area;     } }",1,"812-largest-triangle-area/Solution.java:16:	UnnecessaryLocalBeforeReturn:	Consider simply returning the value vs storing it in local variable 'area'
",0,0,0
"class Solution {     public String mostCommonWord(String paragraph, String[] banned) {         Map<String, Integer> count = new HashMap<>();         Set<String> bannedWords = new HashSet<>(Arrays.asList(banned));         for (String word : paragraph.replaceAll(""[^a-zA-Z ]"", """").toLowerCase().split(""\\s+"")) {             if (!bannedWords.contains(word)) {                 count.put(word, count.getOrDefault(word, 0) + 1);             }         }         return Collections.max(count.entrySet(), Map.Entry.comparingByValue()).getKey();     } }   // The regular expression ""[^a-zA-Z ]"" is used to remove all non-alphabetic characters except spaces from the paragraph.",1,"819-most-common-word/Solution.java:5:	UseLocaleWithCaseConversions:	When doing a String.toLowerCase()/toUpperCase() call, use a Locale
",0,0,0
"class Solution {     public int[] shortestToChar(String s, char c) {         int n = s.length();         int[] result = new int[n];         int prev = Integer.MIN_VALUE / 2;          // Find distance from left to right         for (int i = 0; i < n; i++) {             if (s.charAt(i) == c) {                 prev = i;             }             result[i] = i - prev;         }          prev = Integer.MAX_VALUE / 2;          // Find distance from right to left         for (int i = n - 1; i >= 0; i--) {             if (s.charAt(i) == c) {                 prev = i;             }             result[i] = Math.min(result[i], prev - i);         }          return result;     } }",0,,0,0,0
"class Solution {     public String toGoatLatin(String sentence) {         String[] words = sentence.split("" "");         StringBuilder result = new StringBuilder();         StringBuilder suffix = new StringBuilder(""a"");         for(String word : words) {             if (result.length() > 0) {                 result.append("" "");             }             char firstLetter = Character.toLowerCase(word.charAt(0));             if(firstLetter == 'a' || firstLetter == 'e' || firstLetter == 'i' || firstLetter == 'o' || firstLetter == 'u') {                 result.append(word).append(""ma"");             } else {                 result.append(word.substring(1)).append(word.charAt(0)).append(""ma"");             }             result.append(suffix);             suffix.append(""a"");         }         return result.toString();     } }",1,"824-goat-latin/Solution.java:8:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
824-goat-latin/Solution.java:17:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
",0,0,0
"class Solution {     public List<List<Integer>> largeGroupPositions(String s) {         // Create a list to store the intervals of large groups         List<List<Integer>> largeGroups = new ArrayList<>();         int start = 0, end = 0, n = s.length();         // Traverse the string         while (end < n) {             // Check if current character is different from previous             if (s.charAt(end) != s.charAt(start)) {                  // Check if the group is large                 if (end - start >= 3) {                     // Add the interval to largeGroups                     largeGroups.add(Arrays.asList(start, end - 1));                 }                 // Update start index for next group                 start = end;             }             // Move to next index             end++;         }         // Check the last group after loop completion          if (end - start >= 3) {             largeGroups.add(Arrays.asList(start, end - 1));         }         return largeGroups;     } }",1,"830-positions-of-large-groups/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
class Solution {     public int[][] flipAndInvertImage(int[][] image) {         int n = image.length;                  // flipping each row horizontally         for(int i=0; i<n; i++) {             for(int j=0; j<n/2; j++) {                 int temp = image[i][j];                 image[i][j] = image[i][n-j-1];                 image[i][n-j-1] = temp;             }             }                  // inverting each element in the image         for(int i=0; i<n; i++) {             for(int j=0; j<n; j++) {                 if(image[i][j] == 0) {                     image[i][j] = 1;                 } else {                     image[i][j] = 0;                 }             }             }                  return image;     } },0,,0,0,0
"class Solution {     public boolean isRectangleOverlap(int[] rec1, int[] rec2) {         // Check if the two rectangles share any negative space on the x-axis.         boolean xOverlap = (rec1[0] < rec2[2]) && (rec1[2] > rec2[0]);                  // Check if the two rectangles share any negative space on the y-axis.         boolean yOverlap = (rec1[1] < rec2[3]) && (rec1[3] > rec2[1]);                  // If both axes overlap, then the rectangles overlap.         return xOverlap && yOverlap;     } }",0,,0,0,0
"class Solution {     public boolean backspaceCompare(String s, String t) {         Stack<Character> stack1 = processString(s);         Stack<Character> stack2 = processString(t);          if (stack1.size() != stack2.size()) {             return false;         }          while (!stack1.isEmpty() && !stack2.isEmpty()) {             if (stack1.pop() != stack2.pop()) {                 return false;             }         }          return true;     }      private Stack<Character> processString(String s) {         Stack<Character> stack = new Stack<>();          for (char c : s.toCharArray()) {             if (c == '#') {                 if (!stack.isEmpty()) {                     stack.pop();                 }             } else {                 stack.push(c);             }         }          return stack;     } }",0,,0,0,0
"class Solution {     public boolean buddyStrings(String s, String goal) {         if (s.length() != goal.length()) // if length of both strings is not same             return false;                      if (s.equals(goal)) { // if both strings are equal, then check if any character is repeated             int[] count = new int[26];             for (int i = 0; i < s.length(); i++) {                 count[s.charAt(i) - 'a']++;                 if (count[s.charAt(i) - 'a'] > 1) //if any character is repeated, then return true                     return true;             }             return false; // if no character is repeated, then return false         } else {             int first = -1, second = -1;             for (int i = 0; i < s.length(); i++) {                 if (s.charAt(i) != goal.charAt(i)) {                     if (first == -1)                         first = i;                     else if (second == -1)                         second = i;                     else // more than 2 mismatches                         return false;                 }             }             return (second != -1 && s.charAt(first) == goal.charAt(second) && s.charAt(second) == goal.charAt(first)); // check if the two mismatched positions can be swapped         }     } }",1,"859-buddy-strings/Solution.java:15:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
859-buddy-strings/Solution.java:26:	UselessParentheses:	Useless parentheses.
",1,0,0
class Solution {     public boolean lemonadeChange(int[] bills) {         int fives = 0;         int tens = 0;                  for(int bill : bills) {             if(bill == 5) {                 fives++;             } else if(bill == 10) {                 if(fives == 0) {                     return false;                 }                 fives--;                 tens++;             } else { // bill == 20                 if(tens > 0 && fives > 0) {                     tens--;                     fives--;                 } else if(fives >= 3) {                     fives -= 3;                 } else {                     return false;                 }             }         }         return true;     } },0,,0,0,0
class Solution {     public int[][] transpose(int[][] matrix) {         // Determine the number of rows and columns         int numRows = matrix.length;         int numCols = matrix[0].length;                  // Initialize the new transposed matrix         int[][] result = new int[numCols][numRows];                  // Iterate over each element in the original matrix         for (int i = 0; i < numRows; i++) {             for (int j = 0; j < numCols; j++) {                 // Swap the row and column indices and update the new matrix                 result[j][i] = matrix[i][j];             }         }                  return result;     } },0,,0,0,0
"class Solution {     public int binaryGap(int n) {         // Convert integer n to binary string         String binary = Integer.toBinaryString(n);                  // Find the first index of 1         int startIndex = binary.indexOf(""1"");                  // If there is no 1 or only one 1, return 0         if (startIndex == -1 || binary.lastIndexOf(""1"") == startIndex) {             return 0;         }                  int maxDistance = 0;         int prevIndex = startIndex;                  // Loop through the binary string to find adjacent 1's         for (int i = startIndex + 1; i < binary.length(); i++) {             if (binary.charAt(i) == '1') {                 int distance = i - prevIndex;                 if (distance > maxDistance) {                     maxDistance = distance;                 }                 prevIndex = i;             }         }                  return maxDistance;     } }",1,"868-binary-gap/Solution.java:7:	UseIndexOfChar:	String.indexOf(char) is faster than String.indexOf(String).
868-binary-gap/Solution.java:10:	UseIndexOfChar:	String.indexOf(char) is faster than String.indexOf(String).
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public boolean leafSimilar(TreeNode root1, TreeNode root2) {         List<Integer> list1 = new ArrayList<>();         List<Integer> list2 = new ArrayList<>();         dfs(root1, list1);         dfs(root2, list2);         return list1.equals(list2);     }          private void dfs(TreeNode node, List<Integer> list) {         if (node == null) {             return;         }         if (node.left == null && node.right == null) {             list.add(node.val);         }         dfs(node.left, list);         dfs(node.right, list);     } }",0,,0,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public ListNode middleNode(ListNode head) {         ListNode slow = head;         ListNode fast = head;                  while(fast != null && fast.next != null) {             slow = slow.next;             fast = fast.next.next;         }                  return slow;     } }",0,,0,0,0
"class Solution {     public int projectionArea(int[][] grid) {         int n = grid.length;         int xy = 0, yz = 0, zx = 0;         for (int i = 0; i < n; i++) {             int xz = 0, yx = 0;             for (int j = 0; j < n; j++) {                 if (grid[i][j] > 0) {                     xy++;                 }                 xz = Math.max(xz, grid[j][i]);                 yx = Math.max(yx, grid[i][j]);             }             zx += xz;             yz += yx;         }         return xy + yz + zx;     } }",1,"883-projection-area-of-3d-shapes/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
883-projection-area-of-3d-shapes/Solution.java:6:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"import java.util.*;  class Solution {     public String[] uncommonFromSentences(String s1, String s2) {                  String[] words1 = s1.split("" "");         String[] words2 = s2.split("" "");                  Map<String, Integer> countMap = new HashMap<>();                  // Adding all the words in both the sentences to the map and count their frequency         for(String word : words1) {             countMap.put(word, countMap.getOrDefault(word, 0) + 1);         }         for(String word : words2) {             countMap.put(word, countMap.getOrDefault(word, 0) + 1);         }                  List<String> uncommonWords = new ArrayList<>();                  // Select all the uncommon words         for(Map.Entry<String, Integer> entry : countMap.entrySet()) {             if(entry.getValue() == 1 && (!Arrays.asList(words1).contains(entry.getKey()) || !Arrays.asList(words2).contains(entry.getKey())) ) {                 uncommonWords.add(entry.getKey());             }         }                  return uncommonWords.toArray(new String[0]); // Converting arraylist to array.     } }",1,"884-uncommon-words-from-two-sentences/Solution.java:9:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
",0,0,0
"class Solution {     public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {         int aliceTotal = 0;         int bobTotal = 0;         for(int i=0;i<aliceSizes.length;i++){             aliceTotal += aliceSizes[i];         }         for(int i=0;i<bobSizes.length;i++){             bobTotal += bobSizes[i];         }         int diff = (bobTotal - aliceTotal)/2;         Set<Integer> bobCandies = new HashSet<>();         for(int i=0;i<bobSizes.length;i++){             bobCandies.add(bobSizes[i]);         }         for(int i=0;i<aliceSizes.length;i++){             if(bobCandies.contains(aliceSizes[i]+diff)){                 return new int[]{aliceSizes[i], aliceSizes[i]+diff};             }         }         return new int[]{-1,-1};     } }",1,"888-fair-candy-swap/Solution.java:5:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
888-fair-candy-swap/Solution.java:8:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
888-fair-candy-swap/Solution.java:13:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
888-fair-candy-swap/Solution.java:16:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int surfaceArea(int[][] grid) {         int n = grid.length;         int surfaceArea = 0;         int[] offsets = {0,1,0,-1,0};                  for(int i=0; i<n; i++){             for(int j=0; j<n; j++){                 int currValue = grid[i][j];                 if(currValue > 0){                     surfaceArea += 2; //top and bottom faces count towards surface area                     for(int k=0; k<4; k++){                         int newRow = i + offsets[k];                         int newCol = j + offsets[k+1];                         int neighborValue = 0;                         if(newRow>=0 && newRow<n && newCol>=0 && newCol<n){                             neighborValue = grid[newRow][newCol];                         }                         surfaceArea += Math.max(currValue - neighborValue, 0);                     }                 }             }         }                  return surfaceArea;     } }",0,,0,0,0
class Solution {     public boolean isMonotonic(int[] nums) {         boolean increasing = true;         boolean decreasing = true;         for(int i=1; i<nums.length; i++) {             if(nums[i] < nums[i-1]) {                 increasing = false;             }              if(nums[i] > nums[i-1]) {                 decreasing = false;             }             if(!increasing && !decreasing) {                 return false;             }         }         return true;     } },0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public TreeNode increasingBST(TreeNode root) {         // Store the inorder traversal of the tree in a list         List<Integer> inorderList = new ArrayList<>();         inorderTraversal(root, inorderList);                  // Create a new root with the smallest value from the inorder list         TreeNode newRoot = new TreeNode(inorderList.get(0));         TreeNode current = newRoot;                  // Add the remaining values from the inorder list as right children of the new root         for (int i = 1; i < inorderList.size(); i++) {             current.right = new TreeNode(inorderList.get(i));             current = current.right;         }                  return newRoot;     }          private void inorderTraversal(TreeNode node, List<Integer> list) {         if (node == null) {             return;         }                  // Recursively visit the left subtree         inorderTraversal(node.left, list);                  // Add the current node's value to the list         list.add(node.val);                  // Recursively visit the right subtree         inorderTraversal(node.right, list);     } }",0,,0,0,0
"class Solution {     public int[] sortArrayByParity(int[] nums) {         int i = 0, j = nums.length - 1;         while (i < j) {             if (nums[i] % 2 > nums[j] % 2) {                 int temp = nums[i];                 nums[i] = nums[j];                 nums[j] = temp;             }             if (nums[i] % 2 == 0) i++;  // increment i if nums[i] is even             if (nums[j] % 2 == 1) j--;  // decrement j if nums[j] is odd         }         return nums;     } }",1,"905-sort-array-by-parity/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int smallestRangeI(int[] nums, int k) {         int n = nums.length;         int min = nums[0], max = nums[0];         for(int num : nums) {             min = Math.min(min, num);             max = Math.max(max, num);         }         int diff = max - min - 2*k;         return diff < 0 ? 0 : diff;     } }",1,"908-smallest-range-i/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
908-smallest-range-i/Solution.java:3:	UnusedLocalVariable:	Avoid unused local variables such as 'n'.
",1,0,0
"class Solution {     public boolean hasGroupsSizeX(int[] deck) {         if(deck.length < 2) {             return false;         }         Map<Integer, Integer> map = new HashMap<>();         for(int i = 0; i < deck.length; i++) {             map.put(deck[i], map.getOrDefault(deck[i], 0) + 1);         }         int gcd = 0;         for(int val : map.values()) {             gcd = gcd(gcd, val);             if(gcd == 1) {                 return false;             }         }         return true;     }     public int gcd(int a, int b) {         if(a == 0) {             return b;         }         return gcd(b%a, a);     } }",1,"914-x-of-a-kind-in-a-deck-of-cards/Solution.java:7:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public String reverseOnlyLetters(String s) {         //string to character array         char[] arr = s.toCharArray();         //two pointer approach to reverse only letters         int left = 0, right = s.length() - 1;         while (left < right) {             if (!Character.isLetter(arr[left])) { //if not a letter, move left pointer                 left++;             } else if (!Character.isLetter(arr[right])) { //if not a letter, move right pointer                 right--;             } else {                 //swap letters                 char temp = arr[left];                 arr[left] = arr[right];                 arr[right] = temp;                 //move pointers                 left++;                 right--;             }         }         //return reversed string         return new String(arr);     } }",1,"917-reverse-only-letters/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
917-reverse-only-letters/Solution.java:8:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
917-reverse-only-letters/Solution.java:10:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
917-reverse-only-letters/Solution.java:23:	StringInstantiation:	Avoid instantiating String objects; this is usually unnecessary.
",1,0,0
class Solution {     public int[] sortArrayByParityII(int[] nums) {         int n = nums.length;         int[] result = new int[n];         int evenIndex = 0;         int oddIndex = 1;                  for (int i = 0; i < n; i++) {             if (nums[i] % 2 == 0) {                 result[evenIndex] = nums[i];                 evenIndex += 2;             } else {                 result[oddIndex] = nums[i];                 oddIndex += 2;             }         }                  return result;     } },0,,0,0,0
"class Solution {     public boolean isLongPressedName(String name, String typed) {         if (name.length() > typed.length()) { // no. of characters in `name` should be less than or equal to that in `typed`             return false;         }         int i = 0, j = 0;         while (j < typed.length()) {             if (i < name.length() && name.charAt(i) == typed.charAt(j)) { // if corresponding characters match                 i++;                 j++;             } else if (j > 0 && typed.charAt(j) == typed.charAt(j - 1)) { // if not matching and previous character in `typed` is same                 j++;             } else {                 return false;             }         }         return i == name.length(); // all characters in `name` are matched     } }",1,"925-long-pressed-name/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int numUniqueEmails(String[] emails) {         Set<String> uniqueEmails = new HashSet<>();         for(String email : emails){             String[] parts = email.split(""@"");             String local = parts[0];             String domain = parts[1];             if(local.contains(""+"")){                 local = local.substring(0,local.indexOf(""+""));             }             local = local.replaceAll(""\\."", """");             uniqueEmails.add(local+""@""+domain);         }         return uniqueEmails.size();     } }",1,"929-unique-email-addresses/Solution.java:9:	UseIndexOfChar:	String.indexOf(char) is faster than String.indexOf(String).
",0,0,0
class RecentCounter {      Queue<Integer> requests;          public RecentCounter() {         requests = new LinkedList<>();     }          public int ping(int t) {         requests.offer(t);         while (requests.peek() < t - 3000) {             requests.poll();         }         return requests.size();     } }  /**  * Your RecentCounter object will be instantiated and called as such:  * RecentCounter obj = new RecentCounter();  * int param_1 = obj.ping(t);  */,1,"933-number-of-recent-calls/RecentCounter.java:3:20: Variable 'requests' must be private and have accessor methods. [VisibilityModifier]
933-number-of-recent-calls/RecentCounter.java:5:5: Redundant 'public' modifier. [RedundantModifier]
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public int rangeSumBST(TreeNode root, int low, int high) {         if (root == null) {             return 0;         }         if (root.val < low) {             return rangeSumBST(root.right, low, high);         }         if (root.val > high) {             return rangeSumBST(root.left, low, high);         }         return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);     } }",0,,0,0,0
class Solution {     public boolean validMountainArray(int[] arr) {         int n = arr.length;         // If the array length is less than 3 or first or last index is peak of mountain array         if(n < 3 || arr[0] > arr[1] ) return false;                   int i = 1;         // walk past increasing side of mountain         while(i < n && arr[i-1] < arr[i]) i++;                  // peak can't be first or last element         if(i == n || arr[i-1] == arr[i]) return false;                  // walk past decreasing side of mountain         while(i < n && arr[i-1] > arr[i]) i++;                  // If walk pointer reached end of array. Mountain Array has been found.         return i == n;     } },0,,0,0,0
"class Solution {     public int[] diStringMatch(String s) {         int n = s.length();         int[] result = new int[n+1];         int low = 0, high = n;         for (int i = 0; i < n; i++) {             if (s.charAt(i) == 'I') {                 result[i] = low++;             } else {                 result[i] = high--;             }         }         result[n] = high; // or low, they are equal         return result;     }    }",1,"942-di-string-match/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
class Solution {     public int minDeletionSize(String[] strs) {         int count = 0; // variable to count number of columns to be deleted                  for(int i=0; i<strs[0].length(); i++) { // loop through all columns             for(int j=0; j<strs.length-1; j++) { // loop through all rows                 if(strs[j].charAt(i) > strs[j+1].charAt(i)) { // check if column is not sorted                     count++; // increment count                     break; // break the inner loop as this column needs to be deleted                 }             }         }         return count; // return the count of columns to be deleted     } },0,,0,0,0
"class Solution {     public boolean isAlienSorted(String[] words, String order) {           int[] charOrder = new int[26];  // Array to store the order of characters         for(int i=0; i<order.length(); i++) {             charOrder[order.charAt(i)-'a'] = i;  // Assign order value to the index of the character         }                  for(int i=0; i<words.length-1; i++) {             String currentWord = words[i];             String nextWord = words[i+1];             int minLength = Math.min(currentWord.length(), nextWord.length());             for(int j=0; j<minLength; j++) {                 char currentChar = currentWord.charAt(j);                 char nextChar = nextWord.charAt(j);                 if(currentChar != nextChar) {  // Compare the characters                     if(charOrder[currentChar-'a'] > charOrder[nextChar-'a']) {                         return false;                     }                     break;  // Exit the loop if characters are not equal                 }                 if(j == minLength-1 && currentWord.length() > nextWord.length()) {                     return false;  // Handle edge case where one word is a prefix of another                 }             }         }         return true;     } }",0,,0,0,0
"class Solution {     public int repeatedNTimes(int[] nums) {         int n = nums.length/2;         int[] count = new int[10001];  //array to count the frequency of each element         for(int i=0; i<nums.length; i++) {             count[nums[i]]++;  //increment the count of the element             if(count[nums[i]] == n) {  //if count of the element is n, then it is repeated n times                 return nums[i];             }         }         return -1;  //no element is repeated n times     } }",1,"961-n-repeated-element-in-size-2n-array/Solution.java:5:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public boolean isUnivalTree(TreeNode root) {         if (root == null) {             return true;         }         if (root.left != null && root.val != root.left.val) {             return false;         }         if (root.right != null && root.val != root.right.val) {             return false;         }         return isUnivalTree(root.left) && isUnivalTree(root.right);     } }",0,,0,0,0
"class Solution {     public int largestPerimeter(int[] nums) {         Arrays.sort(nums); // Sorting the given array         int n = nums.length;         // Starting from the last side, checking if two sides preceding it can form a triangle         for(int i=n-1; i>=2; i--){             // If such sides found, return their perimeter             if(nums[i-2] + nums[i-1] > nums[i]){                 return nums[i-2] + nums[i-1] + nums[i];             }         }         return 0; // If no such triangle exists, return 0     } }",0,,0,0,0
"class Solution {     public int[] sortedSquares(int[] nums) {         int[] result = new int[nums.length];         int left = 0, right = nums.length - 1;         for (int i = nums.length - 1; i >= 0; i--) {             if (Math.abs(nums[left]) > Math.abs(nums[right])) {                 result[i] = nums[left] * nums[left];                 left++;             } else {                 result[i] = nums[right] * nums[right];                 right--;             }         }         return result;     } }",1,"977-squares-of-a-sorted-array/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public List<Integer> addToArrayForm(int[] num, int k) {         int n = num.length;         List<Integer> res = new ArrayList<>();         int carry = 0;         for (int i = n - 1; i >= 0; i--) {             int sum = num[i] + k % 10 + carry;             carry = sum / 10;             res.add(sum % 10);             k /= 10;         }         while (k > 0) {             int sum = k % 10 + carry;             carry = sum / 10;             res.add(sum % 10);             k /= 10;         }         if (carry > 0) {             res.add(carry);         }         Collections.reverse(res);         return res;     } }",1,"989-add-to-array-form-of-integer/Solution.java:10:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'k'
",0,1,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public boolean isCousins(TreeNode root, int x, int y) {         if (root == null) {             return false;         }                  //Create a queue for tree traversal         LinkedList<TreeNode> queue = new LinkedList<>();         queue.add(root);                  while (!queue.isEmpty()) {                          int size = queue.size();             boolean foundX = false;             boolean foundY = false;             TreeNode xParent = null;             TreeNode yParent = null;                          for (int i = 0; i < size; i++) {                 TreeNode node = queue.poll();                 //Check whether node's left or right sub tree is x or y                 //If so mark foundX or foundY as true                 if (node.left != null) {                     if (node.left.val == x) {                         foundX = true;                         xParent = node;                     }                     else if (node.left.val == y) {                         foundY = true;                         yParent = node;                     }                     queue.add(node.left);                 }                 if (node.right != null) {                     if (node.right.val == x) {                         foundX = true;                         xParent = node;                     }                     else if (node.right.val == y) {                         foundY = true;                         yParent = node;                     }                     queue.add(node.right);                 }             }                          //If both x and y are found in the same level but not siblings             //Return true             if (foundX && foundY && xParent != yParent) {                 return true;             }         }         return false;     } }",1,"993-cousins-in-binary-tree/TreeNode.java:42:21: '}' at column 21 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
993-cousins-in-binary-tree/TreeNode.java:53:21: '}' at column 21 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
"class Solution {     public int findJudge(int n, int[][] trust) {         // Initializing an array to store the count of trusted people for each person         int[] trustCount = new int[n+1];         for(int[] i : trust){             // i[1] has trusted i[0], so increment the count of trustCount[i[1]]             trustCount[i[1]]++;             // i[0] is not trusted, so decrement the count of trustCount[i[0]]             trustCount[i[0]]--;         }         // Check whether there is only one person with n-1 trust counts (except self-trust)         for(int i=1;i<=n;i++){             if(trustCount[i] == n-1)                 return i;         }         // No judge has been found         return -1;     } }",0,,0,0,0
"class Solution {     public int numRookCaptures(char[][] board) {         int rookRow = -1;         int rookCol = -1;         int count = 0;         int[] rows = {0, 1, 0, -1};         int[] cols = {1, 0, -1, 0};         for(int i=0; i<8; i++) {             for(int j=0; j<8; j++) {                 if(board[i][j] == 'R') {                     rookRow = i;                     rookCol = j;                     break;                 }             }         }         for(int i=0; i<4; i++) {             int row = rookRow;             int col = rookCol;             while(row >= 0 && row < 8 && col >= 0 && col < 8) {                 if(board[row][col] == 'p') {                     count++;                     break;                 }                 if(board[row][col] == 'B') {                     break;                 }                 row += rows[i];                 col += cols[i];             }         }         return count;     } }",0,,0,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public ListNode addTwoNumbers(ListNode l1, ListNode l2) {         ListNode dummyHead = new ListNode(0); // a dummy node to keep track of the head         ListNode ptr = dummyHead; // a pointer to traverse the list                  int carry = 0; // to keep track of the carry                  while (l1 != null || l2 != null || carry != 0) {             int sum = carry;                          if (l1 != null) {                 sum += l1.val;                 l1 = l1.next;             }                          if (l2 != null) {                 sum += l2.val;                 l2 = l2.next;             }                          int digit = sum % 10;             carry = sum / 10;                          ListNode node = new ListNode(digit); // create a new node             ptr.next = node; // link the new node to the previous one             ptr = ptr.next; // move the pointer to the new node         }                  return dummyHead.next; // skip the dummy node and return the actual result     } }",1,"002-add-two-numbers/ListNode.java:23:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'l1'
002-add-two-numbers/ListNode.java:28:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'l2'
",0,1,0
"class Solution {     public int lengthOfLongestSubstring(String s) {         int n = s.length();         int ans = 0;         int[] index = new int[256];         for (int j = 0, i = 0; j < n; j++) {             i = Math.max(index[s.charAt(j)], i);             ans = Math.max(ans, j - i + 1);             index[s.charAt(j)] = j + 1;         }         return ans;     } } ",1,"003-longest-substring-without-repeating-characters/Solution.java:6:	ForLoopVariableCount:	Too many control variables in the for statement
",0,0,0
"class Solution {     public String longestPalindrome(String s) {         if (s == null || s.length() < 1) return """";         int start = 0, end = 0;         for (int i = 0; i < s.length(); i++) {             int len1 = expandAroundCenter(s, i, i);             int len2 = expandAroundCenter(s, i, i + 1);             int len = Math.max(len1, len2);             if (len > end - start) {                 start = i - (len - 1) / 2;                 end = i + len / 2;             }         }         return s.substring(start, end + 1);     }      private int expandAroundCenter(String s, int left, int right) {         int L = left, R = right;         while (L >= 0 && R < s.length() && s.charAt(L) == s.charAt(R)) {             L--;             R++;         }         return R - L - 1;     } }",1,"005-longest-palindromic-substring/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
005-longest-palindromic-substring/Solution.java:18:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
005-longest-palindromic-substring/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
005-longest-palindromic-substring/Solution.java:18:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public String convert(String s, int numRows) {         if (numRows == 1 || s.length() <= numRows) {             return s;         }         StringBuilder[] sb = new StringBuilder[numRows];         for (int i = 0; i < numRows; i++) {             sb[i] = new StringBuilder();         }         int row = 0;         boolean downFlag = false;         for (int i = 0; i < s.length(); i++) {             sb[row].append(s.charAt(i));             if (row == 0 || row == numRows - 1) {                 downFlag = !downFlag;             }             row += downFlag ? 1 : -1;         }         StringBuilder result = new StringBuilder();         for (StringBuilder ss : sb) {             result.append(ss);         }         return result.toString();     } }",0,,0,0,0
class Solution {     public int reverse(int x) {         int result = 0;         while (x != 0) {             //Get the last digit of x             int digit = x % 10;             x /= 10;                          //Check if reversing x causes overflow or not             if (result > Integer.MAX_VALUE / 10 || (result == Integer.MAX_VALUE / 10 && digit > 7)) {                 return 0;             }             if (result < Integer.MIN_VALUE / 10 || (result == Integer.MIN_VALUE / 10 && digit < -8)) {                 return 0;             }                          //Add the digit to the reversed integer             result = result * 10 + digit;         }         return result;     } },1,"007-reverse-integer/Solution.java:7:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'x'
",0,1,0
class Solution {     public int myAtoi(String s) {         int index = 0;         int sign = 1;         int result = 0;         // remove all leading whitespaces         while (index < s.length() && s.charAt(index) == ' ') {             index++;         }         // check if the number is negative or positive         if (index < s.length() && (s.charAt(index) == '+' || s.charAt(index) == '-')) {             sign = s.charAt(index) == '-' ? -1 : 1;             index++;         }         // convert digits to integer until a non-digit is encountered or input ends         while (index < s.length() && Character.isDigit(s.charAt(index))) {             int num = s.charAt(index) - '0';             // check if adding this digit causes integer overflow             if (result > Integer.MAX_VALUE/10 || (result == Integer.MAX_VALUE/10 && num > 7)) {                 return sign == -1 ? Integer.MIN_VALUE : Integer.MAX_VALUE;             }             result = result * 10 + num;             index++;         }         return result * sign;     } },0,,0,0,0
"class Solution {     public int maxArea(int[] height) {         int i = 0;         int j = height.length - 1;         int maxArea = 0;                  while (i < j) {             int area = Math.min(height[i], height[j]) * (j - i);              if (area > maxArea) {                 maxArea = area;             }              if (height[i] < height[j]) {                 i++;             } else {                 j--;             }         }                  return maxArea;     } }",0,,0,0,0
"class Solution {     public String intToRoman(int num) {         // create arrays for the roman numeral symbols and their corresponding values         String[] romanSymbols = {""M"",""CM"",""D"",""CD"",""C"",""XC"",""L"",""XL"",""X"",""IX"",""V"",""IV"",""I""};         int[] numValues = {1000,900,500,400,100,90,50,40,10,9,5,4,1};                  // initialize a string builder to store the resulting roman numeral string         StringBuilder sb = new StringBuilder();                  // iterate through the arrays and build the roman numeral string         int i = 0;         while (num > 0) {             // if the current number is greater than or equal to the current symbol value, add the symbol to the string             if (num >= numValues[i]) {                 sb.append(romanSymbols[i]);                 num -= numValues[i];             } else {                 i++;             }         }                  // return the resulting string         return sb.toString();     } }",1,"012-integer-to-roman/Solution.java:16:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'num'
",0,1,0
"import java.util.*;  class Solution {     public List<List<Integer>> threeSum(int[] nums) {         Arrays.sort(nums);         List<List<Integer>> result = new ArrayList<>();         for (int i = 0; i < nums.length - 2; i++) {             if (i > 0 && nums[i] == nums[i - 1])                 continue; // to avoid duplicates             int j = i + 1, k = nums.length - 1;             while (j < k) {                 if (nums[i] + nums[j] + nums[k] == 0) {                     result.add(Arrays.asList(nums[i], nums[j], nums[k]));                     j++;                     k--;                     while (j < k && nums[j] == nums[j - 1])                         j++; // to avoid duplicates                     while (j < k && nums[k] == nums[k + 1])                         k--; // to avoid duplicates                 } else if (nums[i] + nums[j] + nums[k] < 0) {                     j++;                 } else {                     k--;                 }             }         }         return result;     } }",1,"015-3sum/Solution.java:10:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
015-3sum/Solution.java:10:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int threeSumClosest(int[] nums, int target) {         int n = nums.length;         int closestSum = nums[0] + nums[1] + nums[2]; // initialize closestSum to any random sum of three integers from nums         Arrays.sort(nums); // sort the nums array                 for (int i = 0; i < n - 2; i++) {             int left = i + 1;             int right = n - 1;                          while (left < right) {                 int sum = nums[i] + nums[left] + nums[right];                                  if (sum == target) {                     return target; // sum is equal to target, return target                 }                                  if (Math.abs(sum-target) < Math.abs(closestSum-target)) {                     closestSum = sum; // update closestSum if sum is closest to target                 }                                  if (sum < target) {                     left++; // increase left pointer to increase sum                 } else {                     right--; // decrease right pointer to decrease sum                 }             }         }         return closestSum;     } }",0,,0,0,0
"import java.util.*;  class Solution {     public List<String> letterCombinations(String digits) {         String[] mapping = {""0"", ""1"", ""abc"", ""def"", ""ghi"", ""jkl"", ""mno"", ""pqrs"", ""tuv"", ""wxyz""};         List<String> result = new ArrayList<>();         if (digits.length() == 0) {             return result;         }         result.add("""");         for (int i = 0; i < digits.length(); i++) {             List<String> temp = new ArrayList<>();             String letters = mapping[digits.charAt(i) - '0'];             for (int j = 0; j < letters.length(); j++) {                 for (String s : result) {                     temp.add(s + letters.charAt(j));                 }             }             result = temp;         }         return result;     } }",1,"017-letter-combinations-of-a-phone-number/Solution.java:5:	PrematureDeclaration:	Declaration of 'mapping' can be moved closer to its usages
",0,0,0
"import java.util.*;  class Solution {     public List<List<Integer>> fourSum(int[] nums, int target) {         List<List<Integer>> res = new ArrayList<>();         if(nums == null || nums.length < 4) return res;         Arrays.sort(nums);         int n = nums.length;         for(int i=0; i<n-3; i++) {             if(i!=0 && nums[i] == nums[i-1]) continue;             for(int j=i+1; j<n-2; j++) {                 if(j!=i+1 && nums[j] == nums[j-1]) continue;                 int l = j+1, r = n-1;                 while(l < r) {                     int sum = nums[i] + nums[j] + nums[l] + nums[r];                     if(sum == target) {                         res.add(Arrays.asList(nums[i], nums[j], nums[l], nums[r]));                         while(l<r && nums[l] == nums[l+1]) l++;                         while(l<r && nums[r] == nums[r-1]) r--;                         l++;                         r--;                     }                     else if(sum < target) l++;                     else r--;                 }             }         }         return res;     } }",1,"018-4sum/Solution.java:13:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
018-4sum/Solution.java:22:21: '}' at column 21 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
018-4sum/Solution.java:13:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
018-4sum/Solution.java:22:21: '}' at column 21 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
018-4sum/Solution.java:4:	NPathComplexity:	The method 'fourSum(int[], int)' has an NPath complexity of 336, current threshold is 200
",1,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public ListNode removeNthFromEnd(ListNode head, int n) {         ListNode dummy = new ListNode(0);         dummy.next = head;                  ListNode slow = dummy;         ListNode fast = dummy;                  for(int i=0; i<n; i++) {             fast = fast.next;         }                  while(fast.next != null){             slow = slow.next;             fast = fast.next;         }                  slow.next = slow.next.next;                  return dummy.next;     } }",0,,0,0,0
"class Solution {     public List<String> generateParenthesis(int n) {         List<String> result = new ArrayList<String>();         generateParenthesisHelper(n, 0, 0, """", result);         return result;     }          private void generateParenthesisHelper(int n, int leftCount, int rightCount, String current, List<String> result) {         if (leftCount > n || rightCount > n || rightCount > leftCount) {             return;         }         if (leftCount == n && rightCount == n) {             result.add(current);             return;         }         generateParenthesisHelper(n, leftCount + 1, rightCount, current + ""("", result);         generateParenthesisHelper(n, leftCount, rightCount + 1, current + "")"", result);     } }",0,,0,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public ListNode swapPairs(ListNode head) {         //if head == null or there's only 1 node in the list, return head as is         if (head == null || head.next == null) {             return head;         }                  //create a temporary node to act as the new head of the list         ListNode temp = new ListNode(0);         temp.next = head;                  //create 3 pointers to traverse and swap each pair of nodes         ListNode prev = temp;         ListNode curr = head;         ListNode next = head.next;                  while (curr != null && curr.next != null) {             prev.next = next;             curr.next = next.next;             next.next = curr;                          //move the pointers to the next two nodes to be swapped             prev = curr;             curr = curr.next;             next = (curr != null) ? curr.next : null;         }                  //return the new head         return temp.next;     } }",1,"024-swap-nodes-in-pairs/ListNode.java:35:	NullAssignment:	Assigning an Object to null is a code smell.  Consider refactoring.
",0,0,0
"class Solution {     public int divide(int dividend, int divisor) {         if (dividend == Integer.MIN_VALUE && divisor == -1) {             return Integer.MAX_VALUE;         }         long a = Math.abs((long)dividend), b = Math.abs((long)divisor), res = 0;         int sign = ((dividend < 0) ^ (divisor < 0)) ? -1 : 1;         while (a >= b) {             long temp = b, multiple = 1;             while (a >= (temp << 1)) {                 temp <<= 1;                 multiple <<= 1;             }             res += multiple;             a -= temp;         }         return sign == 1 ? (int)res : -(int)res;     } }",1,"029-divide-two-integers/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
029-divide-two-integers/Solution.java:9:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
029-divide-two-integers/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
029-divide-two-integers/Solution.java:9:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public void nextPermutation(int[] nums) {         int n = nums.length;         int i = n - 2;         while (i >= 0 && nums[i] >= nums[i + 1]) { // find first non-increasing element from the end             i--;         }         if (i >= 0) { // if such element is found             int j = n - 1;             while (j > i && nums[j] <= nums[i]) { // find the smallest element greater than the first non-increasing element                 j--;             }             swap(nums, i, j); // swap the elements         }         reverse(nums, i + 1, n - 1); // reverse the suffix     }          private void swap(int[] nums, int i, int j) {         int temp = nums[i];         nums[i] = nums[j];         nums[j] = temp;     }          private void reverse(int[] nums, int i, int j) {         while (i < j) {             swap(nums, i, j);             i++;             j--;         }     } }",1,"031-next-permutation/Solution.java:27:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'i'
031-next-permutation/Solution.java:28:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'j'
",0,1,0
"class Solution {     public int search(int[] nums, int target) {         int n = nums.length;         int left = 0;         int right = n - 1;                  while (left <= right) {             int mid = (left + right) / 2;             if (nums[mid] == target) {                 return mid;             }                          // Left side is sorted             if (nums[left] <= nums[mid]) {                 // Check if target is in the left side                 if (nums[left] <= target && target < nums[mid]) {                     right = mid - 1; // Target is in left side                 } else {                     left = mid + 1;  // Target is in right side                 }             }                           // Right side is sorted             else {                 // Check if target is in the right side                 if (nums[mid] < target && target <= nums[right]) {                     left = mid + 1;  // Target is in right side                 } else {                     right = mid - 1; // Target is in left side                 }             }         }                  return -1; // Target not found     } }",1,"033-search-in-rotated-sorted-array/Solution.java:21:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
033-search-in-rotated-sorted-array/Solution.java:21:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
"class Solution {     public int[] searchRange(int[] nums, int target) {         int[] result = {-1, -1};         if (nums == null || nums.length == 0) {             return result;         }         int left = 0;         int right = nums.length - 1;         // finding the leftmost occurrence of target         while (left < right) {             int mid = left + (right - left) / 2;             if (nums[mid] >= target) {                 right = mid;             } else {                 left = mid + 1;             }         }         if (nums[left] != target) {             return result;         }         result[0] = left;         right = nums.length - 1;         // finding the rightmost occurrence of target         while (left < right) {             int mid = left + (right - left) / 2 + 1;             if (nums[mid] <= target) {                 left = mid;             } else {                 right = mid - 1;             }         }         result[1] = right;         return result;     } }",0,,0,0,0
"class Solution {     public boolean isValidSudoku(char[][] board) {         // Check each row         for (int i = 0; i < 9; i++) {             boolean[] used = new boolean[9];             for (int j = 0; j < 9; j++) {                 char c = board[i][j];                 if (c >= '1' && c <= '9') {                     if (used[c-'1']) return false;                     used[c-'1'] = true;                 }             }         }                  // Check each column         for (int j = 0; j < 9; j++) {             boolean[] used = new boolean[9];             for (int i = 0; i < 9; i++) {                 char c = board[i][j];                 if (c >= '1' && c <= '9') {                     if (used[c-'1']) return false;                     used[c-'1'] = true;                 }             }         }                  // Check each sub-box         for (int box = 0; box < 9; box++) {             boolean[] used = new boolean[9];             int starti = (box / 3) * 3, startj = (box % 3) * 3;             for (int i = starti; i < starti+3; i++) {                 for (int j = startj; j < startj+3; j++) {                     char c = board[i][j];                     if (c >= '1' && c <= '9') {                         if (used[c-'1']) return false;                         used[c-'1'] = true;                     }                 }             }         }                  // All checks passed         return true;     } }",1,"036-valid-sudoku/Solution.java:30:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
036-valid-sudoku/Solution.java:30:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
036-valid-sudoku/Solution.java:2:	NPathComplexity:	The method 'isValidSudoku(char[][])' has an NPath complexity of 252, current threshold is 200
036-valid-sudoku/Solution.java:30:	UselessParentheses:	Useless parentheses.
036-valid-sudoku/Solution.java:30:	UselessParentheses:	Useless parentheses.
",1,0,0
"class Solution {     public String countAndSay(int n) {         if (n == 1) {             return ""1"";         }         String prev = countAndSay(n - 1);         StringBuilder sb = new StringBuilder();         int count = 1;         for (int i = 0; i < prev.length(); i++) {             if (i == prev.length() - 1 || prev.charAt(i) != prev.charAt(i+1)) {                 sb.append(count).append(prev.charAt(i));                 count = 1;             } else {                 count++;             }         }         return sb.toString();     } }",0,,0,0,0
"import java.util.*;  class Solution {     public List<List<Integer>> combinationSum(int[] candidates, int target) {         List<List<Integer>> result = new ArrayList<>();         List<Integer> temp = new ArrayList<>();         Arrays.sort(candidates);                  backtracking(result, temp, candidates, target, 0);         return result;     }          private void backtracking(List<List<Integer>> result, List<Integer> temp, int[] candidates, int remain, int start){         if(remain < 0) return;         else if (remain == 0) result.add(new ArrayList<>(temp));         else{             for(int i=start; i<candidates.length; i++){                 temp.add(candidates[i]);                 backtracking(result, temp, candidates, remain-candidates[i], i);                 temp.remove(temp.size()-1);             }         }     } }",1,"039-combination-sum/Solution.java:14:	UnnecessaryReturn:	Unnecessary return statement
",0,0,0
"import java.util.ArrayList; import java.util.Arrays; import java.util.List;  class Solution {     public List<List<Integer>> combinationSum2(int[] candidates, int target) {         List<List<Integer>> result = new ArrayList<>();         Arrays.sort(candidates); // sort candidates to avoid duplicate combinations         backtrack(result, candidates, target, new ArrayList<>(), 0);         return result;     }          private void backtrack(List<List<Integer>> result, int[] candidates, int target, List<Integer> combination, int start) {         if (target == 0) { // found a valid combination             result.add(new ArrayList<>(combination));         } else if (target > 0) {             for (int i = start; i < candidates.length; i++) {                 if (i > start && candidates[i] == candidates[i-1]) continue; // skip duplicate values                 combination.add(candidates[i]); // add candidate to the current combination                 backtrack(result, candidates, target - candidates[i], combination, i+1); // move to the next candidate                 combination.remove(combination.size() - 1); // backtrack: remove the last added candidate                 }         }     } }",0,,0,0,0
"class Solution {     public String multiply(String num1, String num2) {          int n1 = num1.length();         int n2 = num2.length();         int[] products = new int[n1 + n2];          for (int i = n1 - 1; i >= 0; i--) {             for (int j = n2 - 1; j >= 0; j--) {                 int d1 = num1.charAt(i) - '0';                 int d2 = num2.charAt(j) - '0';                 products[i + j + 1] += d1 * d2;             }         }          int carry = 0;         for (int i = products.length - 1; i >= 0; i--) {             int tmp = (products[i] + carry) % 10;             carry = (products[i] + carry) / 10;             products[i] = tmp;         }          StringBuilder sb = new StringBuilder();         for(int digit : products) {             sb.append(digit);         }          // remove leading zeroes         while(sb.length() > 1 && sb.charAt(0) == '0') {             sb.deleteCharAt(0);         }          return sb.toString();     } }",0,,0,0,0
"class Solution {     public int jump(int[] nums) {         int jumps = 0, currEnd = 0, currFarthest = 0;         for (int i = 0; i < nums.length - 1; i++) {             currFarthest = Math.max(currFarthest, i + nums[i]);             if (i == currEnd) {                 jumps++;                 currEnd = currFarthest;             }         }         return jumps;     } }",1,"045-jump-game-ii/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
045-jump-game-ii/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public List<List<Integer>> permute(int[] nums) {         List<List<Integer>> permutations = new ArrayList<>();         // Recursive function to generate permutations         generatePermutations(nums, 0, permutations);         return permutations;     }          private void generatePermutations(int[] nums, int start, List<List<Integer>> permutations) {         if(start == nums.length - 1) {             // Add permutation to result             List<Integer> permutation = new ArrayList<>();             for(int num : nums) {                 permutation.add(num);             }             permutations.add(permutation);             return;         }                  // Generate permutations         for(int i = start; i < nums.length; i++) {             // Swap current element with first element             swap(nums, start, i);                          // Recurse to generate permutations             generatePermutations(nums, start + 1, permutations);                          // Backtrack - swap back the elements             swap(nums, start, i);         }     }          private void swap(int[] nums, int i, int j) {         int temp = nums[i];         nums[i] = nums[j];         nums[j] = temp;     } }",0,,0,0,0
"import java.util.*;  class Solution {     public List<List<Integer>> permuteUnique(int[] nums) {         List<List<Integer>> result = new ArrayList<>();         Arrays.sort(nums);         backtrack(result, new ArrayList<>(), nums, new boolean[nums.length]);         return result;     }          private void backtrack(List<List<Integer>> result, List<Integer> tempList, int[] nums, boolean[] used) {         if(tempList.size() == nums.length) {             result.add(new ArrayList<>(tempList));         } else {             for(int i = 0; i < nums.length; i++) {                 if(used[i] || (i > 0 && nums[i] == nums[i-1] && !used[i-1])) continue;                 used[i] = true;                 tempList.add(nums[i]);                 backtrack(result, tempList, nums, used);                 used[i] = false;                 tempList.remove(tempList.size() - 1);             }         }     } }",0,,0,0,0
class Solution {     public void rotate(int[][] matrix) {         int n = matrix.length;          // Transpose the matrix         for(int i=0; i<n; i++){             for(int j=i; j<n; j++){                 int temp = matrix[i][j];                 matrix[i][j] = matrix[j][i];                 matrix[j][i] = temp;             }         }          // Reverse each row of the matrix         for(int i=0; i<n; i++){             for(int j=0; j<n/2; j++){                 int temp = matrix[i][j];                 matrix[i][j] = matrix[i][n-j-1];                 matrix[i][n-j-1] = temp;             }         }     } },0,,0,0,0
"import java.util.*;  class Solution {     public List<List<String>> groupAnagrams(String[] strs) {         HashMap<String, List<String>> map = new HashMap<>();         List<List<String>> result = new ArrayList<>();                  // iterate through each string in the input array         for (String s : strs) {             // convert the string into a character array and sort it             char[] charArray = s.toCharArray();             Arrays.sort(charArray);             String sortedStr = new String(charArray);                          // if the sorted string is already in the map, add the original string to its list             if (map.containsKey(sortedStr)) {                 map.get(sortedStr).add(s);             } else {                 // otherwise, add the sorted string to the map as a new key and create a new list with the original string                 List<String> newList = new ArrayList<>();                 newList.add(s);                 map.put(sortedStr, newList);             }         }                  // add the values (lists of anagrams) from the map to the result list         for (List<String> list : map.values()) {             result.add(list);         }         return result;     } }",1,"049-group-anagrams/Solution.java:5:	LooseCoupling:	Avoid using implementation types like 'HashMap'; use the interface instead
049-group-anagrams/Solution.java:13:	StringInstantiation:	Avoid instantiating String objects; this is usually unnecessary.
",0,0,0
"class Solution {     public double myPow(double x, int n) {         double result = 1.0;         long nLong = n;         if (nLong < 0) {             x = 1 / x;             nLong = -nLong;         }         while (nLong > 0) {             if (nLong % 2 == 1) {                 result *= x;             }             x *= x;             nLong /= 2;         }         return result;     } }",1,"050-powx-n/Solution.java:6:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'x'
",0,1,0
"class Solution {     public int maxSubArray(int[] nums) {         int maxSoFar = nums[0];         int maxEndingHere = nums[0];                  for (int i = 1; i < nums.length; i++) {             maxEndingHere = Math.max(maxEndingHere + nums[i], nums[i]);             maxSoFar = Math.max(maxSoFar, maxEndingHere);         }                  return maxSoFar;     } }",0,,0,0,0
import java.util.ArrayList; import java.util.List;  class Solution {     public List<Integer> spiralOrder(int[][] matrix) {         List<Integer> result = new ArrayList<>();         if (matrix == null || matrix.length == 0) {             return result;         }          int rows = matrix.length;         int columns = matrix[0].length;          int left = 0;         int right = columns - 1;         int top = 0;         int bottom = rows - 1;          while (result.size() < rows * columns) {             // Traverse top row             for (int i = left; i <= right && result.size() < rows * columns; i++) {                 result.add(matrix[top][i]);             }             top++;              // Traverse right column             for (int i = top; i <= bottom && result.size() < rows * columns; i++) {                 result.add(matrix[i][right]);             }             right--;              // Traverse bottom row             for (int i = right; i >= left && result.size() < rows * columns; i--) {                 result.add(matrix[bottom][i]);             }             bottom--;              // Traverse left column             for (int i = bottom; i >= top && result.size() < rows * columns; i--) {                 result.add(matrix[i][left]);             }             left++;         }          return result;     } },1,"054-spiral-matrix/Solution.java:5:	NPathComplexity:	The method 'spiralOrder(int[][])' has an NPath complexity of 246, current threshold is 200
",0,0,0
"class Solution {     public boolean canJump(int[] nums) {         int n = nums.length;         int max_reach = 0;         for (int i = 0; i < n; i++) {             if (i > max_reach) {                 // if the current index cannot be reached                 // from the previous indices, return false                 return false;             }             max_reach = Math.max(max_reach, i + nums[i]);             // update max_reach to the maximum index that can be reached             if (max_reach >= n - 1) {                 // if the last index can be reached, return true                 return true;             }         }         return false;     } }",0,,0,0,0
"class Solution {     public int[][] merge(int[][] intervals) {         if (intervals.length <= 1) {             return intervals;         }                  // Sort by ascending starting point         Arrays.sort(intervals, (arr1, arr2) -> Integer.compare(arr1[0], arr2[0]));                  List<int[]> result = new ArrayList<>();         int[] currentInterval = intervals[0];         result.add(currentInterval);                  for (int[] interval : intervals) {             int currentEnd = currentInterval[1];             int nextStart = interval[0];             int nextEnd = interval[1];             if (currentEnd >= nextStart) {                 currentInterval[1] = Math.max(currentEnd, nextEnd);             } else {                 currentInterval = interval;                 result.add(currentInterval);             }         }         return result.toArray(new int[result.size()][]);     } }",0,,0,0,0
"class Solution {     public int[][] insert(int[][] intervals, int[] newInterval) {         List<int[]> result = new ArrayList<>();         int idx = 0, n = intervals.length;                  // add all the intervals before overlapping interval         while (idx < n && intervals[idx][1] < newInterval[0]) {             result.add(intervals[idx++]);         }                  // merge overlapping intervals         while (idx < n && intervals[idx][0] <= newInterval[1]) {             newInterval[0] = Math.min(newInterval[0], intervals[idx][0]);             newInterval[1] = Math.max(newInterval[1], intervals[idx][1]);             idx++;         }         result.add(newInterval);                  // add all the intervals after overlapping interval         while (idx < n) {             result.add(intervals[idx++]);         }                  return result.toArray(new int[result.size()][2]);     } }",1,"057-insert-interval/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
057-insert-interval/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int[][] generateMatrix(int n) {                  int[][] matrix = new int[n][n];                  int left = 0, right = n-1, top = 0, bottom = n-1;         int num = 1;                  while (left <= right && top <= bottom) {             // Fill top row             for (int j = left; j <= right; j++) {                 matrix[top][j] = num++;             }             top++;                          // Fill right column             for (int i = top; i <= bottom; i++) {                 matrix[i][right] = num++;             }             right--;                          // Fill bottom row             if (top <= bottom) {                 for (int j = right; j >= left; j--) {                     matrix[bottom][j] = num++;                 }                 bottom--;             }                          // Fill left column             if (left <= right) {                 for (int i = bottom; i >= top; i--) {                     matrix[i][left] = num++;                 }                 left++;             }         }                  return matrix;     } }",1,"059-spiral-matrix-ii/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
059-spiral-matrix-ii/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public ListNode rotateRight(ListNode head, int k) {         if (head == null || head.next == null || k == 0) {             return head;         }         // Compute the length of the list         int len = 0;         ListNode curr = head;         while (curr != null) {             len++;             curr = curr.next;         }         // Compute the effective number of rotations         k %= len;         if (k == 0) {             return head;         }         // Find the new tail and head         ListNode tail = head, newTail = head, newHead;         for (int i = 0; i < len - k - 1; i++) {             tail = tail.next;         }         newTail = tail;         newHead = tail.next;         // Rotate the list         newTail.next = null;         tail.next = head;         return newHead;     } }",1,"061-rotate-list/ListNode.java:29:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
061-rotate-list/ListNode.java:29:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
061-rotate-list/ListNode.java:24:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'k'
061-rotate-list/ListNode.java:29:	UnusedAssignment:	The initializer for variable 'newTail' is never used (overwritten on line 33)
061-rotate-list/ListNode.java:36:	NullAssignment:	Assigning an Object to null is a code smell.  Consider refactoring.
",1,1,0
"class Solution {     public int uniquePaths(int m, int n) {         int[][] dp = new int[m][n];                  for(int i=0;i<m;i++){             for(int j=0;j<n;j++){                 if(i==0 || j==0){                     dp[i][j] = 1;                 }                 else{                     dp[i][j] = dp[i-1][j] + dp[i][j-1];                 }             }         }                  return dp[m-1][n-1];     } }",1,"062-unique-paths/Solution.java:9:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
062-unique-paths/Solution.java:9:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
class Solution {     public int uniquePathsWithObstacles(int[][] obstacleGrid) {         int m = obstacleGrid.length;         int n = obstacleGrid[0].length;                  int[][] dp = new int[m][n];                  // Initialize first column         for(int i=0; i<m; i++) {             if(obstacleGrid[i][0] == 1) {                 break;             } else {                 dp[i][0] = 1;             }         }                  // Initialize first row         for(int j=0; j<n; j++) {             if(obstacleGrid[0][j] == 1) {                 break;             } else {                 dp[0][j] = 1;             }         }                  // Fill remaining cells of dp table         for(int i=1; i<m; i++) {             for(int j=1; j<n; j++) {                 if(obstacleGrid[i][j] == 1) {                     dp[i][j] = 0;                 } else {                     dp[i][j] = dp[i-1][j] + dp[i][j-1];                 }             }         }                  return dp[m-1][n-1];     } },0,,0,0,0
"class Solution {     public int minPathSum(int[][] grid) {         int m = grid.length;         int n = grid[0].length;                  int[][] dp = new int[m][n];         dp[0][0] = grid[0][0];                  for(int i=1;i<m;i++) {             dp[i][0] = dp[i-1][0] + grid[i][0];         }                  for(int i=1;i<n;i++) {             dp[0][i] = dp[0][i-1] + grid[0][i];         }                  for(int i=1;i<m;i++) {             for(int j=1;j<n;j++) {                 dp[i][j] = Math.min(dp[i-1][j],dp[i][j-1]) + grid[i][j];             }         }                  return dp[m-1][n-1];     } }",0,,0,0,0
"class Solution {     public String simplifyPath(String path) {         String[] directories = path.split(""/"");         List<String> dirList = new LinkedList<>();         // Iterate over directories in the path         for (String dir : directories) {             if (dir.equals("""") || dir.equals(""."")) {                 // Skip empty or current directory                 continue;             } else if (dir.equals("".."")) {                 // Move up one level                 if (!dirList.isEmpty()) {                     dirList.remove(dirList.size() - 1);                 }             } else {                 // Add directory                 dirList.add(dir);             }         }         // Create simplified path         StringBuilder sb = new StringBuilder(""/"");         for (String dir : dirList) {             sb.append(dir).append(""/"");         }         // Remove trailing slash if present         if (sb.length() > 1 && sb.charAt(sb.length() - 1) == '/') {             sb.deleteCharAt(sb.length() - 1);         }         return sb.toString();     } }",1,"071-simplify-path/Solution.java:7:	LiteralsFirstInComparisons:	Position literals first in String comparisons
071-simplify-path/Solution.java:7:	LiteralsFirstInComparisons:	Position literals first in String comparisons
071-simplify-path/Solution.java:10:	LiteralsFirstInComparisons:	Position literals first in String comparisons
071-simplify-path/Solution.java:23:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
",0,0,0
class Solution {     public void setZeroes(int[][] matrix) {         boolean firstRowHasZero = false;         boolean firstColumnHasZero = false;          int m = matrix.length;         int n = matrix[0].length;          // Check if the first row has a zero         for (int j = 0; j < n; j++) {             if (matrix[0][j] == 0) {                 firstRowHasZero = true;                 break;             }         }          // Check if the first column has a zero         for (int i = 0; i < m; i++) {             if (matrix[i][0] == 0) {                 firstColumnHasZero = true;                 break;             }         }          // Use the first row and first column as markers to check if a cell should be set to zero         for (int i = 1; i < m; i++) {             for (int j = 1; j < n; j++) {                 if (matrix[i][j] == 0) {                     matrix[i][0] = 0;                     matrix[0][j] = 0;                 }             }         }          // Set cells to zero based on markers in first row and first column         for (int i = 1; i < m; i++) {             for (int j = 1; j < n; j++) {                 if (matrix[i][0] == 0 || matrix[0][j] == 0) {                     matrix[i][j] = 0;                 }             }         }          // Set first row to zero if needed         if (firstRowHasZero) {             for (int j = 0; j < n; j++) {                 matrix[0][j] = 0;             }         }          // Set first column to zero if needed         if (firstColumnHasZero) {             for (int i = 0; i < m; i++) {                 matrix[i][0] = 0;             }         }     } },1,"073-set-matrix-zeroes/Solution.java:2:	NPathComplexity:	The method 'setZeroes(int[][])' has an NPath complexity of 1620, current threshold is 200
",0,0,0
"class Solution {    public boolean searchMatrix(int[][] matrix, int target) {         int m = matrix.length;         int n = matrix[0].length;         int left = 0, right = m * n - 1;         while (left <= right) {             int mid = left + (right - left) / 2;             int row = mid / n, col = mid % n;             if (matrix[row][col] == target) {                 return true;             } else if (matrix[row][col] < target) {                 left = mid + 1;             } else {                 right = mid - 1;             }         }         return false;     } }",1,"074-search-a-2d-matrix/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
074-search-a-2d-matrix/Solution.java:8:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
074-search-a-2d-matrix/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
074-search-a-2d-matrix/Solution.java:8:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public void sortColors(int[] nums) {         int low = 0, high = nums.length - 1, mid = 0;                  while(mid <= high){             switch(nums[mid]){                 case 0: {                     int temp = nums[mid];                     nums[mid] = nums[low];                     nums[low] = temp;                     low++; mid++;                     break;                 }                 case 1:{                     mid++;                     break;                 }                 case 2:{                     int temp = nums[mid];                     nums[mid] = nums[high];                     nums[high] = temp;                     high--;                     break;                 }             }         }     } }  ",1,"075-sort-colors/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
075-sort-colors/Solution.java:6:13: switch without ""default"" clause. [MissingSwitchDefault]
075-sort-colors/Solution.java:7:25: Avoid nested blocks. [AvoidNestedBlocks]
075-sort-colors/Solution.java:14:24: Avoid nested blocks. [AvoidNestedBlocks]
075-sort-colors/Solution.java:18:24: Avoid nested blocks. [AvoidNestedBlocks]
075-sort-colors/Solution.java:6:	SwitchStmtsShouldHaveDefault:	Switch statements should be exhaustive, add a default case (or missing enum branches)
",1,0,0
"import java.util.List; import java.util.ArrayList;  class Solution {     public List<List<Integer>> combine(int n, int k) {         List<List<Integer>> result = new ArrayList<>();         if(k == 0 || n == 0 || k > n) return result;         combineHelper(n, k, 1, new ArrayList<>(), result);         return result;     }          // helper function to get all combinations     public void combineHelper(int n, int k, int start, List<Integer> temp, List<List<Integer>> result) {         if(temp.size() == k) {             result.add(new ArrayList<>(temp));             return;         }                  for(int i = start; i <= n; i++) {             temp.add(i);             combineHelper(n, k, i + 1, temp, result);             temp.remove(temp.size() - 1);         }     } }",0,,0,0,0
"class Solution {     public List<List<Integer>> subsets(int[] nums) {         List<List<Integer>> result = new ArrayList<>();         int n = nums.length;         // to generate all subsets we need to iterate from 0 to 2^n         for (int i = 0; i < (1 << n); i++) {             List<Integer> subset = new ArrayList<>();             // for each i, check if jth bit is set or not             for (int j = 0; j < n; j++) {                 if ((i & (1 << j)) != 0) {                     // if jth bit is set add element to subset                     subset.add(nums[j]);                 }             }             result.add(subset);         }         return result;     } }",0,,0,0,0
"class Solution {     public boolean exist(char[][] board, String word) {         for (int i = 0; i < board.length; i++) {             for (int j = 0; j < board[0].length; j++) {                 if (dfs(board, i, j, word, 0)) {                     return true;                 }             }         }         return false;     }          // Depth-first search function to find the word in the grid     private boolean dfs(char[][] board, int i, int j, String word, int index) {         // If we've found the whole word, return true         if (index == word.length()) {             return true;         }                  // If we're out of bounds or the current character doesn't match,         // return false         if (i < 0 || i >= board.length || j < 0 || j >= board[0].length ||             board[i][j] != word.charAt(index)) {             return false;         }                  // Mark the current cell as visited         char temp = board[i][j];         board[i][j] = '#';                  // Go left, right, up, and down to search for the rest of the word         boolean found = dfs(board, i-1, j, word, index+1) || // Go up                        dfs(board, i+1, j, word, index+1) || // Go down                        dfs(board, i, j-1, word, index+1) || // Go left                        dfs(board, i, j+1, word, index+1);  // Go right                  // Unmark the current cell as visited to allow backtracking         board[i][j] = temp;                  return found;     } }",0,,0,0,0
class Solution {     public int removeDuplicates(int[] nums) {         int i = 0;         for (int n : nums) {             if (i < 2 || n > nums[i - 2]) {                 nums[i++] = n;             }         }         return i;     } },0,,0,0,0
"class Solution {     public boolean search(int[] nums, int target) {         int left = 0;         int right = nums.length - 1;                  while (left <= right) {             int mid = left + (right - left) / 2;                          if (nums[mid] == target) {                 return true;             }                          if (nums[left] == nums[mid] && nums[right] == nums[mid]) {                 left++;                 right--;             } else if (nums[left] <= nums[mid]) {                 if (nums[left] <= target && target < nums[mid]) {                     right = mid - 1;                 } else {                     left = mid + 1;                 }             } else {                 if (nums[mid] < target && target <= nums[right]) {                     left = mid + 1;                 } else {                     right = mid - 1;                 }             }         }                  return false;     } }",0,,0,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public ListNode deleteDuplicates(ListNode head) {         if(head==null)             return null;         ListNode prev=null;         ListNode curr=head;         while(curr!=null) {             boolean flag=false;             if(curr.next!=null && curr.val==curr.next.val)                 flag=true;             if(!flag) {                 if(prev==null) {                     prev=curr;                     head=curr;                 }                 else {                     prev.next=curr;                     prev=curr;                 }             }             curr=curr.next;         }         if(prev!=null)             prev.next=null;         return head;     } }",1,"082-remove-duplicates-from-sorted-list-ii/ListNode.java:25:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
082-remove-duplicates-from-sorted-list-ii/ListNode.java:25:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
082-remove-duplicates-from-sorted-list-ii/ListNode.java:24:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'head'
082-remove-duplicates-from-sorted-list-ii/ListNode.java:34:	NullAssignment:	Assigning an Object to null is a code smell.  Consider refactoring.
",0,1,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public ListNode partition(ListNode head, int x) {         ListNode dummy1 = new ListNode();         ListNode dummy2 = new ListNode();         ListNode curr1 = dummy1;         ListNode curr2 = dummy2;                  while (head != null) {             if (head.val < x) {                 curr1.next = head;                 curr1 = curr1.next;             } else {                 curr2.next = head;                 curr2 = curr2.next;             }             head = head.next;         }                  curr2.next = null;         curr1.next = dummy2.next;                  return dummy1.next;     } }",1,"086-partition-list/ListNode.java:26:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'head'
086-partition-list/ListNode.java:29:	NullAssignment:	Assigning an Object to null is a code smell.  Consider refactoring.
",0,1,0
"import java.util.*;  class Solution {     public List<Integer> grayCode(int n) {         List<Integer> grayCodeList = new ArrayList<>();          // Base case         grayCodeList.add(0);          // Generating gray code sequence for n bits         for (int i = 0; i < n; i++) {             int size = grayCodeList.size();              // Reflecting the existing list and adding 2^n to each element             for (int j = size - 1; j >= 0; j--) {                 grayCodeList.add(grayCodeList.get(j) + (int) Math.pow(2, i));             }         }          return grayCodeList;     } }",0,,0,0,0
"import java.util.ArrayList; import java.util.Arrays; import java.util.List;  class Solution {     public List<List<Integer>> subsetsWithDup(int[] nums) {         Arrays.sort(nums); // Sort the input array to handle duplicates         List<List<Integer>> result = new ArrayList<>();         backtracking(result, new ArrayList<>(), nums, 0);         return result;     }      private void backtracking(List<List<Integer>> result, List<Integer> temp, int[] nums, int start) {         result.add(new ArrayList<>(temp));          for (int i = start; i < nums.length; i++) { // Traverse the remaining elements             if (i > start && nums[i] == nums[i-1]) { // Skip duplicate elements                 continue;             }             temp.add(nums[i]); // Choose             backtracking(result, temp, nums, i+1); // Explore             temp.remove(temp.size()-1); // Un-choose         }     } }",0,,0,0,0
"class Solution {     public int numDecodings(String s) {         if(s == null || s.length() == 0 || s.charAt(0) == '0') {             return 0;         }         int n = s.length();         int[] dp = new int[n+1];         dp[0] = 1;         dp[1] = 1;         for(int i=2;i<=n;i++) {             // If the current character is not '0', we can form a new decoding by taking it as a single digit.             if(s.charAt(i-1) != '0') {                 dp[i] = dp[i-1];             }             // If the current and the previous characters can form a digit between 10-26, we can form a new decoding by taking them together.             int twoDigit = Integer.parseInt(s.substring(i-2, i));             if(twoDigit >= 10 && twoDigit <= 26){                 dp[i] += dp[i-2];             }         }         return dp[n];     } }",1,"091-decode-ways/Solution.java:10:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
",0,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public ListNode reverseBetween(ListNode head, int left, int right) {         if (head == null || head.next == null) {             return head;         }                  // create a dummy node to represent the head node         ListNode dummy = new ListNode(-1);         dummy.next = head;                  // find the left-1 node and the left node         ListNode preLeft = dummy;         ListNode leftNode = null;         for (int i = 0; i < left-1; i++) {             preLeft = preLeft.next;         }         leftNode = preLeft.next;                  // reverse the nodes from left to right         ListNode pre = leftNode;         ListNode cur = leftNode.next;         for (int i = left; i < right; i++) {             ListNode next = cur.next;             cur.next = pre;             pre = cur;             cur = next;         }         leftNode.next = cur;         preLeft.next = pre;                  return dummy.next;     } }",1,"092-reverse-linked-list-ii/ListNode.java:23:	UnusedAssignment:	The initializer for variable 'leftNode' is never used (overwritten on line 27)
",0,0,0
"import java.util.*;  class Solution {     public List<String> restoreIpAddresses(String s) {         List<String> res = new ArrayList<>();         dfs(res, s, """", 0, 0);         return res;     }          public void dfs(List<String> res, String s, String curr, int segment, int start) {         if (segment == 4 && start == s.length()) {             res.add(curr);             return;         }         if (segment == 4 || start == s.length()) return;                  for (int i = start; i < s.length(); i++) {             if (i != start && s.charAt(start) == '0') break;             String temp = s.substring(start, i+1);             if (Integer.parseInt(temp) > 255) break;             if (curr.isEmpty()) dfs(res, s, temp, segment+1, i+1);             else dfs(res, s, curr+"".""+temp, segment+1, i+1);         }     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */  class Solution {     public List<TreeNode> generateTrees(int n) {         if (n == 0) {             return new ArrayList<TreeNode>();         }         return buildTrees(1,n);     }          public List<TreeNode> buildTrees(int start, int end) {         List<TreeNode> result = new ArrayList<TreeNode>();         if (start > end) {             result.add(null);             return result;         }         for (int i = start; i <= end; i++) {             List<TreeNode> leftSubtrees = buildTrees(start, i-1);             List<TreeNode> rightSubtrees = buildTrees(i+1, end);             for (TreeNode left : leftSubtrees) {                 for (TreeNode right : rightSubtrees) {                     TreeNode root = new TreeNode(i);                     root.left = left;                     root.right = right;                     result.add(root);                 }             }         }         return result;     } }",0,,0,0,0
class Solution {     public int numTrees(int n) {         int[] dp = new int[n+1];         dp[0] = 1;         dp[1] = 1;         for(int i=2; i<=n; i++){             for(int j=0; j<i; j++){                 dp[i] += dp[j]*dp[i-j-1];             }         }         return dp[n];     } },0,,0,0,0
"class Solution {     public boolean isInterleave(String s1, String s2, String s3) {         int n1 = s1.length();         int n2 = s2.length();         int n = s3.length();         if(n1 + n2 != n)             return false;         boolean[][] dp = new boolean[n1+1][n2+1];                  for(int i = 0; i <= n1; i++){             for(int j = 0; j <= n2; j++){                 if(i == 0 && j == 0)                     dp[i][j] = true;                 else if(i == 0)                     dp[i][j] = dp[i][j-1] && (s2.charAt(j-1) == s3.charAt(i+j-1));                 else if(j == 0)                     dp[i][j] = dp[i-1][j] && (s1.charAt(i-1) == s3.charAt(i+j-1));                 else                     dp[i][j] = (dp[i-1][j] && s1.charAt(i-1) == s3.charAt(i+j-1)) || (dp[i][j-1] && s2.charAt(j-1) == s3.charAt(i+j-1));             }         }         return dp[n1][n2];     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {          public boolean isValidBST(TreeNode root) {         return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);     }          private boolean isValidBST(TreeNode root, long minVal, long maxVal) {         if (root == null) {             return true;         }                  if (root.val <= minVal || root.val >= maxVal) {             return false;         }                  return isValidBST(root.left, minVal, root.val) && isValidBST(root.right, root.val, maxVal);     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     private TreeNode prev, first, second;      public void recoverTree(TreeNode root) {         // initialize variables         prev = first = second = null;          // inorder traversal to detect the misplaced nodes         inorder(root);          // swap the values of the misplaced nodes         int temp = first.val;         first.val = second.val;         second.val = temp;     }      private void inorder(TreeNode curr) {         if (curr == null) {             return;         }          // traverse left         inorder(curr.left);          // check if the current node is misplaced         if (prev != null && prev.val > curr.val) {             // first misplaced node should be the larger one             // second misplaced node should be the smaller one             if (first == null) {                 first = prev;             }             second = curr;         }          prev = curr;          // traverse right         inorder(curr.right);     } }",1,"099-recover-binary-search-tree/TreeNode.java:17:5: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
099-recover-binary-search-tree/TreeNode.java:21:22: Inner assignments should be avoided. [InnerAssignment]
099-recover-binary-search-tree/TreeNode.java:21:31: Inner assignments should be avoided. [InnerAssignment]
099-recover-binary-search-tree/TreeNode.java:17:5: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
099-recover-binary-search-tree/TreeNode.java:21:22: Inner assignments should be avoided. [InnerAssignment]
099-recover-binary-search-tree/TreeNode.java:21:31: Inner assignments should be avoided. [InnerAssignment]
099-recover-binary-search-tree/TreeNode.java:17:	SingularField:	Perhaps 'second' could be replaced by a local variable.
099-recover-binary-search-tree/TreeNode.java:21:	NullAssignment:	Assigning an Object to null is a code smell.  Consider refactoring.
",1,0,0
class Solution {     public boolean isValid(String s) {                  //Declare an empty stack          Stack<Character> stack = new Stack<>();                  for(char c : s.toCharArray()) {                          if(c == 'c') { // If the character is 'c' then it should be preceded by 'b' and 'a' in the stack                                  if(stack.isEmpty() || stack.pop() != 'b') return false;                 if(stack.isEmpty() || stack.pop() != 'a') return false;             }              else { // If the character is 'a' or 'b' insert it to the stack                                  stack.push(c);             }         }                  return stack.isEmpty();     } },1,"1003-check-if-word-is-valid-after-substitutions/Solution.java:13:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1003-check-if-word-is-valid-after-substitutions/Solution.java:13:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
"class Solution {     public int longestOnes(int[] nums, int k) {         int max = 0, zeroCount = 0, left = 0;                  for (int right = 0; right < nums.length; right++) {             if (nums[right] == 0) {                 zeroCount++;             }                          while (zeroCount > k) {                 if (nums[left] == 0) {                     zeroCount--;                 }                 left++;             }                          max = Math.max(max, right - left + 1);         }                  return max;     } }",1,"1004-max-consecutive-ones-iii/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1004-max-consecutive-ones-iii/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
class Solution {     public int clumsy(int n) {         if(n == 1) return 1;         if(n == 2) return 2;         if(n == 3) return 6;         int result = n * (n-1) / (n-2);         int i = n-3;         while(i > 0) {             if(i-3 >= 0) result -= i * (i-1) / (i-2);             else {                 if(i == 2) result -= 2;                 else if(i == 1) result -= 1;             }             i -= 4;         }         return result;     } },0,,0,0,0
"class Solution {     public int minDominoRotations(int[] tops, int[] bottoms) {                  int[] topsCount = new int[7];         int[] bottomsCount = new int[7];         int[] sameCount = new int[7];         int n = tops.length;         for(int i = 0; i < n; i++){             topsCount[tops[i]]++;             bottomsCount[bottoms[i]]++;             if(tops[i] == bottoms[i]){                 sameCount[tops[i]]++;             }         }         for(int i = 1; i <= 6; i++){             if(topsCount[i] + bottomsCount[i] - sameCount[i] == n){                 return n - Math.max(topsCount[i], bottomsCount[i]);             }         }         return -1;     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public TreeNode bstFromPreorder(int[] preorder) {         if (preorder == null || preorder.length == 0) {             return null;         }         return bstFromPreorder(preorder, 0, preorder.length - 1);     }          private TreeNode bstFromPreorder(int[] preorder, int start, int end) {         if (start > end) {             return null;         }         TreeNode root = new TreeNode(preorder[start]);         if (start == end) {             return root;         }         int i;         for (i = start + 1; i <= end; i++) {             if (preorder[i] > root.val) {                 break;             }         }         root.left = bstFromPreorder(preorder, start + 1, i - 1);         root.right = bstFromPreorder(preorder, i, end);         return root;     } }",0,,0,0,0
public class Solution {     public int numPairsDivisibleBy60(int[] time) {         int count = 0;         int[] mod = new int[60]; // store the frequency of remainder                  for(int t : time) {             int remainder = t % 60;             int seek = (60 - remainder) % 60;             // check how many counter-part songs there are.             count += mod[seek];              // update the frequency of current remainder             mod[remainder] += 1;         }         return count;     } },0,,0,0,0
"class Solution {     public int shipWithinDays(int[] weights, int days) {         int maxWeight = 0;         int sumWeight = 0;         for(int weight: weights) {             sumWeight += weight;             maxWeight = Math.max(maxWeight, weight);         }         int left = maxWeight;         int right = sumWeight;                  while(left<right){             int mid = left + (right-left)/2;             int tempWeight = 0;             int tempDays = 1;             for(int weight: weights){                 if(tempWeight+weight>mid){                     tempDays++;                     tempWeight = weight;                 } else {                     tempWeight += weight;                 }             }                          if(tempDays>days){                 left = mid+1;             } else {                 right = mid;             }         }         return left;     } }",0,,0,0,0
"class Solution {     public int maxScoreSightseeingPair(int[] values) {         int maxScore = 0;         int maxLeftValue = values[0];                  for (int j = 1; j < values.length; j++) {             maxScore = Math.max(maxScore, maxLeftValue + values[j] - j);             maxLeftValue = Math.max(maxLeftValue, values[j] + j);         }                  return maxScore;     } }",0,,0,0,0
class Solution {     public int smallestRepunitDivByK(int k) {         if (k == 1) {             return 1;         }         int remainder = 0;         for (int length = 1; length <= k; length++) {             remainder = (remainder * 10 + 1) % k;             if (remainder == 0) {                 return length;             }         }         return -1;     } },0,,0,0,0
"class Solution {     public boolean queryString(String s, int n) {                  // loop through the range [1...n]         for(int i=1;i<=n;i++){             // get the binary representation of i             String binary = Integer.toBinaryString(i);             // check if the binary representation is a substring of s             if(!s.contains(binary)){                 return false;             }         }                  return true;     } }",0,,0,0,0
"class Solution {     public String baseNeg2(int n) {         if(n == 0) {    // special case when n is zero             return ""0"";         }                  StringBuilder sb = new StringBuilder();     // to build the binary string         while(n != 0) {     // keep dividing until quotient is zero             int remainder = n % (-2);     // use the negative base value (-2) to calculate remainder             n /= -2;        // divide with negative base value (-2)                          if(remainder < 0) {     // if remainder is negative, add 2 to make it positive                 remainder += 2;                 n += 1;     // carry 1 to next bit             }                          sb.insert(0, remainder);    // append remainder at the beginning of string         }                  return sb.toString();     } }",1,"1017-convert-to-base-2/Solution.java:10:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
",0,1,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public int[] nextLargerNodes(ListNode head) {         // First, count the number of nodes in the list         int count = 0;         ListNode current = head;         while (current != null) {             count++;             current = current.next;         }                  // Create an integer array to store the answer         int[] answer = new int[count];         Arrays.fill(answer, 0);                  // Use a stack to keep track of nodes with potential larger values         Stack<Integer> stack = new Stack<>();         int index = 0;                  // Traverse the list         current = head;         while (current != null) {             // If the current node's value is larger than the top of the stack,             // it is the next greater node for all nodes in the stack.             while (!stack.isEmpty() && current.val > answer[stack.peek()]) {                 answer[stack.pop()] = current.val;             }                          // Add the current node to the stack.             stack.push(index);             index++;             current = current.next;         }                  return answer;     } }",0,,0,0,0
"import java.util.*;  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public List<List<Integer>> levelOrder(TreeNode root) {         List<List<Integer>> result = new ArrayList<>();         if (root == null)             return result;                  Queue<TreeNode> queue = new LinkedList<>();         queue.add(root);                  while (!queue.isEmpty()) {             int levelSize = queue.size();             List<Integer> currentLevel = new ArrayList<>();             for (int i = 0; i < levelSize; i++) {                 TreeNode currentNode = queue.poll();                 currentLevel.add(currentNode.val);                 if (currentNode.left != null)                     queue.add(currentNode.left);                 if (currentNode.right != null)                     queue.add(currentNode.right);             }             result.add(currentLevel);         }                  return result;     } }",0,,0,0,0
"class Solution {     public int numEnclaves(int[][] grid) {         int n = grid.length;         int m = grid[0].length;         for(int i=0;i<n;i++)         {             if(grid[i][0]==1)             {                 DFS(grid,i,0);             }             if(grid[i][m-1]==1)             {                 DFS(grid,i,m-1);             }         }         for(int j=0;j<m;j++)         {             if(grid[0][j]==1)             {                 DFS(grid,0,j);             }             if(grid[n-1][j]==1)             {                 DFS(grid,n-1,j);             }         }         int res = 0;         for(int i=0;i<n;i++)         {             for(int j=0;j<m;j++)             {                 if(grid[i][j]==1)                 {                     res++;                 }             }         }         return res;     }     public void DFS(int[][] grid,int i,int j)     {         int n = grid.length;         int m = grid[0].length;         if(i<0 || i>=n || j<0 || j>=m || grid[i][j]!=1)         {             return;         }         grid[i][j] = -1;         DFS(grid,i+1,j);         DFS(grid,i-1,j);         DFS(grid,i,j+1);         DFS(grid,i,j-1);     } }",1,"1020-number-of-enclaves/Solution.java:6:9: '{' at column 9 should be on the previous line. [LeftCurly]
1020-number-of-enclaves/Solution.java:8:13: '{' at column 13 should be on the previous line. [LeftCurly]
1020-number-of-enclaves/Solution.java:12:13: '{' at column 13 should be on the previous line. [LeftCurly]
1020-number-of-enclaves/Solution.java:17:9: '{' at column 9 should be on the previous line. [LeftCurly]
1020-number-of-enclaves/Solution.java:19:13: '{' at column 13 should be on the previous line. [LeftCurly]
1020-number-of-enclaves/Solution.java:23:13: '{' at column 13 should be on the previous line. [LeftCurly]
1020-number-of-enclaves/Solution.java:29:9: '{' at column 9 should be on the previous line. [LeftCurly]
1020-number-of-enclaves/Solution.java:31:13: '{' at column 13 should be on the previous line. [LeftCurly]
1020-number-of-enclaves/Solution.java:33:17: '{' at column 17 should be on the previous line. [LeftCurly]
1020-number-of-enclaves/Solution.java:41:5: '{' at column 5 should be on the previous line. [LeftCurly]
1020-number-of-enclaves/Solution.java:45:9: '{' at column 9 should be on the previous line. [LeftCurly]
1020-number-of-enclaves/Solution.java:6:9: '{' at column 9 should be on the previous line. [LeftCurly]
1020-number-of-enclaves/Solution.java:8:13: '{' at column 13 should be on the previous line. [LeftCurly]
1020-number-of-enclaves/Solution.java:12:13: '{' at column 13 should be on the previous line. [LeftCurly]
1020-number-of-enclaves/Solution.java:17:9: '{' at column 9 should be on the previous line. [LeftCurly]
1020-number-of-enclaves/Solution.java:19:13: '{' at column 13 should be on the previous line. [LeftCurly]
1020-number-of-enclaves/Solution.java:23:13: '{' at column 13 should be on the previous line. [LeftCurly]
1020-number-of-enclaves/Solution.java:29:9: '{' at column 9 should be on the previous line. [LeftCurly]
1020-number-of-enclaves/Solution.java:31:13: '{' at column 13 should be on the previous line. [LeftCurly]
1020-number-of-enclaves/Solution.java:33:17: '{' at column 17 should be on the previous line. [LeftCurly]
1020-number-of-enclaves/Solution.java:41:5: '{' at column 5 should be on the previous line. [LeftCurly]
1020-number-of-enclaves/Solution.java:45:9: '{' at column 9 should be on the previous line. [LeftCurly]
1020-number-of-enclaves/Solution.java:40:	MethodNamingConventions:	The instance method name 'DFS' doesn't match '[a-z][a-zA-Z0-9]*'
",0,0,0
"import java.util.ArrayList; import java.util.List;  class Solution {     public List<Boolean> camelMatch(String[] queries, String pattern) {         List<Boolean> result = new ArrayList<>();          for (String query : queries) {             int i = 0;             boolean match = true;              for (char ch : query.toCharArray()) {                 if (i < pattern.length() && ch == pattern.charAt(i)) {                     i++;                 } else if (ch >= 'A' && ch <= 'Z') {                     match = false;                     break;                 }             }              if (i != pattern.length()) {                 match = false;             }              result.add(match);         }          return result;     } }",0,,0,0,0
"class Solution {     public int videoStitching(int[][] clips, int time) {         // Sort clips array based on their starting time         Arrays.sort(clips, (a, b) -> Integer.compare(a[0], b[0]));          // Initialize variables         int end = 0, furthest = 0, count = 0;          // Loop through clips array         for (int[] clip : clips) {             // If clip starts after the furthest point or time has been covered             if (clip[0] > furthest || end >= time) {                 break; // We cannot reach the end from here             }                          // Update end to the maximum end of all clips starting before or at furthest point             while (count < clips.length && clips[count][0] <= furthest) {                 end = Math.max(end, clips[count][1]);                 count++;             }                          // If we have covered the time, return the count             if (end >= time) {                 return count;             }                          // If we cannot extend from this clip, we need to switch clips             if (end < clip[0]) {                 break;             }                          // Update furthest point to this clip's end             furthest = clip[1];         }                  return -1; // If we reach here, it means we cannot cover the time     } }",1,"1024-video-stitching/Solution.java:7:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1024-video-stitching/Solution.java:7:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     int maxDiff = 0;          public int maxAncestorDiff(TreeNode root) {         // call recursive function for root                 maxAncestorDiff(root, root.val, root.val);         return maxDiff;     }          private void maxAncestorDiff(TreeNode node, int maxAncestor, int minAncestor){         if(node == null)             return;         //update maxDiff if the difference between node.val and maxAncestor is greater         if(node.val - minAncestor > maxDiff)             maxDiff = node.val - minAncestor;                //update maxDiff if the difference between node.val and minAncestor is greater         else if(maxAncestor - node.val > maxDiff)             maxDiff = maxAncestor - node.val;                   //update maxAncestor and minAncestor values accordingly.         //call the recursive function for left and right subtrees         maxAncestor = Math.max(maxAncestor, node.val);         minAncestor = Math.min(minAncestor, node.val);                  maxAncestorDiff(node.left, maxAncestor, minAncestor);         maxAncestorDiff(node.right, maxAncestor, minAncestor);     } }",1,"1026-maximum-difference-between-node-and-ancestor/TreeNode.java:17:9: Variable 'maxDiff' must be private and have accessor methods. [VisibilityModifier]
1026-maximum-difference-between-node-and-ancestor/TreeNode.java:17:9: Variable 'maxDiff' must be private and have accessor methods. [VisibilityModifier]
1026-maximum-difference-between-node-and-ancestor/TreeNode.java:37:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'maxAncestor'
1026-maximum-difference-between-node-and-ancestor/TreeNode.java:38:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'minAncestor'
",0,1,0
"class Solution {     public int longestArithSeqLength(int[] nums) {         int n = nums.length;         int[][] dp = new int[n][1001];         int res = 2;         for (int i = 0; i < n; i++) {             for (int j = 0; j < i; j++) {                 int diff = nums[i] - nums[j] + 500;                 dp[i][diff] = dp[j][diff] + 1;                 res = Math.max(res, dp[i][diff] + 1);             }         }         return res;     } }",0,,0,0,0
"class Solution {     public int twoCitySchedCost(int[][] costs) {         // Sort the arrays by the difference of cost to minimize expense          Arrays.sort(costs, (a, b) -> (a[0] - a[1]) - (b[0] - b[1]));                  int n = costs.length;         int minCost = 0;                  // Calculate the minimum cost         for (int i = 0; i < n / 2; i++) {             minCost += costs[i][0] + costs[i + n / 2][1];         }                  return minCost;     } }",1,"1029-two-city-scheduling/Solution.java:4:	UselessParentheses:	Useless parentheses.
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public List<List<Integer>> zigzagLevelOrder(TreeNode root) {         List<List<Integer>> zigzagOrder = new ArrayList<>();         if (root == null) {             return zigzagOrder;         }         Queue<TreeNode> nodeQueue = new LinkedList<>();         nodeQueue.offer(root);         boolean leftToRight = true;         while (!nodeQueue.isEmpty()) {             int size = nodeQueue.size();             List<Integer> levelOrder = new ArrayList<>(size);             for (int i = 0; i < size; i++) {                 TreeNode node = nodeQueue.poll();                 if (leftToRight) {                     levelOrder.add(node.val);                 } else {                     levelOrder.add(0, node.val);                 }                 if (node.left != null) {                     nodeQueue.offer(node.left);                 }                 if (node.right != null) {                     nodeQueue.offer(node.right);                 }             }             zigzagOrder.add(levelOrder);             leftToRight = !leftToRight;         }         return zigzagOrder;     } }",0,,0,0,0
"class Solution {     public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {         int[] prefixSum = new int[nums.length + 1];         for (int i = 0; i < nums.length; i++) {             prefixSum[i + 1] = prefixSum[i] + nums[i];         }         int maxSum = 0;         for (int i = firstLen, j = secondLen; i + j <= nums.length; i++, j++) {             int firstSum = prefixSum[i] - prefixSum[0];             int secondSum = prefixSum[j] - prefixSum[i];             int thirdSum = prefixSum[nums.length] - prefixSum[j];             for (int k = firstLen + secondLen; k <= nums.length; k++) {                 int tempSum = Math.max(firstSum + prefixSum[k] - prefixSum[i], secondSum + prefixSum[k] - prefixSum[j]);                 maxSum = Math.max(maxSum, tempSum + thirdSum - (prefixSum[k] - prefixSum[firstLen + secondLen]));             }         }         return maxSum;     } }",1,"1031-maximum-sum-of-two-non-overlapping-subarrays/Solution.java:8:	ForLoopVariableCount:	Too many control variables in the for statement
",0,0,0
"class Solution {     public int[] numMovesStones(int a, int b, int c) {         // Sort the stones in ascending order         int[] stones = {a, b, c};         Arrays.sort(stones);                  // Calculate minimum moves         int minMoves = 0;         if (stones[1] - stones[0] == 1 && stones[2] - stones[1] == 1) {             // Stones are already in consecutive positions             minMoves = 0;         } else if (stones[1] - stones[0] <= 2 || stones[2] - stones[1] <= 2) {             // Move any stone to the middle of the other two             minMoves = 1;         } else {             // Move one stone to the middle of the other two, and then move the other stone to the middle             minMoves = 2;         }                  // Calculate maximum moves         int maxMoves = (stones[2] - stones[0]) - 2;                  // Return result         return new int[]{minMoves, maxMoves};     } }",1,"1033-moving-stones-until-consecutive/Solution.java:8:	UnusedAssignment:	The initializer for variable 'minMoves' is never used (overwritten on lines 11, 14 and 17)
1033-moving-stones-until-consecutive/Solution.java:21:	UselessParentheses:	Useless parentheses.
",0,0,0
"class Solution {     public int[][] colorBorder(int[][] grid, int row, int col, int color) {         int m = grid.length;         int n = grid[0].length;         boolean[][] visited = new boolean[m][n]; // to keep track of visited cells         dfs(grid, row, col, visited, grid[row][col]);         for(int i=0; i<m; i++) {             for(int j=0; j<n; j++) {                 if(visited[i][j]) { // if the cell is visited                     if(i==0 || i==m-1 || j==0 || j==n-1 || grid[i-1][j]==-1 || grid[i][j-1]==-1 || grid[i+1][j]==-1 || grid[i][j+1]==-1) {                         // if it's a cell in the border or the adjacent cells are outside the border, change the color                         grid[i][j] = color;                     }                 }             }         }         return grid;     }          public void dfs(int[][] grid, int row, int col, boolean[][] visited, int targetColor) {         int m = grid.length;         int n = grid[0].length;         int[][] directions = {{-1,0},{0,1},{1,0},{0,-1}}; // up, right, down, left         if(row<0 || col<0 || row>=m || col>=n) return; // if index out of bounds         if(visited[row][col]) return; // if cell is already visited         if(grid[row][col]!=targetColor) return; // if cell color is not the same as the targetColor         visited[row][col] = true; // mark cell as visited         int cnt = 0; // count of adjacent cells with the same color         for(int[] dir: directions) {             int r = row + dir[0];             int c = col + dir[1];             if(r>=0 && c>=0 && r<m && c<n && grid[r][c]==targetColor) {                 cnt++;             }         }         if(cnt<4) { // if the cell is a border cell             grid[row][col] = -1; // mark the cell as -1 (to differentiate it from the cells inside the connected component)         }         for(int[] dir: directions) {             dfs(grid, row+dir[0], col+dir[1], visited, targetColor); // recursive call on the neighbors         }     } }",1,"1034-coloring-a-border/Solution.java:10:	CollapsibleIfStatements:	This if statement could be combined with its parent
1034-coloring-a-border/Solution.java:20:	NPathComplexity:	The method 'dfs(int[][], int, int, boolean[][], int)' has an NPath complexity of 560, current threshold is 200
1034-coloring-a-border/Solution.java:23:	PrematureDeclaration:	Declaration of 'directions' can be moved closer to its usages
",0,0,0
"class Solution {     public int maxUncrossedLines(int[] nums1, int[] nums2) {         int[][] dp = new int[nums1.length + 1][nums2.length + 1];         for (int i = 1; i <= nums1.length; i++) {             for (int j = 1; j <= nums2.length; j++) {                 if (nums1[i - 1] == nums2[j - 1]) {                     dp[i][j] = dp[i - 1][j - 1] + 1;                 } else {                     dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);                 }             }         }         return dp[nums1.length][nums2.length];     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {          private int sum = 0;          public TreeNode bstToGst(TreeNode root) {         if(root == null) return null;         // traverse right subtree first         bstToGst(root.right);         // update value of current node         root.val += sum;         sum = root.val;         // traverse left subtree         bstToGst(root.left);         return root;     }      }",0,,0,0,0
"class Solution {     public int minScoreTriangulation(int[] values) {         int n = values.length;         int[][] dp = new int[n][n];         for (int gap = 2; gap < n; gap++) {             for (int i = 0, j = gap; j < n; i++, j++) {                 dp[i][j] = Integer.MAX_VALUE;                 for (int k = i + 1; k < j; k++) {                     dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j] + (values[i] * values[j] * values[k]));                 }             }         }         return dp[0][n-1];     } }",1,"1039-minimum-score-triangulation-of-polygon/Solution.java:6:	ForLoopVariableCount:	Too many control variables in the for statement
",0,0,0
"class Solution {     public int[] numMovesStonesII(int[] stones) {         Arrays.sort(stones);   //sorting array         int n = stones.length, i = 0, mini = n;   //initializing variables         int maxi = Math.max(stones[n - 1] - n + 2 - stones[1], stones[n - 2] - stones[0] - n + 2);         for (int j = 0; j < n; ++j) {             while (stones[j] - stones[i] >= n)   //removing smallest stone                  ++i;             if (j - i + 1 == n - 1 && stones[j] - stones[i] == n - 2)  //checking end                  mini = Math.min(mini, 2);             else                 mini = Math.min(mini, n - (j - i + 1));   //finding minimum moves         }         return new int[] { mini, maxi };     } }",1,"1040-moving-stones-until-consecutive-ii/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1040-moving-stones-until-consecutive-ii/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public boolean isRobotBounded(String instructions) {                  // Initialize robot orientation         int x = 0, y = 0;         int currDir = 0;    // 0 - North, 1 - East, 2 - South, 3 - West                  // Initialize robot movements         int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};    // North, East, South, West         int i = 0;                  // Execute robot instructions         while (i < instructions.length()) {             char c = instructions.charAt(i);             if (c == 'G') {                 x += directions[currDir][0];                 y += directions[currDir][1];             } else if (c == 'L') {                 currDir = (currDir + 3) % 4;    // +3 => 90 degrees anti-clockwise             } else if (c == 'R') {                 currDir = (currDir + 1) % 4;    // +1 => 90 degrees clockwise             }             i++;         }                  // Check if robot returns to initial position, or if robot ends up facing in a different direction         return ((x == 0 && y == 0) || (currDir != 0));     } }",1,"1041-robot-bounded-in-circle/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1041-robot-bounded-in-circle/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1041-robot-bounded-in-circle/Solution.java:27:	UselessParentheses:	Useless parentheses.
",1,0,0
"class Solution {     public int[] gardenNoAdj(int n, int[][] paths) {         List<List<Integer>> adjacency = new ArrayList<>();                  // creating adjacency list         for (int i = 0; i < n; i++) {             adjacency.add(new ArrayList<>());         }                  for (int[] path : paths) {             adjacency.get(path[0] - 1).add(path[1] - 1);             adjacency.get(path[1] - 1).add(path[0] - 1);         }                  // creating the answer array         int[] answer = new int[n];         Arrays.fill(answer, -1);                  // assigning flower types         for (int i = 0; i < n; i++) {             boolean[] usedFlowerTypes = new boolean[5]; // 1 to 4 inclusive                          for (Integer adjacentNode : adjacency.get(i)) {                 if (answer[adjacentNode] != -1) {                     usedFlowerTypes[answer[adjacentNode]] = true;                 }             }                          for (int j = 1; j <= 4; j++) {                 if (!usedFlowerTypes[j]) {                     answer[i] = j;                     break;                 }             }         }                  return answer;     } }",0,,0,0,0
"class Solution {     public int maxSumAfterPartitioning(int[] arr, int k) {         int n = arr.length;         int[] dp = new int[n];         for(int i=0;i<n;i++){             int max = Integer.MIN_VALUE;             for(int j=1;j<=k && i-j+1>=0;j++){                 max = Math.max(max,arr[i-j+1]);                 dp[i] = Math.max(dp[i],(i-j>=0?dp[i-j]:0) + max*j);             }         }         return dp[n-1];     } }",0,,0,0,0
"class Solution {     public int longestStrChain(String[] words) {         Map<String, Integer> dp = new HashMap<>();         List<String>[] bucket = new ArrayList[17];         int res = 1;         for (int i = 0; i < 17; i++) {             bucket[i] = new ArrayList<>();         }         for (String word : words) {             dp.put(word, 1);             bucket[word.length()].add(word);         }         for (int i = 2; i <= 16; i++) {             for (String word : bucket[i]) {                 for (int j = 0; j < word.length(); j++) {                     String prev = word.substring(0, j) + word.substring(j + 1);                     if (dp.containsKey(prev)) {                         dp.put(word, Math.max(dp.get(word), dp.get(prev) + 1));                     }                 }                 res = Math.max(res, dp.get(word));             }         }         return res;     } }",0,,0,0,0
"class Solution {     public int lastStoneWeightII(int[] stones) {         Set<Integer> set = new HashSet<>();         set.add(0);         int sum = 0;         for (int stone : stones) {             sum += stone;             Set<Integer> nextSet = new HashSet<>();             for (int prevSum : set) {                 nextSet.add(prevSum + stone);                 nextSet.add(prevSum - stone);             }             set = nextSet;         }         int minDiff = Integer.MAX_VALUE;         for (int stoneWeight : set) {             minDiff = Math.min(minDiff, Math.abs(sum - 2 * stoneWeight));         }         return minDiff;     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public TreeNode buildTree(int[] preorder, int[] inorder) {                  return build(preorder, inorder, 0, preorder.length - 1, 0, inorder.length - 1);     }          private TreeNode build(int[] preorder, int[] inorder, int pre_start, int pre_end, int in_start, int in_end) {         if (pre_start > pre_end || in_start > in_end)             return null;                  int root_val = preorder[pre_start];         int inorder_index = -1;                  for (int i = in_start; i <= in_end; i++) {             if (inorder[i] == root_val) {                 inorder_index = i;                 break;             }         }                  int left_subtree_size = inorder_index - in_start;                  TreeNode root = new TreeNode(root_val);         root.left = build(preorder, inorder, pre_start + 1, pre_start + left_subtree_size, in_start, inorder_index - 1);         root.right = build(preorder, inorder, pre_start + left_subtree_size + 1, pre_end, inorder_index + 1, in_end);                  return root;     } }",0,,0,0,0
"class Solution {     public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {         int maxSatisfied = 0;         int n = customers.length;         int satisfiedWithoutGrumpy = 0;         int satisfiedWithGrumpy = 0;         int windowStart = 0;         int windowEnd;                  for (windowEnd = 0; windowEnd < n; windowEnd++) {             if (grumpy[windowEnd] == 0) {                 satisfiedWithoutGrumpy += customers[windowEnd];             } else {                 satisfiedWithGrumpy += customers[windowEnd];             }                          if (windowEnd - windowStart == minutes - 1) {                 maxSatisfied = Math.max(maxSatisfied, satisfiedWithoutGrumpy + satisfiedWithGrumpy);                                  if (grumpy[windowStart] == 1) {                     satisfiedWithGrumpy -= customers[windowStart];                 } else {                     satisfiedWithoutGrumpy -= customers[windowStart];                 }                 windowStart++;             }         }                  return Math.max(maxSatisfied, satisfiedWithoutGrumpy + satisfiedWithGrumpy);     } }",0,,0,0,0
"class Solution {     public int[] prevPermOpt1(int[] arr) {         int n = arr.length - 1;                  // Find index of first decreasing element from end         int i = n - 1;         while (i >= 0 && arr[i] <= arr[i+1]) {             i--;         }                  // If array is already sorted in decreasing order, return the same array         if (i < 0) {             return arr;         }                  // Find index of largest element that is smaller than arr[i]         int j = n;         while (j > i && arr[j] >= arr[i]) {             j--;         }                  // Swap arr[i] and arr[j]         int temp = arr[i];         arr[i] = arr[j];         arr[j] = temp;                  return arr;     } }",0,,0,0,0
"class Solution {     public int[] rearrangeBarcodes(int[] barcodes) {         int n = barcodes.length;         Map<Integer,Integer> freq = new HashMap<>();         PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->(b[1]-a[1]));                  for(int b: barcodes) freq.put(b, freq.getOrDefault(b,0)+1);         for(int k: freq.keySet()) pq.offer(new int[]{k, freq.get(k)});                  int[] ans = new int[n];         int i=0;                  while(!pq.isEmpty()){             int[] curr = pq.poll();             for(int j=0;j<curr[1];j++){                 ans[i] = curr[0];                 i+=2;                 if(i>=n) i=1;             }         }         return ans;     } }",1,"1054-distant-barcodes/Solution.java:5:	UselessParentheses:	Useless parentheses.
1054-distant-barcodes/Solution.java:13:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
1054-distant-barcodes/Solution.java:15:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public TreeNode buildTree(int[] inorder, int[] postorder) {         int n = inorder.length;         Map<Integer, Integer> map = new HashMap<>();         for (int i = 0; i < n; i++) {             map.put(inorder[i], i);         }         return buildTreeHelper(inorder, postorder, map, n-1, 0, n-1);     }          private TreeNode buildTreeHelper(int[] inorder, int[] postorder, Map<Integer, Integer> map, int postEnd, int inStart, int inEnd) {         if (inStart > inEnd) {             return null;         }                  int nodeVal = postorder[postEnd];         TreeNode node = new TreeNode(nodeVal);                  int index = map.get(nodeVal);         int rightSubtreeSize = inEnd - index;         int leftSubtreeSize = index - inStart;                  node.right = buildTreeHelper(inorder, postorder, map, postEnd-1, index+1, inEnd);         node.left = buildTreeHelper(inorder, postorder, map, postEnd-rightSubtreeSize-1, inStart, index-1);                  return node;     } }",1,"106-construct-binary-tree-from-inorder-and-postorder-traversal/TreeNode.java:36:	UnusedLocalVariable:	Avoid unused local variables such as 'leftSubtreeSize'.
",0,0,0
"class Solution {     public String smallestEquivalentString(String s1, String s2, String baseStr) {         int[] parent = new int[26];         for(int i=0; i<26; i++){             parent[i] = i;         }         for(int i=0; i<s1.length(); i++){             int p1 = find(parent, s1.charAt(i) - 'a');             int p2 = find(parent, s2.charAt(i) - 'a');             if(p1 != p2){                 parent[p1] = p2;             }         }         StringBuilder sb = new StringBuilder();         for(int i=0; i<baseStr.length(); i++){             char c = (char)('a' + find(parent, baseStr.charAt(i) - 'a'));             sb.append(c);         }         return sb.toString();     }          private int find(int[] parent, int i){         if(parent[i] == i){             return i;         }         parent[i] = find(parent, parent[i]);         return parent[i];     } }",0,,0,0,0
"import java.util.*;  public class Solution {     public List<List<Integer>> levelOrderBottom(TreeNode root) {          List<List<Integer>> result = new ArrayList<>(); // list to store the final result                  if(root == null) {             return result;         }                  Queue<TreeNode> queue = new LinkedList<>(); // queue to perform level order traversal         queue.offer(root);                  while(!queue.isEmpty()) {             int size = queue.size(); // size of each level                          List<Integer> levelList = new ArrayList<>(); // list to store the nodes at each level                          for(int i=0; i<size; i++) {                 TreeNode curr = queue.poll();                 levelList.add(curr.val);                                  if(curr.left != null) {                     queue.offer(curr.left);                 }                                  if(curr.right != null) {                     queue.offer(curr.right);                 }             }                          result.add(0, levelList); // add the nodes from current level to the front of the list         }                  return result;     } }",0,,0,0,0
"class Solution {     public int maxEqualRowsAfterFlips(int[][] matrix) {         Map<String, Integer> countMap = new HashMap<>();         int maxCount = 0;         for(int i=0; i<matrix.length; i++) {             StringBuilder sb1 = new StringBuilder();             StringBuilder sb2 = new StringBuilder();             for(int j=0; j<matrix[0].length; j++) {                 sb1.append(matrix[i][j]);                 sb2.append(1-matrix[i][j]);             }             String key = sb1.toString();             countMap.put(key, countMap.getOrDefault(key, 0)+1);             key = sb2.toString();             countMap.put(key, countMap.getOrDefault(key, 0)+1);         }                  for(Map.Entry<String, Integer> entry : countMap.entrySet()) {             maxCount = Math.max(maxCount, entry.getValue());         }         return maxCount;     } }",1,"1072-flip-columns-for-maximum-number-of-equal-rows/Solution.java:5:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int[] addNegabinary(int[] arr1, int[] arr2) {         int i = arr1.length - 1, j = arr2.length - 1, carry = 0;         Stack<Integer> stack = new Stack<>();          while (i >= 0 || j >= 0 || carry != 0) {             if (i >= 0) carry += arr1[i--];             if (j >= 0) carry += arr2[j--];             stack.push(carry & 1);             carry = -(carry >> 1);         }          while (stack.size() > 1 && stack.peek() == 0) stack.pop();                  int[] result = new int[stack.size()];         int index = 0;                  while (!stack.isEmpty()) {             result[index++] = stack.pop();         }                  return result;     } }",1,"1073-adding-two-negabinary-numbers/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1073-adding-two-negabinary-numbers/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int numTilePossibilities(String tiles) {         Map<Character, Integer> map = new HashMap<>();         for (char c : tiles.toCharArray()) {             map.put(c, map.getOrDefault(c, 0) + 1);         }         return dfs(map); // recursion starts here     }          private int dfs(Map<Character, Integer> map) {         int count = 0;         for (char c : map.keySet()) {             int freq = map.get(c);             if (freq == 0) {                 continue; // skip if the letter is used up              }             count++; // count for each possible sequence using current letter             map.put(c, freq - 1); // use up the current letter             count += dfs(map); // recursion with remaining letters             map.put(c, freq); // backtrack to reuse the current letter         }         return count;     } }   // Example usage class Main {     public static void main(String[] args) {         String tiles = ""AAABBC"";         Solution solution = new Solution();         int count = solution.numTilePossibilities(tiles);         System.out.println(count); // Output: 188     } }",1,"1079-letter-tile-possibilities/Solution.java:27:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
1079-letter-tile-possibilities/Solution.java:27:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
1079-letter-tile-possibilities/Solution.java:27:	UseUtilityClass:	This utility class has a non-private constructor
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public TreeNode sufficientSubset(TreeNode root, int limit) {         if (root == null) { //base case             return null;         }         if (root.left == null && root.right == null) { //if it's a leaf and the value is insufficient, remove the node.             if (root.val < limit) {                 return null;             }             return root;         }         TreeNode left = sufficientSubset(root.left, limit - root.val); //compute the tree without the root         TreeNode right = sufficientSubset(root.right, limit - root.val); //compute the tree without the root         if (left == null && right == null) { //if both branches failed, return null.             return null;         }         root.left = left; //assign the computed left subtree         root.right = right; //assign the computed right subtree         return root;      } }",0,,0,0,0
"class Solution {     public String smallestSubsequence(String s) {         int[] count = new int[26];         boolean[] visited = new boolean[26];         char[] result = new char[s.length()];         int pos = 0;                  // populating the count array with character counts         for(char c : s.toCharArray()){             count[c-'a']++;         }                  for(char c : s.toCharArray()){             // decrementing the count of each character             count[c-'a']--;                          if(visited[c-'a']){                 continue;             }                          while(pos>0 && c<result[pos-1] && count[result[pos-1]-'a']>0){                 visited[result[--pos]-'a'] = false;             }                          result[pos++] = c;             visited[c-'a'] = true;         }                  return new String(result, 0, pos);     } }",0,,0,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public TreeNode sortedListToBST(ListNode head) {         if (head == null) {             return null;         }         if (head.next == null) {             return new TreeNode(head.val);         }         ListNode slow = head;         ListNode fast = head;         ListNode prev = null;         while (fast != null && fast.next != null) {             prev = slow;             slow = slow.next;             fast = fast.next.next;         }         prev.next = null;         TreeNode root = new TreeNode(slow.val);         root.left = sortedListToBST(head);         root.right = sortedListToBST(slow.next);         return root;     } }",1,"109-convert-sorted-list-to-binary-search-tree/ListNode.java:42:	NullAssignment:	Assigning an Object to null is a code smell.  Consider refactoring.
",0,0,0
"import java.util.HashMap; import java.util.PriorityQueue;  class Solution {     public int largestValsFromLabels(int[] values, int[] labels, int numWanted, int useLimit) {         // Create a HashMap to store the count of each label         HashMap<Integer, Integer> countMap = new HashMap<>();                  // Create a PriorityQueue to find the maximum value         PriorityQueue<Integer> valueQueue = new PriorityQueue<>((a, b) -> b - a);                  int n = values.length;         int score = 0;                  // Traverse through each item         for(int i = 0; i < n; i++) {             // If the count of the label for the current item is less than the useLimit             if(countMap.getOrDefault(labels[i], 0) < useLimit) {                 // Add the value to the score and update the count of the label                 score += values[i];                 countMap.put(labels[i], countMap.getOrDefault(labels[i], 0) + 1);                 valueQueue.add(values[i]);             }         }                  // Traverse through the remaining items to find the maximum value         while(numWanted > countMap.size() && !valueQueue.isEmpty()) {             int currentValue = valueQueue.poll();             score += currentValue;         }                  return score;     } }",1,"1090-largest-values-from-labels/Solution.java:7:	LooseCoupling:	Avoid using implementation types like 'HashMap'; use the interface instead
1090-largest-values-from-labels/Solution.java:10:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
",0,0,0
"import java.util.*;  class Solution {     int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}, {-1, -1}, {1, -1}, {-1, 1}, {1, 1}};          public int shortestPathBinaryMatrix(int[][] grid) {         int n = grid.length;         if (grid[0][0] == 1 || grid[n-1][n-1] == 1) {             return -1;         }         Queue<int[]> queue = new LinkedList<>();         boolean[][] visited = new boolean[n][n];         queue.offer(new int[]{0, 0});         visited[0][0] = true;         int level = 1;         while (!queue.isEmpty()) {             int size = queue.size();             while (size-- > 0) {                 int[] curr = queue.poll();                 if (curr[0] == n-1 && curr[1] == n-1) {                     return level;                 }                 for (int[] direction : directions) {                     int r = curr[0] + direction[0];                     int c = curr[1] + direction[1];                     if (r >= 0 && c >= 0 && r < n && c < n && grid[r][c] == 0 && !visited[r][c]) {                         queue.offer(new int[]{r, c});                         visited[r][c] = true;                     }                 }             }             level++;         }         return -1;     } }",1,"1091-shortest-path-in-binary-matrix/Solution.java:4:13: Variable 'directions' must be private and have accessor methods. [VisibilityModifier]
1091-shortest-path-in-binary-matrix/Solution.java:4:13: Variable 'directions' must be private and have accessor methods. [VisibilityModifier]
",0,0,0
"class Solution {     public double[] sampleStats(int[] count) {                  int n = count.length;         double min = -1, max = -1, mean = 0, median = 0, mode = 0;         int size = 0, modeFreq = 0;         boolean medianFound = false;          for(int i = 0; i < n; i++){             if(count[i] > 0){                 if(min == -1) min = i; // Set min value                 max = i;  // Set max value                 size += count[i];  // Get total number of elements                 mean += i * count[i]; // Update mean value                 if(count[i] > modeFreq){ // Update mode value if new mode is found                     modeFreq = count[i];                     mode = i;                 }                 if(size % 2 == 0 && !medianFound){ // Get median value for even size                     int j = size / 2;                     int k = j + 1;                     int c1 = 0, c2 = 0;                     for(int l = 0; l < n; l++){                         c1 += count[l];                         if(!medianFound && c1 >= j){                             median += l;                             medianFound = true;                         }                          if(c1 >= k){                             median += l;                             median /= 2;                             break;                         }                     }                 } else if(size % 2 != 0){ // Get median value for odd size                     int j = size / 2 + 1;                     int c1 = 0;                     for(int l = 0; l < n; l++){                         c1 += count[l];                         if(c1 >= j){                             median = l;                             break;                         }                     }                 }             }         }          mean /= size; // Get final mean value          return new double[]{min, max, mean, median, mode};     } }",1,"1093-statistics-from-a-large-sample/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1093-statistics-from-a-large-sample/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1093-statistics-from-a-large-sample/Solution.java:22:21: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1093-statistics-from-a-large-sample/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1093-statistics-from-a-large-sample/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1093-statistics-from-a-large-sample/Solution.java:22:21: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1093-statistics-from-a-large-sample/Solution.java:22:	UnusedLocalVariable:	Avoid unused local variables such as 'c2'.
1093-statistics-from-a-large-sample/Solution.java:40:	AvoidDeeplyNestedIfStmts:	Deeply nested if..then statements are hard to read
",1,0,0
"class Solution {     public boolean carPooling(int[][] trips, int capacity) {         int[] stops = new int[1001];         //calculating total passengers at each stop         for(int[] trip : trips) {             stops[trip[1]] += trip[0];             stops[trip[2]] -= trip[0];         }         //checking the capacity at each stop         int passengers = 0;         for(int i=0;i<1001;i++) {             passengers += stops[i];             if(passengers>capacity)                 return false;         }         return true;     } }",0,,0,0,0
"import java.util.*;  class Solution {     public List<Integer> pathInZigZagTree(int label) {         List<Integer> path = new ArrayList<>();         int level = (int) (Math.log(label) / Math.log(2));         while (label != 0) {             path.add(0, label);             label = (int) (Math.pow(2, level) + Math.pow(2, level + 1) - 1 - label) / 2;             level--;         }         return path;     } }",1,"1104-path-in-zigzag-labelled-binary-tree/Solution.java:9:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'label'
",0,1,0
"class Solution {     public int minHeightShelves(int[][] books, int shelfWidth) {         int n = books.length;         int[] dp = new int[n+1]; // minimum height of bookshelf up to index i                  dp[0] = 0;                  for (int i = 1; i <= n; i++) {             int width = books[i-1][0];             int height = books[i-1][1];             dp[i] = dp[i-1] + height; // place the i-th book on a new shelf                          for (int j = i-1; j > 0 && width + books[j-1][0] <= shelfWidth; j--) {                 // try to place the i-th book with the previous books                 height = Math.max(height, books[j-1][1]); // calculate the maximum height                 width += books[j-1][0];                 dp[i] = Math.min(dp[i], dp[j-1] + height);             }         }                  return dp[n];     } }",0,,0,0,0
"class Solution {     public int[] corpFlightBookings(int[][] bookings, int n) { // function with bookings and n         int[] flights = new int[n]; // new array for flights with N number of elements         for (int[] booking : bookings) { // for each booking in bookings             for (int i = booking[0]; i <= booking[1]; i++) { // for flight from i in booking[0] to i in booking[1]                 flights[i - 1] += booking[2]; // add booked seats to flights array at i-1 location(as array index begins from 0)             }         }         return flights; // array of flights     } }",0,,0,0,0
"import java.util.*;  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public List<TreeNode> delNodes(TreeNode root, int[] to_delete) {         List<TreeNode> result = new ArrayList<>();         if (root == null) {             return result;         }         Set<Integer> toDelete = new HashSet<>();         for (int val : to_delete) {             toDelete.add(val);         }         if (!toDelete.contains(root.val)) {             result.add(root);         }         deleteNodes(root, toDelete, result);         return result;     }          private TreeNode deleteNodes(TreeNode node, Set<Integer> toDelete, List<TreeNode> result) {         if (node == null) {             return null;         }         node.left = deleteNodes(node.left, toDelete, result);         node.right = deleteNodes(node.right, toDelete, result);         if (toDelete.contains(node.val)) {             if (node.left != null) {                 result.add(node.left);             }             if (node.right != null) {                 result.add(node.right);             }             return null;         }         return node;     } }",0,,0,0,0
class Solution {     public int[] maxDepthAfterSplit(String seq) {         int n = seq.length();         int[] ans = new int[n];          int currDepth = 0;         // iterate over the characters of input string seq         for (int i = 0; i < n; i++) {             char c = seq.charAt(i);             if (c == '(') {                 currDepth++; // increment the current depth                 ans[i] = currDepth % 2; // assign 0 or 1 to answer depending upon current depth             } else {                 ans[i] = currDepth % 2; // assign 0 or 1 to answer depending upon current depth                 currDepth--; // decrement the current depth             }         }          return ans;     } },0,,0,0,0
"class FooBar {     private int n;     private boolean fooDone;      public FooBar(int n) {         this.n = n;         this.fooDone = false;     }      public synchronized void fooBar(Runnable printFooBar) throws InterruptedException {         for (int i = 0; i < n; i++) {             while (!fooDone) {                 wait();             }             // printFooBar.run() outputs ""foobar""             printFooBar.run();             fooDone = false;             notify();         }     }      public synchronized void barFoo(Runnable printBarFoo) throws InterruptedException {         for (int i = 0; i < n; i++) {             while (fooDone) {                 wait();             }             // printBarFoo.run() outputs ""foobar""             printBarFoo.run();             fooDone = true;             notify();         }     } }",1,"1115-print-foobar-alternately/FooBar.java:5:5: Redundant 'public' modifier. [RedundantModifier]
1115-print-foobar-alternately/FooBar.java:5:23: 'n' hides a field. [HiddenField]
1115-print-foobar-alternately/FooBar.java:5:5: Redundant 'public' modifier. [RedundantModifier]
1115-print-foobar-alternately/FooBar.java:5:23: 'n' hides a field. [HiddenField]
1115-print-foobar-alternately/FooBar.java:10:	AvoidSynchronizedAtMethodLevel:	Use block level rather than method level synchronization
1115-print-foobar-alternately/FooBar.java:18:	UseNotifyAllInsteadOfNotify:	Call Thread.notifyAll() rather than Thread.notify()
1115-print-foobar-alternately/FooBar.java:22:	AvoidSynchronizedAtMethodLevel:	Use block level rather than method level synchronization
1115-print-foobar-alternately/FooBar.java:30:	UseNotifyAllInsteadOfNotify:	Call Thread.notifyAll() rather than Thread.notify()
",0,0,0
"class ZeroEvenOdd {     private int n;     private int currNum;     private boolean isZero;     private boolean isEven;          public ZeroEvenOdd(int n) {         this.n = n;         this.currNum = 1;         this.isZero = true;         this.isEven = false;     }      // printNumber.accept(x) outputs ""x"", where x is an integer.     public void zero(IntConsumer printNumber) throws InterruptedException {         while (currNum <= n) {             synchronized (this) {                 if (!isZero) {                     wait();                 }                                  printNumber.accept(0);                 isZero = false;                 if (isEven) {                     notifyAll();                 } else {                     isEven = true;                 }             }         }     }      public void even(IntConsumer printNumber) throws InterruptedException {         while (currNum <= n) {             synchronized (this) {                 if (isZero || currNum % 2 != 0) {                     wait();                 }                                  printNumber.accept(currNum++);                 isZero = true;                 notifyAll();             }         }     }      public void odd(IntConsumer printNumber) throws InterruptedException {         while (currNum <= n) {             synchronized (this) {                 if (isZero || currNum % 2 == 0) {                     wait();                 }                                  printNumber.accept(currNum++);                 isZero = true;                 notifyAll();             }         }     } }",1,"1116-print-zero-even-odd/ZeroEvenOdd.java:7:5: Redundant 'public' modifier. [RedundantModifier]
1116-print-zero-even-odd/ZeroEvenOdd.java:7:28: 'n' hides a field. [HiddenField]
1116-print-zero-even-odd/ZeroEvenOdd.java:7:5: Redundant 'public' modifier. [RedundantModifier]
1116-print-zero-even-odd/ZeroEvenOdd.java:7:28: 'n' hides a field. [HiddenField]
",0,0,0
class H2O {     private Semaphore hydrogenSemaphore = new Semaphore(2);     private Semaphore oxygenSemaphore = new Semaphore(0);     private Semaphore barrier = new Semaphore(1);      public H2O() {              }      public void hydrogen(Runnable releaseHydrogen) throws InterruptedException {         hydrogenSemaphore.acquire();         bond(releaseHydrogen);     }      public void oxygen(Runnable releaseOxygen) throws InterruptedException {         oxygenSemaphore.acquire();         bond(releaseOxygen);     }      private void bond(Runnable releaseElement) throws InterruptedException {         barrier.acquire();         releaseElement.run();         if (hydrogenSemaphore.availablePermits() == 0) {             oxygenSemaphore.release();         } else {             hydrogenSemaphore.release();         }         barrier.release();     } },1,"1117-building-h2o/H2O.java:6:5: Redundant 'public' modifier. [RedundantModifier]
1117-building-h2o/H2O.java:6:5: Redundant 'public' modifier. [RedundantModifier]
1117-building-h2o/H2O.java:6:	UncommentedEmptyConstructor:	Document empty constructor
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public TreeNode lcaDeepestLeaves(TreeNode root) {         if (root == null) {             return null;         }         int leftDepth = depth(root.left);         int rightDepth = depth(root.right);         if (leftDepth == rightDepth) {             return root;         } else if (leftDepth > rightDepth) {             return lcaDeepestLeaves(root.left);         } else {             return lcaDeepestLeaves(root.right);         }     }          private int depth(TreeNode node) {         if (node == null) {             return 0;         }         return 1 + Math.max(depth(node.left), depth(node.right));     } }",0,,0,0,0
"class Solution {     public int longestWPI(int[] hours) {         int n = hours.length;         int[] prefixSum = new int[n+1];                  for(int i=0; i<n; i++) {             prefixSum[i+1] = prefixSum[i] + (hours[i]>8 ? 1 : -1);         }                  Stack<Integer> stack = new Stack<>();         for(int i=0; i<=n; i++) {             if(stack.isEmpty() || prefixSum[i]<prefixSum[stack.peek()]) {                 stack.push(i);             }         }                  int length = 0;         for(int i=n; i>=0; i--) {             while(!stack.isEmpty() && prefixSum[i]>prefixSum[stack.peek()]) {                 length = Math.max(length, i-stack.pop());             }         }                  return length;     } }",0,,0,0,0
"import java.util.*;  class Solution {     public int[] shortestAlternatingPaths(int n, int[][] redEdges, int[][] blueEdges) {         // Create the adjacency list         List<List<Integer>> redList = new ArrayList<>();         List<List<Integer>> blueList = new ArrayList<>();         for (int i = 0; i < n; i++) {             redList.add(new ArrayList<>());             blueList.add(new ArrayList<>());         }         for (int[] edge : redEdges) {             redList.get(edge[0]).add(edge[1]);         }         for (int[] edge : blueEdges) {             blueList.get(edge[0]).add(edge[1]);         }           // Initialize the queue and visited arrays         Queue<int[]> queue = new LinkedList<>();         boolean[][] visited = new boolean[n][2];         queue.add(new int[]{0, 0}); // Add the starting node with color red         queue.add(new int[]{0, 1}); // Add the starting node with color blue         visited[0][0] = true;         visited[0][1] = true;           // Initialize the distance array         int[] distance = new int[n];         Arrays.fill(distance, -1);         distance[0] = 0;           // Run BFS to find the shortest alternating path         int level = 0;         while (!queue.isEmpty()) {             int size = queue.size();             for (int i = 0; i < size; i++) {                 int[] curr = queue.poll();                 int node = curr[0];                 int color = curr[1];                 if (distance[node] == -1) {                     distance[node] = level;                 }                 List<List<Integer>> list = (color == 0) ? blueList : redList;                 for (int neighbor : list.get(node)) {                     if (!visited[neighbor][1 - color]) {                         visited[neighbor][1 - color] = true;                         queue.add(new int[]{neighbor, 1 - color});                     }                 }             }             level++;         }           return distance;     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public List<List<Integer>> pathSum(TreeNode root, int targetSum) {         List<List<Integer>> result = new ArrayList<>();         List<Integer> path = new ArrayList<>();         findPaths(root, targetSum, path, result);         return result;     }          private void findPaths(TreeNode root, int targetSum, List<Integer> path, List<List<Integer>> result) {         if (root == null) {             return;         }         path.add(root.val);         if (targetSum == root.val && root.left == null && root.right == null) {             result.add(new ArrayList<>(path));         } else {             findPaths(root.left, targetSum - root.val, path, result);             findPaths(root.right, targetSum - root.val, path, result);         }         path.remove(path.size() - 1);     } }",0,,0,0,0
"class Solution {     public int mctFromLeafValues(int[] arr) {         int n = arr.length;         int[][] dp = new int[n][n];         int[][] max = new int[n][n];         for (int i = 0; i < n; i++) {             int currMax = 0;             for (int j = i; j < n; j++) {                 currMax = Math.max(currMax, arr[j]);                 max[i][j] = currMax;             }         }         for (int len = 1; len < n; len++) {             for (int i = 0; i < n - len; i++) {                 int j = i + len;                 dp[i][j] = Integer.MAX_VALUE;                 if (len == 1) {                     dp[i][j] = arr[i] * arr[j];                 } else {                     for (int k = i; k < j; k++) {                         int left = dp[i][k];                         int right = dp[k + 1][j];                         int currMax = max[i][k] * max[k + 1][j];                         dp[i][j] = Math.min(dp[i][j], left + right + currMax);                     }                 }             }         }         return dp[0][n - 1];     } }",0,,0,0,0
"class Solution {     public int maxAbsValExpr(int[] arr1, int[] arr2) {         // Initialize the maximum values for each absolute value expression         int maxOne = Integer.MIN_VALUE, maxTwo = Integer.MIN_VALUE, maxThree = Integer.MIN_VALUE, maxFour = Integer.MIN_VALUE;          // Initialize the minimum values for each absolute value expression         int minOne = Integer.MAX_VALUE, minTwo = Integer.MAX_VALUE, minThree = Integer.MAX_VALUE, minFour = Integer.MAX_VALUE;          // Calculate max and min values of absolute value expressions         for (int i = 0; i < arr1.length; i++) {             maxOne = Math.max(maxOne, arr1[i] + arr2[i] + i);             minOne = Math.min(minOne, arr1[i] + arr2[i] + i);             maxTwo = Math.max(maxTwo, arr1[i] + arr2[i] - i);             minTwo = Math.min(minTwo, arr1[i] + arr2[i] - i);             maxThree = Math.max(maxThree, arr1[i] - arr2[i] + i);             minThree = Math.min(minThree, arr1[i] - arr2[i] + i);             maxFour = Math.max(maxFour, arr1[i] - arr2[i] - i);             minFour = Math.min(minFour, arr1[i] - arr2[i] - i);         }          // Return maximum value of absolute value expression         return Math.max(maxOne - minOne, Math.max(maxTwo - minTwo, Math.max(maxThree - minThree, maxFour - minFour)));     } }",1,"1131-maximum-of-absolute-value-expression/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1131-maximum-of-absolute-value-expression/Solution.java:7:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1131-maximum-of-absolute-value-expression/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1131-maximum-of-absolute-value-expression/Solution.java:7:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public String alphabetBoardPath(String target) {         StringBuilder sb = new StringBuilder();         int x = 0, y = 0;         for (char ch : target.toCharArray()) {             int x1 = (ch - 'a') / 5, y1 = (ch - 'a') % 5;             if (y1 < y) {                 for (int i = y; i > y1; i--)                     sb.append('L');             }             if (x1 < x) {                 for (int i = x; i > x1; i--)                     sb.append('U');             }             if (y1 > y) {                 for (int i = y; i < y1; i++)                     sb.append('R');             }             if (x1 > x) {                 for (int i = x; i < x1; i++)                     sb.append('D');             }             sb.append('!');             x = x1;             y = y1;         }         return sb.toString();     } }",1,"1138-alphabet-board-path/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1138-alphabet-board-path/Solution.java:6:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1138-alphabet-board-path/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1138-alphabet-board-path/Solution.java:6:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int largest1BorderedSquare(int[][] grid) {         int numRows = grid.length;         int numCols = grid[0].length;         int maxLength = 0;                  int[][][] dp = new int[numRows+1][numCols+1][2];                  for(int i=1; i<=numRows; i++){             for(int j=1; j<=numCols; j++){                 if(grid[i-1][j-1] == 1){                     dp[i][j][0] = dp[i][j-1][0] + 1;                     dp[i][j][1] = dp[i-1][j][1] + 1;                                          int len = Math.min(dp[i][j][0], dp[i][j][1]);                                          while(len > maxLength){                         if(dp[i-len+1][j][0] >= len && dp[i][j-len+1][1] >= len){                             maxLength = len;                         }                         len--;                     }                 }             }         }                  return maxLength * maxLength;     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public void flatten(TreeNode root) {         if (root == null) {             return;         }         if (root.left != null) {             flatten(root.left);         }         if (root.right != null) {             flatten(root.right);         }         TreeNode temp = root.right;         root.right = root.left;         root.left = null;         while (root.right != null) {             root = root.right;         }         root.right = temp;     } }",1,"114-flatten-binary-tree-to-linked-list/TreeNode.java:29:	NullAssignment:	Assigning an Object to null is a code smell.  Consider refactoring.
114-flatten-binary-tree-to-linked-list/TreeNode.java:31:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'root'
",0,1,0
"class Solution {     public int stoneGameII(int[] piles) {         int n = piles.length;         int[] suffixSum = new int[n];         suffixSum[n - 1] = piles[n - 1];         for (int i = n - 2; i >= 0; i--) {             suffixSum[i] = suffixSum[i + 1] + piles[i];         }          int[][] memo = new int[n][n];         return dfs(piles, 0, 1, suffixSum, memo);     }      private int dfs(int[] piles, int i, int m, int[] suffixSum, int[][] memo) {         if (i == piles.length) {             return 0;         }          if (2 * m >= piles.length - i) {             return suffixSum[i];         }          if (memo[i][m] != 0) {             return memo[i][m];         }          int min = Integer.MAX_VALUE;         for (int j = 1; j <= 2 * m; j++) {             min = Math.min(min, dfs(piles, i + j, Math.max(m, j), suffixSum, memo));         }          int res = suffixSum[i] - min;         memo[i][m] = res;         return res;     } }",0,,0,0,0
"class Solution {     public int longestCommonSubsequence(String text1, String text2) {         int m = text1.length();         int n = text2.length();                  int[][] dp = new int[m+1][n+1];                  for (int i = 1; i <= m; i++) {             for (int j = 1; j <= n; j++) {                 if (text1.charAt(i-1) == text2.charAt(j-1)) {                     dp[i][j] = dp[i-1][j-1] + 1;                 } else {                     dp[i][j] = Math.max(dp[i][j-1], dp[i-1][j]);                 }             }         }                  return dp[m][n];     } }",0,,0,0,0
"class Solution {     public int movesToMakeZigzag(int[] nums) {         int evenCount = 0;         int oddCount = 0;         for (int i = 0; i < nums.length; i++) {             int left = i > 0 ? nums[i - 1] : Integer.MAX_VALUE;             int right = i < nums.length - 1 ? nums[i + 1] : Integer.MAX_VALUE;             int diff = nums[i] - Math.min(left, right) + 1;             if (i % 2 == 0) {                 evenCount += diff > 0 ? diff : 0;             } else {                 oddCount += diff > 0 ? diff : 0;             }         }         return Math.min(evenCount, oddCount);     } }",0,,0,0,0
"/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() {} *     TreeNode(int val) { this.val = val; } *     TreeNode(int val, TreeNode left, TreeNode right) { *         this.val = val; *         this.left = left; *         this.right = right; *     } * } */ class Solution {     public boolean btreeGameWinningMove(TreeNode root, int n, int x) {         // Find the node with value x         TreeNode xNode = findNode(root, x);          // Count the number of nodes in the left subtree of xNode         int leftCount = countNodes(xNode.left);          // Count the number of nodes in the right subtree of xNode         int rightCount = countNodes(xNode.right);          // Count the number of nodes in the subtree rooted at the parent of xNode         int parentCount = n - leftCount - rightCount - 1;          // Check if the maximum of these counts is greater than n/2         return Math.max(parentCount, Math.max(leftCount, rightCount)) > n / 2;     }      private TreeNode findNode(TreeNode root, int x) {         if (root == null || root.val == x) {             return root;         }         TreeNode left = findNode(root.left, x);         if (left != null) {             return left;         }         return findNode(root.right, x);     }      private int countNodes(TreeNode root) {         if (root == null) {             return 0;         }         return countNodes(root.left) + countNodes(root.right) + 1;     } }",0,,0,0,0
"class SnapshotArray {     private int[][] snapshots; // 2D array to store snapshots     private int[] current; // current state of array     private int snap_id; // current snapshot id          public SnapshotArray(int length) {         snapshots = new int[length][1];         current = new int[length];         snap_id = 0;     }          public void set(int index, int val) {         current[index] = val;     }          public int snap() {         // store current state of array in snapshots         for (int i = 0; i < current.length; i++) {             snapshots[i] = Arrays.copyOf(current, current.length);         }         int id = snap_id;         snap_id++; // increment snapshot id         return id;     }          public int get(int index, int snap_id) {         // return the value of array[index] at the time of the given snapshot id         return snapshots[index][snap_id];     } } ",1,"1146-snapshot-array/SnapshotArray.java:6:5: Redundant 'public' modifier. [RedundantModifier]
1146-snapshot-array/SnapshotArray.java:26:35: 'snap_id' hides a field. [HiddenField]
",0,0,0
"class Solution {     public int numRollsToTarget(int n, int k, int target) {         int mod = 1000000007;         int[] dp = new int[target + 1];         dp[0] = 1;         for (int i = 0; i < n; i++) {             for (int j = target; j >= 0; j--) {                 dp[j] = 0;                 for (int l = 1; l <= k; l++) {                     if (j >= l) {                         dp[j] += dp[j - l];                         dp[j] %= mod;                     } else {                         break;                     }                 }             }         }         return dp[target];     } }",0,,0,0,0
"class Solution {     public int maxRepOpt1(String text) {         int[] freq = new int[26];         int n = text.length();         for (int i = 0; i < n; i++) {             freq[text.charAt(i) - 'a']++; // keep a count of each character in the string         }         int maxLen = 1;         for (int c = 0; c < 26; c++) {             char ch = (char) (c + 'a');              int i = 0, j = 0, k = 1, cnt = 0;             while (j < n) {                 // increment j until we encounter a different character or until we have reached the end of the string                 if (text.charAt(j) != ch) {                     cnt++;                  }                 j++;                  // if cnt > 1, we can't swap characters, so increment i and k                 while (cnt > 1) {                     if (text.charAt(i) != ch) {                         cnt--;                     }                     i++;                     k = Math.max(k, i); // update k to i if we haven't swapped characters yet                 }                 // check if the substring from i to j-1 is valid and update maxLen accordingly                 if (cnt == 1) {                     maxLen = Math.max(maxLen, j-i); // if we haven't swapped characters yet, the substring is valid if cnt=1                 } else if (cnt == 0 && (j-i) == freq[c]) { // if we have swapped one character, the substring is valid if the length of substring is equal to the frequency of that character                     maxLen = Math.max(maxLen, j-i);                 }                 // increment i and k if we have swapped one character                 if (j < n && text.charAt(j) != ch && k < j) {                     k++;                 }             }         }         return maxLen; // return the length of the longest substring with repeated characters     } }",1,"1156-swap-for-longest-repeated-character-substring/Solution.java:11:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1156-swap-for-longest-repeated-character-substring/Solution.java:11:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"/* // Definition for a Node. class Node {     public int val;     public Node left;     public Node right;     public Node next;      public Node() {}          public Node(int _val) {         val = _val;     }      public Node(int _val, Node _left, Node _right, Node _next) {         val = _val;         left = _left;         right = _right;         next = _next;     } }; */  class Solution {     public Node connect(Node root) {         if (root == null) {             return null;         }         Node leftMost = root;         while (leftMost.left != null) {             Node head = leftMost;             while (head != null) {                 head.left.next = head.right;                 if (head.next != null) {                     head.right.next = head.next.left;                 }                 head = head.next;             }             leftMost = leftMost.left;         }         return root;     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public int maxLevelSum(TreeNode root) {         if (root == null) {             return 0;         }                  int maxSum = Integer.MIN_VALUE;         int level = 1;         int currentLevel = 1;                  Queue<TreeNode> queue = new LinkedList<>();         queue.offer(root);                  while (!queue.isEmpty()) {             int size = queue.size();             int sum = 0;                          for (int i = 0; i < size; i++) {                 TreeNode node = queue.poll();                 sum += node.val;                                  if (node.left != null) {                     queue.offer(node.left);                 }                                  if (node.right != null) {                     queue.offer(node.right);                 }             }                          if (sum > maxSum) {                 maxSum = sum;                 level = currentLevel;             }                          currentLevel++;         }                  return level;     } }",0,,0,0,0
"class Solution {     public int maxDistance(int[][] grid) {         int n = grid.length;         int[][] dist = new int[n][n];         Queue<int[]> queue = new LinkedList<>();          // Add all the land cells to the queue and mark their distance as 0         for (int i = 0; i < n; i++) {             for (int j = 0; j < n; j++) {                 if (grid[i][j] == 1) {                     queue.add(new int[]{i, j});                     dist[i][j] = 0;                 } else {                     // Mark all water cells as unreachable (distance = -1)                     dist[i][j] = -1;                 }             }         }          // Breadth-first search to find the distance of water cells from land cells         int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};         while (!queue.isEmpty()) {             int[] curr = queue.poll();             int x = curr[0];             int y = curr[1];             for (int[] dir : dirs) {                 int newX = x + dir[0];                 int newY = y + dir[1];                 if (newX >= 0 && newX < n && newY >= 0 && newY < n && dist[newX][newY] == -1) {                     dist[newX][newY] = dist[x][y] + 1;                     queue.add(new int[]{newX, newY});                 }             }         }          // Find the maximum distance among all water cells         int maxDist = -1;         for (int i = 0; i < n; i++) {             for (int j = 0; j < n; j++) {                 maxDist = Math.max(maxDist, dist[i][j]);             }         }          return maxDist;     } }",0,,0,0,0
"import java.util.ArrayList; import java.util.HashMap; import java.util.List;  class Solution {     public List<String> invalidTransactions(String[] transactions) {         List<String> invalid = new ArrayList<>();         HashMap<String, List<Transaction>> nameToTransactions = new HashMap<>();         for (String transaction : transactions) {             Transaction t = new Transaction(transaction);             if (t.getAmount() > 1000) {                 invalid.add(transaction);             }             if (nameToTransactions.containsKey(t.getName())) {                 for (Transaction other : nameToTransactions.get(t.getName())) {                     if (!other.getCity().equals(t.getCity())                             && Math.abs(other.getTime() - t.getTime()) <= 60) {                         invalid.add(other.toString());                         invalid.add(transaction);                     }                 }             }             nameToTransactions.putIfAbsent(t.getName(), new ArrayList<>());             nameToTransactions.get(t.getName()).add(t);         }         return invalid;     }      private static class Transaction {         private final String name;         private final int time;         private final int amount;         private final String city;          public Transaction(String transaction) {             String[] parts = transaction.split("","");             this.name = parts[0];             this.time = Integer.parseInt(parts[1]);             this.amount = Integer.parseInt(parts[2]);             this.city = parts[3];         }          public String getName() {             return name;         }          public int getTime() {             return time;         }          public int getAmount() {             return amount;         }          public String getCity() {             return city;         }          @Override         public String toString() {             return name + "","" + time + "","" + amount + "","" + city;         }     } }",1,"1169-invalid-transactions/Solution.java:35:9: Redundant 'public' modifier. [RedundantModifier]
1169-invalid-transactions/Solution.java:35:9: Redundant 'public' modifier. [RedundantModifier]
1169-invalid-transactions/Solution.java:8:	LooseCoupling:	Avoid using implementation types like 'HashMap'; use the interface instead
1169-invalid-transactions/Solution.java:29:	DataClass:	The class 'Transaction' is suspected to be a Data Class (WOC=20.000%, NOPA=0, NOAM=4, WMC=6)
",0,0,0
"/* // Definition for a Node. class Node {     public int val;     public Node left;     public Node right;     public Node next;      public Node() {}          public Node(int _val) {         val = _val;     }      public Node(int _val, Node _left, Node _right, Node _next) {         val = _val;         left = _left;         right = _right;         next = _next;     } }; */  class Solution {     public Node connect(Node root) {         if (root == null) {             return null;         }                  Node leftmost = root;         while (leftmost.left != null) {             Node head = leftmost;             while (head != null) {                 head.left.next = head.right;                 if (head.next != null) {                     head.right.next = head.next.left;                 }                 head = head.next;             }             leftmost = leftmost.left;         }                  return root;     } }",0,,0,0,0
"class Solution {     public int[] numSmallerByFrequency(String[] queries, String[] words) {         int[] ans = new int[queries.length];         int[] count = new int[11];         for (String word : words) {             int freq = getFreq(word);             count[freq]++;         }         for (int i = 9; i >= 0; i--) {             count[i] += count[i+1];         }         for (int i = 0; i < queries.length; i++) {             int freq = getFreq(queries[i]);             ans[i] = count[freq+1];         }         return ans;     }          private int getFreq(String s) {         char c = 'z'+1;         int count = 0;         for (char ch : s.toCharArray()) {             if (ch < c) {                 c = ch;                 count = 1;             } else if (ch == c) {                 count++;             }         }         return count;     } }",0,,0,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public ListNode removeZeroSumSublists(ListNode head) {         if(head == null)             return null;         ListNode dummy = new ListNode(-1);         dummy.next = head;         Map<Integer, ListNode> map = new HashMap<>();         int prefixSum = 0;         for(ListNode curr = dummy; curr != null; curr = curr.next){             prefixSum += curr.val;             map.put(prefixSum, curr);         }         prefixSum = 0;         for(ListNode curr = dummy; curr != null; curr = curr.next){             prefixSum += curr.val;             curr.next = map.get(prefixSum).next;         }         return dummy.next;     } }",0,,0,0,0
"import java.util.*;  class Solution {     public List<Boolean> canMakePaliQueries(String s, int[][] queries) {         List<Boolean> result = new ArrayList<>();         int[][] freq = new int[s.length()+1][26];                  for(int i=1;i<=s.length();i++){             char currChar = s.charAt(i-1);             for(int j=0;j<26;j++) freq[i][j] = freq[i-1][j];             freq[i][currChar-'a']++;         }                  for(int i=0;i<queries.length;i++){             int leftIndex = queries[i][0];             int rightIndex = queries[i][1];             int k = queries[i][2];             int oddCount = 0;                          for(int j=0;j<26;j++){                 int charCount = freq[rightIndex+1][j]-freq[leftIndex][j];                 if(charCount%2 != 0) oddCount++;             }             result.add((k>=oddCount/2));         }                  return result;     } }",1,"1177-can-make-palindrome-from-substring/Solution.java:4:	LinguisticNaming:	Linguistics Antipattern - The method 'canMakePaliQueries' indicates linguistically it returns a boolean, but it returns 'List<Boolean>'
1177-can-make-palindrome-from-substring/Solution.java:14:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
1177-can-make-palindrome-from-substring/Solution.java:24:	UselessParentheses:	Useless parentheses.
",0,0,1
"class Solution {     public int maximumSum(int[] arr) {         int n = arr.length;         int[] dp = new int[n];         int[] dpDel = new int[n];         dp[0] = arr[0];         dpDel[0] = 0;         int ans = arr[0];         for (int i = 1; i < n; i++) {             dp[i] = Math.max(arr[i], dp[i - 1] + arr[i]);             dpDel[i] = Math.max(dpDel[i - 1] + arr[i], dp[i - 1]);             ans = Math.max(ans, Math.max(dp[i], dpDel[i]));         }         return ans;     } }",0,,0,0,0
class Solution {     public String reverseParentheses(String s) {         Stack<Character> stack = new Stack<Character>();         for (int i = 0; i < s.length(); i++) {             if (s.charAt(i) == ')') {                 List<Character> list = new ArrayList<Character>();                 while (stack.peek() != '(') {                     list.add(stack.pop());                 }                 stack.pop(); // remove the '('                 for (char c: list) {                     stack.push(c);                 }             } else {                 stack.push(s.charAt(i));             }         }         char[] chars = new char[stack.size()];         for (int i = stack.size()-1; i >= 0; i--) {             chars[i] = stack.pop();         }         return new String(chars);     } },1,"1190-reverse-substrings-between-each-pair-of-parentheses/Solution.java:22:	StringInstantiation:	Avoid instantiating String objects; this is usually unnecessary.
",0,0,0
"class Solution {     public int kConcatenationMaxSum(int[] arr, int k) {         int mod = 1000000007;                  // Finding the maximum subarray sum using Kadane's algorithm         long maxSoFar = 0;         long maxEndingHere = 0;         for (int i = 0; i < arr.length; i++) {             maxEndingHere += arr[i];             if (maxEndingHere < 0) {                 maxEndingHere = 0;             }             if (maxSoFar < maxEndingHere) {                 maxSoFar = maxEndingHere;             }         }                  // Finding the sum of the array         long sum = 0;         for (int i = 0; i < arr.length; i++) {             sum += arr[i];         }                  if (k == 1) {             return (int) (maxSoFar % mod);         } else if (sum <= 0) {             // If the sum of the array is negative or zero, then repeating the array won't increase the maximum subarray sum             long maxPrefixSum = 0;             long maxSuffixSum = 0;             long currPrefixSum = 0;             long currSuffixSum = 0;             for (int i = 0; i < arr.length; i++) {                 currPrefixSum += arr[i];                 maxPrefixSum = Math.max(maxPrefixSum, currPrefixSum);             }             for (int i = arr.length - 1; i >= 0; i--) {                 currSuffixSum += arr[i];                 maxSuffixSum = Math.max(maxSuffixSum, currSuffixSum);             }             long ans = Math.max(maxSoFar, maxPrefixSum + maxSuffixSum);             return (int) (ans % mod);         } else {             // If the sum of the array is positive, then repeating the array k times will increase the maximum subarray sum             long ans = (maxSoFar + (k - 2) * sum) % mod;             ans = Math.max(ans, maxSoFar + maxSoFar * (k - 1) % mod);             return (int) ans;         }     } }",1,"1191-k-concatenation-maximum-sum/Solution.java:8:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
1191-k-concatenation-maximum-sum/Solution.java:20:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
1191-k-concatenation-maximum-sum/Solution.java:32:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"import java.util.concurrent.Semaphore; import java.util.function.IntConsumer;  class FizzBuzz {     private int n;      // Semaphores to ensure correct order     private Semaphore fizzSem = new Semaphore(0);     private Semaphore buzzSem = new Semaphore(0);     private Semaphore fizzbuzzSem = new Semaphore(0);     private Semaphore numSem = new Semaphore(1);      public FizzBuzz(int n) {         this.n = n;     }      // printFizz.run() outputs ""fizz"".     public void fizz(Runnable printFizz) throws InterruptedException {         for (int i = 3; i <= n; i += 3) {             if (i % 5 != 0) {                 fizzSem.acquire();                 printFizz.run();                 release(i + 1);             }         }     }      // printBuzz.run() outputs ""buzz"".     public void buzz(Runnable printBuzz) throws InterruptedException {         for (int i = 5; i <= n; i += 5) {             if (i % 3 != 0) {                 buzzSem.acquire();                 printBuzz.run();                 release(i + 1);             }         }     }      // printFizzBuzz.run() outputs ""fizzbuzz"".     public void fizzbuzz(Runnable printFizzBuzz) throws InterruptedException {         for (int i = 15; i <= n; i += 15) {             fizzbuzzSem.acquire();             printFizzBuzz.run();             release(i + 1);         }     }      // printNumber.accept(x) outputs ""x"", where x is an integer.     public void number(IntConsumer printNumber) throws InterruptedException {         release(1);         for (int i = 2; i <= n; i++) {             numSem.acquire();             if (i % 3 == 0 && i % 5 == 0) {                 fizzbuzzSem.release();             } else if (i % 3 == 0) {                 fizzSem.release();             } else if (i % 5 == 0) {                 buzzSem.release();             } else {                 printNumber.accept(i);                 release(i + 1);             }         }     }      // Helper method to release the next semaphore     private void release(int i) {         if (i % 3 == 0 && i % 5 == 0) {             fizzbuzzSem.release();         } else if (i % 3 == 0) {             fizzSem.release();         } else if (i % 5 == 0) {             buzzSem.release();         } else {             numSem.release();         }     } }",1,"1195-fizz-buzz-multithreaded/FizzBuzz.java:13:5: Redundant 'public' modifier. [RedundantModifier]
1195-fizz-buzz-multithreaded/FizzBuzz.java:13:25: 'n' hides a field. [HiddenField]
1195-fizz-buzz-multithreaded/FizzBuzz.java:13:5: Redundant 'public' modifier. [RedundantModifier]
1195-fizz-buzz-multithreaded/FizzBuzz.java:13:25: 'n' hides a field. [HiddenField]
",0,0,0
"import java.util.List;  class Solution {     public int minimumTotal(List<List<Integer>> triangle) {         int n = triangle.size();         int[] dp = new int[n];                  // initialize the dp array to the last row of the triangle         for(int i=0; i<n; i++) {             dp[i] = triangle.get(n-1).get(i);         }                  // bottom-up approach: start iterating from the second-last row         for(int i=n-2; i>=0; i--) {             List<Integer> row = triangle.get(i);                          // calculate the minimum path sum for current row             for(int j=0; j<=i; j++) {                 dp[j] = row.get(j) + Math.min(dp[j], dp[j+1]);             }         }                  // the minimum path sum will be at the top of the dp array         return dp[0];     } }",0,,0,0,0
"class Solution {     public int nthUglyNumber(int n, int a, int b, int c) {         long lcmAB = lcm(a, b);         long lcmAC = lcm(a, c);         long lcmBC = lcm(b, c);         long lcmABC = lcm(lcmAB, c);          long left = 1, right = Long.MAX_VALUE;          while (left < right) {             long mid = left + (right - left) / 2;              long count = mid / a + mid / b + mid / c - mid / lcmAB - mid / lcmAC - mid / lcmBC + mid / lcmABC;              if (count >= n) {                 right = mid;             } else {                 left = mid + 1;             }         }          return (int)Math.toIntExact(left);     }      private long gcd(long x, long y) {         if (x == 0) {             return y;         }         return gcd(y % x, x);     }      private long lcm(long x, long y) {         return (x * y) / gcd(x, y);     } }",1,"1201-ugly-number-iii/Solution.java:8:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1201-ugly-number-iii/Solution.java:8:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1201-ugly-number-iii/Solution.java:22:	UnnecessaryCast:	Unnecessary cast (int)
1201-ugly-number-iii/Solution.java:33:	UselessParentheses:	Useless parentheses.
",1,0,0
"import java.util.*;  class Solution {     public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {         // initialize graph and visited array         List<Integer>[] graph = new ArrayList[s.length()];         for (int i = 0; i < s.length(); i++) {             graph[i] = new ArrayList<>();         }         boolean[] visited = new boolean[s.length()];          // build graph using pairs         for (List<Integer> pair : pairs) {             int a = pair.get(0);             int b = pair.get(1);             graph[a].add(b);             graph[b].add(a);         }          // create list of character groups         List<List<Character>> charGroups = new ArrayList<>();         for (int i = 0; i < s.length(); i++) {             // if character is already visited, skip             if (visited[i]) {                 continue;             }             List<Character> charGroup = new ArrayList<>();             dfs(i, graph, visited, s, charGroup);             // sort character group in ascending order             Collections.sort(charGroup);             charGroups.add(charGroup);         }          // create new string using sorted character groups         StringBuilder sb = new StringBuilder(s);         for (List<Character> charGroup : charGroups) {             Collections.sort(charGroup);             for (int i = 0; i < charGroup.size(); i++) {                 int index = sb.indexOf(charGroup.get(i).toString());                 sb.setCharAt(index, charGroup.get(i));             }         }         return sb.toString();     }      // helper method to perform depth-first search     private void dfs(int index, List<Integer>[] graph, boolean[] visited, String s, List<Character> charGroup) {         // if index is already visited, skip         if (visited[index]) {             return;         }         visited[index] = true;         charGroup.add(s.charAt(index));         for (int i = 0; i < graph[index].size(); i++) {             dfs(graph[index].get(i), graph, visited, s, charGroup);         }     } }",1,"1202-smallest-string-with-swaps/Solution.java:38:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int equalSubstring(String s, String t, int maxCost) {         int maxLength = 0;         int left = 0;         int right = 0;         int currentCost = 0;                  while (right < s.length()) {             currentCost += Math.abs(s.charAt(right) - t.charAt(right));             right++;                          while (currentCost > maxCost) {                 currentCost -= Math.abs(s.charAt(left) - t.charAt(left));                 left++;             }                          maxLength = Math.max(maxLength, right - left);         }                  return maxLength;     } }",0,,0,0,0
"class Solution {     public String removeDuplicates(String s, int k) {         Stack<Character> stack = new Stack<>();         Stack<Integer> countStack = new Stack<>();                  for(int i=0; i<s.length(); i++) {             char curr = s.charAt(i);             if(!stack.isEmpty() && stack.peek()==curr) {                 countStack.push(countStack.peek()+1);                 if(countStack.peek()==k) {                     int num = k;                     while(num>0) {                         stack.pop();                         countStack.pop();                         num--;                     }                 }             } else {                 stack.push(curr);                 countStack.push(1);             }         }                  StringBuilder sb = new StringBuilder();         while(!stack.isEmpty()) {             char curr = stack.pop();             int count = countStack.pop();             while(count>0) {                 sb.append(curr);                 count--;             }         }                  return sb.reverse().toString();     } }",0,,0,0,0
"class Solution {     public int longestSubsequence(int[] arr, int difference) {         int maxLength = 0;         Map<Integer, Integer> dp = new HashMap<>();         for (int i = 0; i < arr.length; i++) {             int prev = arr[i] - difference;             int prevLength = dp.getOrDefault(prev, 0); // get the length of the previous subsequence ending at prev             int currLength = dp.getOrDefault(arr[i], 0) + 1; // get the length of the current subsequence ending at arr[i]             dp.put(arr[i], Math.max(prevLength + 1, currLength)); // update the length of the longest subsequence ending at arr[i]             maxLength = Math.max(maxLength, dp.get(arr[i])); // update the maximum length         }         return maxLength;     } }  // Time Complexity: O(n) // Space Complexity: O(n)",1,"1218-longest-arithmetic-subsequence-of-given-difference/Solution.java:5:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     int maxGold = 0;     public int getMaximumGold(int[][] grid) {         for(int i=0; i<grid.length; i++){             for(int j=0;j<grid[0].length;j++){                 if(grid[i][j]!=0){                     backtrack(grid,i,j,0);// Pass current position and gold collected so far to backtrack function                 }             }         }         return maxGold;     }     void backtrack(int[][] grid, int i, int j, int gold){         if(i<0 || i>=grid.length || j<0 || j>=grid[0].length || grid[i][j]==0) return; // if current position is out of grid or has 0 gold, return                  gold+=grid[i][j]; // Collect gold at current position         maxGold=Math.max(maxGold,gold); // Compare gold collected with maxGold                  int temp = grid[i][j];         grid[i][j]=0; // Mark current position as visited                  backtrack(grid,i+1,j,gold);// Move down         backtrack(grid,i-1,j,gold);// Move up         backtrack(grid,i,j+1,gold);// Move right         backtrack(grid,i,j-1,gold);// Move left                  grid[i][j]=temp;  // Mark current position as unvisited after visiting all its neighbors     } }",1,"1219-path-with-maximum-gold/Solution.java:2:9: Variable 'maxGold' must be private and have accessor methods. [VisibilityModifier]
1219-path-with-maximum-gold/Solution.java:2:9: Variable 'maxGold' must be private and have accessor methods. [VisibilityModifier]
1219-path-with-maximum-gold/Solution.java:16:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'gold'
",0,1,0
"class Solution {     public int maxProfit(int[] prices) {         int maxProfit = 0;         int currentMinPrice = Integer.MAX_VALUE;         for (int price : prices) {             if (price < currentMinPrice) {                  currentMinPrice = price;             } else {                 maxProfit = Math.max(maxProfit, price - currentMinPrice);             }         }         return maxProfit;     } }",0,,0,0,0
"import java.util.ArrayList; import java.util.Arrays; import java.util.List;  class Solution {     public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {         List<List<Integer>> result = new ArrayList<>();         boolean[][] board = new boolean[8][8];         for (int[] queen : queens) {             board[queen[0]][queen[1]] = true;         }         // check upper side         for (int i = king[0]; i >= 0; i--) {             if (board[i][king[1]]) {                 result.add(Arrays.asList(i, king[1]));                 break;             }         }         // check lower side         for (int i = king[0]; i < 8; i++) {             if (board[i][king[1]]) {                 result.add(Arrays.asList(i, king[1]));                 break;             }         }         // check left side         for (int i = king[1]; i >= 0; i--) {             if (board[king[0]][i]) {                 result.add(Arrays.asList(king[0], i));                 break;             }         }         // check right side         for (int i = king[1]; i < 8; i++) {             if (board[king[0]][i]) {                 result.add(Arrays.asList(king[0], i));                 break;             }         }         // check upper-left diagonal         int i = king[0];         int j = king[1];         while (i >= 0 && j >= 0) {             if (board[i][j]) {                 result.add(Arrays.asList(i, j));                 break;             }             i--;             j--;         }         // check upper-right diagonal         i = king[0];         j = king[1];         while (i >= 0 && j < 8) {             if (board[i][j]) {                 result.add(Arrays.asList(i, j));                 break;             }             i--;             j++;         }         // check lower-left diagonal         i = king[0];         j = king[1];         while (i < 8 && j >= 0) {             if (board[i][j]) {                 result.add(Arrays.asList(i, j));                 break;             }             i++;             j--;         }         // check lower-right diagonal         i = king[0];         j = king[1];         while (i < 8 && j < 8) {             if (board[i][j]) {                 result.add(Arrays.asList(i, j));                 break;             }             i++;             j++;         }         return result;     } }",1,"1222-queens-that-can-attack-the-king/Solution.java:6:	NPathComplexity:	The method 'queensAttacktheKing(int[][], int[])' has an NPath complexity of 41472, current threshold is 200
",0,0,0
"import java.util.concurrent.Semaphore;  class DiningPhilosophers {      // The maximum number of philosophers     private static final int MAX_PHILOSOPHERS = 5;      // The forks are represented with a Semaphore array     private Semaphore[] forks;      public DiningPhilosophers() {         forks = new Semaphore[MAX_PHILOSOPHERS];         for (int i = 0; i < MAX_PHILOSOPHERS; i++) {             forks[i] = new Semaphore(1);         }     }      public void wantsToEat(int philosopher,                            Runnable pickLeftFork,                            Runnable pickRightFork,                            Runnable eat,                            Runnable putLeftFork,                            Runnable putRightFork) throws InterruptedException {          // Choose the philosopher with the lowest id as the left philosopher         int leftFork = philosopher;         int rightFork = (philosopher + 1) % MAX_PHILOSOPHERS;          // Acquire the left fork         forks[leftFork].acquire();         pickLeftFork.run();          // Acquire the right fork         forks[rightFork].acquire();         pickRightFork.run();          // Eat         eat.run();          // Release the forks         putLeftFork.run();         forks[leftFork].release();          putRightFork.run();         forks[rightFork].release();     } }",1,"1226-the-dining-philosophers/DiningPhilosophers.java:11:5: Redundant 'public' modifier. [RedundantModifier]
1226-the-dining-philosophers/DiningPhilosophers.java:11:5: Redundant 'public' modifier. [RedundantModifier]
",0,0,0
class Solution {     public double nthPersonGetsNthSeat(int n) {         if (n == 1) {             return 1.0;         } else {             return 0.5;         }     } },0,,0,0,0
"import java.util.*;  class Solution {     public List<String> removeSubfolders(String[] folder) {         // Sort the folders in lexicographic order         Arrays.sort(folder);         List<String> result = new ArrayList<>();         // Add the first folder to the result list         result.add(folder[0]);         String prev = folder[0] + ""/"";         // Traverse the rest of the folders         for (int i = 1; i < folder.length; i++) {             // Check if the current folder starts with the previous folder path             if (!folder[i].startsWith(prev)) {                 // If it doesn't, add it to the result list                 result.add(folder[i]);                 prev = folder[i] + ""/"";             }         }         return result;     } }",0,,0,0,0
"class Solution {     public int balancedString(String s) {         int[] freq = new int[128];         int n = s.length();         int target = n / 4;     //target frequency of each character                  //count frequency of each character         for(char c : s.toCharArray()){             freq[c]++;         }                  int left = 0;         int right = 0;         int result = Integer.MAX_VALUE;                  while(right < n){             //keep moving right pointer until string is not balanced             freq[s.charAt(right)]--;             right++;                          //keep moving left pointer until string is balanced             while(left < n && freq['Q'] <= target && freq['W'] <= target && freq['E'] <= target && freq['R'] <= target){                 result = Math.min(result, right - left);                 freq[s.charAt(left)]++;                 left++;             }         }         return result;     }   }",0,,0,0,0
"import java.util.ArrayList; import java.util.List;  /**  * // This is the custom function interface.  * // You should not implement it, or speculate about its implementation  * class CustomFunction {  * // Returns f(x, y) for any given positive integers x and y.  * // Note that f(x, y) is increasing with respect to both x and y.  * // i.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)  * public int f(int x, int y);  * };  */ class Solution {     public List<List<Integer>> findSolution(CustomFunction customfunction, int z) {         List<List<Integer>> result = new ArrayList<>();         int x = 1, y = 1000;         while (x <= 1000 && y >= 1) {             int value = customfunction.f(x, y);             if (value == z) {                 result.add(List.of(x, y));                 x++;                 y--;             } else if (value < z) {                 x++;             } else {                 y--;             }         }         return result;     } }",1,"1237-find-positive-integer-solution-for-a-given-equation/CustomFunction.java:17:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1237-find-positive-integer-solution-for-a-given-equation/CustomFunction.java:17:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"import java.util.*;  class Solution {     public List<Integer> circularPermutation(int n, int start) {         List<Integer> ans = new ArrayList<>();         for (int i = 0; i < (1 << n); i++) {             ans.add(i ^ (i >> 1));             if (ans.get(i) == start) {                 Collections.rotate(ans, -i);                 return ans;             }         }         return ans;     } }",0,,0,0,0
"import java.util.*;  class Solution {     public int maxLength(List<String> arr) {         List<Integer> dp = new ArrayList<Integer>();         dp.add(0);         int res = 0;         for (String s : arr) {             int a = 0, dup = 0;             for (char c : s.toCharArray()) {                 dup |= a & (1 << (c - 'a'));                 a |= 1 << (c - 'a');             }             if (dup > 0)                 continue;             for (int i = dp.size() - 1; i >= 0; i--) {                 int t = dp.get(i);                 if ((t & a) > 0)                     continue;                 dp.add(t | a);                 res = Math.max(res, Integer.bitCount(t | a));             }         }         return res;     } }",1,"1239-maximum-length-of-a-concatenated-string-with-unique-characters/Solution.java:9:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1239-maximum-length-of-a-concatenated-string-with-unique-characters/Solution.java:9:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1239-maximum-length-of-a-concatenated-string-with-unique-characters/Solution.java:5:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new ArrayList<>()`
",1,0,0
"class Solution {     public int minimumSwap(String s1, String s2) {                  int xyCount = 0;         int yxCount = 0;                  for(int i = 0; i < s1.length(); i++){                          if(s1.charAt(i) == 'x' && s2.charAt(i) == 'y'){                 xyCount++;             }             else if(s1.charAt(i) == 'y' && s2.charAt(i) == 'x'){                 yxCount++;             }         }                  // If the number of x's and y's in both the strings is not equal          // then we cannot make the strings equal.         if((xyCount + yxCount) % 2 != 0){             return -1;         }                  // If we have characters that can be swapped between the two strings         // We can swap 1 characters or 2 characters (xy and yx)         // We can calculate the minimum number of swaps required using ceil count of xy/2 and yx/2.          int result = (int)(Math.ceil(xyCount/2.0) + Math.ceil(yxCount/2.0));                  return result;        } }",1,"1247-minimum-swaps-to-make-strings-equal/Solution.java:11:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1247-minimum-swaps-to-make-strings-equal/Solution.java:11:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1247-minimum-swaps-to-make-strings-equal/Solution.java:26:	UnnecessaryLocalBeforeReturn:	Consider simply returning the value vs storing it in local variable 'result'
",0,0,0
"class Solution {     public int numberOfSubarrays(int[] nums, int k) {         int left = 0;         int right = 0;         int oddCount = 0;         int ans = 0;          while (right < nums.length) {             if (nums[right] % 2 == 1) {                 oddCount++;             }             while (oddCount > k) {                 if (nums[left] % 2 == 1) {                     oddCount--;                 }                 left++;             }             int windowSize = right - left + 1;             if (oddCount == k) {                 ans += windowSize;             }             right++;         }          return ans;     } }",0,,0,0,0
"class Solution {     public String minRemoveToMakeValid(String s) {         char[] arr = s.toCharArray();         int left = 0, right = 0;                  // First, remove all redundant closing parentheses         for(int i = 0; i < arr.length; i++){             if(arr[i] == '('){                 left++;             } else if(arr[i] == ')'){                 if(left == 0){                     arr[i] = '*';                 } else {                     left--;                 }             }         }                  // Then, remove redundant opening parentheses         for(int i = arr.length - 1; i >= 0; i--){             if(arr[i] == ')'){                 right++;             } else if(arr[i] == '('){                 if(right == 0){                     arr[i] = '*';                 } else {                     right--;                 }             }         }                  // Finally, construct the resulting string and return         StringBuilder sb = new StringBuilder();         for(int i = 0; i < arr.length; i++){             if(arr[i] != '*'){                 sb.append(arr[i]);             }         }         return sb.toString();     } }",1,"1249-minimum-remove-to-make-valid-parentheses/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1249-minimum-remove-to-make-valid-parentheses/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1249-minimum-remove-to-make-valid-parentheses/Solution.java:34:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",1,0,1
"class Solution {     public int[][] reconstructMatrix(int upper, int lower, int[] colsum) {         int n = colsum.length;         int[][] matrix = new int[2][n];         for (int i = 0; i < n; i++) {             if (colsum[i] == 2) {                 matrix[0][i] = matrix[1][i] = 1;                 upper -= 1;                 lower -= 1;             }         }         if (upper < 0 || lower < 0) {             return new int[0][0];         }         for (int i = 0; i < n; i++) {             if (colsum[i] == 1) {                 if (upper > 0) {                     matrix[0][i] = 1;                     upper -= 1;                 } else if (lower > 0) {                     matrix[1][i] = 1;                     lower -= 1;                 } else {                     return new int[0][0];                 }             }         }         if (upper != 0 || lower != 0) {             return new int[0][0];         }         return matrix;     } }",1,"1253-reconstruct-a-2-row-binary-matrix/Solution.java:7:45: Inner assignments should be avoided. [InnerAssignment]
1253-reconstruct-a-2-row-binary-matrix/Solution.java:7:45: Inner assignments should be avoided. [InnerAssignment]
1253-reconstruct-a-2-row-binary-matrix/Solution.java:8:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'upper'
1253-reconstruct-a-2-row-binary-matrix/Solution.java:9:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'lower'
",0,1,0
"class Solution {     public int closedIsland(int[][] grid) {         int m = grid.length;         int n = grid[0].length;         int count = 0;                  // mark all the edge 0s as visited         for(int i=0; i<m; i++) {             if(grid[i][0] == 0) dfs(grid, i, 0);             if(grid[i][n-1] == 0) dfs(grid, i, n-1);         }                  for(int j=0; j<n; j++) {             if(grid[0][j] == 0) dfs(grid, 0, j);             if(grid[m-1][j] == 0) dfs(grid, m-1, j);         }                  // perform dfs on unvisited 0s         for(int i=1; i<m-1; i++) {             for(int j=1; j<n-1; j++) {                 if(grid[i][j] == 0) {                     count++;                     dfs(grid, i, j);                 }             }         }                  return count;     }          private void dfs(int[][] grid, int i, int j) {         int m = grid.length;         int n = grid[0].length;                  if(i<0 || j<0 || i>=m || j>=n || grid[i][j] == 1) return;                  grid[i][j] = 1;                  dfs(grid, i-1, j);         dfs(grid, i+1, j);         dfs(grid, i, j-1);         dfs(grid, i, j+1);     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class FindElements {     private Set<Integer> values;      public FindElements(TreeNode root) {         root.val = 0;         values = new HashSet<>();         recover(root, 0);     }          public boolean find(int target) {         return values.contains(target);     }          private void recover(TreeNode node, int val) {         if (node == null) {             return;         }         node.val = val;         values.add(val);         recover(node.left, 2 * val + 1);         recover(node.right, 2 * val + 2);     } }",1,"1261-find-elements-in-a-contaminated-binary-tree/TreeNode.java:19:5: Redundant 'public' modifier. [RedundantModifier]
1261-find-elements-in-a-contaminated-binary-tree/TreeNode.java:19:5: Redundant 'public' modifier. [RedundantModifier]
",0,0,0
"class Solution {     public int maxSumDivThree(int[] nums) {         int n = nums.length;         int sum = 0;          // Collect sum of all elements in the array         for (int i = 0; i < n; i++) {             sum += nums[i];         }          // Using DP to store the best sum modulo 3 upto this index         int[] dp = new int[3];         for (int i = 0; i < n; i++) {             int mod = nums[i] % 3;             int[] temp = Arrays.copyOf(dp, dp.length); // Copying DP[] to temp[]              for (int j = 0; j < 3; j++) {                 int index = (j + mod) % 3;                 dp[index] = Math.max(dp[index], temp[j] + nums[i]);             }         }         return dp[0] != 0 ? dp[0] : (sum % 3 == 0 ? sum : 0); // Returning the final result based on above DP     } }",1,"1262-greatest-sum-divisible-by-three/Solution.java:22:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
1262-greatest-sum-divisible-by-three/Solution.java:22:	UselessParentheses:	Useless parentheses.
",0,0,0
class Solution {     public int countServers(int[][] grid) {         int m = grid.length; // number of rows         int n = grid[0].length; // number of columns         int[] rowSum = new int[m]; // keeps track of the sum of each row         int[] colSum = new int[n]; // keeps track of the sum of each column         int count = 0; // counts the number of servers that communicate                  // calculate row and column sums         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 rowSum[i] += grid[i][j];                 colSum[j] += grid[i][j];             }         }                  // check for servers that communicate         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 if (grid[i][j] == 1 && (rowSum[i] > 1 || colSum[j] > 1)) {                     count++;                 }             }         }                  return count;     } },0,,0,0,0
"import java.util.*;  class Solution {     public List<List<String>> suggestedProducts(String[] products, String searchWord) {         Arrays.sort(products);         List<List<String>> result = new ArrayList<>();         String prefix = """";         for (char c : searchWord.toCharArray()) {             prefix += c;             List<String> suggestions = new ArrayList<>();             for (String product : products) {                 if (product.startsWith(prefix)) {                     suggestions.add(product);                     if (suggestions.size() >= 3) break;                 }             }             result.add(suggestions);         }         return result;     } }",1,"1268-search-suggestions-system/Solution.java:9:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
",0,0,0
"import java.util.*;  class Solution {     public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {                  List<Integer> result = new ArrayList<>();                  int small = tomatoSlices - 2 * cheeseSlices;         int jumbo = cheeseSlices - small / 2;                  if (small >= 0 && small % 2 == 0 && jumbo >= 0 && jumbo % 1 == 0) {             result.add(jumbo);             result.add(small / 2);         }                  return result;     } }",0,,0,0,0
"class Solution {     public int countSquares(int[][] matrix) {         int m = matrix.length; // number of rows         int n = matrix[0].length; // number of columns         int count = 0; // number of squares                  // Iterate over all cells in the matrix         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 if (matrix[i][j] == 1) { // if the current cell is a 1                     // check how far to the right and down we can go                     int max = Math.min(m-i, n-j);                     for (int k = 1; k < max; k++) { // iterate over possible square sizes                         boolean allOnes = true;                         // check if all cells in the square are 1s                         for (int x = i; x <= i+k; x++) {                             for (int y = j; y <= j+k; y++) {                                 if (matrix[x][y] != 1) {                                     allOnes = false;                                     break;                                 }                             }                             if (!allOnes) {                                 break;                             }                         }                         if (allOnes) {                             count++; // increment the counter                         } else {                             break; // we can't go any further to the right or down                         }                     }                 }             }         }         return count;     } }",0,,0,0,0
"class Solution {     public int longestConsecutive(int[] nums) {         Set<Integer> set = new HashSet<>();         for(int num : nums) {             set.add(num);         }         int maxLen = 0;         for(int num : nums) {             if(!set.contains(num - 1)) {                 int cur = num;                 int len = 1;                 while(set.contains(cur + 1)) {                     cur++;                     len++;                 }                 maxLen = Math.max(maxLen, len);             }         }         return maxLen;     } }",0,,0,0,0
"import java.util.*;  class Solution {     public List<List<Integer>> groupThePeople(int[] groupSizes) {         List<List<Integer>> result = new ArrayList<>();         Map<Integer, List<Integer>> groups = new HashMap<>();                  for (int i = 0; i < groupSizes.length; i++) {             int size = groupSizes[i];             if (!groups.containsKey(size)) {                 groups.put(size, new ArrayList<Integer>());             }             groups.get(size).add(i);             if (groups.get(size).size() == size) {                 result.add(groups.get(size));                 groups.put(size, new ArrayList<Integer>());             }         }                  return result;     } }",1,"1282-group-the-people-given-the-group-size-they-belong-to/Solution.java:6:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
1282-group-the-people-given-the-group-size-they-belong-to/Solution.java:11:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new ArrayList<>()`
1282-group-the-people-given-the-group-size-they-belong-to/Solution.java:16:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new ArrayList<>()`
",0,0,0
"class Solution {     public int smallestDivisor(int[] nums, int threshold) {         int left = 1, right = (int)1e6;         while(left < right) {             int middle = (left + right) / 2, sum = 0;             for(int num : nums) {                 sum += (num - 1) / middle + 1;             }             if(sum <= threshold) right = middle;             else left = middle + 1;         }         return left;     } }",1,"1283-find-the-smallest-divisor-given-a-threshold/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1283-find-the-smallest-divisor-given-a-threshold/Solution.java:5:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1283-find-the-smallest-divisor-given-a-threshold/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1283-find-the-smallest-divisor-given-a-threshold/Solution.java:5:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"import java.util.*;  class CombinationIterator {     private int[] indices;     private String characters;     private int combinationLength;     private boolean hasNext;          public CombinationIterator(String characters, int combinationLength) {         this.indices = new int[combinationLength];         for (int i = 0; i < combinationLength; i++) {             this.indices[i] = i;         }         this.characters = characters;         this.combinationLength = combinationLength;         this.hasNext = true;     }          public String next() {         StringBuilder sb = new StringBuilder();         for (int index : indices) {             sb.append(characters.charAt(index));         }                  // Update indices         int n = characters.length();         int i = combinationLength - 1;         while (i >= 0 && indices[i] == n - combinationLength + i) {             i--;         }         if (i < 0) {             hasNext = false;         } else {             indices[i]++;             for (int j = i + 1; j < combinationLength; j++) {                 indices[j] = indices[i] + j - i;             }         }                  return sb.toString();     }          public boolean hasNext() {         return hasNext;     } }  /**  * Your CombinationIterator object will be instantiated and called as such:  * CombinationIterator obj = new CombinationIterator(characters, combinationLength);  * String param_1 = obj.next();  * boolean param_2 = obj.hasNext();  */",1,"1286-iterator-for-combination/CombinationIterator.java:9:5: Redundant 'public' modifier. [RedundantModifier]
1286-iterator-for-combination/CombinationIterator.java:9:39: 'characters' hides a field. [HiddenField]
1286-iterator-for-combination/CombinationIterator.java:9:55: 'combinationLength' hides a field. [HiddenField]
1286-iterator-for-combination/CombinationIterator.java:9:5: Redundant 'public' modifier. [RedundantModifier]
1286-iterator-for-combination/CombinationIterator.java:9:39: 'characters' hides a field. [HiddenField]
1286-iterator-for-combination/CombinationIterator.java:9:55: 'combinationLength' hides a field. [HiddenField]
1286-iterator-for-combination/CombinationIterator.java:1:	UnnecessaryImport:	Unused import 'java.util.*'
1286-iterator-for-combination/CombinationIterator.java:7:	AvoidFieldNameMatchingMethodName:	Field hasNext has the same name as a method
",0,0,0
"class Solution {     public int removeCoveredIntervals(int[][] intervals) {         int count = 0;         int n = intervals.length;                  // Sort the intervals based on start time         Arrays.sort(intervals, (a,b) -> a[0]-b[0]);                  int end = intervals[0][1];         count++;                  // Check for each interval if it is not covered by the previous interval         // Update the end time of the previous interval if the current interval is covered         // Count the remaining intervals         for(int i=1; i<n; i++){             int[] curr = intervals[i];             if(end < curr[1]){                 end = curr[1];                 count++;             }         }         return count;     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public int sumNumbers(TreeNode root) {         return findSum(root, 0);     }          private int findSum(TreeNode node, int current) {         if (node == null) {             return 0;         }         current = current * 10 + node.val;         if (node.left == null && node.right == null) {             return current;         }         return findSum(node.left, current) + findSum(node.right, current);     } }",1,"129-sum-root-to-leaf-numbers/TreeNode.java:25:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'current'
",0,1,0
"class Solution {     public List<Integer> sequentialDigits(int low, int high) {                  List<Integer> result = new ArrayList<>();         String allDigits = ""123456789"";         int lowDigitCount = String.valueOf(low).length();         int highDigitCount = String.valueOf(high).length();                  for(int i=lowDigitCount; i<=highDigitCount; i++) {             for(int j=0; j<=9-i; j++) {                 String current = allDigits.substring(j, j+i);                 int currentNum = Integer.parseInt(current);                 if(currentNum>=low && currentNum<=high) {                     result.add(currentNum);                 }             }         }                  return result;     } }",0,,0,0,0
"class Solution {     public int maxSideLength(int[][] mat, int threshold) {         int m = mat.length;         int n = mat[0].length;         int[][] prefixSum = new int[m + 1][n + 1];         int maxLength = 0;         // Taking Prefix sum of the Matrix         for (int i = 1; i <= m; i++) {             for (int j = 1; j <= n; j++) {                 prefixSum[i][j] = prefixSum[i-1][j] + prefixSum[i][j-1] - prefixSum[i-1][j-1] + mat[i-1][j-1];                    }         }         // Binary Search on the size of the square         int lo = 0, hi = Math.min(m, n);         while(lo <= hi) {             int mid = lo + (hi - lo)/2;             boolean found = false;             for (int i = mid; i <= m && !found; i++) {                 for (int j = mid; j <= n && !found; j++) {                     int sum = prefixSum[i][j] - prefixSum[i-mid][j]                             - prefixSum[i][j-mid] + prefixSum[i-mid][j-mid];                     if(sum <= threshold) {                         found = true;                         maxLength = mid;                     }                 }             }             if (found) {                 lo = mid + 1;             } else {                 hi = mid - 1;             }         }         return maxLength;     } }",1,"1292-maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/Solution.java:14:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1292-maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/Solution.java:14:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"import java.util.*;  class Solution {     public boolean isPossibleDivide(int[] nums, int k) {         // If nums array is not divisible by k, return false         if (nums.length % k != 0) {             return false;         }                  Map<Integer, Integer> map = new TreeMap<>();         // Count occurrences of each number in the array         for (int num : nums) {             map.put(num, map.getOrDefault(num, 0) + 1);         }                  // Iterate over each distinct number         for (int num : map.keySet()) {             int count = map.get(num);             // If count is already 0, it means this number has already been used             if (count == 0) {                 continue;             }             // Iterate over k consecutive numbers             for (int i = num; i < num + k; i++) {                 // If any number is not present in the map, return false                 if (!map.containsKey(i) || map.get(i) < count) {                     return false;                 }                 // Decrement count for each number                 map.put(i, map.get(i) - count);             }         }                  return true;     } }",1,"1296-divide-array-in-sets-of-k-consecutive-numbers/Solution.java:10:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
",0,0,0
"class Solution {     public int maxFreq(String s, int maxLetters, int minSize, int maxSize) {          HashMap<String, Integer> map = new HashMap<>();         int maxFreq = 0;          for(int i =0; i <= s.length() - minSize; i++) {             String current = s.substring(i, i + minSize);             if(check(current, maxLetters)) {                 if(map.containsKey(current)) {                     int freq = map.get(current);                     freq++;                     map.put(current, freq);                 } else {                     map.put(current, 1);                 }                 maxFreq = Math.max(maxFreq, map.get(current));             }         }         return maxFreq;     }       private boolean check(String s, int maxLetters) {         HashSet<Character> set = new HashSet<>();         for(int i =0 ; i< s.length(); i++) {             set.add(s.charAt(i));             if(set.size() > maxLetters) {                 return false;             }         }         return true;     } }",0,,0,0,0
"class Solution {     public int maxFreq(String s, int maxLetters, int minSize, int maxSize) {          HashMap<String, Integer> map = new HashMap<>();         int maxFreq = 0;          for(int i =0; i <= s.length() - minSize; i++) {             String current = s.substring(i, i + minSize);             if(check(current, maxLetters)) {                 if(map.containsKey(current)) {                     int freq = map.get(current);                     freq++;                     map.put(current, freq);                 } else {                     map.put(current, 1);                 }                 maxFreq = Math.max(maxFreq, map.get(current));             }         }         return maxFreq;     }       private boolean check(String s, int maxLetters) {         HashSet<Character> set = new HashSet<>();         for(int i =0 ; i< s.length(); i++) {             set.add(s.charAt(i));             if(set.size() > maxLetters) {                 return false;             }         }         return true;     } }",0,,0,0,0
"class Solution {     public int findBestValue(int[] arr, int target) {         int n = arr.length;         int left = 0, right = 0, sum = 0;         for (int i = 0; i < n; i++) {             right = Math.max(right, arr[i]);             sum += arr[i];         }         if (sum <= target) {             return right;         }         int diff = Integer.MAX_VALUE, val = 0;         while (left <= right) {             int mid = left + (right - left) / 2;             int curSum = getSum(arr, mid);             if (Math.abs(curSum - target) < diff || (Math.abs(curSum - target) == diff && mid < val)) {                 diff = Math.abs(curSum - target);                 val = mid;             }             if (curSum > target) {                 right = mid - 1;             } else {                 left = mid + 1;             }         }         return val;     }          private int getSum(int[] arr, int val) {         int sum = 0;         for (int num : arr) {             sum += Math.min(num, val);         }         return sum;     } }",1,"1300-sum-of-mutated-array-closest-to-target/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1300-sum-of-mutated-array-closest-to-target/Solution.java:12:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1300-sum-of-mutated-array-closest-to-target/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1300-sum-of-mutated-array-closest-to-target/Solution.java:12:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1300-sum-of-mutated-array-closest-to-target/Solution.java:4:	PrematureDeclaration:	Declaration of 'left' can be moved closer to its usages
",1,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public int deepestLeavesSum(TreeNode root) {         Map<Integer, Integer> deepestLeaves = new HashMap<>();         traverse(root, deepestLeaves, 0);         return deepestLeaves.get(deepestLeaves.keySet().stream().max(Integer::compareTo).get());     }          private void traverse(TreeNode node, Map<Integer, Integer> deepestLeaves, int depth) {         if (node == null) {             return;         }                  if (node.left == null && node.right == null) {             deepestLeaves.put(depth, deepestLeaves.getOrDefault(depth, 0) + node.val);         }                  traverse(node.left, deepestLeaves, depth + 1);         traverse(node.right, deepestLeaves, depth + 1);     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public List<Integer> getAllElements(TreeNode root1, TreeNode root2) {         List<Integer> list = new ArrayList<>();         Stack<TreeNode> stack1 = new Stack<>();         Stack<TreeNode> stack2 = new Stack<>();         while (root1 != null || root2 != null || !stack1.isEmpty() || !stack2.isEmpty()) {             while (root1 != null) {                 stack1.push(root1);                 root1 = root1.left;             }             while (root2 != null) {                 stack2.push(root2);                 root2 = root2.left;             }             if (stack2.isEmpty() || !stack1.isEmpty() && stack1.peek().val <= stack2.peek().val) {                 root1 = stack1.pop();                 list.add(root1.val);                 root1 = root1.right;             } else {                 root2 = stack2.pop();                 list.add(root2.val);                 root2 = root2.right;             }         }         return list;     } }",1,"1305-all-elements-in-two-binary-search-trees/TreeNode.java:24:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'root1'
1305-all-elements-in-two-binary-search-trees/TreeNode.java:28:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'root2'
",0,1,0
"class Solution {     public boolean canReach(int[] arr, int start) {         if (start < 0 || start >= arr.length || arr[start] < 0) {             // Returns false if start is out of bounds or arr[start] is negative.             return false;         }         if (arr[start] == 0) {             // Returns true if arr[start] is already 0.             return true;         }         arr[start] *= -1; // Mark the current index as negative to avoid infinite loop.         return canReach(arr, start + arr[start]) || canReach(arr, start - arr[start]);     } }",0,,0,0,0
"class Solution {     public boolean canReach(int[] arr, int start) {         if (start < 0 || start >= arr.length || arr[start] < 0) {             // Returns false if start is out of bounds or arr[start] is negative.             return false;         }         if (arr[start] == 0) {             // Returns true if arr[start] is already 0.             return true;         }         arr[start] *= -1; // Mark the current index as negative to avoid infinite loop.         return canReach(arr, start + arr[start]) || canReach(arr, start - arr[start]);     } }",0,,0,0,0
"class Solution {     public int[] xorQueries(int[] arr, int[][] queries) {         int[] prefixXOR = new int[arr.length + 1];         for (int i = 0; i < arr.length; i++) {             prefixXOR[i + 1] = prefixXOR[i] ^ arr[i];         }         int[] result = new int[queries.length];         for (int i = 0; i < queries.length; i++) {             result[i] = prefixXOR[queries[i][0]] ^ prefixXOR[queries[i][1] + 1];         }         return result;     } }",0,,0,0,0
"import java.util.*;  class Solution {     public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {         Map<String, Integer> freqMap = new HashMap<>();         boolean[] visited = new boolean[friends.length];         Queue<Integer> queue = new LinkedList<>();         queue.offer(id);         visited[id] = true;         int currLevel = 0;         while (!queue.isEmpty() && currLevel <= level) {             int size = queue.size();             for (int i = 0; i < size; i++) {                 int currId = queue.poll();                 if (currLevel == level) {                     List<String> videos = watchedVideos.get(currId);                     for (String video : videos) {                         freqMap.put(video, freqMap.getOrDefault(video, 0) + 1);                     }                 } else {                     int[] currFriends = friends[currId];                     for (int friend : currFriends) {                         if (!visited[friend]) {                             queue.offer(friend);                             visited[friend] = true;                         }                     }                 }             }             currLevel++;         }         List<String> result = new ArrayList<>(freqMap.keySet());         Collections.sort(result, new Comparator<String>() {             public int compare(String s1, String s2) {                 int freq1 = freqMap.get(s1);                 int freq2 = freqMap.get(s2);                 if (freq1 == freq2) {                     return s1.compareTo(s2);                 } else {                     return freq1 - freq2;                 }             }         });         return result;     } }",1,"1311-get-watched-videos-by-your-friends/Solution.java:5:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
1311-get-watched-videos-by-your-friends/Solution.java:33:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new Comparator<>()`
1311-get-watched-videos-by-your-friends/Solution.java:34:	MissingOverride:	The method 'compare(String, String)' is missing an @Override annotation.
",0,0,0
"class Solution {     public int[][] matrixBlockSum(int[][] mat, int k) {         int m = mat.length;         int n = mat[0].length;                  // create a prefix sum matrix         int[][] prefixSum = new int[m+1][n+1];         for(int i=1;i<=m;i++){             for(int j=1;j<=n;j++){                 prefixSum[i][j] = prefixSum[i][j-1] + prefixSum[i-1][j] + mat[i-1][j-1] - prefixSum[i-1][j-1];             }         }                  // calculate the answer matrix         int[][] answer = new int[m][n];         for(int i=0;i<m;i++){             for(int j=0;j<n;j++){                 int x1 = Math.max(0, i-k);                 int y1 = Math.max(0, j-k);                 int x2 = Math.min(m-1, i+k);                 int y2 = Math.min(n-1, j+k);                 answer[i][j] = prefixSum[x2+1][y2+1] - prefixSum[x2+1][y1] - prefixSum[x1][y2+1] + prefixSum[x1][y1];             }         }                  return answer;     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public int sumEvenGrandparent(TreeNode root) {         return sumEvenGrandparent(root, null, null);     }          private int sumEvenGrandparent(TreeNode root, TreeNode parent, TreeNode grandparent) {         if (root == null) {             return 0;         }         int sum = 0;         if (grandparent != null && grandparent.val % 2 == 0) {             sum += root.val;         }         sum += sumEvenGrandparent(root.left, root, parent);         sum += sumEvenGrandparent(root.right, root, parent);         return sum;     } }",0,,0,0,0
"class Solution {     public int minFlips(int a, int b, int c) {         int flips = 0;         for(int i=0; i<31; i++){             boolean bitA = ((a>>i) & 1) == 1;             boolean bitB = ((b>>i) & 1) == 1;             boolean bitC = ((c>>i) & 1) == 1;             if(bitC){                 if(!bitA && !bitB) flips++;             }             else{                 if(bitA) flips++;                 if(bitB) flips++;             }         }         return flips;     } }",1,"1318-minimum-flips-to-make-a-or-b-equal-to-c/Solution.java:10:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1318-minimum-flips-to-make-a-or-b-equal-to-c/Solution.java:10:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
"class Solution {     public int makeConnected(int n, int[][] connections) {         //if number of cables is less than n-1 then we cannot make all connecitons         if(connections.length < n-1) {             return -1;         }        //create a graph         List<List<Integer>> graph = new ArrayList<>();         for(int i=0;i<n;i++) {             graph.add(new ArrayList<>());         }         //adding edges to graph         for(int[] connection : connections) {             graph.get(connection[0]).add(connection[1]);             graph.get(connection[1]).add(connection[0]);         }         //using dfs getting number of disconnected components         boolean[] visited = new boolean[n];         int components = 0;         for(int i=0;i<n;i++) {             if(!visited[i]) {                 dfs(graph,visited,i);                 components++;             }         }         //minimum required cables          return components-1;     }          //dfs traversal     private void dfs(List<List<Integer>> graph, boolean[] visited, int node) {         visited[node] = true;         for(int neighbour : graph.get(node)) {             if(!visited[neighbour]) {                 dfs(graph,visited,neighbour);             }         }     } }",0,,0,0,0
"import java.util.ArrayList; import java.util.List;  class Solution {     public List<String> printVertically(String s) {         String[] words = s.split("" "");         int maxLength = getMaxStringLength(words);         List<String> result = new ArrayList<>();         for (int i = 0; i < maxLength; i++) {             StringBuilder sb = new StringBuilder();             for (String word : words) {                 if (i < word.length()) {                     sb.append(word.charAt(i));                 } else {                     sb.append("" "");                 }             }             result.add(sb.toString().replaceAll(""\\s+$"", """"));         }         return result;     }      private int getMaxStringLength(String[] words) {         int maxLength = 0;         for (String word : words) {             maxLength = Math.max(maxLength, word.length());         }         return maxLength;     } }",1,"1324-print-words-vertically/Solution.java:15:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */  class Solution {     public TreeNode removeLeafNodes(TreeNode root, int target) {         if (root == null)             return null;         root.left = removeLeafNodes(root.left, target);         root.right = removeLeafNodes(root.right, target);         if (root.left == null && root.right == null && root.val == target)             return null;         return root;     } }",0,,0,0,0
"public class Solution {     public String breakPalindrome(String palindrome) {         if(palindrome.length() == 1) return """";         char[] charArray = palindrome.toCharArray();         for(int i = 0; i < charArray.length; i++) {             if(charArray[i] != 'a') {                 charArray[i] = 'a';                 if(!isPalindrome(charArray)) {                     return String.valueOf(charArray);                 }                 charArray[i] = palindrome.charAt(i);             }         }         charArray[charArray.length - 1] = 'b';         return String.valueOf(charArray);     }          private boolean isPalindrome(char[] charArray) {         int i = 0;         int j = charArray.length - 1;         while(i < j) {             if(charArray[i] != charArray[j]) {                 return false;             }             i++;             j--;         }         return true;     } }",0,,0,0,0
"class Solution {     public int[][] diagonalSort(int[][] mat) {         int m = mat.length;         int n = mat[0].length;         Map<Integer, PriorityQueue<Integer>> diagMap = new HashMap<>();         for(int i=0;i<m;i++){             for(int j=0;j<n;j++){                 diagMap.putIfAbsent(i-j, new PriorityQueue<>());                 diagMap.get(i-j).add(mat[i][j]);             }         }         int[][] res = new int[m][n];         for(int i=0;i<m;i++){             for(int j=0;j<n;j++){                 res[i][j] = diagMap.get(i-j).poll();             }         }         return res;     } }",0,,0,0,0
"// Definition for a Node. class Node {     public int val;     public List<Node> neighbors;     public Node() {         val = 0;         neighbors = new ArrayList<Node>();     }     public Node(int _val) {         val = _val;         neighbors = new ArrayList<Node>();     }     public Node(int _val, ArrayList<Node> _neighbors) {         val = _val;         neighbors = _neighbors;     } }  class Solution {     public Node cloneGraph(Node node) {         if(node==null)             return node;                  HashMap<Node, Node> visited = new HashMap<>();         Queue<Node> queue = new LinkedList<>();         queue.add(node);         visited.put(node, new Node(node.val));                   while(!queue.isEmpty()){             Node n = queue.poll();              for(Node neighbor: n.neighbors){                 if(!visited.containsKey(neighbor)){                     visited.put(neighbor, new Node(neighbor.val));                     queue.add(neighbor);                 }                 visited.get(n).neighbors.add(visited.get(neighbor));             }         }                  return visited.get(node);     } }",1,"133-clone-graph/Node.java:3:16: Variable 'val' must be private and have accessor methods. [VisibilityModifier]
133-clone-graph/Node.java:4:23: Variable 'neighbors' must be private and have accessor methods. [VisibilityModifier]
133-clone-graph/Node.java:5:5: Redundant 'public' modifier. [RedundantModifier]
133-clone-graph/Node.java:9:5: Redundant 'public' modifier. [RedundantModifier]
133-clone-graph/Node.java:13:5: Redundant 'public' modifier. [RedundantModifier]
133-clone-graph/Node.java:3:16: Variable 'val' must be private and have accessor methods. [VisibilityModifier]
133-clone-graph/Node.java:4:23: Variable 'neighbors' must be private and have accessor methods. [VisibilityModifier]
133-clone-graph/Node.java:5:5: Redundant 'public' modifier. [RedundantModifier]
133-clone-graph/Node.java:9:5: Redundant 'public' modifier. [RedundantModifier]
133-clone-graph/Node.java:13:5: Redundant 'public' modifier. [RedundantModifier]
",0,0,0
"import java.util.ArrayList; import java.util.Comparator; import java.util.List;  class Solution {     public List<Integer> filterRestaurants(int[][] restaurants, int veganFriendly, int maxPrice, int maxDistance) {         // Filter restaurants         List<int[]> filteredRestaurants = new ArrayList<>();         for (int i = 0; i < restaurants.length; i++) {             if ((veganFriendly == 0 || restaurants[i][2] == 1)                     && restaurants[i][3] <= maxPrice                     && restaurants[i][4] <= maxDistance) {                 filteredRestaurants.add(restaurants[i]);             }         }          // Sort filtered restaurants         filteredRestaurants.sort((r1, r2) -> {             if (r1[1] != r2[1]) {                 return Integer.compare(r2[1], r1[1]);             } else {                 return Integer.compare(r2[0], r1[0]);             }         });          // Extract restaurants IDs from filtered and sorted restaurants         List<Integer> result = new ArrayList<>();         for (int i = 0; i < filteredRestaurants.size(); i++) {             result.add(filteredRestaurants.get(i)[0]);         }          return result;     } }",1,"1333-filter-restaurants-by-vegan-friendly-price-and-distance/Solution.java:2:8: Unused import - java.util.Comparator. [UnusedImports]
1333-filter-restaurants-by-vegan-friendly-price-and-distance/Solution.java:2:8: Unused import - java.util.Comparator. [UnusedImports]
1333-filter-restaurants-by-vegan-friendly-price-and-distance/Solution.java:2:	UnnecessaryImport:	Unused import 'java.util.Comparator'
1333-filter-restaurants-by-vegan-friendly-price-and-distance/Solution.java:9:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
1333-filter-restaurants-by-vegan-friendly-price-and-distance/Solution.java:19:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
1333-filter-restaurants-by-vegan-friendly-price-and-distance/Solution.java:28:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"import java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; import java.util.PriorityQueue;  class Solution {     public int findTheCity(int n, int[][] edges, int distanceThreshold) {         // Build adjacency list representation of the graph         ArrayList<int[]>[] adjList = new ArrayList[n];         for (int i = 0; i < n; i++) {             adjList[i] = new ArrayList<int[]>();         }         for (int[] edge : edges) {             int from = edge[0];             int to = edge[1];             int weight = edge[2];             adjList[from].add(new int[] { to, weight });             adjList[to].add(new int[] { from, weight });         }          // Use Dijkstra's algorithm to calculate the number of reachable cities from each node         int[][] distances = new int[n][n];         for (int i = 0; i < n; i++) {             dijkstra(i, adjList, distances[i]);         }          // Find the city with the smallest number of reachable cities that is greater than or equal to any other city         int minReachable = n;         int minCity = -1;         for (int i = 0; i < n; i++) {             int reachable = 0;             for (int j = 0; j < n; j++) {                 if (distances[i][j] <= distanceThreshold) {                     reachable++;                 }             }             if (reachable <= minReachable) {                 minReachable = reachable;                 minCity = i;             }         }         return minCity;     }      private void dijkstra(int start, ArrayList<int[]>[] adjList, int[] distances) {         Arrays.fill(distances, Integer.MAX_VALUE);         PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));         pq.add(new int[] { start, 0 });         distances[start] = 0;         while (!pq.isEmpty()) {             int[] curr = pq.poll();             int node = curr[0];             int dist = curr[1];             if (dist > distances[node]) {                 continue;             }             for (int[] neighbor : adjList[node]) {                 int nextNode = neighbor[0];                 int nextDist = dist + neighbor[1];                 if (nextDist < distances[nextNode]) {                     distances[nextNode] = nextDist;                     pq.add(new int[] { nextNode, nextDist });                 }             }         }     } }",1,"1334-find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/Solution.java:9:	LooseCoupling:	Avoid using implementation types like 'ArrayList'; use the interface instead
1334-find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/Solution.java:11:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new ArrayList<>()`
1334-find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/Solution.java:45:	LooseCoupling:	Avoid using implementation types like 'ArrayList'; use the interface instead
1334-find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/Solution.java:47:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
",0,0,0
"class Solution {     public int minSetSize(int[] arr) {         //Create a hashmap to store the count of each integer in the array         HashMap<Integer,Integer> freq = new HashMap<Integer,Integer>();         for(int i=0;i<arr.length;i++){             if(freq.containsKey(arr[i])){                 freq.put(arr[i],freq.get(arr[i])+1);             } else{                 freq.put(arr[i],1);             }         }                  //Create a priority queue to sort the frequencies in descending order         PriorityQueue<Integer> pq = new PriorityQueue<Integer>(new Comparator<Integer>(){             public int compare(Integer a,Integer b){                 return b-a;             }         });         pq.addAll(freq.values());                  //Find the size of the set to remove         int count = 0, removed = 0;         while(removed < arr.length/2){             removed += pq.poll();             count++;         }         return count;     } }",1,"1338-reduce-array-size-to-the-half/Solution.java:22:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1338-reduce-array-size-to-the-half/Solution.java:22:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1338-reduce-array-size-to-the-half/Solution.java:5:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",1,0,1
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     long totalSum = 0;     long maxProd = 0;     public int maxProduct(TreeNode root) {         totalSum = getSum(root);         getProd(root);         return (int)(maxProd % (int)(1e9 + 7));     }          public void getProd(TreeNode node){         if(node == null){             return;         }         long prod = (totalSum - node.val) * node.val;         if(prod > maxProd){             maxProd = prod;         }         getProd(node.left);         getProd(node.right);     }          public long getSum(TreeNode node){         if(node == null){             return 0;         }         return node.val + getSum(node.left) + getSum(node.right);     } }",1,"1339-maximum-product-of-splitted-binary-tree/TreeNode.java:17:10: Variable 'totalSum' must be private and have accessor methods. [VisibilityModifier]
1339-maximum-product-of-splitted-binary-tree/TreeNode.java:18:10: Variable 'maxProd' must be private and have accessor methods. [VisibilityModifier]
1339-maximum-product-of-splitted-binary-tree/TreeNode.java:17:10: Variable 'totalSum' must be private and have accessor methods. [VisibilityModifier]
1339-maximum-product-of-splitted-binary-tree/TreeNode.java:18:10: Variable 'maxProd' must be private and have accessor methods. [VisibilityModifier]
1339-maximum-product-of-splitted-binary-tree/TreeNode.java:25:	LinguisticNaming:	Linguistics Antipattern - The getter 'getProd' should not return void linguistically
",0,0,0
"class Solution {     public int canCompleteCircuit(int[] gas, int[] cost) {         int n = gas.length;         int start = 0, currGas = 0, totalGas = 0; // initialize start index, current gas in tank and total gas          for (int i = 0; i < n; i++) {             totalGas += gas[i] - cost[i]; // calculate total gas vs cost difference              currGas += gas[i] - cost[i]; // add the gas at each station to the tank, and subtract its cost              if (currGas < 0) { // if th current gas is negative, we need to start from a new station                 start = i + 1;                 currGas = 0;             }         }          return totalGas >= 0 ? start : -1; // if total gas is negative, it means there isn't enough gas to travel around the circuit     } }",1,"134-gas-station/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
134-gas-station/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
134-gas-station/Solution.java:2:	LinguisticNaming:	Linguistics Antipattern - The method 'canCompleteCircuit' indicates linguistically it returns a boolean, but it returns 'int'
",1,0,0
"class Solution {     public int numOfSubarrays(int[] arr, int k, int threshold) {         int sum = 0;         int count = 0;         int target = k * threshold;         for(int i = 0; i < k; i++) {             sum += arr[i];         }         if(sum >= target) count++;         for(int i = k; i < arr.length; i++) {             sum += arr[i] - arr[i-k];             if(sum >= target) count++;         }         return count;     } }",0,,0,0,0
"class Solution {     public double angleClock(int hour, int minutes) {         double hourAngle = (hour % 12 + minutes / 60.0) * 30;         double minuteAngle = minutes * 6;         double angle = Math.abs(hourAngle - minuteAngle);         return Math.min(angle, 360 - angle);     } }",0,,0,0,0
"class Solution {     public int minSteps(String s, String t) {         int[] count = new int[26];         int result = 0;                  // Count frequency of characters in s         for(char c : s.toCharArray()){             count[c - 'a']++;         }                  // Calculate difference between count of each character in s and t         for(char c : t.toCharArray()){             if(count[c - 'a'] > 0){                 count[c - 'a']--;             }else{                 result++;             }         }                  return result;     } }",0,,0,0,0
"import java.util.*;  class TweetCounts {      private Map<String, List<Integer>> tweetMap;      public TweetCounts() {         tweetMap = new HashMap<>();     }          public void recordTweet(String tweetName, int time) {         tweetMap.putIfAbsent(tweetName, new ArrayList<>());         tweetMap.get(tweetName).add(time);     }          public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {         List<Integer> result = new ArrayList<>();         List<Integer> tweets = tweetMap.get(tweetName);         if (tweets == null) {             return result;         }         int chunk = getChunkSize(freq);         int[] counts = new int[(endTime - startTime) / chunk + 1];         for (int i = 0; i < tweets.size(); i++) {             int time = tweets.get(i);             if (time >= startTime && time <= endTime) {                 int index = (time - startTime) / chunk;                 counts[index]++;             }         }         for (int count : counts) {             result.add(count);         }         return result;     }      private int getChunkSize(String freq) {         switch (freq) {             case ""minute"":                 return 60;             case ""hour"":                 return 3600;             case ""day"":                 return 86400;             default:                 return -1;         }     }      }",1,"1348-tweet-counts-per-frequency/TweetCounts.java:7:5: Redundant 'public' modifier. [RedundantModifier]
1348-tweet-counts-per-frequency/TweetCounts.java:7:5: Redundant 'public' modifier. [RedundantModifier]
1348-tweet-counts-per-frequency/TweetCounts.java:24:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
import java.util.ArrayList; import java.util.List;  class ProductOfNumbers {     private List<Integer> list;      public ProductOfNumbers() {         list = new ArrayList<>();         list.add(1); // sentinel value at position 0     }          public void add(int num) {         if (num == 0) {             list = new ArrayList<>();             list.add(1); // reset to sentinel value         } else {             list.add(list.get(list.size() - 1) * num);         }     }          public int getProduct(int k) {         int n = list.size();         if (n <= k) { // get product of all numbers in list             return list.get(n - 1);         } else {             return list.get(n - 1) / list.get(n - k - 1);         }     } },1,"1352-product-of-the-last-k-numbers/ProductOfNumbers.java:7:5: Redundant 'public' modifier. [RedundantModifier]
1352-product-of-the-last-k-numbers/ProductOfNumbers.java:7:5: Redundant 'public' modifier. [RedundantModifier]
",0,0,0
"class Solution {     public int maxEvents(int[][] events) {         Arrays.sort(events, (a,b) -> Integer.compare(a[1], b[1])); //Sort the events by end day         Set<Integer> attended = new HashSet<>();         for(int[] event : events) {             for(int i=event[0]; i <= event[1]; i++) { //Try to attend the next available day                 if(attended.add(i)) { //If it is not already attended, then attend                     break;                 }             }         }         return attended.size();     } }",0,,0,0,0
"import java.util.HashMap; import java.util.Map;  class Cashier {     private int n;     private int discount;     private int[] products;     private int[] prices;     private int count;     private Map<Integer, Integer> idToPrice;      public Cashier(int n, int discount, int[] products, int[] prices) {         this.n = n;         this.discount = discount;         this.products = products;         this.prices = prices;         this.count = 0;         this.idToPrice = new HashMap<>();         for (int i = 0; i < products.length; i++) {             idToPrice.put(products[i], prices[i]);         }     }      public double getBill(int[] product, int[] amount) {         double bill = 0.0;         for (int i = 0; i < product.length; i++) {             bill += amount[i] * idToPrice.get(product[i]);         }         count++;         if (count == n) {             bill = bill - (discount * bill) / 100.0;             count = 0;         }         return bill;     } }  /**  * Your Cashier object will be instantiated and called as such:  * Cashier obj = new Cashier(n, discount, products, prices);  * double param_1 = obj.getBill(product,amount);  */",1,"1357-apply-discount-every-n-orders/Cashier.java:12:5: Redundant 'public' modifier. [RedundantModifier]
1357-apply-discount-every-n-orders/Cashier.java:12:24: 'n' hides a field. [HiddenField]
1357-apply-discount-every-n-orders/Cashier.java:12:31: 'discount' hides a field. [HiddenField]
1357-apply-discount-every-n-orders/Cashier.java:12:47: 'products' hides a field. [HiddenField]
1357-apply-discount-every-n-orders/Cashier.java:12:63: 'prices' hides a field. [HiddenField]
1357-apply-discount-every-n-orders/Cashier.java:12:5: Redundant 'public' modifier. [RedundantModifier]
1357-apply-discount-every-n-orders/Cashier.java:12:24: 'n' hides a field. [HiddenField]
1357-apply-discount-every-n-orders/Cashier.java:12:31: 'discount' hides a field. [HiddenField]
1357-apply-discount-every-n-orders/Cashier.java:12:47: 'products' hides a field. [HiddenField]
1357-apply-discount-every-n-orders/Cashier.java:12:63: 'prices' hides a field. [HiddenField]
1357-apply-discount-every-n-orders/Cashier.java:7:	UnusedPrivateField:	Avoid unused private fields such as 'products'.
1357-apply-discount-every-n-orders/Cashier.java:8:	UnusedPrivateField:	Avoid unused private fields such as 'prices'.
1357-apply-discount-every-n-orders/Cashier.java:15:	ArrayIsStoredDirectly:	The user-supplied array 'products' is stored directly.
1357-apply-discount-every-n-orders/Cashier.java:16:	ArrayIsStoredDirectly:	The user-supplied array 'prices' is stored directly.
1357-apply-discount-every-n-orders/Cashier.java:31:	UselessParentheses:	Useless parentheses.
",0,0,0
class Solution {     public int numberOfSubstrings(String s) {         int n = s.length();         int res = 0;         int[] count = new int[3];         int left = 0;         for (int right = 0; right < n; right++) {             count[s.charAt(right) - 'a']++;             while (count[0] > 0 && count[1] > 0 && count[2] > 0) {                 count[s.charAt(left) - 'a']--;                 left++;             }             res += left;         }         return res;     } },0,,0,0,0
"class Solution {     public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {         int[] inDegree = new int[n];         for (int i = 0; i < n; i++) {             if (leftChild[i] != -1) {                 inDegree[leftChild[i]]++;                 if (inDegree[leftChild[i]] > 1) {                     return false; // two parents for one node                 }             }             if (rightChild[i] != -1) {                 inDegree[rightChild[i]]++;                 if (inDegree[rightChild[i]] > 1) {                     return false; // two parents for one node                 }             }         }                  int rootCount = 0;         for (int i = 0; i < n; i++) {             if (inDegree[i] == 0) {                 rootCount++;             }             if (rootCount > 1) {                 return false; // multiple roots             }         }                  return rootCount == 1; // only one root     } }",0,,0,0,0
class Solution {     public int[] closestDivisors(int num) {         int[] res = new int[2];         int n1 = num + 1;         int n2 = num + 2;         int diff1 = Integer.MAX_VALUE;         int diff2 = Integer.MAX_VALUE;          for (int i = (int)Math.sqrt(n1); i >= 1; i--) {             if (n1 % i == 0) {                 int j = n1 / i;                 if (Math.abs(i - j) < diff1) {                     diff1 = Math.abs(i - j);                     res[0] = i;                     res[1] = j;                 }                 break;             }         }          for (int i = (int)Math.sqrt(n2); i >= 1; i--) {             if (n2 % i == 0) {                 int j = n2 / i;                 if (Math.abs(i - j) < diff2) {                     diff2 = Math.abs(i - j);                     res[0] = i;                     res[1] = j;                 }                 break;             }         }          return res;     } },1,"1362-closest-divisors/Solution.java:13:	UnusedAssignment:	The value assigned to variable 'diff1' is never used
1362-closest-divisors/Solution.java:25:	UnusedAssignment:	The value assigned to variable 'diff2' is never used
",0,0,0
"class Solution {     public String rankTeams(String[] votes) {         int numOfTeams = votes[0].length();         int[][] ranks = new int[26][numOfTeams + 1];          for (int i = 0; i < votes[0].length(); i++) {             ranks[votes[0].charAt(i) - 'A'][numOfTeams] = votes[0].charAt(i);         }          for (int i = 1; i < votes.length; i++) {             for (int j = 0; j < numOfTeams; j++) {                 ranks[votes[i].charAt(j) - 'A'][j]++;                 ranks[votes[i].charAt(j) - 'A'][numOfTeams] = votes[i].charAt(j);             }         }          Arrays.sort(ranks, new Comparator<int[]>() {             public int compare(final int[] entry1, final int[] entry2) {                 for (int i = 0; i < entry1.length - 1; i++) {                     if (entry1[i] != entry2[i]) {                         return entry2[i] - entry1[i];                     }                 }                 return entry1[entry1.length - 1] - entry2[entry2.length - 1];             }         });          StringBuilder sb = new StringBuilder();          for (int i = 0; i < numOfTeams; i++) {             if (ranks[i][numOfTeams] != 0) {                 sb.append((char) ranks[i][numOfTeams]);             }         }          return sb.toString();     } }",0,,0,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public boolean isSubPath(ListNode head, TreeNode root) {         if(head == null) {             return true;         }         if(root == null) {             return false;         }         if(root.val == head.val) {             if(isSubPathHelper(head.next, root.left) || isSubPathHelper(head.next, root.right)) {                 return true;             }         }         return isSubPath(head, root.left) || isSubPath(head, root.right);     }          private boolean isSubPathHelper(ListNode head, TreeNode node) {         if(head == null) {             return true;         }         if(node == null) {             return false;         }         if(node.val != head.val) {             return false;         }         return isSubPathHelper(head.next, node.left) || isSubPathHelper(head.next, node.right);     } }",1,"1367-linked-list-in-binary-tree/ListNode.java:35:	CollapsibleIfStatements:	This if statement could be combined with its parent
",0,0,0
"class Solution {     public int singleNumber(int[] nums) {         int ones = 0, twos = 0;         for (int i = 0; i < nums.length; i++) {             ones = (ones ^ nums[i]) & ~twos;             twos = (twos ^ nums[i]) & ~ones;         }         return ones;     } }",1,"137-single-number-ii/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
137-single-number-ii/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
137-single-number-ii/Solution.java:4:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",1,0,1
"class Solution {    public static int findTheLongestSubstring(String s) {         Map<Integer,Integer> map = new HashMap<>();         map.put(0,-1);         int max = 0;         int status = 0;         for(int i=0;i<s.length();i++) {             if(s.charAt(i) == 'a')                 status ^= 1 << 0;             if(s.charAt(i) == 'e')                 status ^= 1 << 1;             if(s.charAt(i) == 'i')                 status ^= 1 << 2;             if(s.charAt(i) == 'o')                 status ^= 1 << 3;             if(s.charAt(i) == 'u')                 status ^= 1 << 4;             if(map.containsKey(status))                 max = Math.max(max,i - map.get(status));             else                 map.put(status,i);         }         return max;     } }",1,"1371-find-the-longest-substring-containing-vowels-in-even-counts/Solution.java:1:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
1371-find-the-longest-substring-containing-vowels-in-even-counts/Solution.java:1:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
1371-find-the-longest-substring-containing-vowels-in-even-counts/Solution.java:1:	UseUtilityClass:	This utility class has a non-private constructor
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public int longestZigZag(TreeNode root) {         return Math.max(helper(root, true), helper(root, false)) - 1;     }          // recursive helper method     private int helper(TreeNode node, boolean isRight) {         if (node == null) {             return 0;         }         int left = helper(node.left, false);         int right = helper(node.right, true);         if (isRight) {             return right + 1;         } else {             return left + 1;         }     } }",0,,0,0,0
"class Solution {     public int numTimesAllBlue(int[] flips) {         int n = flips.length;         int prefixSum = 0;         int maxIndex = 0;         int alignedCount = 0;         for(int i=0;i<n;i++){             prefixSum += flips[i];             maxIndex = Math.max(maxIndex, flips[i]);             if((i+1) == prefixSum && (i+1) == maxIndex){                 alignedCount++;             }         }         return alignedCount;     } }",0,,0,0,0
"class Solution {     public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {                  //Create an adjacency list to represent the tree structure         List<List<Integer>> adjList = new ArrayList<>();         for(int i=0; i<n; i++){             adjList.add(new ArrayList<Integer>());         }         for(int i=0; i<n; i++){             int managerId = manager[i];             if(managerId!=-1){                 adjList.get(managerId).add(i);             }         }                  //Perform DFS to find the maximum time to inform all employees starting from the head         return dfs(headID, adjList, informTime);     }          private int dfs(int empId, List<List<Integer>> adjList, int[] informTime){         int maxTime = 0; //max time to inform the subordinates of the current employee         for(int subId : adjList.get(empId)){             int time = dfs(subId, adjList, informTime);             maxTime = Math.max(maxTime, time);         }         return maxTime + informTime[empId];     } }",0,,0,0,0
"/* // Definition for a Node. class Node {     int val;     Node next;     Node random;      public Node(int val) {         this.val = val;         this.next = null;         this.random = null;     } } */  class Solution {     public Node copyRandomList(Node head) {         if (head == null) {             return null;         }          Map<Node, Node> map = new HashMap<>();          Node oldNode = head;         Node newNode = new Node(oldNode.val);         map.put(oldNode, newNode);          while (oldNode != null) {             newNode.random = getCloneNode(map, oldNode.random);             newNode.next = getCloneNode(map, oldNode.next);              oldNode = oldNode.next;             newNode = newNode.next;         }          return map.get(head);     }      public Node getCloneNode(Map<Node, Node> map, Node node) {         if (node != null) {             if (map.containsKey(node)) {                 return map.get(node);             } else {                 map.put(node, new Node(node.val));                 return map.get(node);             }         }         return null;     } }",0,,0,0,0
"class CustomStack {      private int[] stack;     private int size;      public CustomStack(int maxSize) {         stack = new int[maxSize];         size = 0;     }          public void push(int x) {         if (size < stack.length) {             stack[size++] = x;         }     }          public int pop() {         if (size > 0) {             return stack[--size];         }         return -1;     }          public void increment(int k, int val) {         for (int i = 0; i < Math.min(k, size); i++) {             stack[i] += val;         }     } }",1,"1381-design-a-stack-with-increment-operation/CustomStack.java:6:5: Redundant 'public' modifier. [RedundantModifier]
1381-design-a-stack-with-increment-operation/CustomStack.java:6:5: Redundant 'public' modifier. [RedundantModifier]
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public TreeNode balanceBST(TreeNode root) {         if(root == null) {             return null;         }         // get sorted list of all nodes in the binary search tree         List<TreeNode> nodes = new ArrayList<>();         inorder(root, nodes);                  // build balanced binary search tree from sorted node list         return buildBalancedBST(nodes, 0, nodes.size()-1);     }          // helper function to get sorted list of all nodes in the binary search tree     public void inorder(TreeNode root, List<TreeNode> nodes) {         if(root == null) {             return;         }         inorder(root.left, nodes);         nodes.add(root);         inorder(root.right, nodes);     }          // helper function to build balanced binary search tree from sorted node list     public TreeNode buildBalancedBST(List<TreeNode> nodes, int start, int end) {         if(start > end) {             return null;         }         int mid = (start + end) / 2;         TreeNode root = nodes.get(mid);         root.left = buildBalancedBST(nodes, start, mid-1);         root.right = buildBalancedBST(nodes, mid+1, end);         return root;     } }",0,,0,0,0
"class Solution {     public int maxNumberOfFamilies(int n, int[][] reservedSeats) {         // map for storing reserved seats in each row         Map<Integer, Set<Integer>> reserved = new HashMap<>();         // iterating over the reservedSeats array         for (int[] seat : reservedSeats) {             int row = seat[0];             int col = seat[1];             // if the row is not present in the map, add it with empty set             reserved.putIfAbsent(row, new HashSet<>());             // add the reserved seat to the corresponding row set             reserved.get(row).add(col);         }         int count = 2 * n; // there can be at most 2 groups in each row         // iterating over each row to check if seats can be allotted to groups         for (int row : reserved.keySet()) {             Set<Integer> reservedSeatsInRow = reserved.get(row);             boolean left = true, middle = true, right = true;             // checking if the left adjacent seats are reserved             if (reservedSeatsInRow.contains(2) || reservedSeatsInRow.contains(3) ||                     reservedSeatsInRow.contains(4) || reservedSeatsInRow.contains(5)) {                 left = false;             }             // checking if the middle adjacent seats are reserved             if (reservedSeatsInRow.contains(4) || reservedSeatsInRow.contains(5) ||                     reservedSeatsInRow.contains(6) || reservedSeatsInRow.contains(7)) {                 middle = false;             }             // checking if the right adjacent seats are reserved             if (reservedSeatsInRow.contains(6) || reservedSeatsInRow.contains(7) ||                     reservedSeatsInRow.contains(8) || reservedSeatsInRow.contains(9)) {                 right = false;             }             // updating count based on the availability of seats             if (left && right) {                 // all 4 seats are available                 count += 2;             } else if (left || middle || right) {                 // 2 seats are available                 count++;             }         }         return count;     } }",1,"1386-cinema-seat-allocation/Solution.java:18:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1386-cinema-seat-allocation/Solution.java:18:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1386-cinema-seat-allocation/Solution.java:2:	NPathComplexity:	The method 'maxNumberOfFamilies(int, int[][])' has an NPath complexity of 1502, current threshold is 200
",1,0,0
"class Solution {     public int getKth(int lo, int hi, int k) {         Map<Integer, Integer> powerMap = new HashMap<>();         List<Integer> list = new ArrayList<>();         for (int i=lo; i<=hi; i++) {             int num = i;             int power = 0;             while (num != 1) {                 if (powerMap.containsKey(num)) {                     power += powerMap.get(num);                     break;                 }                 if (num % 2 == 0) {                     num /= 2;                 } else {                     num = 3*num + 1;                 }                 power++;             }             powerMap.put(i, power);             list.add(i);         }         Collections.sort(list, (a,b) -> {             int result = Integer.compare(powerMap.get(a), powerMap.get(b));             if (result == 0) {                 result = Integer.compare(a,b);             }             return result;         });         return list.get(k-1);     } }",0,,0,0,0
"import java.util.*;  class Solution {     public boolean wordBreak(String s, List<String> wordDict) {         // Create a hashset to store the words in the dictionary for O(1) lookup         Set<String> dict = new HashSet<>(wordDict);         int n = s.length();         // Create a boolean array to store the subproblem results         boolean[] dp = new boolean[n+1];         // Empty string is always considered as a valid string         dp[0] = true;          // Loop through each character of the string         for (int i = 1; i <= n; i++) {             // Loop through each valid index before i             for (int j = 0; j < i; j++) {                 // Check if the substring from j to i exists in the dictionary                 if (dp[j] && dict.contains(s.substring(j, i))) {                     // If the substring exists and the previous substring is valid, Mark it as true in the dp array                     dp[i] = true;                     break;                 }             }         }                  // Return the last value of the dp array which indicates if the whole string could be segmented using words from the dictionary.           return dp[n];     } }  class Main {     public static void main(String[] args) {         Solution sol = new Solution();         String s1 = ""leetcode"";         List<String> dict1 = new ArrayList<>(Arrays.asList(""leet"",""code""));         System.out.println(""Example 1: "" + sol.wordBreak(s1, dict1)); // expected output is true          String s2 = ""applepenapple"";         List<String> dict2 = new ArrayList<>(Arrays.asList(""apple"",""pen""));         System.out.println(""Example 2: "" + sol.wordBreak(s2, dict2)); // expected output is true          String s3 = ""catsandog"";         List<String> dict3 = new ArrayList<>(Arrays.asList(""cats"",""dog"",""sand"",""and"",""cat""));         System.out.println(""Example 3: "" + sol.wordBreak(s3, dict3)); // expected output is false     } }",1,"139-word-break/Solution.java:31:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
139-word-break/Solution.java:31:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
139-word-break/Solution.java:31:	UseUtilityClass:	This utility class has a non-private constructor
",0,0,0
class Solution {     public int sumFourDivisors(int[] nums) {         int sum = 0;         for(int n : nums) {             int divisorCount = 0;             int divisorSum = 0;             for(int i = 1; i <= (int)Math.sqrt(n); i++) {                 if(n % i == 0) {                     divisorCount++;                     divisorSum += i;                     if(i != n/i) {                         divisorCount++;                         divisorSum += n/i;                     }                     if(divisorCount > 4) {                         break;                     }                 }             }             if(divisorCount == 4) {                 sum += divisorSum;             }         }         return sum;     } },0,,0,0,0
"class Solution {     public boolean hasValidPath(int[][] grid) {         int m = grid.length, n = grid[0].length;                  //Possible moves for each type of streets         int[][][] moves = {             {{0, -1}, {0, 1}}, //street 1 (horizontal)             {{-1, 0}, {1, 0}}, //street 2 (vertical)             {{0, -1}, {1, 0}}, //street 3 (left to down)             {{0, 1}, {1, 0}}, //street 4 (right to down)             {{-1, 0}, {0, -1}}, //street 5 (left to up)             {{-1, 0}, {0, 1}} //street 6 (right to up)         };                  boolean[][] visited = new boolean[m][n];         Queue<int[]> queue = new LinkedList<>();         visited[0][0] = true;         queue.offer(new int[]{0, 0});                  while (!queue.isEmpty()) {             int[] current = queue.poll();             int x = current[0], y = current[1];             int street = grid[x][y] - 1;             for (int[] move : moves[street]) {                 int dx = move[0], dy = move[1];                 if (x + dx < 0 || x + dx >= m || y + dy < 0 || y + dy >= n) continue; //out of boundary                 int nextStreet = grid[x + dx][y + dy] - 1;                 for (int[] reverseMove : moves[nextStreet]) {                     int reverseDx = reverseMove[0], reverseDy = reverseMove[1];                     //check if there is a path between the two cells                     if (x + dx + reverseDx == x && y + dy + reverseDy == y) {                         if (!visited[x + dx][y + dy]) {                             visited[x + dx][y + dy] = true;                             queue.offer(new int[]{x + dx, y + dy});                         }                     }                 }             }         }                  return visited[m - 1][n - 1];     } }",1,"1391-check-if-there-is-a-valid-path-in-a-grid/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1391-check-if-there-is-a-valid-path-in-a-grid/Solution.java:22:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1391-check-if-there-is-a-valid-path-in-a-grid/Solution.java:25:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1391-check-if-there-is-a-valid-path-in-a-grid/Solution.java:29:21: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1391-check-if-there-is-a-valid-path-in-a-grid/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1391-check-if-there-is-a-valid-path-in-a-grid/Solution.java:22:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1391-check-if-there-is-a-valid-path-in-a-grid/Solution.java:25:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1391-check-if-there-is-a-valid-path-in-a-grid/Solution.java:29:21: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1391-check-if-there-is-a-valid-path-in-a-grid/Solution.java:32:	CollapsibleIfStatements:	This if statement could be combined with its parent
",1,0,0
class Solution {     public int numTeams(int[] rating) {         int count = 0;         for (int i = 0; i < rating.length - 2; i++) {             for (int j = i + 1; j < rating.length - 1; j++) {                 for (int k = j + 1; k < rating.length; k++) {                     if ((rating[i] < rating[j] && rating[j] < rating[k])                         || (rating[i] > rating[j] && rating[j] > rating[k])) {                         count++;                     }                 }             }         }         return count;     } },0,,0,0,0
"import java.util.HashMap; import java.util.Map;  class Station {     String name;     int totalTime;     int count;      public Station(String name, int totalTime, int count) {         this.name = name;         this.totalTime = totalTime;         this.count = count;     } }  class Journey {     String startStation;     String endStation;     int startTime;      public Journey(String startStation, String endStation, int startTime) {         this.startStation = startStation;         this.endStation = endStation;         this.startTime = startTime;     } }  public class UndergroundSystem {     Map<Integer, Journey> journeys;     Map<String, Station> stations;      public UndergroundSystem() {         journeys = new HashMap<>();         stations = new HashMap<>();     }      public void checkIn(int id, String stationName, int t) {         Journey journey = new Journey(stationName, """", t);         journeys.put(id, journey);     }      public void checkOut(int id, String stationName, int t) {         Journey journey = journeys.get(id);         String startStation = journey.startStation;         String endStation = stationName;         int startTime = journey.startTime;         int timeTaken = t - startTime;          String key = startStation + ""->"" + endStation;         Station station = stations.getOrDefault(key, new Station(key, 0, 0));         station.totalTime += timeTaken;         station.count += 1;         stations.put(key, station);          journeys.remove(id);     }      public double getAverageTime(String startStation, String endStation) {         String key = startStation + ""->"" + endStation;         Station station = stations.get(key);         return (double) station.totalTime / station.count;     } }",1,"1396-design-underground-system/UndergroundSystem.java:5:12: Variable 'name' must be private and have accessor methods. [VisibilityModifier]
1396-design-underground-system/UndergroundSystem.java:6:9: Variable 'totalTime' must be private and have accessor methods. [VisibilityModifier]
1396-design-underground-system/UndergroundSystem.java:7:9: Variable 'count' must be private and have accessor methods. [VisibilityModifier]
1396-design-underground-system/UndergroundSystem.java:9:5: Redundant 'public' modifier. [RedundantModifier]
1396-design-underground-system/UndergroundSystem.java:9:27: 'name' hides a field. [HiddenField]
1396-design-underground-system/UndergroundSystem.java:9:37: 'totalTime' hides a field. [HiddenField]
1396-design-underground-system/UndergroundSystem.java:9:52: 'count' hides a field. [HiddenField]
1396-design-underground-system/UndergroundSystem.java:17:12: Variable 'startStation' must be private and have accessor methods. [VisibilityModifier]
1396-design-underground-system/UndergroundSystem.java:18:12: Variable 'endStation' must be private and have accessor methods. [VisibilityModifier]
1396-design-underground-system/UndergroundSystem.java:19:9: Variable 'startTime' must be private and have accessor methods. [VisibilityModifier]
1396-design-underground-system/UndergroundSystem.java:21:5: Redundant 'public' modifier. [RedundantModifier]
1396-design-underground-system/UndergroundSystem.java:21:27: 'startStation' hides a field. [HiddenField]
1396-design-underground-system/UndergroundSystem.java:21:48: 'endStation' hides a field. [HiddenField]
1396-design-underground-system/UndergroundSystem.java:21:64: 'startTime' hides a field. [HiddenField]
1396-design-underground-system/UndergroundSystem.java:29:27: Variable 'journeys' must be private and have accessor methods. [VisibilityModifier]
1396-design-underground-system/UndergroundSystem.java:30:26: Variable 'stations' must be private and have accessor methods. [VisibilityModifier]
1396-design-underground-system/UndergroundSystem.java:5:12: Variable 'name' must be private and have accessor methods. [VisibilityModifier]
1396-design-underground-system/UndergroundSystem.java:6:9: Variable 'totalTime' must be private and have accessor methods. [VisibilityModifier]
1396-design-underground-system/UndergroundSystem.java:7:9: Variable 'count' must be private and have accessor methods. [VisibilityModifier]
1396-design-underground-system/UndergroundSystem.java:9:5: Redundant 'public' modifier. [RedundantModifier]
1396-design-underground-system/UndergroundSystem.java:9:27: 'name' hides a field. [HiddenField]
1396-design-underground-system/UndergroundSystem.java:9:37: 'totalTime' hides a field. [HiddenField]
1396-design-underground-system/UndergroundSystem.java:9:52: 'count' hides a field. [HiddenField]
1396-design-underground-system/UndergroundSystem.java:17:12: Variable 'startStation' must be private and have accessor methods. [VisibilityModifier]
1396-design-underground-system/UndergroundSystem.java:18:12: Variable 'endStation' must be private and have accessor methods. [VisibilityModifier]
1396-design-underground-system/UndergroundSystem.java:19:9: Variable 'startTime' must be private and have accessor methods. [VisibilityModifier]
1396-design-underground-system/UndergroundSystem.java:21:5: Redundant 'public' modifier. [RedundantModifier]
1396-design-underground-system/UndergroundSystem.java:21:27: 'startStation' hides a field. [HiddenField]
1396-design-underground-system/UndergroundSystem.java:21:48: 'endStation' hides a field. [HiddenField]
1396-design-underground-system/UndergroundSystem.java:21:64: 'startTime' hides a field. [HiddenField]
1396-design-underground-system/UndergroundSystem.java:29:27: Variable 'journeys' must be private and have accessor methods. [VisibilityModifier]
1396-design-underground-system/UndergroundSystem.java:30:26: Variable 'stations' must be private and have accessor methods. [VisibilityModifier]
",0,0,0
"class Solution {     public boolean canConstruct(String s, int k) {         if (s.length() < k) {             return false;         }         int[] freq = new int[26];         for (char ch : s.toCharArray()) {             freq[ch - 'a']++;         }         int oddCount = 0;         for (int f : freq) {             if (f % 2 == 1) {                 oddCount++;             }         }         return oddCount <= k;     } }",0,,0,0,0
"class Solution {     public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {         int nearestX = Math.max(x1, Math.min(xCenter, x2));         int nearestY = Math.max(y1, Math.min(yCenter, y2));                  int deltaX = nearestX - xCenter;         int deltaY = nearestY - yCenter;                  return (deltaX * deltaX + deltaY * deltaY) <= (radius * radius);     } }",0,,0,0,0
class Solution {     public int numSteps(String s) {         int steps = 0;         int carry = 0;         int n = s.length();          // iterate from the rightmost bit to the leftmost bit         for (int i = n-1; i >= 0; i--) {             int bit = s.charAt(i) - '0';              if (i == 0 && bit == 0) {                 break;             }              // add carry if there is one             if (bit + carry == 1) {                 steps += 2;             } else if (bit + carry == 2) {                 steps += 1;             }              // set carry for the next iteration             // only set the carry if the current number is odd             carry = bit == 1 ? 1 : 0;         }          return steps;     } },0,,0,0,0
"class Solution {     public String longestDiverseString(int a, int b, int c) {         StringBuilder sb = new StringBuilder();         int[] count = new int[] {a, b, c};         int[] last = new int[] {-1, -1, -1};         while (true) {             int maxCount = 0;             int maxChar = -1;             for (int i = 0; i < 3; i++) {                 if (count[i] > 0 && last[i] != 0 && count[i] >= maxCount) {                     maxCount = count[i];                     maxChar = i;                 }             }             if (maxChar == -1) {                 break;             }             if (sb.length() >= 2 && sb.charAt(sb.length() - 1) == maxChar + 'a' && sb.charAt(sb.length() - 2) == maxChar + 'a') {                 maxCount--;             }             sb.append((char) (maxChar + 'a'));             count[maxChar]--;             last[maxChar] = 0;             int secondMaxCount = 0;             int secondMaxChar = -1;             for (int i = 0; i < 3; i++) {                 if (count[i] > 0 && last[i] != 0 && count[i] >= secondMaxCount) {                     secondMaxCount = count[i];                     secondMaxChar = i;                 }             }             if (secondMaxChar != -1) {                 sb.append((char) (secondMaxChar + 'a'));                 count[secondMaxChar]--;                 last[secondMaxChar] = 0;             }             else {                 break;             }         }         return sb.toString();     } }",1,"1405-longest-happy-string/Solution.java:36:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1405-longest-happy-string/Solution.java:36:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1405-longest-happy-string/Solution.java:2:	NPathComplexity:	The method 'longestDiverseString(int, int, int)' has an NPath complexity of 401, current threshold is 200
1405-longest-happy-string/Solution.java:19:	UnusedAssignment:	The updated value of variable 'maxCount' is never used
1405-longest-happy-string/Solution.java:32:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",0,0,0
"class Solution {     public int[] processQueries(int[] queries, int m) {         int[] result = new int[queries.length];         List<Integer> perm = new ArrayList<>();         for (int i = 1; i <= m; i++) {             perm.add(i);         }         for (int i = 0; i < queries.length; i++) {             int query = queries[i];             int index = perm.indexOf(query);             result[i] = index;             perm.remove(index);             perm.add(0, query);         }         return result;     } }",0,,0,0,0
"class Solution {     public String entityParser(String text) {         StringBuilder result = new StringBuilder();         int i = 0;         while(i < text.length()) {             if(text.charAt(i) == '&') {                 if(i+3 < text.length() && text.substring(i+1, i+4).equals(""amp"")) {                     result.append(""&"");                     i += 4;                 }                 else if(i+4 < text.length() && text.substring(i+1, i+5).equals(""quot"")) {                     result.append(""\"""");                     i += 5;                 }                 else if(i+4 < text.length() && text.substring(i+1, i+5).equals(""apos"")) {                     result.append(""'"");                     i += 5;                 }                 else if(i+3 < text.length() && text.substring(i+1, i+4).equals(""gt"")) {                     result.append("">"");                     i += 4;                 }                 else if(i+3 < text.length() && text.substring(i+1, i+4).equals(""lt"")) {                     result.append(""<"");                     i += 4;                 }                 else if(i+5 < text.length() && text.substring(i+1, i+6).equals(""frasl"")) {                     result.append(""/"");                     i += 6;                 }                 else {                     result.append(text.charAt(i));                     i++;                 }             }             else {                 result.append(text.charAt(i));                 i++;             }         }         return result.toString();     } }",1,"1410-html-entity-parser/Solution.java:10:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1410-html-entity-parser/Solution.java:14:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1410-html-entity-parser/Solution.java:18:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1410-html-entity-parser/Solution.java:22:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1410-html-entity-parser/Solution.java:26:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1410-html-entity-parser/Solution.java:30:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1410-html-entity-parser/Solution.java:35:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1410-html-entity-parser/Solution.java:10:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1410-html-entity-parser/Solution.java:14:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1410-html-entity-parser/Solution.java:18:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1410-html-entity-parser/Solution.java:22:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1410-html-entity-parser/Solution.java:26:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1410-html-entity-parser/Solution.java:30:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1410-html-entity-parser/Solution.java:35:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1410-html-entity-parser/Solution.java:7:	LiteralsFirstInComparisons:	Position literals first in String comparisons
1410-html-entity-parser/Solution.java:8:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
1410-html-entity-parser/Solution.java:11:	LiteralsFirstInComparisons:	Position literals first in String comparisons
1410-html-entity-parser/Solution.java:12:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
1410-html-entity-parser/Solution.java:15:	LiteralsFirstInComparisons:	Position literals first in String comparisons
1410-html-entity-parser/Solution.java:16:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
1410-html-entity-parser/Solution.java:19:	LiteralsFirstInComparisons:	Position literals first in String comparisons
1410-html-entity-parser/Solution.java:20:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
1410-html-entity-parser/Solution.java:23:	LiteralsFirstInComparisons:	Position literals first in String comparisons
1410-html-entity-parser/Solution.java:24:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
1410-html-entity-parser/Solution.java:27:	LiteralsFirstInComparisons:	Position literals first in String comparisons
1410-html-entity-parser/Solution.java:28:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
",0,0,0
"class Solution {     public int findMinFibonacciNumbers(int k) {         int count = 0; //Initialize the count to zero         int a = 1, b = 1, c = 2; //Initialize the Fibonacci sequence values                  while(c <= k) { //Loop until we reach or exceed k             a = b;             b = c;             c = a + b; //Update the Fibonacci sequence values         }                  while(k > 0) { //Loop until k becomes zero             if(b <= k) { //If the current Fibonacci number is less than or equal to k                 k -= b; //Subtract it from k                 count++; //Increment the count             }             //Move to the next smaller Fibonacci number             c = b;             b = a;             a = c - b;         }                  return count; //Return the count     } }",1,"1414-find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1414-find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1414-find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/Solution.java:14:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'k'
",1,1,0
"class Solution {     public String getHappyString(int n, int k) {         if (k > 3 * Math.pow(2, n - 1)) { // if k > total number of happy strings of length n (which is 3 * 2^(n-1)), return empty string             return """";         }         StringBuilder sb = new StringBuilder(); // Use StringBuilder to build the string         for (int i = n - 1; i >= 0; i--) { // build the string from back to front             int num = (int) Math.pow(2, i); // for each position, there are 2^(n-i-1) happy strings starting with 'a' or 'b' or 'c'             int index = (k - 1) / num; // index of the character to be added to the string based on the value of k and num             char ch = (char) ('a' + index); // get the character to be added based on the index             sb.append(ch); // add the character to the string             k -= index * num; // update k for the next position         }         return sb.toString(); // return the final happy string     } }",1,"1415-the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/Solution.java:12:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'k'
",0,1,0
"import java.util.*;  class Solution {     public List<List<String>> displayTable(List<List<String>> orders) {         List<List<String>> displayTable = new ArrayList<>();         Map<String, Map<String, Integer>> tableOrderMap = new TreeMap<>();                  // Compute table order map         for (List<String> order : orders) {             String table = order.get(1);             String foodItem = order.get(2);                          if (!tableOrderMap.containsKey(table)) {                 tableOrderMap.put(table, new HashMap<>());             }                          Map<String, Integer> foodItemMap = tableOrderMap.get(table);             foodItemMap.put(foodItem, foodItemMap.getOrDefault(foodItem, 0) + 1);             tableOrderMap.put(table, foodItemMap);         }                  // Compute header row         List<String> headerRow = new ArrayList<>(tableOrderMap.size() + 1);         headerRow.add(""Table"");                  Set<String> foodItems = new TreeSet<>();         for (Map<String, Integer> foodItemMap : tableOrderMap.values()) {             foodItems.addAll(foodItemMap.keySet());         }                  headerRow.addAll(foodItems);         displayTable.add(headerRow);                  // Compute data rows         for (Map.Entry<String, Map<String, Integer>> entry : tableOrderMap.entrySet()) {             List<String> dataRow = new ArrayList<>(tableOrderMap.size() + 1);             dataRow.add(entry.getKey());                          Map<String, Integer> foodItemMap = entry.getValue();             for (String foodItem : foodItems) {                 dataRow.add(String.valueOf(foodItemMap.getOrDefault(foodItem, 0)));             }                          displayTable.add(dataRow);         }                  return displayTable;     } }",1,"1418-display-table-of-food-orders-in-a-restaurant/Solution.java:6:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
",0,0,0
"class Solution {     public int minNumberOfFrogs(String croakOfFrogs) {         int[] counts = new int[5]; // counts for c, r, o, a, k         int frogs = 0; // number of frogs         int maxFrogs = 0; // maximum number of frogs seen so far         for (int i = 0; i < croakOfFrogs.length(); i++) {             char c = croakOfFrogs.charAt(i);             if (c == 'c') {                 // a new croak starts, check if there's a free frog                 if (frogs == maxFrogs) {                     // there's no free frog, we need a new one                     frogs++;                 }                 counts[0]++;             } else if (c == 'r') {                 counts[1]++;             } else if (c == 'o') {                 counts[2]++;             } else if (c == 'a') {                 counts[3]++;             } else if (c == 'k') {                 // a croak has finished, check if it's valid                 for (int j = 0; j < 4; j++) {                     if (counts[j] < counts[j+1]) {                         // the croak is invalid, return -1                         return -1;                     }                 }                 // the croak is valid, update the counts                 counts[4]++;                 for (int j = 0; j < 5; j++) {                     counts[j]--;                 }                 // check if a frog is free now                 if (counts[0] == 0) {                     frogs--;                 }                 // update the maximum number of frogs seen so far                 maxFrogs = Math.max(maxFrogs, frogs);             }         }         // check if all frogs have finished their croaks         for (int j = 0; j < 4; j++) {             if (counts[j] > 0) {                 // there are some unfished croaks, return -1                 return -1;             }         }         // return the minimum number of frogs needed         return maxFrogs;     } }",0,,0,0,0
"/**  * Definition for singly-linked list.  * class ListNode {  *     int val;  *     ListNode next;  *     ListNode(int x) {  *         val = x;  *         next = null;  *     }  * }  */ public class Solution {     public ListNode detectCycle(ListNode head) {         ListNode slow = head;         ListNode fast = head;                  // First, check if a cycle exists         while(fast != null && fast.next != null){             slow = slow.next;             fast = fast.next.next;             if(slow == fast){                 // cycle exists, break out of loop                 break;             }         }                  if(fast == null || fast.next == null){             // no cycle exists, return null             return null;         }                  // Move slow pointer to head of the linked list         slow = head;                  // Advance both pointers at same pace until they meet, which will be the start of the cycle         while(slow != fast){             slow = slow.next;             fast = fast.next;         }                  // return the node where the cycle begins         return slow;     } }",0,,0,0,0
"class Solution {     public int maxScore(int[] cardPoints, int k) {         int n = cardPoints.length;         int left = 0, right = n - k;         int sum = 0;         for (int i = left; i < right; i++) {             sum += cardPoints[i];         }         int maxSum = sum;         while (right < n) {             sum -= cardPoints[left++];             sum += cardPoints[right++];             maxSum = Math.max(maxSum, sum);         }         return maxSum;     } }",1,"1423-maximum-points-you-can-obtain-from-cards/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1423-maximum-points-you-can-obtain-from-cards/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int[] findDiagonalOrder(int[][] nums) {         if (nums == null || nums.length == 0) {             return new int[0];         }         int m = nums.length;         int n = nums[0].length;         int[] result = new int[m * n];         int row = 0, col = 0, d = 1;         for (int i = 0; i < m * n; i++) {             result[i] = nums[row][col];             row -= d;             col += d;             if (row >= m) { row = m - 1; col += 2; d = -d; }             if (col >= n) { col = n - 1; row += 2; d = -d; }             if (row < 0) { row = 0; d = -d; }             if (col < 0) { col = 0; d = -d; }         }         return result;     } }",1,"1424-diagonal-traverse-ii/Solution.java:9:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1424-diagonal-traverse-ii/Solution.java:14:27: '{' at column 27 should have line break after. [LeftCurly]
1424-diagonal-traverse-ii/Solution.java:15:27: '{' at column 27 should have line break after. [LeftCurly]
1424-diagonal-traverse-ii/Solution.java:16:26: '{' at column 26 should have line break after. [LeftCurly]
1424-diagonal-traverse-ii/Solution.java:17:26: '{' at column 26 should have line break after. [LeftCurly]
1424-diagonal-traverse-ii/Solution.java:9:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1424-diagonal-traverse-ii/Solution.java:14:27: '{' at column 27 should have line break after. [LeftCurly]
1424-diagonal-traverse-ii/Solution.java:15:27: '{' at column 27 should have line break after. [LeftCurly]
1424-diagonal-traverse-ii/Solution.java:16:26: '{' at column 26 should have line break after. [LeftCurly]
1424-diagonal-traverse-ii/Solution.java:17:26: '{' at column 26 should have line break after. [LeftCurly]
",1,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public void reorderList(ListNode head) {         if(head ==null || head.next == null){             return;         }                  //find the mid point of the linked list         ListNode slow = head;         ListNode fast = head;                  while(fast!=null && fast.next!=null){             slow = slow.next;             fast = fast.next.next;         }                  //reverse the second half of the linked list         ListNode prev = null;         ListNode current = slow.next;         ListNode next = null;         slow.next = null;                  while(current!=null){             next = current.next;             current.next = prev;             prev = current;             current = next;         }                  //merge the first half and reversed second half         ListNode head1 = head;         ListNode head2 = prev;         ListNode temp = null;                  while(head2!=null){             temp = head1.next;             head1.next = head2;             head1 = temp;                          temp = head2.next;             head2.next = head1;             head2 = temp;         }                       } }",1,"143-reorder-list/ListNode.java:29:	UnusedAssignment:	The initializer for variable 'next' is never used (overwritten on line 33)
143-reorder-list/ListNode.java:30:	NullAssignment:	Assigning an Object to null is a code smell.  Consider refactoring.
143-reorder-list/ListNode.java:42:	UnusedAssignment:	The initializer for variable 'temp' is never used (overwritten on line 45)
",0,0,0
"class Solution {     public int maxDiff(int num) {         // Convert input integer to string         String s = String.valueOf(num);         // Initialize a and b as s         String a = s, b = s;         // Find smallest digit that is not 9 in the number and replace it with 9 in a         for (char ch : s.toCharArray()) {             if (ch != '9') {                 a = a.replace(ch, '9');                 break;             }         }         // If the first digit is not 1 replace it with 1 in b         char first = s.charAt(0);         if (first != '1') {             b = b.replace(first, '1');         } else {             // Else find the smallest digit that is not 0 and replace it with 0 in b             for (int i = 1; i < s.length(); i++) {                 char ch = s.charAt(i);                 if (ch != '0' && ch != first) {                     b = b.replace(ch, '0');                     break;                 }             }         }         // Return the difference between the values of a and b converted back to integer         return Integer.parseInt(a) - Integer.parseInt(b);     } }",1,"1432-max-difference-you-can-get-from-changing-an-integer/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1432-max-difference-you-can-get-from-changing-an-integer/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1432-max-difference-you-can-get-from-changing-an-integer/Solution.java:16:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",1,0,0
"class Solution {     public boolean checkIfCanBreak(String s1, String s2) {         int[] s1Freq = new int[26];         int[] s2Freq = new int[26];         int n = s1.length();                  for(int i=0; i<n; i++){             s1Freq[s1.charAt(i) - 'a']++;             s2Freq[s2.charAt(i) - 'a']++;         }                  int s1Count = 0, s2Count = 0;         boolean s1CanBreak = true, s2CanBreak = true;                  for(int i=0; i<26; i++){             s1Count += s1Freq[i];             s2Count += s2Freq[i];             if(s1Count < s2Count){                 s1CanBreak = false;             }             if(s2Count < s1Count){                 s2CanBreak = false;             }         }                  return s1CanBreak || s2CanBreak;     } }",1,"1433-check-if-a-string-can-break-another-string/Solution.java:12:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1433-check-if-a-string-can-break-another-string/Solution.java:13:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1433-check-if-a-string-can-break-another-string/Solution.java:12:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1433-check-if-a-string-can-break-another-string/Solution.java:13:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int longestSubarray(int[] nums, int limit) {         int n = nums.length;         Deque<Integer> maxQ = new LinkedList<>();         Deque<Integer> minQ = new LinkedList<>();         int left = 0, right;         for (right = 0; right < n; right++) {             while (!maxQ.isEmpty() && nums[right] > maxQ.peekLast()) {                 maxQ.removeLast();             }             while (!minQ.isEmpty() && nums[right] < minQ.peekLast()) {                 minQ.removeLast();             }             maxQ.addLast(nums[right]);             minQ.addLast(nums[right]);             if (maxQ.peekFirst() - minQ.peekFirst() > limit) {                 if (maxQ.peekFirst() == nums[left]) {                     maxQ.removeFirst();                 }                 if (minQ.peekFirst() == nums[left]) {                     minQ.removeFirst();                 }                 left++;             }         }         return right - left;     } }",1,"1438-longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1438-longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public List<String> buildArray(int[] target, int n) {         List<String> result = new ArrayList<>();                  int i = 0;         int num = 1;         while (i < target.length) {             if (num == target[i]) {                 result.add(""Push"");                 i++;             } else {                 result.add(""Push"");                 result.add(""Pop"");             }             num++;         }                  return result;     } }",0,,0,0,0
class Solution {     public int countTriplets(int[] arr) {         int n = arr.length;         int count = 0;         for (int i = 0; i < n; i++) {             int xor = arr[i];             for (int j = i + 1; j < n; j++) {                 xor ^= arr[j];                 if (xor == 0) {                     count += j - i;                 }             }         }         return count;     } },0,,0,0,0
"class Solution {     public int minTime(int n, int[][] edges, List<Boolean> hasApple) {         // Create a map to store the nodes connected by edges         Map<Integer, List<Integer>> map = new HashMap<>();         for(int i = 0; i < edges.length; i++) {             int u = edges[i][0];             int v = edges[i][1];             List<Integer> list1 = map.getOrDefault(u, new ArrayList<>());             List<Integer> list2 = map.getOrDefault(v, new ArrayList<>());             list1.add(v);             list2.add(u);             map.put(u, list1);             map.put(v, list2);         }         boolean[] visited = new boolean[n]; // to keep track of visited nodes         visited[0] = true; // starting node         int time = dfs(0, visited, map, hasApple); // find time taken to travel all vertices with apples         return Math.max(0, time - 2); // Time to travel all vertices minus the time to reach the starting point     }          private int dfs(int node, boolean[] visited, Map<Integer, List<Integer>> map, List<Boolean> hasApple) {         int time = 0;         if(hasApple.get(node)) {             time++; // if the current node has apple, add one to the time variable         }         for(int child : map.getOrDefault(node, new ArrayList<>())) {             if(!visited[child]) {                 visited[child] = true; // mark the child node as visited                 time += dfs(child, visited, map, hasApple) + 2; // add the time to traverse the child node and return back to the current node             }         }         return time; // return the total time taken to traverse all nodes with apples     } }",1,"1443-minimum-time-to-collect-all-apples-in-a-tree/Solution.java:5:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"import java.util.*;  class Solution {     public List<String> simplifiedFractions(int n) {         List<String> result = new ArrayList<String>();                  for(int i=2; i<=n; i++){             for(int j=1; j<i; j++){                 if(gcd(i,j) == 1) {                     result.add(j+""/""+i);                 }             }         }         return result;     }          private int gcd(int a, int b) {         if(a == 0) {             return b;         }         return gcd(b%a, a);     } }",1,"1447-simplified-fractions/Solution.java:5:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new ArrayList<>()`
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public int goodNodes(TreeNode root) {         return helper(root, Integer.MIN_VALUE);     }          private int helper(TreeNode node, int maxSoFar) {         if(node == null) {             return 0;         }         int count = 0;         if(node.val >= maxSoFar) {             count++;             maxSoFar = node.val;         }         count += helper(node.left, maxSoFar);         count += helper(node.right, maxSoFar);         return count;     } }",1,"1448-count-good-nodes-in-binary-tree/TreeNode.java:28:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'maxSoFar'
",0,1,0
"class Solution {     public String arrangeWords(String text) {         String[] words = text.toLowerCase().split("" "");         Arrays.sort(words, Comparator.comparingInt(String::length));         StringBuilder sb = new StringBuilder();         for(int i = 0; i < words.length; i++) {             sb.append(words[i]);             if(i != words.length - 1) {                 sb.append("" "");             }         }         sb.setCharAt(0, Character.toUpperCase(sb.charAt(0)));         return sb.toString();     } }",1,"1451-rearrange-words-in-a-sentence/Solution.java:3:	UseLocaleWithCaseConversions:	When doing a String.toLowerCase()/toUpperCase() call, use a Locale
1451-rearrange-words-in-a-sentence/Solution.java:9:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
",0,0,0
"import java.util.*;  class Solution {     public List<Integer> peopleIndexes(List<List<String>> favoriteCompanies) {         List<Integer> result = new ArrayList<>();         int n = favoriteCompanies.size();         boolean[] isSubset = new boolean[n];                  // Check if each list of companies is a subset of another list         for (int i = 0; i < n; i++) {             if (isSubset[i]) {                 // Skip lists that have already been marked as subsets                 continue;             }             for (int j = i+1; j < n; j++) {                 if (isSubset[j]) {                     // Skip lists that have already been marked as subsets                     continue;                 }                 if (isSubset(favoriteCompanies.get(i), favoriteCompanies.get(j))) {                     isSubset[j] = true;                 } else if (isSubset(favoriteCompanies.get(j), favoriteCompanies.get(i))) {                     isSubset[i] = true;                     break;                 }             }         }                  // Add indices of lists that are not subsets to the result         for (int i = 0; i < n; i++) {             if (!isSubset[i]) {                 result.add(i);             }         }                  return result;     }          private boolean isSubset(List<String> a, List<String> b) {         // Check if list a is a subset of list b         for (String s : a) {             if (!b.contains(s)) {                 return false;             }         }         return true;     } }",1,"1452-people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/Solution.java:7:	LinguisticNaming:	Linguistics Antipattern - The variable 'isSubset' indicates linguistically it is a boolean, but it is 'boolean[]'
",0,0,0
"class Solution {     public int maxVowels(String s, int k) {         int maxCount=0;         int count=0;         int start=0;         for(int i=0;i<s.length();i++){             if(isVowel(s.charAt(i))){                 count++;             }             // slide the window             if(i>=k-1){                 maxCount=Math.max(count,maxCount);                 // removing the contribution of the first character from the present window                 if(isVowel(s.charAt(start))){                     count--;                 }                 start++;             }         }         return maxCount;     }          // method to check vowel     public boolean isVowel(char c){         if(c=='a'||c=='e'||c=='i'||c=='o'||c=='u'){             return true;         }         return false;     } }",1,"1456-maximum-number-of-vowels-in-a-substring-of-given-length/Solution.java:25:	SimplifyBooleanReturns:	This if statement can be replaced by `return {condition};`
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public int pseudoPalindromicPaths(TreeNode root) {         return getPaths(root, new int[10]);   // call helper method to get the count of pseudo-palindromic paths     }      public int getPaths(TreeNode node, int[] count) {         if (node == null) {   // base case             return 0;         }          count[node.val]++;  // increment the count of current node value in count array          if (node.left == null && node.right == null) {   // check if the current node is a leaf node             int oddCount = 0;   // count of nodes with odd occurrence             for (int i = 1; i <= 9; i++) {                 if (count[i] % 2 != 0) {                     oddCount++;                 }             }             count[node.val]--;  // decrement the count of current node value in count array             return oddCount <= 1 ? 1 : 0;   // return 1 if the path is pseudo-palindromic, else return 0         }          int leftPaths = getPaths(node.left, count);   // recursively get paths from left subtree         int rightPaths = getPaths(node.right, count);   // recursively get paths from right subtree          count[node.val]--;   // decrement the count of current node value in count array          return leftPaths + rightPaths;   // return the total count of pseudo-palindromic paths     } }  ",0,,0,0,0
"import java.util.HashMap; class LRUCache {      Node head;     Node tail;     int cacheCapacity;     HashMap<Integer, Node> nodeMap = null;      public LRUCache(int capacity) {         this.cacheCapacity = capacity;         this.nodeMap = new HashMap<>();     }      public int get(int key) {         if (!nodeMap.containsKey(key)) {             return -1;         }         Node node = nodeMap.get(key);         remove(node);         addNode(node);         return node.value;     }      public void put(int key, int value) {         // If node already exists update value         if (nodeMap.containsKey(key)) {             Node node = nodeMap.get(key);             node.value = value;             remove(node);             addNode(node);             return;         }         if (nodeMap.size() == cacheCapacity) {             nodeMap.remove(tail.key);             remove(tail);         }         Node node = new Node(key, value);         nodeMap.put(key, node);         addNode(node);     }      private void remove(Node node) {         if (node == head && node == tail) {             head = null;             tail = null;         } else if (node == head) {             head = head.next;             head.prev = null;         } else if (node == tail) {             tail = tail.prev;             tail.next = null;         } else {             node.prev.next = node.next;             node.next.prev = node.prev;         }     }      private void addNode(Node node) {         if (head == null && tail == null) {             head = node;             tail = node;         } else {             node.next = head;             head.prev = node;             head = node;         }     }      static class Node {         int key;         int value;         Node prev;         Node next;          Node(int k, int v) {             this.key = k;             this.value = v;         }     } }",1,"146-lru-cache/LRUCache.java:4:10: Variable 'head' must be private and have accessor methods. [VisibilityModifier]
146-lru-cache/LRUCache.java:5:10: Variable 'tail' must be private and have accessor methods. [VisibilityModifier]
146-lru-cache/LRUCache.java:6:9: Variable 'cacheCapacity' must be private and have accessor methods. [VisibilityModifier]
146-lru-cache/LRUCache.java:7:28: Variable 'nodeMap' must be private and have accessor methods. [VisibilityModifier]
146-lru-cache/LRUCache.java:9:5: Redundant 'public' modifier. [RedundantModifier]
146-lru-cache/LRUCache.java:70:13: Variable 'key' must be private and have accessor methods. [VisibilityModifier]
146-lru-cache/LRUCache.java:71:13: Variable 'value' must be private and have accessor methods. [VisibilityModifier]
146-lru-cache/LRUCache.java:72:14: Variable 'prev' must be private and have accessor methods. [VisibilityModifier]
146-lru-cache/LRUCache.java:73:14: Variable 'next' must be private and have accessor methods. [VisibilityModifier]
146-lru-cache/LRUCache.java:4:10: Variable 'head' must be private and have accessor methods. [VisibilityModifier]
146-lru-cache/LRUCache.java:5:10: Variable 'tail' must be private and have accessor methods. [VisibilityModifier]
146-lru-cache/LRUCache.java:6:9: Variable 'cacheCapacity' must be private and have accessor methods. [VisibilityModifier]
146-lru-cache/LRUCache.java:7:28: Variable 'nodeMap' must be private and have accessor methods. [VisibilityModifier]
146-lru-cache/LRUCache.java:9:5: Redundant 'public' modifier. [RedundantModifier]
146-lru-cache/LRUCache.java:70:13: Variable 'key' must be private and have accessor methods. [VisibilityModifier]
146-lru-cache/LRUCache.java:71:13: Variable 'value' must be private and have accessor methods. [VisibilityModifier]
146-lru-cache/LRUCache.java:72:14: Variable 'prev' must be private and have accessor methods. [VisibilityModifier]
146-lru-cache/LRUCache.java:73:14: Variable 'next' must be private and have accessor methods. [VisibilityModifier]
146-lru-cache/LRUCache.java:7:	LooseCoupling:	Avoid using implementation types like 'HashMap'; use the interface instead
146-lru-cache/LRUCache.java:7:	UnusedAssignment:	The field initializer for 'nodeMap' is never used (overwritten on line 11)
146-lru-cache/LRUCache.java:43:	CompareObjectsWithEquals:	Use equals() to compare object references.
146-lru-cache/LRUCache.java:43:	CompareObjectsWithEquals:	Use equals() to compare object references.
146-lru-cache/LRUCache.java:44:	NullAssignment:	Assigning an Object to null is a code smell.  Consider refactoring.
146-lru-cache/LRUCache.java:45:	NullAssignment:	Assigning an Object to null is a code smell.  Consider refactoring.
146-lru-cache/LRUCache.java:46:	CompareObjectsWithEquals:	Use equals() to compare object references.
146-lru-cache/LRUCache.java:48:	NullAssignment:	Assigning an Object to null is a code smell.  Consider refactoring.
146-lru-cache/LRUCache.java:49:	CompareObjectsWithEquals:	Use equals() to compare object references.
146-lru-cache/LRUCache.java:51:	NullAssignment:	Assigning an Object to null is a code smell.  Consider refactoring.
",0,0,0
"class Solution {     public boolean hasAllCodes(String s, int k) {                  // Total number of unique binary codes possible of length k         int totalPossible = 1 << k;                  // Create a Set to store all the unique binary codes of length k found in string s         Set<String> binaryCodes = new HashSet<>();                  // Loop through the entire string s and store all the unique binary codes of length k         for(int i = 0; i <= s.length() - k; i++){             binaryCodes.add(s.substring(i, i+k));             if(binaryCodes.size() == totalPossible){                 // If all the unique binary codes of length k have been found, return true                 return true;             }         }                  // If all the unique binary codes of length k have not been found, return false         return false;     } }",0,,0,0,0
"import java.util.*;  class Solution {     public List<Boolean> checkIfPrerequisite(int numCourses, int[][] prerequisites, int[][] queries) {         // Keep a count of prerequisites for each course         int[] indegree = new int[numCourses];         // Initialize the adjacency list for each course         List<List<Integer>> adjList = new ArrayList<>();         for (int i = 0; i < numCourses; i++) {             adjList.add(new ArrayList<>());         }          // Build the prerequisites graph         for (int[] pre : prerequisites) {             int u = pre[0];             int v = pre[1];             adjList.get(u).add(v);             indegree[v]++;         }          // Perform Topological Sort to determine the correct order of courses         Queue<Integer> queue = new LinkedList<>();         for (int i = 0; i < numCourses; i++) {             if (indegree[i] == 0) {                 queue.offer(i);             }         }          while (!queue.isEmpty()) {             int u = queue.poll();             for (int v : adjList.get(u)) {                 indegree[v]--;                 if (indegree[v] == 0) {                     queue.offer(v);                 }             }         }          // Initialize the answer list         List<Boolean> ansList = new ArrayList<>();          // Check if each query course is a prerequisite of the target course         for (int[] query : queries) {             int u = query[0];             int v = query[1];             ansList.add(indegree[v] == 0 && adjList.get(u).contains(v));         }          return ansList;     } }",0,,0,0,0
"class Solution {     public int maxArea(int h, int w, int[] horizontalCuts, int[] verticalCuts) {         int mod = 1000000007; // Modulus to be used as the result can be a large number                  //Sorting the two arrays         Arrays.sort(horizontalCuts);         Arrays.sort(verticalCuts);                  //Initialize max height and width as the difference between the first and the last elements         int maxHeight = Math.max(horizontalCuts[0], h - horizontalCuts[horizontalCuts.length-1]);         int maxWidth = Math.max(verticalCuts[0], w - verticalCuts[verticalCuts.length-1]);                  //Iterating over the heights and widths to find the max gap between horizontal cuts and vertical cuts         for (int i = 1; i < horizontalCuts.length; i++) {             maxHeight = Math.max(maxHeight, horizontalCuts[i] - horizontalCuts[i-1]);         }                  for (int i = 1; i < verticalCuts.length; i++) {             maxWidth = Math.max(maxWidth, verticalCuts[i] - verticalCuts[i-1]);         }                  //Returning the maximum area         return (int)((long)maxHeight * maxWidth % mod);     } }",0,,0,0,0
"import java.util.*;  class Solution {     public int minReorder(int n, int[][] connections) {         List<List<Integer>> adjList = new ArrayList<>();         for (int i = 0; i < n; i++) {             adjList.add(new ArrayList<>());         }         for (int[] conn : connections) {             adjList.get(conn[0]).add(conn[1]); // add outgoing edge             adjList.get(conn[1]).add(~conn[0]); // add incoming edge         }                  Queue<Integer> q = new LinkedList<>();         boolean[] visited = new boolean[n];         visited[0] = true;         q.offer(0);                  int count = 0;         while (!q.isEmpty()) {             int fromNode = q.poll();             for (int toNode : adjList.get(fromNode)) {                 if (!visited[Math.abs(toNode)]) {                     if (toNode >= 0) {                         count++; // need to change direction to reach 0                     }                     visited[Math.abs(toNode)] = true;                     q.offer(Math.abs(toNode));                 }             }         }         return count;     } }",0,,0,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public ListNode insertionSortList(ListNode head) {         // if the linked list is empty or contains only 1 node, return the linked list as it is         if(head == null || head.next == null) return head;                  // initialise pointers for traversal and sorting         ListNode sorted = null;         ListNode curr = head;                  // iterate over the linked list         while(curr != null) {             // store the next element in a separate variable             ListNode next = curr.next;             // for each element, find the correct position to insert it in the sorted list             sorted = insertNode(sorted, curr);             // move to the next element             curr = next;         }         // return the head of the sorted linked list         return sorted;     }          // helper function to insert nodes in the correct position in the sorted list     public ListNode insertNode(ListNode sorted, ListNode nodeToInsert) {         // if sorted is null, the nodeToInsert becomes the head of the sorted list         if(sorted == null || sorted.val >= nodeToInsert.val) {             nodeToInsert.next = sorted;             sorted = nodeToInsert;         } else {             // else iterate over the sorted list to find the correct position to insert the nodeToInsert             ListNode curr = sorted;             while(curr.next != null && curr.next.val < nodeToInsert.val) {                 curr = curr.next;             }             // insert the nodeToInsert in the correct position             nodeToInsert.next = curr.next;             curr.next = nodeToInsert;         }         // return the head of the sorted linked list after insertion         return sorted;     } }",1,"147-insertion-sort-list/ListNode.java:38:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'sorted'
",0,1,0
"class Solution {     public int[] getStrongest(int[] arr, int k) {         int n = arr.length;         Arrays.sort(arr);         int m = arr[(n-1)/2];  // median         Integer[] a = new Integer[n];         for (int i = 0; i < n; i++) {             a[i] = arr[i];         }         Arrays.sort(a, Comparator.comparingInt(x -> Math.abs(x - m)).thenComparingInt(x -> -x));         int[] ans = new int[k];         for (int i = 0; i < k; i++) {             ans[i] = a[i];         }         return ans;     } }",1,"1471-the-k-strongest-values-in-an-array/Solution.java:7:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
1471-the-k-strongest-values-in-an-array/Solution.java:12:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
",0,0,0
"import java.util.*;  class BrowserHistory {      LinkedList<String> history;     int current;      public BrowserHistory(String homepage) {         history = new LinkedList<String>();         history.add(homepage);         current = 0;     }          public void visit(String url) {         // Remove all forward history         while (current < history.size()-1) {             history.removeLast();         }         // Add new url to history and update current position         history.add(url);         current = history.size()-1;     }          public String back(int steps) {         // Move steps back in history (at most)         current = Math.max(current - steps, 0);         // Return current url         return history.get(current);     }          public String forward(int steps) {         // Move steps forward in history (at most)         current = Math.min(current + steps, history.size()-1);         // Return current url         return history.get(current);     } }  /**  * Your BrowserHistory object will be instantiated and called as such:  * BrowserHistory obj = new BrowserHistory(homepage);  * obj.visit(url);  * String param_2 = obj.back(steps);  * String param_3 = obj.forward(steps);  */",1,"1472-design-browser-history/BrowserHistory.java:5:24: Variable 'history' must be private and have accessor methods. [VisibilityModifier]
1472-design-browser-history/BrowserHistory.java:6:9: Variable 'current' must be private and have accessor methods. [VisibilityModifier]
1472-design-browser-history/BrowserHistory.java:8:5: Redundant 'public' modifier. [RedundantModifier]
1472-design-browser-history/BrowserHistory.java:5:24: Variable 'history' must be private and have accessor methods. [VisibilityModifier]
1472-design-browser-history/BrowserHistory.java:6:9: Variable 'current' must be private and have accessor methods. [VisibilityModifier]
1472-design-browser-history/BrowserHistory.java:8:5: Redundant 'public' modifier. [RedundantModifier]
1472-design-browser-history/BrowserHistory.java:5:	LooseCoupling:	Avoid using implementation types like 'LinkedList'; use the interface instead
1472-design-browser-history/BrowserHistory.java:9:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new LinkedList<>()`
",0,0,0
"class SubrectangleQueries {     private int[][] rectangle;     public SubrectangleQueries(int[][] rectangle) {         this.rectangle = rectangle;     }          public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {         for(int i = row1; i <= row2; i++) {             for(int j = col1; j <= col2; j++) {                 rectangle[i][j] = newValue;             }         }     }          public int getValue(int row, int col) {         return rectangle[row][col];     } }  /**  * Your SubrectangleQueries object will be instantiated and called as such:  * SubrectangleQueries obj = new SubrectangleQueries(rectangle);  * obj.updateSubrectangle(row1,col1,row2,col2,newValue);  * int param_2 = obj.getValue(row,col);  */",1,"1476-subrectangle-queries/SubrectangleQueries.java:3:5: Redundant 'public' modifier. [RedundantModifier]
1476-subrectangle-queries/SubrectangleQueries.java:3:40: 'rectangle' hides a field. [HiddenField]
1476-subrectangle-queries/SubrectangleQueries.java:3:5: Redundant 'public' modifier. [RedundantModifier]
1476-subrectangle-queries/SubrectangleQueries.java:3:40: 'rectangle' hides a field. [HiddenField]
1476-subrectangle-queries/SubrectangleQueries.java:4:	ArrayIsStoredDirectly:	The user-supplied array 'rectangle' is stored directly.
",0,0,0
"import java.util.HashMap; import java.util.Map;  class Solution {     public int minSumOfLengths(int[] arr, int target) {          Map<Integer, Integer> map = new HashMap<>();         map.put(0, -1);          int currSum = 0;         int currMinLength = Integer.MAX_VALUE;          int[] minLengths = new int[arr.length];         for (int i = 0; i < arr.length; i++) {             currSum += arr[i];             if (map.containsKey(currSum - target)) {                 int prevIndex = map.get(currSum - target);                 int currLength = i - prevIndex;                 if (prevIndex >= 0 && minLengths[prevIndex] != Integer.MAX_VALUE) {                     currMinLength = Math.min(currMinLength, currLength + minLengths[prevIndex]);                 }             }             minLengths[i] = currMinLength;             currMinLength = Math.min(currMinLength, i - map.getOrDefault(currSum, i));             map.put(currSum, i);         }          return (minLengths[arr.length - 1] == Integer.MAX_VALUE) ? -1 : minLengths[arr.length - 1];     } }",1,"1477-find-two-non-overlapping-sub-arrays-each-with-target-sum/Solution.java:7:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
",0,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public ListNode sortList(ListNode head) {         if (head == null || head.next == null)             return head;                  // split the list into two halves         ListNode prev = null, slow = head, fast = head;         while (fast != null && fast.next != null) {             prev = slow;             slow = slow.next;             fast = fast.next.next;         }         prev.next = null;                  // sort the two halves         ListNode left = sortList(head);         ListNode right = sortList(slow);                  // merge the two sorted halves         ListNode dummy = new ListNode(0);         ListNode curr = dummy;         while (left != null && right != null) {             if (left.val < right.val) {                 curr.next = left;                 left = left.next;             } else {                 curr.next = right;                 right = right.next;             }             curr = curr.next;         }         if (left != null)             curr.next = left;         else             curr.next = right;                  return dummy.next;     } }",1,"148-sort-list/ListNode.java:17:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
148-sort-list/ListNode.java:17:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
148-sort-list/ListNode.java:23:	NullAssignment:	Assigning an Object to null is a code smell.  Consider refactoring.
",1,0,0
"class Solution {     public int findLeastNumOfUniqueInts(int[] arr, int k) {         // Create a hashmap to store count of each unique integer in the array         Map<Integer, Integer> freqMap = new HashMap<>();         for (int num : arr) {             freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);         }                  // Sort the frequencies of unique integers in ascending order         List<Integer> freqList = new ArrayList<>(freqMap.values());         Collections.sort(freqList);                  int count = freqList.size();         for (int freq : freqList) {             // Remove the unique integer with the lowest frequency until either k is reached or all unique integers are removed             if (k >= freq) {                 k -= freq;                 count--;             } else {                 break;             }         }                  return count;     } }",1,"1481-least-number-of-unique-integers-after-k-removals/Solution.java:17:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'k'
",0,1,0
"class Solution {     public int minDays(int[] bloomDay, int m, int k) {         int n = bloomDay.length;         if (m * k > n) {             return -1; // Not enough flowers to make m bouquets         }         int left = 1;         int right = (int)1e9; // Maximum bloomDay value         while (left < right) {             int mid = left + (right - left) / 2;             if (canMakeBouquets(bloomDay, m, k, mid)) {                 right = mid;             } else {                 left = mid + 1;             }         }         return left;     }          private boolean canMakeBouquets(int[] bloomDay, int m, int k, int days) {         int flowersUsed = 0;         int bouquetsMade = 0;         for (int i = 0; i < bloomDay.length; i++) {             if (bloomDay[i] <= days) {                 flowersUsed++;                 if (flowersUsed == k) {                     bouquetsMade++;                     flowersUsed = 0;                 }             } else {                 flowersUsed = 0;             }         }         return bouquetsMade >= m;     } }",1,"1482-minimum-number-of-days-to-make-m-bouquets/Solution.java:23:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int minDays(int[] bloomDay, int m, int k) {         int n = bloomDay.length;         if (m * k > n) {             return -1; // Not enough flowers to make m bouquets         }         int left = 1;         int right = (int)1e9; // Maximum bloomDay value         while (left < right) {             int mid = left + (right - left) / 2;             if (canMakeBouquets(bloomDay, m, k, mid)) {                 right = mid;             } else {                 left = mid + 1;             }         }         return left;     }          private boolean canMakeBouquets(int[] bloomDay, int m, int k, int days) {         int flowersUsed = 0;         int bouquetsMade = 0;         for (int i = 0; i < bloomDay.length; i++) {             if (bloomDay[i] <= days) {                 flowersUsed++;                 if (flowersUsed == k) {                     bouquetsMade++;                     flowersUsed = 0;                 }             } else {                 flowersUsed = 0;             }         }         return bouquetsMade >= m;     } }",0,,0,0,0
"class Solution {     public int[] avoidFlood(int[] rains) {         int n = rains.length;         int[] ans = new int[n];         Map<Integer, Integer> fullLakes = new HashMap<>();          for (int i = 0; i < n; i++) {             int lake = rains[i];              // If it's a sunny day and there are full lakes             if (lake == 0) {                 // Check if we can dry a lake without causing a flood                 boolean found = false;                 for (int j = i + 1; j < n; j++) {                     // Check if this lake is full                     if (rains[j] > 0) {                         // Check if we can dry the full lake without causing a flood                         if (!fullLakes.containsKey(rains[j]) || fullLakes.get(rains[j]) >= j) {                             ans[i] = rains[j];                             fullLakes.put(rains[j], i);                             found = true;                             break;                         }                     }                 }                  // If we couldn't find any lake to dry, we can't avoid a flood                 if (!found) {                     return new int[0];                 }             } else {                 // It's a rainy day                 // Check if this lake is already full                 if (fullLakes.containsKey(lake)) {                     int lastRainyDay = fullLakes.get(lake);                     ans[lastRainyDay] = -1;                     fullLakes.put(lake, i);                     ans[i] = -1;                 } else {                     ans[i] = -1;                     fullLakes.put(lake, i);                 }             }         }          return ans;     } }",1,"1488-avoid-flood-in-the-city/Solution.java:18:	CollapsibleIfStatements:	This if statement could be combined with its parent
",0,0,0
"class Solution {     public int kthFactor(int n, int k) {         int count = 0;         for (int i = 1; i <= n; i++) {             if (n % i == 0) {                 count++;                 if (count == k) {                     return i;                 }             }         }         return -1;     } }  /* Test the program */ public class Main {     public static void main(String[] args) {         Solution solution = new Solution();         System.out.println(solution.kthFactor(12, 3)); // Output: 3         System.out.println(solution.kthFactor(7, 2)); // Output: 7         System.out.println(solution.kthFactor(4, 4)); // Output: -1     } }",1,"1492-the-kth-factor-of-n/Main.java:17:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
1492-the-kth-factor-of-n/Main.java:17:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
1492-the-kth-factor-of-n/Main.java:17:	UseUtilityClass:	This utility class has a non-private constructor
",0,0,0
"class Solution {     public int longestSubarray(int[] nums) {         int n = nums.length;         int[] left = new int[n]; // stores length of consecutive ones starting from left         int[] right = new int[n]; // stores length of consecutive ones starting from right          left[0] = nums[0];         for (int i = 1; i < n; i++) {             if (nums[i] == 1) {                 left[i] = left[i - 1] + 1;             }         }          right[n - 1] = nums[n - 1];         for (int i = n - 2; i >= 0; i--) {             if (nums[i] == 1) {                 right[i] = right[i + 1] + 1;             }         }          int maxOnes = 0;         for (int i = 0; i < n; i++) {             if (nums[i] == 0) {                 // if we delete the current element, calculate the length of consecutive ones                 int ones = 0;                 if (i > 0) {                     ones += left[i - 1];                 }                 if (i < n - 1) {                     ones += right[i + 1];                 }                 maxOnes = Math.max(maxOnes, ones);             }         }          return maxOnes;     } }",0,,0,0,0
"class Solution {     public boolean canArrange(int[] arr, int k) {         int[] freq = new int[k];         for(int num : arr){             int remain = num % k;             if(remain < 0) remain += k;             freq[remain]++;         }         if(freq[0] % 2 != 0) return false;         for(int i=1; i<k; i++){             if(freq[i] != freq[k - i]) return false;         }         return true;     } }",0,,0,0,0
"class Solution {     public int numSubseq(int[] nums, int target) {         Arrays.sort(nums); // Sort the given array         int left = 0, right = nums.length - 1;          int res = 0;         int mod = (int) 1e9 + 7;          int[] pow = new int[nums.length];         pow[0] = 1;         for (int i = 1; i < nums.length; i++)             pow[i] = (pow[i - 1] * 2) % mod;                  while (left <= right) {             if (nums[left] + nums[right] > target) {                 right--;             } else {                 res = (res + pow[right - left]) % mod;                 left++;             }         }         return res;     } }",1,"1498-number-of-subsequences-that-satisfy-the-given-sum-condition/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1498-number-of-subsequences-that-satisfy-the-given-sum-condition/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1498-number-of-subsequences-that-satisfy-the-given-sum-condition/Solution.java:10:	UselessParentheses:	Useless parentheses.
",1,0,0
"class Solution {     public int evalRPN(String[] tokens) {         Stack<Integer> stack = new Stack<>(); // create stack to store operands         int operand1, operand2, result;          for (String token : tokens) {             switch (token) {                 case ""+"": // case for addition                     operand2 = stack.pop();                     operand1 = stack.pop();                     result = operand1 + operand2;                     stack.push(result);                     break;                 case ""-"": // case for subtraction                     operand2 = stack.pop();                     operand1 = stack.pop();                     result = operand1 - operand2;                     stack.push(result);                     break;                 case ""*"": // case for multiplication                     operand2 = stack.pop();                     operand1 = stack.pop();                     result = operand1 * operand2;                     stack.push(result);                     break;                 case ""/"": // case for division                     operand2 = stack.pop();                     operand1 = stack.pop();                     result = operand1 / operand2;                     stack.push(result);                     break;                 default: // case for operands                     stack.push(Integer.parseInt(token));                     break;             }         }          return stack.pop(); // return the final result from the stack     } }",1,"150-evaluate-reverse-polish-notation/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
150-evaluate-reverse-polish-notation/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int getLastMoment(int n, int[] left, int[] right) {         int maxFallTime = 0;         //finding maximum time taken by ants moving to left side and ants moving to right side before they leave the plank         for(int i=0;i<left.length;i++){             maxFallTime = Math.max(maxFallTime, left[i]);         }         for(int i=0;i<right.length;i++){             maxFallTime = Math.max(maxFallTime, n-right[i]);         }         return maxFallTime;     } }",1,"1503-last-moment-before-all-ants-fall-out-of-a-plank/Solution.java:5:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
1503-last-moment-before-all-ants-fall-out-of-a-plank/Solution.java:8:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int numSubmat(int[][] mat) {         int m = mat.length;         int n = mat[0].length;         int[][] matrix = new int[m][n];                  // Copy the first row of matrix         for (int j = 0; j < n; j++) {             matrix[0][j] = mat[0][j];         }                  // Fill the rest of the matrix         for (int i = 1; i < m; i++) {             for (int j = 0; j < n; j++) {                 if (mat[i][j] == 1) {                     matrix[i][j] = matrix[i - 1][j] + 1;                 }             }         }                  int count = 0;         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 int min = matrix[i][j];                 for (int k = j; k < n && min > 0; k++) {                     min = Math.min(min, matrix[i][k]);                     count += min;                 }             }         }                  return count;     } }",0,,0,0,0
"class Solution {     public int rangeSum(int[] nums, int n, int left, int right) {         int mod = 1000000007;         int[] sortedSums = new int[(n * (n + 1)) / 2]; // create the new array to store sorted sums         int k = 0;         for (int i = 0; i < n; i++) {             int sum = 0;             for (int j = i; j < n; j++) {                 sum += nums[j]; // calculate the sum of each subarray                 sortedSums[k++] = sum; // store the sum into the new array             }         }         Arrays.sort(sortedSums); // sort the new array         int ans = 0;         for (int i = left - 1; i < right; i++) {             ans = (ans + sortedSums[i]) % mod; // calculate the sum of the desired range         }         return ans;     } }",1,"1508-range-sum-of-sorted-subarray-sums/Solution.java:4:	UselessParentheses:	Useless parentheses.
",0,0,0
"class Solution {     public int minDifference(int[] nums) {         int n = nums.length;         if (n <= 4) {             return 0;         }            Arrays.sort(nums);         int minDiff = nums[n - 1] - nums[0];         for (int i = 0; i < 4; i++) {             minDiff = Math.min(minDiff, nums[n - 4 + i] - nums[i]);         }         return minDiff;     } }",0,,0,0,0
"class Solution {     public String reverseWords(String s) {         //trimming the whitespace from the start and end of the string         s = s.trim();         //splitting the words based on single or multiple spaces         String[] words = s.split(""\\s+"");         StringBuilder sb = new StringBuilder();          for (int i = words.length - 1; i >= 0; i--) { //iterating the words array from the last index             sb.append(words[i]).append("" ""); //appending the word to the StringBuilder followed by a single space         }          return sb.toString().trim(); //returning the final reverse string with leading/trailing spaces removed     } }",1,"151-reverse-words-in-a-string/Solution.java:4:	AvoidReassigningParameters:	Avoid reassigning parameters such as 's'
151-reverse-words-in-a-string/Solution.java:10:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
",0,1,0
class Solution {     public int numSub(String s) {         int res = 0;         int cnt = 0;         int mod = 1000000007;         for (int i = 0; i < s.length(); i++) {             if (s.charAt(i) == '1') {                 cnt++;                 res = (res + cnt) % mod;             } else {                 cnt = 0;             }         }         return res;     } },0,,0,0,0
"import java.util.*; class Solution {     public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {         // create adjacency list         Map<Integer, List<double[]>> graph = new HashMap<>();         for (int i = 0; i < edges.length; i++) {             int u = edges[i][0], v = edges[i][1];             graph.putIfAbsent(u, new ArrayList<>());             graph.putIfAbsent(v, new ArrayList<>());             graph.get(u).add(new double[]{v, succProb[i]});             graph.get(v).add(new double[]{u, succProb[i]});         }                  // calculate max probability using Dijkstra's algorithm         PriorityQueue<double[]> pq = new PriorityQueue<>((a, b) -> Double.compare(b[1], a[1]));         boolean[] visited = new boolean[n];         double[] probs = new double[n];         probs[start] = 1;         pq.offer(new double[]{start, 1});         while (!pq.isEmpty()) {             double[] curr = pq.poll();             int node = (int) curr[0];             double prob = curr[1];             if (visited[node]) continue;             visited[node] = true;             if (node == end) return prob;             for (double[] neighbor : graph.get(node)) {                 int next = (int) neighbor[0];                 double edgeProb = neighbor[1];                 if (!visited[next]) {                     probs[next] = Math.max(probs[next], prob * edgeProb);                     pq.offer(new double[]{next, probs[next]});                 }             }         }         return 0;     } }",1,"1514-path-with-maximum-probability/Solution.java:7:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1514-path-with-maximum-probability/Solution.java:7:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1514-path-with-maximum-probability/Solution.java:5:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
1514-path-with-maximum-probability/Solution.java:15:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
",1,0,0
"class Solution {     public int[] countSubTrees(int n, int[][] edges, String labels) {         Map<Integer, List<Integer>> graph = new HashMap<>();         for (int i = 0; i < n - 1; i++) {             int u = edges[i][0], v = edges[i][1];             graph.computeIfAbsent(u, x -> new ArrayList<>()).add(v);             graph.computeIfAbsent(v, x -> new ArrayList<>()).add(u);         }         int[] ans = new int[n];         boolean[] visited = new boolean[n];         dfs(0, graph, visited, ans, labels);         return ans;     }          private int[] dfs(int node, Map<Integer, List<Integer>> graph, boolean[] visited, int[] ans, String labels) {         int[] count = new int[26];         visited[node] = true;         char c = labels.charAt(node);         count[c - 'a']++;         for (int neighbor : graph.getOrDefault(node, new ArrayList<>())) {             if (!visited[neighbor]) {                 int[] subCount = dfs(neighbor, graph, visited, ans, labels);                 for (int i = 0; i < 26; i++) {                     count[i] += subCount[i];                 }             }         }         ans[node] = count[c - 'a'];         return count;     } }",1,"1519-number-of-nodes-in-the-sub-tree-with-the-same-label/Solution.java:5:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1519-number-of-nodes-in-the-sub-tree-with-the-same-label/Solution.java:5:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int maxProduct(int[] nums) {       int maxProduct = nums[0];       int currMax = nums[0];       int currMin = nums[0];                for(int i=1; i<nums.length; i++){           int temp = currMax;           currMax = Math.max(Math.max(currMax*nums[i], currMin*nums[i]), nums[i]);           currMin = Math.min(Math.min(temp*nums[i], currMin*nums[i]), nums[i]);                      if(currMax>maxProduct){               maxProduct = currMax;           }       }       return maxProduct;     } }",0,,0,0,0
class Solution {     public int numOfSubarrays(int[] arr) {         int mod = 1000000007;    // Modulo value         int oddSum = 0;    // Number of subarrays with odd sum         int evenSum = 1;    // Number of subarrays with even sum         int sum = 0;    // Running sum of array elements                  for(int i=0;i<arr.length;i++){             sum+=arr[i];    // Add current element to the running sum                          if(sum%2==0)                 evenSum = (evenSum+1)%mod;    // Increment evenSum             else                 oddSum = (oddSum+1)%mod;    // Increment oddSum         }                  return oddSum%mod;    // Return final answer after taking modulo     } },1,"1524-number-of-sub-arrays-with-odd-sum/Solution.java:8:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int numSplits(String s) {         int[] left = new int[26];         int[] right = new int[26];         int countLeft = 0, countRight = 0, result = 0;          // Count distinct characters in the right array         for (int i = 0; i < s.length(); i++) {             if (right[s.charAt(i) - 'a'] == 0) {                 countRight++;             }             right[s.charAt(i) - 'a']++;         }          // Traverse the string and count good splits         for (int i = 0; i < s.length() - 1; i++) {             int ch = s.charAt(i) - 'a';             if (left[ch] == 0) {                 countLeft++;             }             left[ch]++;              right[ch]--;             if (right[ch] == 0) {                 countRight--;             }              if (countLeft == countRight) {                 result++;             }         }          return result;     } }",1,"1525-number-of-good-ways-to-split-a-string/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1525-number-of-good-ways-to-split-a-string/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int minFlips(String target) {         int n = target.length();         int flips = 0;         char prev = '0';         for (int i = 0; i < n; i++) {             char curr = target.charAt(i);             if (curr != prev) {                 flips++;                 prev = curr;             }         }         return flips;     } }   //Test the code with the given examples public class Main {     public static void main(String[] args) {         Solution solution = new Solution();         String target = ""10111"";         int flips = solution.minFlips(target);         System.out.println(flips); // Expected output: 3          target = ""101"";         flips = solution.minFlips(target);         System.out.println(flips); // Expected output: 3          target = ""00000"";         flips = solution.minFlips(target);         System.out.println(flips); // Expected output: 0     } }",1,"1529-minimum-suffix-flips/Main.java:18:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
1529-minimum-suffix-flips/Main.java:18:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
1529-minimum-suffix-flips/Main.java:18:	UseUtilityClass:	This utility class has a non-private constructor
",0,0,0
"class Solution {     public int findMin(int[] nums) {         int low = 0, high = nums.length-1;         while(low<high){             int mid = low+(high-low)/2;             if(nums[mid] > nums[high]) //the minimum element lies in the right half                 low = mid+1;             else //the minimum element lies in the left half                 high = mid;         }         return nums[low];     } }",1,"153-find-minimum-in-rotated-sorted-array/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
153-find-minimum-in-rotated-sorted-array/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */  class Solution {     // stores the answer     int ans = 0;          public int countPairs(TreeNode root, int distance) {         // call dfs (depth first search)         dfs(root, distance);         // return the answer         return ans;     }          private List<Integer> dfs(TreeNode root, int distance){         // if the leaf node is null, return an empty list         if(root == null) return new ArrayList<>();         // if root is leaf node, return a list with just 1 element i.e. 0         if(root.left == null && root.right == null) return Arrays.asList(0);          // get the list of distances from the dfs of left child         List<Integer> left = dfs(root.left, distance);         // get the list of distances from the dfs of right child         List<Integer> right = dfs(root.right, distance);          // iterate for every left and right distances         for(int l : left){             for(int r : right){                 // add the distance between left and right                 if(l + r + 2 <= distance) ans++;             }         }          // sort the distances in ascending order, so we can get the shortest distances         List<Integer> res = new ArrayList<>();         for(int l : left){             if(l + 1 < distance) res.add(l + 1);         }         for(int r : right){             if(r + 1 < distance) res.add(r + 1);         }          // return the list of distances         return res;     } }",1,"1530-number-of-good-leaf-nodes-pairs/TreeNode.java:19:9: Variable 'ans' must be private and have accessor methods. [VisibilityModifier]
1530-number-of-good-leaf-nodes-pairs/TreeNode.java:19:9: Variable 'ans' must be private and have accessor methods. [VisibilityModifier]
1530-number-of-good-leaf-nodes-pairs/TreeNode.java:28:	NPathComplexity:	The method 'dfs(TreeNode, int)' has an NPath complexity of 216, current threshold is 200
",0,0,0
"class Solution {     public int getWinner(int[] arr, int k) {         int winner = arr[0];         int winCount = 0;         for (int i = 1; i < arr.length; i++) {             if (arr[i] > winner) {                 winner = arr[i];                 winCount = 1;             } else {                 winCount++;             }             if (winCount == k) {                 break;             }         }         return winner;     } }",0,,0,0,0
"class Solution {     public int minSwaps(int[][] grid) {         int n = grid.length;         int[] row = new int[n]; // stores the number of zeros on each row                  // count number of zeros of each row         for(int i=0;i<n;i++){             for(int j=0;j<n;j++){                 if(grid[i][j] == 0){                     row[i]++;                 }             }         }                  int swaps = 0; // stores the minimum number of swaps needed to make the grid valid                  // for each row starting from the last row         for(int i=n-1;i>=0;i--){             // check if there are enough zeros on the right of the current row             if(row[i]<n-i-1){                 int j = i+1;                 // find the first row with enough zeros on the right                 while(j<n && row[j]<n-i-1){                     j++;                 }                 // if no such row exists, then the grid cannot be valid                 if(j == n){                     return -1;                 }                 // swap rows until the ith row and the jth row                 while(j>i){                     int temp = row[j];                     row[j] = row[j-1];                     row[j-1] = temp;                     j--;                     swaps++;                 }             }         }                  return swaps;     } }",1,"1536-minimum-swaps-to-arrange-a-binary-grid/Solution.java:31:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
",0,0,0
"class Solution {     public boolean canConvertString(String s, String t, int k) {         if (s.length() != t.length()) {             // If the lengths of s and t are not the same, it's impossible to convert s to t             return false;         }         int[] shifts = new int[26]; // Keep track of how many times we need to shift each letter         for (int i = 0; i < s.length(); i++) {             if (s.charAt(i) != t.charAt(i)) {                 int diff = (t.charAt(i) - s.charAt(i) + 26) % 26; // Calculate the minimum number of shifts needed to get s[i] to t[i]                 if (k < diff + shifts[diff]) {                     // If we don't have enough moves left to perform the shift, it's impossible to convert s to t                     return false;                 }                 shifts[diff] += 26; // Update the number of shifts needed for s[i] and any future letters that need the same amount of shifts             }         }         return true;     } }",0,,0,0,0
class Solution {     public int minInsertions(String s) {         Stack<Character> stack = new Stack<>();         int insertions = 0;         int n = s.length();         int i = 0;         while (i < n) {             char c = s.charAt(i);             if (c == '(') {                 stack.push(c);                 i++;             } else { // c must be ')'                 if (i == n - 1 || s.charAt(i + 1) != ')') {                     insertions++;                 } else {                     i++;                 }                 if (!stack.isEmpty() && stack.peek() == '(') {                     stack.pop();                 } else {                     insertions++;                 }                 i++;             }         }         insertions += 2 * stack.size(); // two ')'s needed for each unmatched '('         return insertions;     } },0,,0,0,0
"class Solution {     public char findKthBit(int n, int k) {                  // initialize the string to ""0"" as per requirement         String s = ""0"";                  // loop to generate the binary string Sn         for(int i=2; i<=n; i++){             String temp = s;             // invert the string and reverse it             temp = invert(temp);             temp = reverse(temp);             // concatenate the original string with inverted and reversed string             s = s + ""1"" + temp;         }                  // return the kth bit of the generated string         return s.charAt(k-1);     }          // function to invert the binary string     public String invert(String s){         String temp = """";         for(int i=0; i<s.length(); i++){             if(s.charAt(i) == '0')                 temp = temp + ""1"";             else                 temp = temp + ""0"";         }         return temp;     }          // function to reverse the binary string     public String reverse(String s){         String temp = """";         for(int i=s.length()-1; i>=0; i--){             temp = temp + s.charAt(i);         }         return temp;     } }",1,"1545-find-kth-bit-in-nth-binary-string/Solution.java:14:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
1545-find-kth-bit-in-nth-binary-string/Solution.java:26:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
1545-find-kth-bit-in-nth-binary-string/Solution.java:28:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
1545-find-kth-bit-in-nth-binary-string/Solution.java:37:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
",0,0,0
"class Solution {     public int maxNonOverlapping(int[] nums, int target) {         int count = 0;         int sum = 0;         Set<Integer> set = new HashSet<>();         set.add(0);         for (int num : nums) {             sum += num;             if (set.contains(sum - target)) {                 count++;                 set = new HashSet<>();                 set.add(0);                 sum = 0;             } else {                 set.add(sum);             }         }         return count;     } }",0,,0,0,0
class MinStack {     private Stack<Integer> stack;     private Stack<Integer> minStack;          public MinStack() {         stack = new Stack<>();         minStack = new Stack<>();     }          public void push(int val) {         stack.push(val);         if (minStack.isEmpty() || val <= minStack.peek()) {             minStack.push(val);         }     }          public void pop() {         if (stack.pop().equals(minStack.peek())) {             minStack.pop();         }     }          public int top() {         return stack.peek();     }          public int getMin() {         return minStack.peek();     } },1,"155-min-stack/MinStack.java:5:5: Redundant 'public' modifier. [RedundantModifier]
155-min-stack/MinStack.java:5:5: Redundant 'public' modifier. [RedundantModifier]
155-min-stack/MinStack.java:3:	AvoidFieldNameMatchingTypeName:	It is somewhat confusing to have a field name matching the declaring class name
",0,0,0
class Solution {     public int minOperations(int n) {         int target = (2*n - 1) / 2; //target value for all elements to become equal         int operations = 0;         for(int i = 0; i < n/2; i++) {             int curr = (2 * i) + 1; //current element value             operations += target - curr; //calculate the number of operations required to make it equal to target         }         return operations;             } },0,,0,0,0
"class Solution {     public int maxDistance(int[] position, int m) {         Arrays.sort(position);         int n = position.length;         int left = 1, right = position[n-1] - position[0];         while (left < right) {             int mid = (left + right + 1) / 2;             if (canPlaceBalls(position, mid, m)) {                 left = mid;             } else {                 right = mid - 1;             }         }         return left;     }          private boolean canPlaceBalls(int[] position, int distance, int m) {         int n = position.length;         int lastPos = position[0];         int ballsPlaced = 1;         for (int i = 1; i < n; i++) {             if (position[i] - lastPos >= distance) {                 ballsPlaced++;                 lastPos = position[i];                 if (ballsPlaced == m) {                     return true;                 }             }         }         return false;     } }",1,"1552-magnetic-force-between-two-balls/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1552-magnetic-force-between-two-balls/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"import java.util.*;  class Solution {     public List<Integer> findSmallestSetOfVertices(int n, List<List<Integer>> edges) {         // Create a list to store the in-degree of each node         List<Integer> inDegree = new ArrayList<>(n);         for (int i = 0; i < n; i++) {             inDegree.add(0);         }          // Count the in-degree of each node         for (List<Integer> edge : edges) {             int from = edge.get(0);             int to = edge.get(1);             inDegree.set(to, inDegree.get(to) + 1);         }          // Find the nodes with in-degree 0         List<Integer> result = new ArrayList<>();         for (int i = 0; i < n; i++) {             if (inDegree.get(i) == 0) {                 result.add(i);             }         }          return result;     } }",1,"1557-minimum-number-of-vertices-to-reach-all-nodes/Solution.java:13:	UnusedLocalVariable:	Avoid unused local variables such as 'from'.
",0,0,0
"class Solution {     public int minOperations(int[] nums) {         int res = 0;         int maxVal = 0;         for (int num : nums) {             int cur = 0;             while (num > 0) {                 if (num % 2 == 1) {                     res++; // increment operation count                     cur++; // cur counts the number of 1's in binary expansion                 }                 num /= 2;             }             maxVal = Math.max(maxVal, cur);         }         return res + maxVal -1;     } }",0,,0,0,0
"class Solution {     public boolean containsCycle(char[][] grid) {         int m = grid.length;         int n = grid[0].length;                  // initialize visited array         boolean[][] visited = new boolean[m][n];                  // loop through each cell in the grid         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                                  // if this cell is not visited yet, start DFS                 if (!visited[i][j]) {                                          // if DFS finds a cycle, return true                     if (dfs(grid, visited, i, j, -1, -1, grid[i][j]))                         return true;                 }             }         }                  return false;     }          private boolean dfs(char[][] grid, boolean[][] visited, int row, int col, int prevRow, int prevCol, char target) {                  visited[row][col] = true;                  // check all 4 adjancent cells         if (row > 0 && grid[row-1][col] == target) { // up             if (!(row-1 == prevRow && col == prevCol)) { // check if not last visited cell                 if (visited[row-1][col] || dfs(grid, visited, row-1, col, row, col, target))                     return true;             }         }         if (row < grid.length-1 && grid[row+1][col] == target) { // down             if (!(row+1 == prevRow && col == prevCol)) { // check if not last visited cell                 if (visited[row+1][col] || dfs(grid, visited, row+1, col, row, col, target))                     return true;             }         }         if (col > 0 && grid[row][col-1] == target) { // left             if (!(row == prevRow && col-1 == prevCol)) { // check if not last visited cell                 if (visited[row][col-1] || dfs(grid, visited, row, col-1, row, col, target))                     return true;             }         }         if (col < grid[0].length-1 && grid[row][col+1] == target) { // right             if (!(row == prevRow && col+1 == prevCol)) { // check if not last visited cell                 if (visited[row][col+1] || dfs(grid, visited, row, col+1, row, col, target))                     return true;             }         }                  return false;     } }",1,"1559-detect-cycles-in-2d-grid/Solution.java:17:	CollapsibleIfStatements:	This if statement could be combined with its parent
1559-detect-cycles-in-2d-grid/Solution.java:26:	NPathComplexity:	The method 'dfs(char[][], boolean[][], int, int, int, int, char)' has an NPath complexity of 2401, current threshold is 200
1559-detect-cycles-in-2d-grid/Solution.java:32:	CollapsibleIfStatements:	This if statement could be combined with its parent
1559-detect-cycles-in-2d-grid/Solution.java:33:	AvoidDeeplyNestedIfStmts:	Deeply nested if..then statements are hard to read
1559-detect-cycles-in-2d-grid/Solution.java:33:	CollapsibleIfStatements:	This if statement could be combined with its parent
1559-detect-cycles-in-2d-grid/Solution.java:38:	CollapsibleIfStatements:	This if statement could be combined with its parent
1559-detect-cycles-in-2d-grid/Solution.java:39:	AvoidDeeplyNestedIfStmts:	Deeply nested if..then statements are hard to read
1559-detect-cycles-in-2d-grid/Solution.java:39:	CollapsibleIfStatements:	This if statement could be combined with its parent
1559-detect-cycles-in-2d-grid/Solution.java:44:	CollapsibleIfStatements:	This if statement could be combined with its parent
1559-detect-cycles-in-2d-grid/Solution.java:45:	AvoidDeeplyNestedIfStmts:	Deeply nested if..then statements are hard to read
1559-detect-cycles-in-2d-grid/Solution.java:45:	CollapsibleIfStatements:	This if statement could be combined with its parent
1559-detect-cycles-in-2d-grid/Solution.java:50:	CollapsibleIfStatements:	This if statement could be combined with its parent
1559-detect-cycles-in-2d-grid/Solution.java:51:	AvoidDeeplyNestedIfStmts:	Deeply nested if..then statements are hard to read
1559-detect-cycles-in-2d-grid/Solution.java:51:	CollapsibleIfStatements:	This if statement could be combined with its parent
",0,0,0
class Solution {     public int maxCoins(int[] piles) {         Arrays.sort(piles);         int sum = 0;         int n = piles.length / 3;         for (int i = n; i < piles.length; i += 2) {             sum += piles[i];         }         return sum;     } },0,,0,0,0
"class Solution {     public int findLatestStep(int[] arr, int m) {         int n = arr.length;         int[] lengths = new int[n+2]; // lengths[i] will store the length of the continuous segment of 1s that the ith bit belongs to         int[] count = new int[n+1]; // count[i] will store the number of segments of length i         int latest = -1; // will store the answer                  for(int i=0;i<n;i++){             int idx = arr[i];             int leftLength = lengths[idx-1];             int rightLength = lengths[idx+1];             int sum = leftLength + rightLength + 1;             lengths[idx-leftLength] = lengths[idx+rightLength] = sum;             count[leftLength]--; count[rightLength]--; count[sum]++;             if(count[m]>0) latest = i+1; // if the segment of length m exists, update the answer         }                  return latest;     } }",1,"1562-find-latest-group-of-size-m/Solution.java:13:64: Inner assignments should be avoided. [InnerAssignment]
1562-find-latest-group-of-size-m/Solution.java:13:64: Inner assignments should be avoided. [InnerAssignment]
",0,0,0
"class Solution {     public int getMaxLen(int[] nums) {         int negCount = 0;         int firstNeg = -1;         int zeroIndex = -1;         int maxLen = 0;         for(int i=0;i<nums.length;i++){             if(nums[i]==0){                 negCount = 0;                 firstNeg = -1;                 zeroIndex = i;             }             else{                 if(nums[i]<0){                     negCount++;                     if(firstNeg==-1){                         firstNeg = i;                     }                 }                                  if(negCount%2==0){                     maxLen = Math.max(maxLen,i-zeroIndex);                 }                 else{                     maxLen = Math.max(maxLen,i-firstNeg);                 }             }         }         return maxLen;     } }",1,"1567-maximum-length-of-subarray-with-positive-product/Solution.java:12:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1567-maximum-length-of-subarray-with-positive-product/Solution.java:23:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1567-maximum-length-of-subarray-with-positive-product/Solution.java:12:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1567-maximum-length-of-subarray-with-positive-product/Solution.java:23:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
"class Solution {     public int numWays(String s) {         int ones = 0;         int n = s.length();         int mod = 1000000007;         for (char c : s.toCharArray()) {             if (c == '1') {                 ones++;             }         }         if (ones % 3 != 0) {             return 0;         }         if (ones == 0) {             return (int) ((long) (n - 1) * (long) (n - 2) / 2 % mod);         }         int target = ones / 3;         int count = 0;         long left = 0, right = 0;         for (char c : s.toCharArray()) {             if (c == '1') {                 count++;             }             if (count == target) {                 left++;             } else if (count == target * 2) {                 right++;             }         }         return (int) (left * right % mod);     } }",1,"1573-number-of-ways-to-split-a-string/Solution.java:19:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1573-number-of-ways-to-split-a-string/Solution.java:19:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1573-number-of-ways-to-split-a-string/Solution.java:4:	PrematureDeclaration:	Declaration of 'n' can be moved closer to its usages
1573-number-of-ways-to-split-a-string/Solution.java:5:	PrematureDeclaration:	Declaration of 'mod' can be moved closer to its usages
1573-number-of-ways-to-split-a-string/Solution.java:15:	UnnecessaryCast:	Unnecessary cast (long)
1573-number-of-ways-to-split-a-string/Solution.java:15:	UnnecessaryCast:	Unnecessary cast (long)
",1,0,0
"class Solution {     public int findLengthOfShortestSubarray(int[] arr) {         int n = arr.length;         int left = 0, right = n - 1;                  // Check which prefix of `arr` is non-decreasing         while (left < n-1 && arr[left] <= arr[left+1]) {             left++;         }                  // If the entire array is non-decreasing         if (left == n-1) {             return 0;         }                  // Check which suffix of `arr` is non-decreasing         while (right >= 0 && arr[right] >= arr[right-1]) {             right--;         }                  // Minimum subarray to remove is either the prefix or suffix         int ans = Math.min(n - left - 1, right);                  // One pass to check all other subarrays to remove         int i = 0, j = right;         while (i <= left && j < n) {             if (arr[i] <= arr[j]) {                 ans = Math.min(ans, j - i - 1);                 i++;             } else {                 j++;             }         }                  return ans;     } }",1,"1574-shortest-subarray-to-be-removed-to-make-array-sorted/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1574-shortest-subarray-to-be-removed-to-make-array-sorted/Solution.java:25:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1574-shortest-subarray-to-be-removed-to-make-array-sorted/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1574-shortest-subarray-to-be-removed-to-make-array-sorted/Solution.java:25:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1574-shortest-subarray-to-be-removed-to-make-array-sorted/Solution.java:4:	PrematureDeclaration:	Declaration of 'right' can be moved closer to its usages
",1,0,0
"class Solution {     public int numTriplets(int[] nums1, int[] nums2) {         int result = 0;         result += countTriplets(nums1, nums2);         result += countTriplets(nums2, nums1);         return result;     }      private int countTriplets(int[] nums1, int[] nums2) {         int count = 0;         for (int i = 0; i < nums1.length; i++) {             long square = (long) nums1[i] * nums1[i];             for (int j = 0; j < nums2.length; j++) {                 for (int k = j + 1; k < nums2.length; k++) {                     if (square == (long) nums2[j] * nums2[k]) {                         count++;                     }                 }             }         }         return count;     } }",1,"1577-number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/Solution.java:11:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {          public int minCost(String colors, int[] neededTime) {         int n = colors.length();                  // Initialize variables         int[] dp = new int[n];         dp[0] = 0;                  for(int i=1;i<n;i++) {             // If adjacent colors are diff, we need not worry about cost             if(colors.charAt(i) != colors.charAt(i-1)) {                 dp[i] = dp[i-1];             }             else {                 // We calculate cost needed for current configuration and previously end at i-2                 dp[i] = dp[i-1] + neededTime[i-1];                                  // We should not change ith element as we want to count only minimum cost                 neededTime[i] = Math.max(neededTime[i], neededTime[i-1]);                                  // We traverse backward for newly created sequence to see if we can remove any elements                 for(int j = i-2; j >= 0; j--) {                     if(colors.charAt(i) != colors.charAt(j)) break;                     // Calculating cost of removing elements                     int removalCost = neededTime[i] + dp[j];                     if(removalCost < dp[i]) {                         dp[i] = removalCost;                         // We set j+1 element to ith element because we don't want any sequence of equal elements                         neededTime[j+1] = Math.max(neededTime[j+1], neededTime[i]);                     }                 }             }         }                  return dp[n-1];     } }",1,"1578-minimum-time-to-make-rope-colorful/Solution.java:14:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1578-minimum-time-to-make-rope-colorful/Solution.java:14:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1578-minimum-time-to-make-rope-colorful/Solution.java:12:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",0,0,0
"class Solution {     public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {         int[] pairIndex = new int[n];         for (int[] pair : pairs) {             pairIndex[pair[0]] = pair[1];             pairIndex[pair[1]] = pair[0];         }         int unhappyFriendsCount = 0;         for (int x = 0; x < n; x++) {             int y = pairIndex[x];             boolean unhappy = false;             for (int i = 0; i < preferences[x].length && !unhappy; i++) {                 int u = preferences[x][i];                 if (u == y) {                     break;                 }                 int v = pairIndex[u];                 for (int j = 0; j < preferences[u].length; j++) {                     if (preferences[u][j] == x) {                         unhappy = true;                         unhappyFriendsCount++;                         break;                     } else if (preferences[u][j] == v) {                         break;                     }                 }             }         }         return unhappyFriendsCount;     } }",0,,0,0,0
"import java.util.*;  class Solution {     public int minCostConnectPoints(int[][] points) {         int n = points.length;         int[] dist = new int[n];         boolean[] visited = new boolean[n];         Arrays.fill(dist, Integer.MAX_VALUE);         dist[0] = 0;         int cost = 0;         for(int count = 0; count < n; count++){             int u = minDistance(dist,visited);             visited[u] = true;             cost += dist[u];             for(int v = 0; v < n; v++){                 if(!visited[v] && manhattanDist(points[v],points[u]) < dist[v]){                     dist[v] = manhattanDist(points[v],points[u]);                 }             }         }         return cost;     }     private int minDistance(int[] dist, boolean[] visited){         int min = Integer.MAX_VALUE;         int minIndex = -1;         for(int i = 0; i < dist.length; i++){             if(!visited[i] && dist[i] < min){                 min = dist[i];                 minIndex = i;             }         }         return minIndex;     }     private int manhattanDist(int[] x, int[] y){         return Math.abs(x[0] - y[0]) + Math.abs(x[1] - y[1]);     } }",0,,0,0,0
"import java.util.*;  class Solution {     public int maxSumRangeQuery(int[] nums, int[][] requests) {         int n = nums.length;         int[] freq = new int[n];         for (int i = 0; i < requests.length; i++) {             freq[requests[i][0]]++;             if (requests[i][1] + 1 < n)                 freq[requests[i][1] + 1]--;         }         for (int i = 1; i < n; i++)             freq[i] += freq[i-1];         Arrays.sort(freq);         Arrays.sort(nums);          long res = 0;         long mod = (long)1e9 + 7;         for (int i = n - 1; i >= 0 && freq[i] > 0; i--) {             res = (res + (long)nums[i] * freq[i]) % mod;         }         return (int)res;     } }",1,"1589-maximum-sum-obtained-of-any-permutation/Solution.java:7:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int minSubarray(int[] nums, int p) {         int n = nums.length;         int remain = 0;         for (int i = 0; i < n; i++) {             remain = (remain + nums[i]) % p;         }         if (remain == 0) {             return 0;         }         int ans = n;         int last[] = new int[p];         Arrays.fill(last, -1);         last[0] = -1;         int sum = 0;         for (int i = 0; i < n; i++) {             sum = (sum + nums[i]) % p;             int need = (sum - remain + p) % p;             if (last[need] != -1) {                 ans = Math.min(ans, i - last[need]);             }             last[sum] = i;         }         return ans < n ? ans : -1;     } } ",1,"1590-make-sum-divisible-by-p/Solution.java:12:17: Array brackets at illegal position. [ArrayTypeStyle]
",0,0,0
"import java.util.HashSet; import java.util.Set;  class Solution {     public int maxUniqueSplit(String s) {         // create a set to store unique substrings         Set<String> uniqueSubstrings = new HashSet<>();         // call the recursive helper function to find all unique substrings         recursiveSplit(s, uniqueSubstrings, 0);         // return the size of the set containing unique substrings         return uniqueSubstrings.size();     }      private void recursiveSplit(String s, Set<String> uniqueSubstrings, int start) {         if (start == s.length()) {             return;         }         for (int i = start + 1; i <= s.length(); i++) {             String currentSubstring = s.substring(start, i);             if (!uniqueSubstrings.contains(currentSubstring)) {                 uniqueSubstrings.add(currentSubstring);                 recursiveSplit(s, uniqueSubstrings, i);                 // remove the current substring to try different combinations                 uniqueSubstrings.remove(currentSubstring);             }         }     } }",0,,0,0,0
"class Solution {     public int maxProductPath(int[][] grid) {         int mod = 1000000007;         int m = grid.length;         int n = grid[0].length;         long[][][] dp = new long[m][n][2];         dp[0][0][0] = grid[0][0];         dp[0][0][1] = grid[0][0];         for(int i=1;i<m;i++){             dp[i][0][0] = dp[i-1][0][0]*grid[i][0];             dp[i][0][1] = dp[i-1][0][1]*grid[i][0];         }         for(int i=1;i<n;i++){             dp[0][i][0] = dp[0][i-1][0]*grid[0][i];             dp[0][i][1] = dp[0][i-1][1]*grid[0][i];         }         for(int i=1;i<m;i++){             for(int j=1;j<n;j++){                 if(grid[i][j]>=0){                     dp[i][j][0] = Math.min(dp[i-1][j][0], dp[i][j-1][0])*grid[i][j];                     dp[i][j][1] = Math.max(dp[i-1][j][1], dp[i][j-1][1])*grid[i][j];                 }else{                     dp[i][j][0] = Math.max(dp[i-1][j][1], dp[i][j-1][1])*grid[i][j];                     dp[i][j][1] = Math.min(dp[i-1][j][0], dp[i][j-1][0])*grid[i][j];                 }             }         }         if(dp[m-1][n-1][1]<0) return -1;         else return (int)(dp[m-1][n-1][1]%mod);     } }",0,,0,0,0
"class Solution {     public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {         int waiting = 0; // number of customers waiting         int profit = 0; // current profit         int maxProfit = 0; // maximum profit         int maxRotation = -1; // optimal number of rotations to maximize profit                  for (int i = 0; i < customers.length || waiting > 0; i++) {             int boarded = Math.min(waiting, 4); // number of customers that board on current rotation             profit += boarded * boardingCost - runningCost; // update current profit             waiting -= boarded; // update number of waiting customers             if (i < customers.length) {                 waiting += customers[i]; // add new customers to waiting queue             }             if (profit > maxProfit) { // update maximum profit and optimal number of rotations                 maxProfit = profit;                 maxRotation = i + 1;             }         }                  return maxRotation;     } }",0,,0,0,0
"import java.util.*;  class ThroneInheritance {    Map<String, List<String>> family;   Set<String> dead;   String king;    public ThroneInheritance(String kingName) {     family = new HashMap<>();     dead = new HashSet<>();     king = kingName;     family.put(king, new ArrayList<>());   }    public void birth(String parentName, String childName) {     family.putIfAbsent(parentName, new ArrayList<>());     family.putIfAbsent(childName, new ArrayList<>());     family.get(parentName).add(childName);   }    public void death(String name) {     dead.add(name);   }    public List<String> getInheritanceOrder() {     List<String> order = new ArrayList<>();     dfs(order, king);     return order;   }    public void dfs(List<String> order, String name) {     if (!dead.contains(name)) {       order.add(name);     }     for (String child : family.get(name)) {       dfs(order, child);     }   } }  /**  * Your ThroneInheritance object will be instantiated and called as such:  * ThroneInheritance obj = new ThroneInheritance(kingName);  * obj.birth(parentName,childName);  * obj.death(name);  * List<String> param_3 = obj.getInheritanceOrder();  */",1,"1600-throne-inheritance/ThroneInheritance.java:5:29: Variable 'family' must be private and have accessor methods. [VisibilityModifier]
1600-throne-inheritance/ThroneInheritance.java:6:15: Variable 'dead' must be private and have accessor methods. [VisibilityModifier]
1600-throne-inheritance/ThroneInheritance.java:7:10: Variable 'king' must be private and have accessor methods. [VisibilityModifier]
1600-throne-inheritance/ThroneInheritance.java:9:3: Redundant 'public' modifier. [RedundantModifier]
1600-throne-inheritance/ThroneInheritance.java:5:29: Variable 'family' must be private and have accessor methods. [VisibilityModifier]
1600-throne-inheritance/ThroneInheritance.java:6:15: Variable 'dead' must be private and have accessor methods. [VisibilityModifier]
1600-throne-inheritance/ThroneInheritance.java:7:10: Variable 'king' must be private and have accessor methods. [VisibilityModifier]
1600-throne-inheritance/ThroneInheritance.java:9:3: Redundant 'public' modifier. [RedundantModifier]
",0,0,0
"class Solution {     public List<String> alertNames(String[] keyName, String[] keyTime) {         Map<String, List<Integer>> map = new HashMap<>();         // mapping each keyName with their keyTimes         for(int i=0; i<keyName.length; i++) {             String[] time = keyTime[i].split("":"");             int hours = Integer.parseInt(time[0]);             int mins = Integer.parseInt(time[1]);             int total = hours*60 + mins;             if(!map.containsKey(keyName[i])) {                 map.put(keyName[i], new ArrayList<Integer>());             }             map.get(keyName[i]).add(total);         }         List<String> res = new ArrayList<>();         // traversing each keyName and their keyTimes to check for any alert         for(String name : map.keySet()) {             List<Integer> times = map.get(name);             Collections.sort(times);             for(int i=2; i<times.size(); i++) {                 if(times.get(i) - times.get(i-2) <= 60) {                     res.add(name);                     break;                 }             }         }         Collections.sort(res);         return res;     } }",0,,0,0,0
"class Solution {     public int[][] restoreMatrix(int[] rowSum, int[] colSum) {         int m = rowSum.length;         int n = colSum.length;          int[][] matrix = new int[m][n];          for (int i = 0; i < m && rowSum[i] > 0; i++) {             for (int j = 0; j < n && colSum[j] > 0; j++) {                 int val = Math.min(rowSum[i], colSum[j]);                 matrix[i][j] = val;                 rowSum[i] -= val;                 colSum[j] -= val;             }         }          return matrix;     } } ",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public boolean isEvenOddTree(TreeNode root) {         if (root == null) {             return true;         }                  Queue<TreeNode> queue = new LinkedList<>();         queue.add(root);         int level = 0;                  while (!queue.isEmpty()) {             int size = queue.size();             int prevVal = (level % 2 == 0) ? Integer.MIN_VALUE : Integer.MAX_VALUE;                          for (int i = 0; i < size; i++) {                 TreeNode curr = queue.poll();                                  // Conditions for Even-Odd tree                 if (level % 2 == 0) {  // Even-level                     if (curr.val % 2 == 0 || curr.val <= prevVal) {                         return false;                     }                 } else {  // Odd-level                     if (curr.val % 2 != 0 || curr.val >= prevVal) {                         return false;                     }                 }                                  prevVal = curr.val;                                  if (curr.left != null) {                     queue.add(curr.left);                 }                                  if (curr.right != null) {                     queue.add(curr.right);                 }             }                          level++;         }                  return true;     } }",0,,0,0,0
"class Solution {     public int maximalNetworkRank(int n, int[][] roads) {         int[] count = new int[n];         boolean[][] connected = new boolean[n][n];         for (int[] road : roads) {             count[road[0]]++;             count[road[1]]++;             connected[road[0]][road[1]] = true;             connected[road[1]][road[0]] = true;         }         int maxRank = 0;         for (int i = 0; i < n; i++) {             for (int j = i + 1; j < n; j++) {                 int rank = count[i] + count[j];                 if (connected[i][j]) {                     rank--;                 }                 maxRank = Math.max(maxRank, rank);             }         }         return maxRank;     } }",0,,0,0,0
"class Solution {     public boolean checkPalindromeFormation(String a, String b) {         int n = a.length();         for (int i = 0, j = n - 1; i < j; i++, j--) {             if (a.charAt(i) != b.charAt(j)) {                 return isPalindrome(a, i, j) || isPalindrome(b, i, j);             }         }         return true;     }          private boolean isPalindrome(String s, int i, int j) {         while (i < j) {             if (s.charAt(i) != s.charAt(j)) {                 return false;             }             i++;             j--;         }         return true;     }  }",1,"1616-split-two-strings-to-make-palindrome/Solution.java:4:	ForLoopVariableCount:	Too many control variables in the for statement
1616-split-two-strings-to-make-palindrome/Solution.java:17:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'i'
1616-split-two-strings-to-make-palindrome/Solution.java:18:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'j'
",0,1,0
"class Solution {     public int findPeakElement(int[] nums) {         int left = 0, right = nums.length - 1;         while (left < right) {             int mid = left + (right - left) / 2;             if (nums[mid] < nums[mid + 1]) {                 left = mid + 1;             } else {                 right = mid;             }         }         return left;     } }  // Time Complexity: O(log n) // Space Complexity: O(1)",1,"162-find-peak-element/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
162-find-peak-element/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int[] bestCoordinate(int[][] towers, int radius) {         int maxNetworkQuality = 0;         int[] optimalCoordinate = new int[2];                  for(int x = 0; x <= 50; x++) {             for(int y = 0; y <= 50; y++) {                 int networkQuality = 0;                 for(int[] tower : towers) {                     double distance = Math.sqrt(Math.pow(x - tower[0], 2) + Math.pow(y - tower[1], 2));                     if(distance <= radius) {                         int signalQuality = (int) (tower[2] / (1 + distance));                         networkQuality += signalQuality;                     }                 }                 if(networkQuality > maxNetworkQuality) {                     maxNetworkQuality = networkQuality;                     optimalCoordinate[0] = x;                     optimalCoordinate[1] = y;                 }             }         }         return optimalCoordinate;     } }",0,,0,0,0
"class Solution {     public int numberOfSets(int n, int k) {         int MOD = 1000000007;         int[][] dp = new int[k+1][n+1];         for(int i=0; i<=k; i++) {             for(int j=0; j<=n; j++) {                 if(i==0 || j==0) {                     dp[i][j] = 0;                 } else {                     dp[i][j] = dp[i][j-1];                     if(i==1) {                         dp[i][j] += j;                     } else {                         dp[i][j] += dp[i-1][j-1];                     }                     dp[i][j] %= MOD;                 }             }         }         return dp[k][n];     } }",0,,0,0,0
"class Solution {     public String findLexSmallestString(String s, int a, int b) {         String result = s; // initialize the result with the original string         int n = s.length();         int[] arr = new int[n];         for (int i = 0; i < n; i++) {             arr[i] = s.charAt(i) - '0'; // convert string to integer array         }         Set<String> set = new HashSet<>(); // to keep track of visited strings                  // Apply DFS to explore all possible combinations         dfs(arr, a, b, set);                  // Find the lexicographically smallest string from the set         for (String str : set) {             if (str.compareTo(result) < 0) {                 result = str;             }         }         return result;     }          private void dfs(int[] arr, int a, int b, Set<String> set) {         String curr = arrayToString(arr); // current string         if (set.contains(curr)) {             return; // avoid infinite loop         }         set.add(curr);         int n = arr.length;         // Add a to all odd indices         int[] addOne = new int[n];         for (int i = 0; i < n; i++) {             addOne[i] = arr[i];             if (i % 2 == 1) {                 addOne[i] += a;                 addOne[i] %= 10; // handle the cycling back to 0 for digits greater than 9             }         }         dfs(addOne, a, b, set);         // Rotate to right by b positions         int[] rotate = new int[n];         for (int i = 0; i < n; i++) {             rotate[(i + b) % n] = arr[i];         }         dfs(rotate, a, b, set);     }          private String arrayToString(int[] arr) {         StringBuilder sb = new StringBuilder();         for (int num : arr) {             sb.append(num);         }         return sb.toString();     } }",1,"1625-lexicographically-smallest-string-after-applying-operations/Solution.java:32:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
",0,0,0
"class Solution {     public int bestTeamScore(int[] scores, int[] ages) {         int n = scores.length;         int[][] player = new int[n][2];         // Creating the 2d array with the score and respective age         for(int i=0;i<n;i++) {             player[i][0] = ages[i];             player[i][1] = scores[i];         }         // Sorting the 2d array in non-decreasing order of age         Arrays.sort(player, (a,b) -> a[0]-b[0]);         // Creating an integer array to store the max score achievable with the ith player         int[] dp = new int[n];         int max = 0;         // Filling the dp array with max score with the ith player         for(int i=0;i<n;i++) {             dp[i] = player[i][1];             for(int j=0;j<i;j++) {                 // Checking for conflicts and calculating the max score achievable with the ith player                 if(player[j][1]<=player[i][1]) dp[i] = Math.max(dp[i], dp[j]+player[i][1]);             }             // Updating the max score achievable             max = Math.max(max, dp[i]);         }         return max;     } }",0,,0,0,0
"class Solution {     public List<Boolean> checkArithmeticSubarrays(int[] nums, int[] l, int[] r) {         List<Boolean> answer = new ArrayList<>();         for(int i = 0;i<l.length;i++){             int Start = l[i];             int End = r[i];                          int[] sortedSubArr = subsetArr(nums,Start,End);             answer.add(isArithmetic(sortedSubArr));         }         return answer;     }          public boolean isArithmetic(int[] arr){         if(arr.length<2) return false;         Arrays.sort(arr);         int diff = arr[1]-arr[0];         for(int i=2;i<arr.length;i++){             if(diff != arr[i]-arr[i-1]){                 return false;             }         }         return true;     }          public int[] subsetArr(int[] arr,int start,int end){         int[] subArr = new int[end-start+1];         int count = 0;         for(int i=start;i<=end;i++){             subArr[count] = arr[i];             count++;         }         return subArr;     } }",0,,0,0,0
"class Solution {     public int minimumEffortPath(int[][] heights) {         int rows = heights.length;         int cols = heights[0].length;         int[][] direction = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};         boolean[][] visited = new boolean[rows][cols];         PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[2]));         pq.offer(new int[]{0, 0, 0});         while (!pq.isEmpty()) {             int[] curr = pq.poll();             int row = curr[0];             int col = curr[1];             int effort = curr[2];             if (visited[row][col]) {                 continue;             }             visited[row][col] = true;             if (row == rows - 1 && col == cols - 1) {                 return effort;             }             for (int[] dir : direction) {                 int newRow = row + dir[0];                 int newCol = col + dir[1];                 if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && !visited[newRow][newCol]) {                     int newEffort = Math.max(effort, Math.abs(heights[newRow][newCol] - heights[row][col]));                     pq.offer(new int[]{newRow, newCol, newEffort});                 }             }         }         return -1; // Dummy value, code should never reach this point     } }",0,,0,0,0
"class Solution {     public int maxWidthOfVerticalArea(int[][] points) {         int n = points.length;         int[] xCoordinates = new int[n];         for(int i = 0; i < n; i++) {             xCoordinates[i] = points[i][0];         }         Arrays.sort(xCoordinates);         int maxGap = 0;         for (int i = 1; i < n; i++) {             maxGap = Math.max(maxGap, xCoordinates[i] - xCoordinates[i-1]);         }         return maxGap;     } }",0,,0,0,0
"class Solution {     public int countSubstrings(String s, String t) {         int count = 0;         int m = s.length();         int n = t.length();                  for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 int diffCount = 0;                 for (int k = 0; i + k < m && j + k < n; k++) {                     if (s.charAt(i + k) != t.charAt(j + k)) {                         diffCount++;                     }                     if (diffCount > 1) {                         break;                     } else if (diffCount == 1) {                         count++;                     }                 }             }         }                  return count;     } }",0,,0,0,0
class Solution {     public int countVowelStrings(int n) {         int[][] dp = new int[n+1][6];                  for(int i=1; i<=n; i++){             for(int j=1; j<=5; j++){                 if(i == 1){                     dp[i][j] = 1;                 } else {                     dp[i][j] = dp[i][j-1] + dp[i-1][j];                 }             }         }                  return dp[n][5];     } }   /*  **Algorithm: Dynamic Programming **Time Complexity: O(n^2) **Space Complexity: O(n^2) */,0,,0,0,0
"class Solution {     public int furthestBuilding(int[] heights, int bricks, int ladders) {         PriorityQueue<Integer> ladderUsed = new PriorityQueue<>(); // To keep track of ladder used         for (int i=0; i<heights.length-1; i++) {             int difference = heights[i+1] - heights[i]; // Height to be climbed             if (difference < 0) {                 continue; // No bricks or ladder needed             }             if (difference <= bricks) {                 bricks -= difference; // Using bricks                 continue;             }             if (ladderUsed.size() <= ladders-1) { // Check if we have any ladders left to be used                 ladderUsed.add(difference); // Use ladder             } else if (!ladderUsed.isEmpty() && difference > ladderUsed.peek()) {                 int maxDifference = ladderUsed.poll();                 bricks += maxDifference; // Replace the ladder used with bricks                 bricks -= difference;                 ladderUsed.add(difference);             } else { // No ladders left and height to be climbed is greater than the bricks we have                 return i;             }         }         return heights.length-1; // We are able to reach the last building     } }",1,"1642-furthest-building-you-can-reach/Solution.java:10:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'bricks'
",0,1,0
"class Solution {     public int minDeletions(String s) {                  int[] freq = new int[26]; // hold frequency of all lowercase English letters         for(char ch : s.toCharArray()){             freq[ch - 'a']++; // increment frequency         }                  Set<Integer> set = new HashSet<>(); // to keep track of frequency already visited         int deletions = 0;         for(int i=0; i<26; i++){             while(freq[i] > 0 && !set.add(freq[i])){ // check if the current frequency is already visited or not                 freq[i]--; // if it is visited, decrement the frequency                 deletions++; // increment the deletion count             }         }         return deletions;     } }",0,,0,0,0
"class Solution {     public int maxProfit(int[] inventory, int orders) {         int mod = (int)1e9 + 7;         long ans = 0;         int n = inventory.length;         int l = 0, r = (int)1e9;         while (l <= r) {             int mid = (l + r) / 2;             long cnt = 0;             for (int x : inventory) {                 cnt += Math.max(x - mid, 0);             }             if (cnt <= orders) {                 r = mid - 1;             } else {                 l = mid + 1;             }         }         for (int x : inventory) {             if (x > l) {                 long cnt = x - l;                 ans += ((x + l + 1) * cnt / 2);                 orders -= cnt;             }         }         ans += (long)orders * l;         return (int)(ans % mod);     } }",1,"1648-sell-diminishing-valued-colored-balls/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1648-sell-diminishing-valued-colored-balls/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1648-sell-diminishing-valued-colored-balls/Solution.java:5:	UnusedLocalVariable:	Avoid unused local variables such as 'n'.
1648-sell-diminishing-valued-colored-balls/Solution.java:23:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'orders'
",1,1,0
"class Solution {     public int compareVersion(String version1, String version2) {         String[] v1 = version1.split(""\\.""); // splitting version1 into an array of revisions         String[] v2 = version2.split(""\\.""); // splitting version2 into an array of revisions         int i=0;         while(i<v1.length || i<v2.length){             int rev1 = 0, rev2=0;             if(i<v1.length) rev1 = Integer.parseInt(v1[i]);             if(i<v2.length) rev2 = Integer.parseInt(v2[i]);             if(rev1>rev2) return 1;             else if(rev2>rev1) return -1;             i++;         }         return 0;     } }",1,"165-compare-version-numbers/Solution.java:7:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
165-compare-version-numbers/Solution.java:7:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int minimumDeletions(String s) {         int count = 0;         int bCount = 0;         // count number of 'b' characters         for(char c : s.toCharArray()) {             if(c == 'b') {                 bCount++;             }         }         int aCount = s.length() - bCount;         int minDeletions = Math.min(aCount, bCount);         int bSeen = 0;         // count number of 'b' characters after 'a'         for(int i = 0; i < s.length(); i++) {             char c = s.charAt(i);             if(c == 'a') {                 // check if we have 'b' characters on the right side of 'a'                 if(bSeen < bCount && bCount - bSeen - 1 < aCount) {                     // we can delete this 'a' to make the string more balanced                     minDeletions = Math.min(minDeletions, i + bSeen - count);                 }                 aCount--;             } else {                 bSeen++;             }             count++;         }         return minDeletions;     } }",0,,0,0,0
"import java.util.*;  class Solution {     public int minimumJumps(int[] forbidden, int a, int b, int x) {         Set<String> visited = new HashSet<>(); // to keep track of visited positions         Set<Integer> forbiddenSet = new HashSet<>(); // to quickly check if a position is forbidden         for (int num : forbidden) {             forbiddenSet.add(num);         }         Queue<int[]> queue = new LinkedList<>(); // to implement BFS         queue.offer(new int[]{0, 0}); // starting from position 0, with 0 jumps         visited.add(""0,0"");         int maxPos = 2000 + b; // the bug may jump beyond its home         while (!queue.isEmpty()) {             int[] curr = queue.poll();             int pos = curr[0], jumps = curr[1];             if (pos == x) { // if the bug has reached home                 return jumps;             }             // generate next positions by jumping forward or backward             int nextForwardPos = pos + a, nextBackwardPos = pos - b;             if (nextForwardPos <= maxPos && !forbiddenSet.contains(nextForwardPos)) {                 String key = nextForwardPos + "","" + jumps + 1;                 if (!visited.contains(key)) {                     visited.add(key);                     queue.offer(new int[]{nextForwardPos, jumps + 1});                 }             }             if (nextBackwardPos > 0 && b < a && !forbiddenSet.contains(nextBackwardPos)) {                 String key = nextBackwardPos + "","" + (jumps + 1) + "",backward"";                 if (!visited.contains(key)) {                     visited.add(key);                     queue.offer(new int[]{nextBackwardPos, jumps + 1});                 }             }         }         return -1; // if the bug cannot reach its home     } }",1,"1654-minimum-jumps-to-reach-home/Solution.java:16:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1654-minimum-jumps-to-reach-home/Solution.java:21:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1654-minimum-jumps-to-reach-home/Solution.java:16:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1654-minimum-jumps-to-reach-home/Solution.java:21:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"import java.util.Arrays;  class Solution {     public boolean closeStrings(String word1, String word2) {         if (word1.length() != word2.length()) {             return false;         }         int[] freq1 = new int[26];         int[] freq2 = new int[26];         for (char c : word1.toCharArray()) {             freq1[c - 'a']++;         }         for (char c : word2.toCharArray()) {             freq2[c - 'a']++;         }         for (int i = 0; i < 26; i++) {             if (freq1[i] > 0 && freq2[i] == 0 || freq1[i] == 0 && freq2[i] > 0) {                 return false; // different set of characters             }         }         Arrays.sort(freq1);         Arrays.sort(freq2);         return Arrays.equals(freq1, freq2); // same frequencies for each character     } }",0,,0,0,0
"class Solution {     public int minOperations(int[] nums, int x) {                  // Initialize the initial sum of array         int sum = 0;               for(int i : nums) {             sum += i;         }                  // Target should be a valid value to calculate the number of operations         int target = sum - x;         if(target < 0) {             return -1;         }                  int start = 0, end = 0;         int maxFound = Integer.MIN_VALUE;         int currentSum = 0;         while(end < nums.length) {                          currentSum += nums[end];                          // Check if the current sum is greater than the target             if(currentSum > target) {                 currentSum -= nums[start];                 start++;             }                           // Check if the current sum is equal to the target             if(currentSum == target) {                 maxFound = Math.max(maxFound, end-start+1);             }                          // Move to the next element             end++;         }                  // Calculate the number of operations to perform         int operations = sum - maxFound;                  return operations == sum ? -1 : operations;     } }",1,"1658-minimum-operations-to-reduce-x-to-zero/Solution.java:16:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1658-minimum-operations-to-reduce-x-to-zero/Solution.java:16:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public String fractionToDecimal(int numerator, int denominator) {          // If numerator is 0, then return 0 in string format         if (numerator == 0)             return ""0"";                  // If denominator is 0, then throw an exception         if (denominator == 0)             throw new IllegalArgumentException(""Undefined fraction!"");          StringBuilder fraction = new StringBuilder();                  // If either numerator or denominator is negative (not both), then add ""-"" to the fraction         if ((numerator < 0) != (denominator < 0)) {             fraction.append(""-"");         }          // Convert numerator and denominator to long to handle integer overflow cases          long dividend = Math.abs(Long.valueOf(numerator));         long divisor = Math.abs(Long.valueOf(denominator));          fraction.append(dividend / divisor);                  long remainder = dividend % divisor;          // If remainder is 0, then return the fraction in string format         if (remainder == 0) {             return fraction.toString();         }                  fraction.append(""."");                  Map<Long, Integer> map = new HashMap<>();                  // Calculate the digits after decimal until remainder becomes 0 or a repeating pattern is found         while (remainder != 0) {             if (map.containsKey(remainder)) {                 fraction.insert(map.get(remainder), ""("");                 fraction.append("")"");                 break;             }                          map.put(remainder, fraction.length());                          remainder *= 10;                          fraction.append(remainder / divisor);                          remainder %= divisor;         }          return fraction.toString();     } }",1,"166-fraction-to-recurring-decimal/Solution.java:16:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
166-fraction-to-recurring-decimal/Solution.java:20:	UnnecessaryBoxing:	Unnecessary explicit conversion from int to long
166-fraction-to-recurring-decimal/Solution.java:21:	UnnecessaryBoxing:	Unnecessary explicit conversion from int to long
166-fraction-to-recurring-decimal/Solution.java:32:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
166-fraction-to-recurring-decimal/Solution.java:40:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
",0,0,0
"class Solution {     public String getSmallestString(int n, int k) {         char[] result = new char[n]; // initialize a character array of size n to store the result         for(int i=0; i<n; i++) {              int maxVal = 26*(n-i-1); // calculate the maximum value of remaining characters to be filled in the result             if(k-maxVal <= 1){ // if the remaining characters can be filled with 'a' only                 Arrays.fill(result, i, n, 'a');                 break;             }             else if(k-maxVal > 26){ // if the remaining characters can be filled with 'z' only                 result[i] = 'z';                 k -= 26;             }             else{ // fill the remaining characters with optimal values                 result[i] = (char)(k-maxVal+'a'-1);                 Arrays.fill(result, i+1, n, 'a');                 break;             }         }         return new String(result); // return the result as a string     } }",1,"1663-smallest-string-with-a-given-numeric-value/Solution.java:9:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1663-smallest-string-with-a-given-numeric-value/Solution.java:13:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1663-smallest-string-with-a-given-numeric-value/Solution.java:9:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1663-smallest-string-with-a-given-numeric-value/Solution.java:13:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1663-smallest-string-with-a-given-numeric-value/Solution.java:12:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'k'
1663-smallest-string-with-a-given-numeric-value/Solution.java:20:	StringInstantiation:	Avoid instantiating String objects; this is usually unnecessary.
",0,1,0
class Solution {     public int waysToMakeFair(int[] nums) {         int n=nums.length;         int[] prefixOdd=new int[n+1];         int[] prefixEven=new int[n+1];         for(int i=1;i<=n;i++){             prefixOdd[i]=prefixOdd[i-1] + (i%2==1 ? nums[i - 1] : 0);             prefixEven[i]=prefixEven[i-1] + (i%2==0 ? nums[i - 1] : 0);         }         int count=0;         for(int i=0;i<n;i++){             int oddSum=prefixOdd[i] + prefixEven[n] - prefixEven[i+1];             int evenSum=prefixEven[i] + prefixOdd[n] - prefixOdd[i+1];             if(oddSum == evenSum){                 count++;             }         }         return count;     } },0,,0,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {         ListNode cur = list1;         ListNode prev = null;         int index = 0;         // advance the cur ListNode to a         while (index < a) {             prev = cur;             cur = cur.next;             index++;         }         ListNode tail2 = list2;         // find the tail of list2         while (tail2.next != null) {             tail2 = tail2.next;         }         // reconnect the prev ListNode to the head of list2         prev.next = list2;         // advance cur ListNode to b+1 and disconnect the sublist in list1         while (index <= b) {             cur = cur.next;             index++;         }         tail2.next = cur;         return list1;     } }",0,,0,0,0
"class Solution {     public int[] twoSum(int[] numbers, int target) {         int left = 0;         int right = numbers.length - 1;         while (left < right) {             int sum = numbers[left] + numbers[right];             if (sum == target) {                 return new int[] {left + 1, right + 1}; // 1-indexed             } else if (sum < target) {                 left++;             } else {                 right--;             }         }         throw new IllegalArgumentException(""No solution found"");     } }",0,,0,0,0
"import java.util.LinkedList;  class FrontMiddleBackQueue {      private LinkedList<Integer> list;      public FrontMiddleBackQueue() {         list = new LinkedList<Integer>();     }          public void pushFront(int val) {         list.addFirst(val);     }          public void pushMiddle(int val) {         int n = list.size();         int middle = n / 2;         list.add(middle, val);     }          public void pushBack(int val) {         list.addLast(val);     }          public int popFront() {         if (list.isEmpty()) {             return -1;         }         return list.removeFirst();     }          public int popMiddle() {         if (list.isEmpty()) {             return -1;         }         int n = list.size();         int middle = (n - 1) / 2;         return list.remove(middle);     }          public int popBack() {         if (list.isEmpty()) {             return -1;         }         return list.removeLast();     } }  /**  * Your FrontMiddleBackQueue object will be instantiated and called as such:  * FrontMiddleBackQueue obj = new FrontMiddleBackQueue();  * obj.pushFront(val);  * obj.pushMiddle(val);  * obj.pushBack(val);  * int param_4 = obj.popFront();  * int param_5 = obj.popMiddle();  * int param_6 = obj.popBack();  */",1,"1670-design-front-middle-back-queue/FrontMiddleBackQueue.java:7:5: Redundant 'public' modifier. [RedundantModifier]
1670-design-front-middle-back-queue/FrontMiddleBackQueue.java:7:5: Redundant 'public' modifier. [RedundantModifier]
1670-design-front-middle-back-queue/FrontMiddleBackQueue.java:5:	LooseCoupling:	Avoid using implementation types like 'LinkedList'; use the interface instead
1670-design-front-middle-back-queue/FrontMiddleBackQueue.java:8:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new LinkedList<>()`
",0,0,0
"class Solution {     public int[] mostCompetitive(int[] nums, int k) {                  int[] stack = new int[k];         int top = -1;                  for(int i = 0; i < nums.length; i++) {             while(top >= 0 && stack[top] > nums[i] && top + nums.length - i >= k) {                 top--;             }             if(top < k - 1) {                 stack[++top] = nums[i];             }         }                  return stack;     } }",0,,0,0,0
"class Solution {     public int minMoves(int[] nums, int limit) {         int[] delta = new int[2 * limit + 2];                  int n = nums.length;         for (int i = 0; i < n / 2; i++) {             int a = nums[i];             int b = nums[n - 1 - i];             int min = Math.min(a, b);             int max = Math.max(a, b);                          delta[2] += 2;                          // changing both a and b to 2             delta[min + 1] -= 1;             delta[min + max] -= 1;             delta[min + max + 1] += 1;             delta[max + limit + 1] += 1;            // changing both a and b to limit         }                  int moves = n / 2;         int sum = 0;         for (int i = 2; i <= 2 * limit; i++) {             sum += delta[i];             moves = Math.min(moves, sum);         }                  return moves;     } }",0,,0,0,0
"class Solution {     public int maxOperations(int[] nums, int k) {         HashMap<Integer, Integer> frequency = new HashMap<Integer, Integer>();         int count = 0;         for(int i=0; i<nums.length; i++){             int diff = k - nums[i];             if(frequency.containsKey(diff) && frequency.get(diff) > 0){                 count++;                 frequency.put(diff, frequency.get(diff)-1);             }             else{                 frequency.put(nums[i], frequency.getOrDefault(nums[i], 0)+1);             }         }         return count;     } }",1,"1679-max-number-of-k-sum-pairs/Solution.java:10:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1679-max-number-of-k-sum-pairs/Solution.java:10:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1679-max-number-of-k-sum-pairs/Solution.java:5:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
class Solution {     public int concatenatedBinary(int n) {         StringBuilder sb = new StringBuilder();         for(int i = 1; i <= n; i++) {             sb.append(Integer.toBinaryString(i));         }         String binaryString = sb.toString();         int decimalValue = 0;         int mod = 1000000007;         for(int i = 0; i < binaryString.length(); i++) {             decimalValue = ((decimalValue * 2) % mod + (binaryString.charAt(i) - '0')) % mod;         }         return decimalValue;     } },1,"1680-concatenation-of-consecutive-binary-numbers/Solution.java:11:	UselessParentheses:	Useless parentheses.
1680-concatenation-of-consecutive-binary-numbers/Solution.java:11:	UselessParentheses:	Useless parentheses.
",0,0,0
class Solution {     public int[] getSumAbsoluteDifferences(int[] nums) {         int n = nums.length;         int[] result = new int[n];                  // Initialize leftSum to 0         int leftSum = 0;         for (int i = 0; i < n; i++) {             // Calculate rightSum             int rightSum = 0;             for (int j = i+1; j < n; j++) {                 rightSum += nums[j] - nums[i];             }                          // Calculate leftSum             result[i] = rightSum - (n-i-1) * (nums[i] - nums[i-1]) + i * (nums[i] - nums[i-1]) - leftSum;             leftSum += nums[i] - nums[i-1];         }         return result;     } },0,,0,0,0
"class Solution {     public int stoneGameVI(int[] aliceValues, int[] bobValues) {         // sort the stones in decreasing order of the sum of their values for Alice and Bob         int[][] stones = new int[aliceValues.length][2];         for (int i = 0; i < aliceValues.length; i++) {             stones[i][0] = aliceValues[i];             stones[i][1] = bobValues[i];         }         Arrays.sort(stones, (a, b) -> (b[0] + b[1]) - (a[0] + a[1]));                  int alicePoints = 0;         int bobPoints = 0;         for (int i = 0; i < stones.length; i++) {             if (i % 2 == 0) { // Alice's turn                 alicePoints += stones[i][0];             } else { // Bob's turn                 bobPoints += stones[i][1];             }         }                  if (alicePoints > bobPoints) {             return 1;         } else if (bobPoints > alicePoints) {             return -1;         } else {             return 0;         }     } }",1,"1686-stone-game-vi/Solution.java:9:	UselessParentheses:	Useless parentheses.
",0,0,0
"class Solution {     public int minPartitions(String n) {         int maxDigit = 0;         for (int i = 0; i < n.length(); i++) {             int digit = n.charAt(i) - '0';             maxDigit = Math.max(maxDigit, digit);             if (maxDigit == 9) {                 return maxDigit;             }         }         return maxDigit;     } }",0,,0,0,0
"class Solution {     public int stoneGameVII(int[] stones) {         int n = stones.length;         int[] prefixSum = new int[n+1];          for(int i=1; i<=n; i++) {             prefixSum[i] = prefixSum[i-1] + stones[i-1];         }          int[][] dp = new int[n][n];          for(int len=2; len<=n; len++) {             for(int left=0; left<=n-len; left++) {                 int right = left+len-1;                  int scoreRemoveLeft = prefixSum[right+1] - prefixSum[left+1] + dp[left+1][right];                 int scoreRemoveRight = prefixSum[right] - prefixSum[left] + dp[left][right-1];                  dp[left][right] = Math.max(scoreRemoveLeft, scoreRemoveRight);             }         }          return dp[0][n-1];     } }",0,,0,0,0
"class Solution {     public int maximumUniqueSubarray(int[] nums) {         int n = nums.length;         int[] freq = new int[10005]; // to store frequency of elements in subarray         int l = 0, r = 0, sum = 0, ans = 0;         while(r < n) {             freq[nums[r]]++; // increase the frequency of current element             sum += nums[r]; // add current element to subarray             while(freq[nums[r]] > 1) { // if current element is not unique                 freq[nums[l]]--; // decrease the frequency of leftmost element in subarray                 sum -= nums[l]; // remove leftmost element from subarray                 l++; // move left pointer to the right             }             ans = Math.max(ans, sum); // update maximum score             r++; // move right pointer to the right         }         return ans;     } }    /*     Time Complexity: O(n)    Space Complexity: O(1) (constant space as frequency array size is fixed) */",1,"1695-maximum-erasure-value/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1695-maximum-erasure-value/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int maxResult(int[] nums, int k) {         int n = nums.length;         int[] dp = new int[n];         dp[0] = nums[0];         Deque<Integer> deque = new LinkedList<>();         deque.offerLast(0);         for (int i = 1; i < n; i++) {             while (deque.peekFirst() < i - k) {                 deque.pollFirst();             }             dp[i] = dp[deque.peekFirst()] + nums[i];             while (!deque.isEmpty() && dp[i] >= dp[deque.peekLast()]) {                 deque.pollLast();             }             deque.offerLast(i);         }         return dp[n - 1];     } }",0,,0,0,0
"class Solution {     public double averageWaitingTime(int[][] customers) {         double ans = 0;         double finishTime = 0; //Chef's finish time after previous order.         for (int i = 0; i < customers.length; i++) {             int arrival = customers[i][0];             int time = customers[i][1];             if (arrival >= finishTime) {                 // If Chef is idle, customer doesn't have to wait, finish time is arrival + time.                 ans += time;                 finishTime = arrival + time;             } else {                 // Else, calculate customer's waiting time as the time Chef finishes service minus arrival time.                 ans += finishTime - arrival + time;                 finishTime += time;             }         }         return ans / customers.length; // Return average waiting time.     } }",1,"1701-average-waiting-time/Solution.java:5:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public String maximumBinaryString(String binary) {         int n = binary.length();         StringBuilder result = new StringBuilder(n);          int zeros = 0, ones = 0, firstZero = -1;          // count the number of zeros and ones, and find the leftmost zero         for (int i = 0; i < n; i++) {             if (binary.charAt(i) == '0') {                 zeros++;                 if (firstZero == -1) {                     firstZero = i;                 }             } else {                 ones++;             }         }          // if there is no zero, we can't do any operation         if (firstZero == -1) {             return binary;         }          // append ones to the result         for (int i = 0; i < n - ones; i++) {             result.append('1');         }          // append zeros before the leftmost zero         for (int i = 0; i < firstZero + ones - zeros - 1; i++) {             result.append('0');         }          // append the remaining zeros after the leftmost zero         for (int i = 0; i < zeros; i++) {             result.append('1');         }          return result.toString();     } }",1,"1702-maximum-binary-string-after-change/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1702-maximum-binary-string-after-change/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int eatenApples(int[] apples, int[] days) {         int n = apples.length;          // Initialization: Priority queue to store apples with earliest expiration date first         PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));          int eaten = 0;         int day = 0;          while (!pq.isEmpty() || day < n) {             // Add new apples to the tree             if (day < n && apples[day] > 0) {                 pq.offer(new int[]{day + days[day], apples[day]});             }              // Remove rotten apples             while (!pq.isEmpty() && pq.peek()[0] <= day) {                 pq.poll();             }              // Eat one apple per day             if (!pq.isEmpty()) {                 int[] apple = pq.poll();                 apple[1]--;                 eaten++;                 if (apple[1] > 0) {                     pq.offer(apple);                 }             }              day++;         }          return eaten;     } }",0,,0,0,0
"class Solution {     public int[] findBall(int[][] grid) {         int m = grid.length;         int n = grid[0].length;         int[] answer = new int[n];         Arrays.fill(answer, -1);                  // Iterate over each ball in top row         for (int i = 0; i < n; i++) {             int row = 0;             int col = i;             boolean stuck = false;                          // Move the ball down until it falls out or get stuck             while (row < m) {                 if (grid[row][col] == 1) {                     if (col == n - 1 || grid[row][col + 1] == -1) {                         stuck = true;                         break;                     }                     col++;                 } else {                     if (col == 0 || grid[row][col - 1] == 1) {                         stuck = true;                         break;                     }                     col--;                 }                 row++;             }             if (!stuck) {                 answer[i] = col;             }         }         return answer;     } }",0,,0,0,0
"class Solution {     public int countPairs(int[] deliciousness) {         Map<Integer, Integer> map = new HashMap<>();         int mod = 1000000007;         int count = 0;                  for (int i = 0; i < deliciousness.length; i++) {             for (int j = 0; j < 22; j++) {                 int target = (1 << j) - deliciousness[i];                 if (map.containsKey(target)) {                     count = (count + map.get(target)) % mod;                 }             }                          map.put(deliciousness[i], map.getOrDefault(deliciousness[i], 0) + 1);         }                  return count;     } } ",1,"1711-count-good-meals/Solution.java:7:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public static int waysToSplit(int[] nums) {         int n = nums.length;         long[] prefixSum = new long[n];         prefixSum[0] = nums[0];         for(int i = 1; i < n; i++) prefixSum[i] = prefixSum[i - 1] + nums[i]; // Calculate Prefix Sum         long ans = 0;         long mod = (long) 1e9 + 7;         for(int i = 0; i < n - 2; i++){             int left = i + 1, right = n - 2;             while(left <= right){                 int mid = left + (right - left) / 2;                 long sum1 = prefixSum[mid] - prefixSum[i];                 long sum2 = prefixSum[n - 1] - prefixSum[mid];                 if(sum1 <= sum2){                     ans = (ans + (mid - i)) % mod;                     left = mid + 1;                 }                 else right = mid - 1;             }         }         return (int)ans;     } }",1,"1712-ways-to-split-array-into-three-subarrays/Solution.java:1:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
1712-ways-to-split-array-into-three-subarrays/Solution.java:10:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1712-ways-to-split-array-into-three-subarrays/Solution.java:18:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1712-ways-to-split-array-into-three-subarrays/Solution.java:1:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
1712-ways-to-split-array-into-three-subarrays/Solution.java:10:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1712-ways-to-split-array-into-three-subarrays/Solution.java:18:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1712-ways-to-split-array-into-three-subarrays/Solution.java:1:	UseUtilityClass:	This utility class has a non-private constructor
1712-ways-to-split-array-into-three-subarrays/Solution.java:16:	UselessParentheses:	Useless parentheses.
",1,0,0
"class Solution {     public int maximumGain(String s, int x, int y) {         int score = 0;                  // For each type of operation, remove the corresponding substring and add the points         score += processString(s, ""ab"", x);         score += processString(s, ""ba"", y);                  return score;     }          private int processString(String s, String substring, int score) {         int count = 0;         int index = s.indexOf(substring);                  // Remove all instances of the substring and count how many were removed         while (index != -1) {             count++;             s = s.substring(0, index) + s.substring(index + 2);             index = s.indexOf(substring);         }                  // Add the total points from removing the substring         return count * score;     } }",1,"1717-maximum-score-from-removing-substrings/Solution.java:19:	AvoidReassigningParameters:	Avoid reassigning parameters such as 's'
",0,1,0
"class Solution {     public int[] constructDistancedSequence(int n) {         int[] ans = new int[2 * n - 1];         boolean[] used = new boolean[n + 1]; // to check already placed numbers         dfs(ans, used, 0); // start the search         return ans;     }      private boolean dfs(int[] ans, boolean[] used, int index) {         if (index == ans.length) { // filled all cells in the ans array             return true;         }         if (ans[index] != 0) { // cell already filled             return dfs(ans, used, index + 1);         }         for (int i = used.length - 1; i >= 1; i--) { // fill from largest possible number             if (!used[i] && isValid(i, index, ans)) {                 ans[index] = i;                 used[i] = true;                 if (i == 1 || dfs(ans, used, index + i)) { // search for next cell, forward index by i if i != 1                     return true;                 }                 ans[index] = 0;                 used[i] = false;             }         }         return false;     }      private boolean isValid(int num, int index, int[] ans) {         if (num == 1) {             return true;         }         if (index + num >= ans.length || ans[index + num] != 0) { // boundary conditions             return false;         }         ans[index] = ans[index + num] = num;         for (int i = 1; i < num; i++) { // check other available slots             if (index + i >= ans.length || ans[index + i] != 0) {                 ans[index] = ans[index + num] = 0; // backtrack                 return false;             }             ans[index + i] = ans[index + num - i] = num;         }         return true;     } }",1,"1718-construct-the-lexicographically-largest-valid-sequence/Solution.java:37:39: Inner assignments should be avoided. [InnerAssignment]
1718-construct-the-lexicographically-largest-valid-sequence/Solution.java:40:47: Inner assignments should be avoided. [InnerAssignment]
1718-construct-the-lexicographically-largest-valid-sequence/Solution.java:43:51: Inner assignments should be avoided. [InnerAssignment]
1718-construct-the-lexicographically-largest-valid-sequence/Solution.java:37:39: Inner assignments should be avoided. [InnerAssignment]
1718-construct-the-lexicographically-largest-valid-sequence/Solution.java:40:47: Inner assignments should be avoided. [InnerAssignment]
1718-construct-the-lexicographically-largest-valid-sequence/Solution.java:43:51: Inner assignments should be avoided. [InnerAssignment]
",0,0,0
class Solution {     public int trailingZeroes(int n) {         int count = 0;         while (n > 0) {             count += n / 5;             n /= 5;         }         return count;     } },1,"172-factorial-trailing-zeroes/Solution.java:6:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
",0,1,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public ListNode swapNodes(ListNode head, int k) {         ListNode slow = head;         ListNode fast = head;         ListNode kth = null;         while (fast != null) {             if (k > 1) {                 k--;             } else {                 kth = slow;                 slow = slow.next;             }             fast = fast.next;         }         int temp = kth.val;         kth.val = slow.val;         slow.val = temp;         return head;     } }",1,"1721-swapping-nodes-in-a-linked-list/ListNode.java:18:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'k'
",0,1,0
"class Solution {     public int minimumHammingDistance(int[] source, int[] target, int[][] allowedSwaps) {         int n = source.length;         int[] parent = new int[n];         for(int i=0; i<n; i++)             parent[i] = i;         // union find operation to form connected components         for(int[] swap:allowedSwaps){             int parent1 = find(swap[0], parent);             int parent2 = find(swap[1], parent);             if(parent1!=parent2)                 parent[parent1]=parent2;         }         // form groups with common parent for the elements of source and target         Map<Integer, Map<Integer,Integer>> map=new HashMap<>();         for(int i=0; i<n; i++) {             int parent_i=find(i, parent);             if(!map.containsKey(parent_i))                 map.put(parent_i, new HashMap<Integer,Integer>());             map.get(parent_i).put(source[i], map.get(parent_i).getOrDefault(source[i], 0) + 1);         }          // find the Hamming distance for each common parent of source and target arrays         // and calculate the sum of their Hamming distances as the result         int res=0;         for(int i=0; i<n; i++){             int parent_i=find(i, parent);             Map<Integer, Integer> temp=map.get(parent_i);             if(temp.get(target[i])==null||temp.get(target[i])==0)                 res++;             else                 temp.put(target[i], temp.get(target[i])-1);         }         return res;     }      //find operation using path compression     public int find(int x, int[] parent){         if(parent[x]!=x){             parent[x] = find(parent[x], parent);         }         return parent[x];     } }",0,,0,0,0
"class Solution {     public int tupleSameProduct(int[] nums) {         int n = nums.length;         Map<Integer, Integer> map = new HashMap<>();  // Map to store product and its frequency                  int count = 0;                  for (int i = 0; i < n; i++) {             for (int j = i + 1; j < n; j++) {                 int prod = nums[i] * nums[j];                                  // To count tuples in constant time                 count += 8 * map.getOrDefault(prod, 0);                                  map.put(prod, map.getOrDefault(prod, 0) + 1);             }         }                  return count;  // Return the final count of tuples     } }",0,,0,0,0
class Solution {     public int largestSubmatrix(int[][] matrix) {         int rows = matrix.length;         int cols = matrix[0].length;         int result = 0;         int[] heights = new int[cols];          for (int i = 0; i < rows; i++) {             for (int j = 0; j < cols; j++) {                 // Calculate the height of the current column.                 if (matrix[i][j] == 1) {                     heights[j]++;                 } else {                     heights[j] = 0;                 }             }              // Sort the heights array to find the maximum possible area.             int[] sortedHeights = heights.clone();             Arrays.sort(sortedHeights);             for (int j = 0; j < cols; j++) {                 int area = sortedHeights[j] * (cols - j);                 if (area > result) {                     result = area;                 }             }         }          return result;     } },0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class BSTIterator {     private TreeNode current;     private Stack<TreeNode> stack;      public BSTIterator(TreeNode root) {         current = root;         stack = new Stack<TreeNode>();     }      public int next() {         while (current != null) {             stack.push(current);             current = current.left;         }         current = stack.pop();         int val = current.val;         current = current.right;         return val;     }      public boolean hasNext() {         return current != null || !stack.isEmpty();     } }",1,"173-binary-search-tree-iterator/TreeNode.java:20:5: Redundant 'public' modifier. [RedundantModifier]
173-binary-search-tree-iterator/TreeNode.java:20:5: Redundant 'public' modifier. [RedundantModifier]
",0,0,0
"import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set;  class Solution {     public int minimumTeachings(int n, int[][] languages, int[][] friendships) {         int m = languages.length;                  // Get the list of friends who don't share any language         List<Set<Integer>> nonSharingFriends = new ArrayList<>();         for (int i = 0; i < m; i++) {             nonSharingFriends.add(new HashSet<>());         }         for (int[] friendship : friendships) {             int u = friendship[0] - 1;             int v = friendship[1] - 1;             boolean haveCommonLanguage = false;             for (int lang : languages[u]) {                 if (arrayContains(languages[v], lang)) {                     haveCommonLanguage = true;                     break;                 }             }             if (!haveCommonLanguage) {                 nonSharingFriends.get(u).add(v);                 nonSharingFriends.get(v).add(u);             }         }                  // Find the language with the minimum number of speakers         int minNumSpeakers = Integer.MAX_VALUE;         int minLang = 0;         for (int lang = 1; lang <= n; lang++) {             int numSpeakers = 0;             for (int i = 0; i < m; i++) {                 if (arrayContains(languages[i], lang)) {                     numSpeakers++;                 }             }             if (numSpeakers < minNumSpeakers) {                 minNumSpeakers = numSpeakers;                 minLang = lang;             }         }                  // Teach the language with the minimum number of speakers         Set<Integer> usersToTeach = new HashSet<>();         for (int i = 0; i < m; i++) {             if (!arrayContains(languages[i], minLang)) {                 for (int friend : nonSharingFriends.get(i)) {                     if (!arrayContains(languages[friend], minLang)) {                         usersToTeach.add(i);                         break;                     }                 }             }         }                  return usersToTeach.size();     }          private boolean arrayContains(int[] array, int value) {         for (int elem : array) {             if (elem == value) {                 return true;             }         }         return false;     } }",1,"1733-minimum-number-of-people-to-teach/Solution.java:7:	NPathComplexity:	The method 'minimumTeachings(int, int[][], int[][])' has an NPath complexity of 490, current threshold is 200
",0,0,0
class Solution {     public int[] decode(int[] encoded) {         int n = encoded.length + 1; // length of original perm array         int[] perm = new int[n];                  // Calculate XOR of all elements from 1 to n         int XOR = 0;         for (int i = 1; i <= n; i++) {             XOR ^= i;         }                  // Calculate XOR of all elements in encoded array         int XOR_ex = 0;         for (int i = 1; i < n - 1; i += 2) {             XOR_ex ^= encoded[i];         }                  // Calculate first element of perm array         perm[0] = XOR ^ XOR_ex;                  // Calculate rest of the elemets of perm array using encoded array         for (int i = 1; i < n; i++) {             perm[i] = encoded[i - 1] ^ perm[i - 1];         }                  return perm;     } },0,,0,0,0
"class Solution {     public int minCharacters(String a, String b) {                  // create a frequency array for characters in strings a and b         int[] freqA = new int[26];         int[] freqB = new int[26];                  for (char c : a.toCharArray()) {             freqA[c - 'a']++;         }                  for (char c : b.toCharArray()) {             freqB[c - 'a']++;         }                  int ans = Integer.MAX_VALUE;                  // condition 1: every letter in a is strictly less than every letter in b         for (int i = 0; i < 25; i++) {             int operations = 0;             for (int j = i + 1; j < 26; j++) {                 operations += freqA[j];                 operations += freqB[i];             }             ans = Math.min(ans, operations);         }                  // condition 2: every letter in b is strictly less than every letter in a         for (int i = 0; i < 25; i++) {             int operations = 0;             for (int j = i + 1; j < 26; j++) {                 operations += freqA[i];                 operations += freqB[j];             }             ans = Math.min(ans, operations);         }                  // condition 3: both a and b consist of only one distinct letter         int sameChar = 0;         for (int i = 0; i < 26; i++) {             sameChar += freqA[i];             sameChar += freqB[i];         }         ans = Math.min(ans, a.length() + b.length() - sameChar);                  return ans;     } }",0,,0,0,0
"import java.util.PriorityQueue;  class Solution {     public int kthLargestValue(int[][] matrix, int k) {         int m = matrix.length;         int n = matrix[0].length;         int[][] dp = new int[m][n];         PriorityQueue<Integer> heap = new PriorityQueue<>((a, b) -> b - a);         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 int val = matrix[i][j];                 if (i == 0 && j == 0) {                     dp[i][j] = val;                 } else if (i == 0) {                     dp[i][j] = dp[i][j-1] ^ val;                 } else if (j == 0) {                     dp[i][j] = dp[i-1][j] ^ val;                 } else {                     dp[i][j] = dp[i-1][j-1] ^ dp[i-1][j] ^ dp[i][j-1] ^ val;                 }                 heap.offer(dp[i][j]);             }         }         int ans = 0;         for (int i = 0; i < k; i++) {             ans = heap.poll();         }         return ans;     } }",1,"1738-find-kth-largest-xor-coordinate-value/Solution.java:8:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
",0,0,0
"class Solution {     public int[] restoreArray(int[][] adjacentPairs) {         Map<Integer, List<Integer>> map = new HashMap<>();         // build map         for (int[] pair : adjacentPairs) {             int u = pair[0], v = pair[1];             if (!map.containsKey(u)) map.put(u, new ArrayList<>());             if (!map.containsKey(v)) map.put(v, new ArrayList<>());             map.get(u).add(v);             map.get(v).add(u);         }         int n = adjacentPairs.length + 1;         int[] ans = new int[n];         // find the start         for (int key : map.keySet()) {             if (map.get(key).size() == 1) {                 ans[0] = key;                 break;             }         }         // fill the array         ans[1] = map.get(ans[0]).get(0);         for (int i = 2; i < n; i++) {             List<Integer> list = map.get(ans[i - 1]);             ans[i] = ans[i - 2] == list.get(0) ? list.get(1) : list.get(0);         }         return ans;     } }",1,"1743-restore-the-array-from-adjacent-pairs/Solution.java:6:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1743-restore-the-array-from-adjacent-pairs/Solution.java:6:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public boolean[] canEat(int[] candiesCount, int[][] queries) {         int n = candiesCount.length, m = queries.length;         long[] pre = new long[n];         pre[0] = candiesCount[0];         for (int i = 1;i < n;i ++) pre[i] += pre[i - 1] + candiesCount[i];         boolean[] ans = new boolean[m];         for (int i = 0;i < m;i ++) {             int type = queries[i][0], day = queries[i][1], cap = queries[i][2];             if (day >= pre[type] || day < (type == 0 ? 0 : pre[type - 1] / (type + 1))) continue;             long min = (long) (day - (type == 0 ? 0 : pre[type - 1] / (type + 1))) * 1;             long max = (long) cap * (day + 1 - (type == 0 ? 0 : pre[type - 1] / (type + 1)));             ans[i] = pre[type] > min && pre[type] <= max;         }         return ans;     } }",1,"1744-can-you-eat-your-favorite-candy-on-your-favorite-day/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1744-can-you-eat-your-favorite-candy-on-your-favorite-day/Solution.java:9:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1744-can-you-eat-your-favorite-candy-on-your-favorite-day/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1744-can-you-eat-your-favorite-candy-on-your-favorite-day/Solution.java:9:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1744-can-you-eat-your-favorite-candy-on-your-favorite-day/Solution.java:2:	LinguisticNaming:	Linguistics Antipattern - The method 'canEat' indicates linguistically it returns a boolean, but it returns 'boolean[]'
1744-can-you-eat-your-favorite-candy-on-your-favorite-day/Solution.java:11:	UnnecessaryCast:	Unnecessary cast (long)
1744-can-you-eat-your-favorite-candy-on-your-favorite-day/Solution.java:12:	UnnecessaryCast:	Unnecessary cast (long)
",1,0,0
"class Solution {     public int maxAbsoluteSum(int[] nums) {         int maxSum = 0, minSum = 0, currMax = 0, currMin = 0;         for (int num : nums) {             currMax += num;             currMin += num;             maxSum = Math.max(maxSum, currMax);             minSum = Math.min(minSum, currMin);             if (currMax < 0) {                 currMax = 0;             }             if (currMin > 0) {                 currMin = 0;             }         }         return Math.max(maxSum, -1 * minSum);     } }",1,"1749-maximum-absolute-sum-of-any-subarray/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1749-maximum-absolute-sum-of-any-subarray/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
class Solution {     public int minimumLength(String s) {         int left = 0;         int right = s.length() - 1;                  while (left < right) {             char charLeft = s.charAt(left);             char charRight = s.charAt(right);                          if (charLeft != charRight) {                 break;             }                          while (left < right && s.charAt(left) == charLeft) {                 left++;             }                          while (right > left && s.charAt(right) == charRight) {                 right--;             }         }                  return right - left + 1;     } },0,,0,0,0
"class Solution {     public int maximumScore(int a, int b, int c) {         int[] arr = {a, b, c};         Arrays.sort(arr);         int score = 0;         while (arr[1] > 0) {             arr[2]--;             arr[1]--;             score++;             Arrays.sort(arr);         }         return score;     } }",0,,0,0,0
"class Solution {     public String largestMerge(String word1, String word2) {         StringBuilder merge = new StringBuilder();         while (!word1.isEmpty() || !word2.isEmpty()) {             if (word1.compareTo(word2) > 0) {                 merge.append(word1.charAt(0));                 word1 = word1.substring(1);             } else {                 merge.append(word2.charAt(0));                 word2 = word2.substring(1);             }         }         return merge.toString();     } }",1,"1754-largest-merge-of-two-strings/Solution.java:7:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'word1'
1754-largest-merge-of-two-strings/Solution.java:10:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'word2'
",0,1,0
"class Solution {     public String largestMerge(String word1, String word2) {         StringBuilder merge = new StringBuilder();         while (!word1.isEmpty() || !word2.isEmpty()) {             if (word1.compareTo(word2) > 0) {                 merge.append(word1.charAt(0));                 word1 = word1.substring(1);             } else {                 merge.append(word2.charAt(0));                 word2 = word2.substring(1);             }         }         return merge.toString();     } }",0,,0,0,0
"class Solution {     public int minimumSize(int[] nums, int maxOperations) {         int left = 1, right = (int) 1e9; // Initialize lower and upper bounds         while (left < right) { // Binary search loop             int mid = (left + right) / 2, ops = 0;             for (int num : nums) {                 if (num > mid) { // Split if bag size is > mid                     ops += (num - 1) / mid; // Calculate number of splits needed                 }             }             if (ops <= maxOperations) { // Update upper bound                 right = mid;             } else { // Update lower bound                 left = mid + 1;             }         }         return left;     } }",1,"1760-minimum-limit-of-balls-in-a-bag/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1760-minimum-limit-of-balls-in-a-bag/Solution.java:5:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1760-minimum-limit-of-balls-in-a-bag/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1760-minimum-limit-of-balls-in-a-bag/Solution.java:5:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public boolean canChoose(int[][] groups, int[] nums) {         int n = groups.length;         int i = 0; // i will keep track of group index         for(int j = 0; j < nums.length && i < n; j++) {             if(nums[j] == groups[i][0]) { // if first element of current group matches with nums[j]                 int k = j + 1; // k will keep track of nums array                 int l = 1; // l will keep track of current group                 while(k < nums.length && l < groups[i].length) { // check if all elements of current group matches the corresponding elements in nums array                     if(nums[k] != groups[i][l]) {                         break;                     }                     k++;                     l++;                 }                 if(l == groups[i].length) { // if all elements of the current group match the elements in nums array                     i++; // move on to the next group                     j = k - 1; // j will start from k - 1 as the for loop will increment it again                 }             }         }         return i == n; // return true if all groups are found     } }",0,,0,0,0
"class Solution {     public int[][] highestPeak(int[][] isWater) {         int m = isWater.length;         int n = isWater[0].length;         int[][] height = new int[m][n];         Queue<int[]> queue = new LinkedList<>();         boolean[][] visited = new boolean[m][n];                  // Initialize all water cells to height 0 and add them to the queue         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 if (isWater[i][j] == 1) {                     height[i][j] = 0;                     visited[i][j] = true;                     queue.offer(new int[]{i, j});                 }             }         }                  // BFS to assign heights to land cells         int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};         while (!queue.isEmpty()) {             int[] curr = queue.poll();             int currRow = curr[0];             int currCol = curr[1];             for (int[] dir : directions) {                 int newRow = currRow + dir[0];                 int newCol = currCol + dir[1];                 if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && !visited[newRow][newCol]) {                     height[newRow][newCol] = height[currRow][currCol] + 1;                     visited[newRow][newCol] = true;                     queue.offer(new int[]{newRow, newCol});                 }             }         }                  return height;     } }",0,,0,0,0
"class Solution {     public int[] minOperations(String boxes) {         int n = boxes.length();         int[] ans = new int[n];         int left = 0, right = 0, count = 0;                  for (int i = 0; i < n; i++) {             ans[i] += left;             count += boxes.charAt(i) == '1' ? 1 : 0;             left += count;         }                  count = 0;         for (int i = n - 1; i >= 0; i--) {             ans[i] += right;             count += boxes.charAt(i) == '1' ? 1 : 0;             right += count;         }                  return ans;     } }",1,"1769-minimum-number-of-operations-to-move-all-balls-to-each-box/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1769-minimum-number-of-operations-to-move-all-balls-to-each-box/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     private int closestCost;     public int closestCost(int[] baseCosts, int[] toppingCosts, int target) {         closestCost = baseCosts[0];         for (int base : baseCosts) {             helper(base, toppingCosts, target, 0);             if (closestCost == target) {                 break;             }         }         return closestCost;     }          private void helper(int baseCost, int[] toppingCosts, int target, int index) {         if (index == toppingCosts.length) {             if (Math.abs(target - closestCost) > Math.abs(target - baseCost)) {                 closestCost = baseCost;             } else if (Math.abs(target - closestCost) == Math.abs(target - baseCost)) {                 closestCost = Math.min(closestCost, baseCost);             }             return;         }                  helper(baseCost, toppingCosts, target, index + 1);         helper(baseCost + toppingCosts[index], toppingCosts, target, index + 1);         helper(baseCost + 2 * toppingCosts[index], toppingCosts, target, index + 1);     } }",1,"1774-closest-dessert-cost/Solution.java:2:	AvoidFieldNameMatchingMethodName:	Field closestCost has the same name as a method
",0,0,0
"class Solution {     public int minOperations(int[] nums1, int[] nums2) {         int sum1 = 0, sum2 = 0;         int[] freq1 = new int[7], freq2 = new int[7];         for (int num : nums1) {             sum1 += num;             freq1[num]++;         }         for (int num : nums2) {             sum2 += num;             freq2[num]++;         }         if (sum1 > sum2 + (6 * (nums2.length - nums1.length)) || sum1 + (6 * (nums1.length - nums2.length)) < sum2) {             return -1;         }         int count = 0, diff = Math.abs(sum1 - sum2);         if (sum1 > sum2) {             for (int i = 1; i <= 5 && diff > 0; i++) {                 while (freq1[6 - i] > 0 && diff > 0) {                     freq1[6 - i]--;                     diff -= i;                     count++;                 }             }             for (int i = 1; i <= 5 && diff > 0; i++) {                 while (freq2[i] > 0 && diff > 0) {                     freq2[i]--;                     diff -= 6 - i;                     count++;                 }             }         } else {             for (int i = 1; i <= 5 && diff > 0; i++) {                 while (freq2[6 - i] > 0 && diff > 0) {                     freq2[6 - i]--;                     diff -= i;                     count++;                 }             }             for (int i = 1; i <= 5 && diff > 0; i++) {                 while (freq1[i] > 0 && diff > 0) {                     freq1[i]--;                     diff -= 6 - i;                     count++;                 }             }         }         return count;     } }",1,"1775-equal-sum-arrays-with-minimum-number-of-operations/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1775-equal-sum-arrays-with-minimum-number-of-operations/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1775-equal-sum-arrays-with-minimum-number-of-operations/Solution.java:16:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1775-equal-sum-arrays-with-minimum-number-of-operations/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1775-equal-sum-arrays-with-minimum-number-of-operations/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1775-equal-sum-arrays-with-minimum-number-of-operations/Solution.java:16:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1775-equal-sum-arrays-with-minimum-number-of-operations/Solution.java:2:	NPathComplexity:	The method 'minOperations(int[], int[])' has an NPath complexity of 600, current threshold is 200
",1,0,0
class Solution {     public boolean checkPowersOfThree(int n) {         while (n > 0) {             int remainder = n % 3;             if (remainder > 1) {                 return false;             }             n /= 3;         }         return true;     } },1,"1780-check-if-number-is-a-sum-of-powers-of-three/Solution.java:8:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
",0,1,0
"class Solution {     public int beautySum(String s) {         int beautySum = 0;         for (int i = 0; i < s.length(); i++) {             int[] charFreq = new int[26]; //frequency count of 26 lowercase alphabets             for (int j = i; j < s.length(); j++) {                 charFreq[s.charAt(j) - 'a']++;                 int maxFreq = 0, minFreq = 501; //initial values                 for (int freq : charFreq) { //finding max and min frequencies in the substring                     if (freq > 0) {                         maxFreq = Math.max(maxFreq, freq);                         minFreq = Math.min(minFreq, freq);                     }                 }                 beautySum += maxFreq - minFreq; //adding beauty of substring to total beauty             }         }         return beautySum;     } }",1,"1781-sum-of-beauty-of-all-substrings/Solution.java:8:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1781-sum-of-beauty-of-all-substrings/Solution.java:8:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int minElements(int[] nums, int limit, int goal) {         long sum = 0; // use long to avoid integer overflow         for (int num: nums) {             sum += num;         }         long diff = Math.abs(goal - sum);         long limitSum = (diff + limit - 1) / limit; // compute ceiling of diff/limit         return (int) limitSum;     } }  // Note: It is important to use long to avoid integer overflow  // when computing the sum and the difference. Also, we add limit - 1 // before dividing by limit to ensure that the ceiling is computed // correctly.",0,,0,0,0
"import java.util.*;  class Solution {     public int countRestrictedPaths(int n, int[][] edges) {         // Create adjacency list to store graph         List<int[]>[] adjList = new ArrayList[n+1];         for(int i=1; i<=n; i++){             adjList[i] = new ArrayList<int[]>();         }         for(int[] edge : edges){             int u = edge[0];             int v = edge[1];             int w = edge[2];             adjList[u].add(new int[]{v, w});             adjList[v].add(new int[]{u, w});         }                  // Create distance array and set all values to infinity         int[] dist = new int[n+1];         Arrays.fill(dist, Integer.MAX_VALUE);                  // Perform Dijkstra's algorithm from node n         PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[1]-b[1]);         pq.offer(new int[]{n, 0});         while(!pq.isEmpty()){             int[] curr = pq.poll();             int node = curr[0];             int currDist = curr[1];             if(dist[node] == Integer.MAX_VALUE){                 dist[node] = currDist;                 for(int[] neighbor : adjList[node]){                     int nextNode = neighbor[0];                     int weight = neighbor[1];                     pq.offer(new int[]{nextNode, currDist+weight});                 }             }         }                  // Create memoization array to store restricted path count for each node         int[] memo = new int[n+1];         memo[n] = 1;                  // Perform dynamic programming to calculate restricted path count for each node         int[] bfsDist = dist.clone(); // distance from source node n using BFS         Queue<Integer> queue = new LinkedList<>();         queue.offer(1);         while(!queue.isEmpty()){             int curr = queue.poll();             for(int[] neighbor : adjList[curr]){                 int next = neighbor[0];                 if(bfsDist[curr] > bfsDist[next]){ // if it is a restricted path                     memo[curr] = (memo[curr] + memo[next]) % 1000000007;                 }                 if(bfsDist[curr] > bfsDist[next]){ // if next node has a shorter distance to node n                     continue; // ignore this node for now because we haven't finished BFS                 }                 if(dist[curr] > dist[next]){ // if distance to node n is greater than next node                     queue.offer(next);                     bfsDist[next] = bfsDist[curr] + 1;                 }             }         }                  return memo[1] % 1000000007;     } }",1,"1786-number-of-restricted-paths-from-first-to-last-node/Solution.java:8:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new ArrayList<>()`
1786-number-of-restricted-paths-from-first-to-last-node/Solution.java:23:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
",0,0,0
"class Solution {     public String largestNumber(int[] nums) {         // Convert int array to string array         String[] strArr = new String[nums.length];         for(int i=0;i<nums.length;i++){             strArr[i] = String.valueOf(nums[i]);         }                  // Sort the string array in descending order         Arrays.sort(strArr, new Comparator<String>(){             @Override             public int compare(String s1, String s2){                 return (s2+s1).compareTo(s1+s2);             }         });                  // Check if the first element is 0, return ""0""         if(strArr[0].equals(""0"")){             return ""0"";         }                  // Combine the sorted string array into a single string         StringBuilder sb = new StringBuilder();         for(String s : strArr){             sb.append(s);         }                  return sb.toString();     } }",1,"179-largest-number/Solution.java:18:	LiteralsFirstInComparisons:	Position literals first in String comparisons
",0,0,0
"class Solution {     public double maxAverageRatio(int[][] classes, int extraStudents) {         PriorityQueue<double[]> pq = new PriorityQueue<>((a, b) -> Double.compare(b[0], a[0]));         double sum = 0;         // calculating initial pass ratio in each class and storing it in priority queue         for(int[] cls : classes) {             double passRatio = (double)cls[0]/cls[1];             pq.offer(new double[]{passRatio, cls[0], cls[1]});             sum += passRatio;         }         // assigning extra students and updating pass ratio         while(extraStudents-- > 0) {             double[] cls = pq.poll();             double passRatio = (double)(cls[1]+1)/(cls[2]+1);             sum += passRatio - cls[0];             pq.offer(new double[]{passRatio, cls[1]+1, cls[2]+1});         }         // calculating average pass ratio         return sum/classes.length;     } }",1,"1792-maximum-average-pass-ratio/Solution.java:12:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'extraStudents'
1792-maximum-average-pass-ratio/Solution.java:14:	UnnecessaryCast:	Unnecessary cast (double)
",0,1,0
"class AuthenticationManager {     // map to hold token information     private Map<String, Integer> tokens;     private int timeToLive;      public AuthenticationManager(int timeToLive) {         this.tokens = new HashMap<>();         this.timeToLive = timeToLive;     }      public void generate(String tokenId, int currentTime) {         tokens.put(tokenId, currentTime + timeToLive);     }      public void renew(String tokenId, int currentTime) {         if (tokens.containsKey(tokenId) && tokens.get(tokenId) > currentTime) {             tokens.put(tokenId, currentTime + timeToLive);         }     }      public int countUnexpiredTokens(int currentTime) {         // remove expired tokens         tokens.values().removeIf(expiry -> expiry <= currentTime);         return tokens.size();     } }",1,"1797-design-authentication-manager/AuthenticationManager.java:6:5: Redundant 'public' modifier. [RedundantModifier]
1797-design-authentication-manager/AuthenticationManager.java:6:38: 'timeToLive' hides a field. [HiddenField]
1797-design-authentication-manager/AuthenticationManager.java:6:5: Redundant 'public' modifier. [RedundantModifier]
1797-design-authentication-manager/AuthenticationManager.java:6:38: 'timeToLive' hides a field. [HiddenField]
",0,0,0
"class Solution {     public int getMaximumConsecutive(int[] coins) {         Arrays.sort(coins); // Sort the coins array         int maxSum = 0; // initialize maxSum to zero         for (int coin : coins) {             // Check if the current coin value is less than or equal to maxSum + 1             // If true, then we can make the sum of current coin value and current maxSum value             // Otherwise, we cannot make a consecutive sequence starting from maxSum + 1             if (coin <= maxSum + 1) {                 maxSum += coin; // add the current coin value to maxSum             } else {                 break; // We cannot make any more consecutive sequences             }         }         return maxSum + 1; // return the next consecutive value after the maximum sum     } }",0,,0,0,0
"class Solution {     public int getNumberOfBacklogOrders(int[][] orders) {         PriorityQueue<int[]> sellOrders = new PriorityQueue<>((a, b) -> a[0] - b[0]);         PriorityQueue<int[]> buyOrders = new PriorityQueue<>((a, b) -> b[0] - a[0]);         int mod = (int) 1e9 + 7;         for (int[] o : orders) {             if (o[2] == 0) {                 while (o[1] > 0 && !sellOrders.isEmpty() && o[0] >= sellOrders.peek()[0]) {                     int[] sell = sellOrders.poll();                     int minAmount = Math.min(o[1], sell[1]);                     o[1] -= minAmount;                     sell[1] -= minAmount;                     if (sell[1] > 0) {                         sellOrders.offer(sell);                     }                 }                 if (o[1] > 0) {                     buyOrders.offer(o);                 }             } else {                 while (o[1] > 0 && !buyOrders.isEmpty() && o[0] <= buyOrders.peek()[0]) {                     int[] buy = buyOrders.poll();                     int minAmount = Math.min(o[1], buy[1]);                     o[1] -= minAmount;                     buy[1] -= minAmount;                     if (buy[1] > 0) {                         buyOrders.offer(buy);                     }                 }                 if (o[1] > 0) {                     sellOrders.offer(o);                 }             }         }         long ans = 0;         while (!buyOrders.isEmpty()) {             ans = (ans + buyOrders.poll()[1]) % mod;         }         while (!sellOrders.isEmpty()) {             ans = (ans + sellOrders.poll()[1]) % mod;         }         return (int) ans;     } }",0,,0,0,0
,0,,0,0,0
"class Solution {     public int reinitializePermutation(int n) {         int[] perm = new int[n];         for(int i=0; i<n; i++) {             perm[i] = i;         }         int[] arr = new int[n];         int count = 0;         while(true) {             for(int i=0; i<n; i++) {                 if(i%2==0) {                     arr[i] = perm[i/2];                 } else {                     arr[i] = perm[n/2 + (i-1)/2];                 }             }             count++;             System.arraycopy(arr, 0, perm, 0, n);             boolean isInitial = true;             for(int i=0; i<n; i++) {                 if(perm[i]!=i) {                     isInitial = false;                     break;                 }             }             if(isInitial) {                 break;             }         }         return count;     } }",1,"1806-minimum-number-of-operations-to-reinitialize-a-permutation/Solution.java:10:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
",0,0,0
"class Solution {     public String evaluate(String s, List<List<String>> knowledge) {         // create a map to store the key-value pairs         Map<String, String> map = new HashMap<>();                  // fill the map with key-value pairs from knowledge list         for(List<String> pair : knowledge) {             map.put(pair.get(0), pair.get(1));         }                  // create a StringBuilder to modify the string         StringBuilder sb = new StringBuilder();                  // iterate through the string         for(int i=0; i<s.length(); i++) {             // if character at i is opening bracket             if(s.charAt(i) == '(') {                 // find the closing bracket index                 int j = i+1;                 while(j<s.length() && s.charAt(j) != ')') {                     j++;                 }                                  // get the key from the substring between i and j                 String key = s.substring(i+1, j);                                  // check if the key exists in the map                 if(map.containsKey(key)) {                     // if yes, replace the bracket pair with the value from map                     sb.append(map.get(key));                 } else {                     // if no, replace the bracket pair with ""?""                     sb.append(""?"");                 }                                  // move the index to after the closing bracket                 i = j;             } else {                 // if character at i is not an opening bracket, just add it to the StringBuilder                 sb.append(s.charAt(i));             }         }                  // return the result as a string         return sb.toString();     } }",1,"1807-evaluate-the-bracket-pairs-of-a-string/Solution.java:33:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
",0,0,0
"class Solution {     public boolean areSentencesSimilar(String sentence1, String sentence2) {         String[] words1 = sentence1.split("" "");         String[] words2 = sentence2.split("" "");                  if(words1.length > words2.length) {             String[] temp = words1;             words1 = words2;             words2 = temp;         }                  int i = 0;         while(i < words1.length && words1[i].equals(words2[i])) {             i++;         }                  int j = words1.length - 1;         int k = words2.length - 1;         while(j >= 0 && k >= 0 && words1[j].equals(words2[k])) {             j--;             k--;         }                  return i == words1.length || j == -1 || k == -1;     } }",0,,0,0,0
"class Solution {     public int countNicePairs(int[] nums) {         Map<Long, Long> freq = new HashMap<>();         long res = 0;         int mod = 1000000007;         for (int i = 0; i < nums.length; i++) {             long rev = reverse(nums[i]);             long diff = nums[i] - rev;             freq.put(diff, freq.getOrDefault(diff, 0L) + 1);         }          for (long val : freq.values()) {             res += val * (val - 1) / 2;             res %= mod;         }          return (int)res;     }      public long reverse(int num) {         long res = 0;         while (num > 0) {             res = res * 10 + num % 10;             num /= 10;         }         return res;     } }",1,"1814-count-nice-pairs-in-an-array/Solution.java:6:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
1814-count-nice-pairs-in-an-array/Solution.java:24:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'num'
",0,1,1
"class Solution {     public int[] findingUsersActiveMinutes(int[][] logs, int k) {         int[] answer = new int[k];         Map<Integer, Set<Integer>> userActions = new HashMap<>();         for (int i = 0; i < logs.length; i++) {             int userId = logs[i][0];             int minute = logs[i][1];             Set<Integer> actions = userActions.getOrDefault(userId, new HashSet<>());             actions.add(minute);             userActions.put(userId, actions);         }         for (Map.Entry<Integer, Set<Integer>> entry : userActions.entrySet()) {             int uam = entry.getValue().size();             if (uam <= k) {                 answer[uam-1]++;             }         }         return answer;     } }",1,"1817-finding-the-users-active-minutes/Solution.java:5:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     static final int MODULO = 1000000007;      public int minAbsoluteSumDiff(int[] nums1, int[] nums2) {         int n = nums1.length;         int[] sortedNums1 = nums1.clone();         Arrays.sort(sortedNums1); // sort nums1 in ascending order         int sum = 0, maxReducedSum = 0;         for (int i = 0; i < n; i++) {             int diff = Math.abs(nums1[i] - nums2[i]);             sum = (sum + diff) % MODULO; // calculate sum             int idx = Arrays.binarySearch(sortedNums1, nums2[i]); // find index of element in sortedNums1 that is closest to nums2[i]             if (idx < 0) {                 idx = -1 - idx; // if not found exactly, find the index of the next smaller element             }             if (idx < n) {                 maxReducedSum = Math.max(maxReducedSum, diff - (sortedNums1[idx] - nums2[i])); // calculate max possible reduced sum             }             if (idx > 0) {                 maxReducedSum = Math.max(maxReducedSum, diff - (nums2[i] - sortedNums1[idx - 1])); // calculate max possible reduced sum             }         }         return (sum - maxReducedSum + MODULO) % MODULO; // subtract maxReducedSum from sum and return the result     } }",1,"1818-minimum-absolute-sum-difference/Solution.java:8:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1818-minimum-absolute-sum-difference/Solution.java:8:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"/**  * Definition for a node in a circular linked list  */ class Node {     int val;     Node next;          Node(int val) {         this.val = val;         this.next = null;     } }  class Solution {     public int findTheWinner(int n, int k) {         // Create a circular linked list of the friends         Node head = new Node(1);         Node tail = head;         for (int i = 2; i <= n; i++) {             tail.next = new Node(i);             tail = tail.next;         }         tail.next = head; // Make the list circular          // Delete friends until there is only one left in the list         Node curr = head;         while (curr.next != curr) {             // Find the kth friend starting from the current friend             for (int i = 1; i < k; i++) {                 curr = curr.next;             }             // Delete the kth friend and update the current friend             curr.next = curr.next.next;             curr = curr.next;         }          return curr.val; // Return the last friend in the list (the winner)     } }",1,"1823-find-the-winner-of-the-circular-game/Node.java:5:9: Variable 'val' must be private and have accessor methods. [VisibilityModifier]
1823-find-the-winner-of-the-circular-game/Node.java:6:10: Variable 'next' must be private and have accessor methods. [VisibilityModifier]
1823-find-the-winner-of-the-circular-game/Node.java:8:14: 'val' hides a field. [HiddenField]
1823-find-the-winner-of-the-circular-game/Node.java:5:9: Variable 'val' must be private and have accessor methods. [VisibilityModifier]
1823-find-the-winner-of-the-circular-game/Node.java:6:10: Variable 'next' must be private and have accessor methods. [VisibilityModifier]
1823-find-the-winner-of-the-circular-game/Node.java:8:14: 'val' hides a field. [HiddenField]
1823-find-the-winner-of-the-circular-game/Node.java:10:	NullAssignment:	Assigning an Object to null is a code smell.  Consider refactoring.
1823-find-the-winner-of-the-circular-game/Node.java:27:	CompareObjectsWithEquals:	Use equals() to compare object references.
",0,0,0
"class Solution {     public int minSideJumps(int[] obstacles) {         int n = obstacles.length - 1;         int[][] dp = new int[n][3];         dp[0][0] = dp[0][2] = 1;          for (int i = 1; i < n; i++) {             int obs = obstacles[i];             if (obs != 1) dp[i][0] = dp[i - 1][0];             else dp[i][0] = Integer.MAX_VALUE / 2;             if (obs != 2) dp[i][1] = dp[i - 1][1];             else dp[i][1] = Integer.MAX_VALUE / 2;             if (obs != 3) dp[i][2] = dp[i - 1][2];             else dp[i][2] = Integer.MAX_VALUE / 2;              if (obs != 1) dp[i][0] = Math.min(dp[i][0], Math.min(dp[i][1], dp[i][2]) + 1);             if (obs != 2) dp[i][1] = Math.min(dp[i][1], Math.min(dp[i][0], dp[i][2]) + 1);             if (obs != 3) dp[i][2] = Math.min(dp[i][2], Math.min(dp[i][0], dp[i][1]) + 1);         }          return Math.min(dp[n - 1][0], Math.min(dp[n - 1][1], dp[n - 1][2]));     } }",1,"1824-minimum-sideway-jumps/Solution.java:5:29: Inner assignments should be avoided. [InnerAssignment]
1824-minimum-sideway-jumps/Solution.java:5:29: Inner assignments should be avoided. [InnerAssignment]
1824-minimum-sideway-jumps/Solution.java:9:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
1824-minimum-sideway-jumps/Solution.java:11:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
1824-minimum-sideway-jumps/Solution.java:13:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",0,0,0
"class Solution {     public int[] countPoints(int[][] points, int[][] queries) {         int n = queries.length;         int[] answer = new int[n];         for (int i = 0; i < n; i++) {             int x = queries[i][0];             int y = queries[i][1];             int r = queries[i][2];             int count = 0;             for (int j = 0; j < points.length; j++) {                 int xj = points[j][0];                 int yj = points[j][1];                 if ((xj - x) * (xj - x) + (yj - y) * (yj - y) <= r * r) {                     count++;                 }             }             answer[i] = count;         }         return answer;     } }",1,"1828-queries-on-number-of-points-inside-a-circle/Solution.java:10:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int[] getMaximumXor(int[] nums, int maximumBit) {         int n = nums.length;         int[] ans = new int[n];                  // Calculate target XOR sum         int target = (1 << maximumBit) - 1;         for (int i = 0; i < n; i++) {             target ^= nums[i];         }                  // Calculate answer for each query         for (int i = 0; i < n; i++) {             ans[i] = target;             target ^= nums[n-1-i]; // Remove last element         }                  return ans;     } }",0,,0,0,0
"class Solution {     public int maxIceCream(int[] costs, int coins) {         int[] freq = new int[100001];         int maxPrice = 0;          for(int i=0; i<costs.length; i++){             freq[costs[i]]++;             maxPrice = Math.max(maxPrice, costs[i]);         }          int totalIceCreams = 0;         for(int i=1; i<=maxPrice; i++){             if(coins >= i && freq[i] > 0){                 int iceCreamsToBuy = Math.min(freq[i], coins/i);                 totalIceCreams += iceCreamsToBuy;                 coins -= iceCreamsToBuy * i;             }         }          return totalIceCreams;     } }",1,"1833-maximum-ice-cream-bars/Solution.java:6:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
1833-maximum-ice-cream-bars/Solution.java:16:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'coins'
",0,1,1
"import java.util.*;  class Task {     int index, enqueueTime, processingTime;      public Task(int index, int enqueueTime, int processingTime) {         this.index = index;         this.enqueueTime = enqueueTime;         this.processingTime = processingTime;     } }  class Solution {     public int[] getOrder(int[][] tasks) {         int n = tasks.length;         Task[] taskArr = new Task[n];         int[] result = new int[n];         for(int i=0; i<n; i++) {             taskArr[i] = new Task(i, tasks[i][0], tasks[i][1]);         }          Arrays.sort(taskArr, (a,b) -> a.enqueueTime - b.enqueueTime); // First sort by enqueueTime         PriorityQueue<Task> taskQueue = new PriorityQueue<>((a,b) -> a.processingTime - b.processingTime); // Queue to keep track of tasks          long currentTime = 0;         int i = 0;         int j = 0;          // Process tasks         while(i < n || !taskQueue.isEmpty()) {             if(taskQueue.isEmpty()) {                 currentTime = taskArr[i].enqueueTime;             }             while(i < n && taskArr[i].enqueueTime <= currentTime) {                 taskQueue.offer(taskArr[i]);                 i++;             }             Task t = taskQueue.poll();             result[j++] = t.index;             currentTime += t.processingTime;         }          return result;     } }",1,"1834-single-threaded-cpu/Task.java:4:5: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1834-single-threaded-cpu/Task.java:4:9: Variable 'index' must be private and have accessor methods. [VisibilityModifier]
1834-single-threaded-cpu/Task.java:4:16: Variable 'enqueueTime' must be private and have accessor methods. [VisibilityModifier]
1834-single-threaded-cpu/Task.java:4:29: Variable 'processingTime' must be private and have accessor methods. [VisibilityModifier]
1834-single-threaded-cpu/Task.java:6:5: Redundant 'public' modifier. [RedundantModifier]
1834-single-threaded-cpu/Task.java:6:21: 'index' hides a field. [HiddenField]
1834-single-threaded-cpu/Task.java:6:32: 'enqueueTime' hides a field. [HiddenField]
1834-single-threaded-cpu/Task.java:6:49: 'processingTime' hides a field. [HiddenField]
1834-single-threaded-cpu/Task.java:4:5: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1834-single-threaded-cpu/Task.java:4:9: Variable 'index' must be private and have accessor methods. [VisibilityModifier]
1834-single-threaded-cpu/Task.java:4:16: Variable 'enqueueTime' must be private and have accessor methods. [VisibilityModifier]
1834-single-threaded-cpu/Task.java:4:29: Variable 'processingTime' must be private and have accessor methods. [VisibilityModifier]
1834-single-threaded-cpu/Task.java:6:5: Redundant 'public' modifier. [RedundantModifier]
1834-single-threaded-cpu/Task.java:6:21: 'index' hides a field. [HiddenField]
1834-single-threaded-cpu/Task.java:6:32: 'enqueueTime' hides a field. [HiddenField]
1834-single-threaded-cpu/Task.java:6:49: 'processingTime' hides a field. [HiddenField]
1834-single-threaded-cpu/Task.java:23:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
",1,0,0
"class Solution {     public int maxFrequency(int[] nums, int k) {         Arrays.sort(nums); // Sort the array         int left = 0;         long sum = 0; // Use long to avoid integer overflow         int result = 1; // Answer is atleast 1         for (int right = 0; right < nums.length; right++) {         // Here we check for the k operations availability wihin window and we keep on adding elements from the right             sum += nums[right];             while ((right - left + 1) * nums[right] - sum > k) {                 // Check for sum of remaining ops                 sum -= nums[left];                 left++; // Move left pointer to get a window of more size             }             result = Math.max(result, right - left + 1); // Update the answer at each iteration         }         return result; // Return the final result     } }",0,,0,0,0
"class Solution {     public int longestBeautifulSubstring(String word) {         int n = word.length();         int maxLen = 0;         int start = 0;         boolean found = false;                  for (int i = 0; i < n - 1; i++) {             if (word.charAt(i) > word.charAt(i + 1)) {                 if (found) {                     maxLen = Math.max(maxLen, i - start + 1);                 }                 start = i + 1;                 found = false;             } else if (word.charAt(i) < word.charAt(i + 1)) {                 found = true;             }         }                  if (found) {             maxLen = Math.max(maxLen, n - start);         }                  return maxLen >= 5 ? maxLen : 0;     } }",0,,0,0,0
import java.util.PriorityQueue;  class SeatManager {          // minHeap to store the available seats     private PriorityQueue<Integer> minHeap;          public SeatManager(int n) {         // initialize the minHeap with all the seats         minHeap = new PriorityQueue<>();         for (int i = 1; i <= n; i++) {             minHeap.offer(i);         }     }          public int reserve() {         // get the smallest-numbered unreserved seat         int seatNumber = minHeap.poll();         return seatNumber;     }          public void unreserve(int seatNumber) {         // add the seat back to the available seats         minHeap.offer(seatNumber);     } }  /**  * Your SeatManager object will be instantiated and called as such:  * SeatManager obj = new SeatManager(n);  * int param_1 = obj.reserve();  * obj.unreserve(seatNumber);  */,1,"1845-seat-reservation-manager/SeatManager.java:8:5: Redundant 'public' modifier. [RedundantModifier]
1845-seat-reservation-manager/SeatManager.java:8:5: Redundant 'public' modifier. [RedundantModifier]
1845-seat-reservation-manager/SeatManager.java:6:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
1845-seat-reservation-manager/SeatManager.java:18:	UnnecessaryLocalBeforeReturn:	Consider simply returning the value vs storing it in local variable 'seatNumber'
",0,0,0
import java.util.Arrays;  class Solution {     public int maximumElementAfterDecrementingAndRearranging(int[] arr) {         // Sort the array in ascending order         Arrays.sort(arr);                  // Set the first element to 1         arr[0] = 1;                  // Decrease any element that is more than 1 greater than the previous element         for (int i = 1; i < arr.length; i++) {             if (arr[i] - arr[i-1] > 1) {                 arr[i] = arr[i-1] + 1;             }         }                  // Return the maximum element in the array         int max = arr[0];         for (int i = 1; i < arr.length; i++) {             if (arr[i] > max) {                 max = arr[i];             }         }         return max;     } },0,,0,0,0
"class Solution {     public boolean splitString(String s) {         int n = s.length();         for(int i=1; i<n; i++) {             long num = Long.parseLong(s.substring(0, i));             if(dfs(s, i, num-1)) {                 return true;             }         }         return false;     }          public boolean dfs(String s, int start, long prev) {         if(start == s.length()) {             return true;         }         for(int i=start+1; i<=s.length(); i++) {             long num = Long.parseLong(s.substring(start, i));             if(num == prev-1 && dfs(s, i, num)) {                 return true;             }         }         return false;     } }",0,,0,0,0
"class Solution {     public int getMinSwaps(String num, int k) {         // Create char array for num         char[] arr = num.toCharArray();                  // Perform k permutations on the char array         while (k-- > 0) {             nextPermutation(arr);         }                  // Create a sorted copy of the original num string         char[] sortedArr = num.toCharArray();         Arrays.sort(sortedArr);                  // Count the number of swaps needed to sort the array in the order of the permutations         int swaps = 0;         for (int i = 0; i < arr.length; i++) {             if (arr[i] != sortedArr[i]) {                 int j = i + 1;                 while (j < arr.length && sortedArr[j] != arr[i]) {                     j++;                 }                 while (j > i) {                     char temp = arr[j];                     arr[j] = arr[j-1];                     arr[j-1] = temp;                     swaps++;                     j--;                 }             }         }                  return swaps;     }          private void nextPermutation(char[] arr) {         // Find the largest index i such that arr[i] < arr[i+1]         int i = arr.length - 2;         while (i >= 0 && arr[i] >= arr[i+1]) {             i--;         }                  // If there is no such i, the array is in reverse sorted order, so return the reversed array         if (i < 0) {             reverse(arr, 0, arr.length - 1);             return;         }                  // Find the largest index j such that arr[j] > arr[i]         int j = arr.length - 1;         while (j >= 0 && arr[j] <= arr[i]) {             j--;         }                  // Swap arr[i] with arr[j]         char temp = arr[i];         arr[i] = arr[j];         arr[j] = temp;                  // Reverse the suffix starting from i+1         reverse(arr, i+1, arr.length-1);     }          private void reverse(char[] arr, int start, int end) {         while (start < end) {             char temp = arr[start];             arr[start] = arr[end];             arr[end] = temp;             start++;             end--;         }     } }",1,"1850-minimum-adjacent-swaps-to-reach-the-kth-smallest-number/Solution.java:7:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'k'
1850-minimum-adjacent-swaps-to-reach-the-kth-smallest-number/Solution.java:17:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
1850-minimum-adjacent-swaps-to-reach-the-kth-smallest-number/Solution.java:23:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
1850-minimum-adjacent-swaps-to-reach-the-kth-smallest-number/Solution.java:69:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'start'
1850-minimum-adjacent-swaps-to-reach-the-kth-smallest-number/Solution.java:70:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'end'
",0,1,0
"class Solution {     public int maxDistance(int[] nums1, int[] nums2) {         int maxDistance = 0; // variable to store the maximum distance of any valid pair         int i = 0, j = 0; // indices for iterating through nums1 and nums2                  // iterate through both arrays, until we have seen all valid pairs         while (i < nums1.length && j < nums2.length) {             // if the current pair is valid, calculate the distance and update maxDistance if it is greater             if (nums1[i] <= nums2[j]) {                 maxDistance = Math.max(maxDistance, j - i);                 j++; // move to the next index in nums2             } else {                 i++; // move to the next index in nums1             }         }                  return maxDistance;     } }",1,"1855-maximum-distance-between-a-pair-of-values/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1855-maximum-distance-between-a-pair-of-values/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int maxSumMinProduct(int[] nums) {         int n = nums.length;         long[] prefSum = new long[n];  // to store prefix sum         int[] prevSmaller = new int[n];  // to store previous smaller element's index         int[] nextSmaller = new int[n];  // to store next smaller element's index         long ans = 0; // to store result         int MOD = 1000000007;                  // FINDING PREFIX SUM         prefSum[0] = nums[0];         for(int i=1; i<n; i++){             prefSum[i] = prefSum[i-1] + nums[i];         }                  // FINDING PREVIOUS SMALLERS         Stack<Integer> stack = new Stack<>(); // to store indices of array elements         for(int i=0; i<n; i++){             while(!stack.isEmpty() && nums[stack.peek()]>=nums[i]){                 stack.pop();             }             if(stack.isEmpty()){                 prevSmaller[i] = -1;             }             else{                 prevSmaller[i] = stack.peek();             }             stack.push(i);         }                  // RESETS THE STACK         stack.clear();                  // FINDING NEXT SMALLERS         for(int i=n-1; i>=0; i--){             while(!stack.isEmpty() && nums[stack.peek()]>=nums[i]){                 stack.pop();             }             if(stack.isEmpty()){                 nextSmaller[i] = n;             }             else{                 nextSmaller[i] = stack.peek();             }             stack.push(i);         }                  // CALCULATING RESULT         for(int i=0; i<n; i++){             long sum = 0L;             if(prevSmaller[i]==-1){                 sum = prefSum[nextSmaller[i]-1];             }             else{                 sum = prefSum[nextSmaller[i]-1] - prefSum[prevSmaller[i]];             }             ans = Math.max(ans, nums[i]*sum);         }         ans %= MOD;         return (int) ans;     } }",1,"1856-maximum-subarray-min-product/Solution.java:24:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1856-maximum-subarray-min-product/Solution.java:41:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1856-maximum-subarray-min-product/Solution.java:53:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1856-maximum-subarray-min-product/Solution.java:24:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1856-maximum-subarray-min-product/Solution.java:41:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1856-maximum-subarray-min-product/Solution.java:53:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1856-maximum-subarray-min-product/Solution.java:2:	NPathComplexity:	The method 'maxSumMinProduct(int[])' has an NPath complexity of 294, current threshold is 200
1856-maximum-subarray-min-product/Solution.java:50:	UnusedAssignment:	The initializer for variable 'sum' is never used (overwritten on lines 52 and 55)
",0,0,0
"class Solution {     public int[] memLeak(int memory1, int memory2) {         int time = 1;         while (memory1 >= time || memory2 >= time) {             // allocate memory to the memory stick with higher available memory             if (memory1 >= memory2) {                 memory1 -= time;             } else {                 memory2 -= time;             }             time++;         }         return new int[]{time, memory1, memory2};     } }",1,"1860-incremental-memory-leak/Solution.java:7:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'memory1'
1860-incremental-memory-leak/Solution.java:9:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'memory2'
",0,1,0
class Solution {     public char[][] rotateTheBox(char[][] box) {         int m = box.length;     // number of rows         int n = box[0].length;  // number of columns            // rotate the box 90 degrees clockwise         char[][] rotatedBox = new char[n][m];         for (int i = 0; i < n; i++) {             for (int j = m - 1; j >= 0; j--) {                 rotatedBox[i][m - 1 - j] = box[j][i];             }         }                  // apply gravity to each column         for (int i = 0; i < n; i++) {             int row = m - 1;             for (int j = m - 1; j >= 0; j--) {                 if (rotatedBox[i][j] == '#') {                     rotatedBox[i][j] = '.';                     rotatedBox[i][row] = '#';                     row--;                 } else if (rotatedBox[i][j] == '*') {                     rotatedBox[i][row] = '*';                     row = j - 1;                 }             }             while (row >= 0) {                 rotatedBox[i][row] = '.';                 row--;             }         }                  return rotatedBox;     } },0,,0,0,0
"class Solution {     public int minSwaps(String s) {         int count = 0;         int n = s.length();         int ones = 0;         int zeros = 0;         // counting the number of ones and zeros in the string         for(int i=0;i<n;i++){             if(s.charAt(i)=='1') ones++;             else zeros++;         }         // if the difference between ones and zeros is more than 1 then we can't make it alternating string         if(Math.abs(ones-zeros)>1) return -1;         // if the ones and zeros are equal that means we need to find the string with 010101... or 101010...          if(ones == zeros){             int count1=0,count2=0;             for(int i=0;i<n;i++){                 if(i%2==0 && s.charAt(i)=='1') count1++;                 else if(i%2==0 && s.charAt(i)=='0') count2++;                 else if(i%2!=0 && s.charAt(i)=='0') count1++;                 else if(i%2!=0 && s.charAt(i)=='1') count2++;             }         // returning the minimum number of swaps required                 count = Math.min(count1,count2);         }         else if(ones>zeros){             for(int i=0;i<n;i+=2){                 if(s.charAt(i)=='1') count++;             }         }         else if(zeros>ones){             for(int i=0;i<n;i+=2){                 if(s.charAt(i)=='0') count++;             }         }         return count;     } }",1,"1864-minimum-number-of-swaps-to-make-the-binary-string-alternating/Solution.java:16:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1864-minimum-number-of-swaps-to-make-the-binary-string-alternating/Solution.java:25:9: '}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1864-minimum-number-of-swaps-to-make-the-binary-string-alternating/Solution.java:30:9: '}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1864-minimum-number-of-swaps-to-make-the-binary-string-alternating/Solution.java:16:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1864-minimum-number-of-swaps-to-make-the-binary-string-alternating/Solution.java:25:9: '}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1864-minimum-number-of-swaps-to-make-the-binary-string-alternating/Solution.java:30:9: '}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1864-minimum-number-of-swaps-to-make-the-binary-string-alternating/Solution.java:3:	PrematureDeclaration:	Declaration of 'count' can be moved closer to its usages
",1,0,0
"import java.util.*;  class FindSumPairs {     int[] nums1, nums2;     Map<Integer, Integer> map;      public FindSumPairs(int[] nums1, int[] nums2) {         this.nums1 = nums1;         this.nums2 = nums2;         map = new HashMap<>();         for (int num : nums2) {             map.put(num, map.getOrDefault(num, 0) + 1);         }     }      public void add(int index, int val) {         map.put(nums2[index], map.get(nums2[index]) - 1);         nums2[index] += val;         map.put(nums2[index], map.getOrDefault(nums2[index], 0) + 1);     }      public int count(int tot) {         int count = 0;         for (int num : nums1) {             count += map.getOrDefault(tot - num, 0);         }         return count;     } }",1,"1865-finding-pairs-with-a-certain-sum/FindSumPairs.java:4:5: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1865-finding-pairs-with-a-certain-sum/FindSumPairs.java:4:11: Variable 'nums1' must be private and have accessor methods. [VisibilityModifier]
1865-finding-pairs-with-a-certain-sum/FindSumPairs.java:4:18: Variable 'nums2' must be private and have accessor methods. [VisibilityModifier]
1865-finding-pairs-with-a-certain-sum/FindSumPairs.java:5:27: Variable 'map' must be private and have accessor methods. [VisibilityModifier]
1865-finding-pairs-with-a-certain-sum/FindSumPairs.java:7:5: Redundant 'public' modifier. [RedundantModifier]
1865-finding-pairs-with-a-certain-sum/FindSumPairs.java:7:31: 'nums1' hides a field. [HiddenField]
1865-finding-pairs-with-a-certain-sum/FindSumPairs.java:7:44: 'nums2' hides a field. [HiddenField]
1865-finding-pairs-with-a-certain-sum/FindSumPairs.java:4:5: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1865-finding-pairs-with-a-certain-sum/FindSumPairs.java:4:11: Variable 'nums1' must be private and have accessor methods. [VisibilityModifier]
1865-finding-pairs-with-a-certain-sum/FindSumPairs.java:4:18: Variable 'nums2' must be private and have accessor methods. [VisibilityModifier]
1865-finding-pairs-with-a-certain-sum/FindSumPairs.java:5:27: Variable 'map' must be private and have accessor methods. [VisibilityModifier]
1865-finding-pairs-with-a-certain-sum/FindSumPairs.java:7:5: Redundant 'public' modifier. [RedundantModifier]
1865-finding-pairs-with-a-certain-sum/FindSumPairs.java:7:31: 'nums1' hides a field. [HiddenField]
1865-finding-pairs-with-a-certain-sum/FindSumPairs.java:7:44: 'nums2' hides a field. [HiddenField]
1865-finding-pairs-with-a-certain-sum/FindSumPairs.java:8:	ArrayIsStoredDirectly:	The user-supplied array 'nums1' is stored directly.
1865-finding-pairs-with-a-certain-sum/FindSumPairs.java:9:	ArrayIsStoredDirectly:	The user-supplied array 'nums2' is stored directly.
",1,0,0
"import java.util.*;  class Solution {     public List<String> findRepeatedDnaSequences(String s) {         List<String> res = new ArrayList<>();         Map<String, Integer> map = new HashMap<>();         for (int i = 0; i <= s.length() - 10; i++) {             String sub = s.substring(i, i + 10);             map.put(sub, map.getOrDefault(sub, 0) + 1);             if (map.get(sub) == 2) {                 res.add(sub);             }         }         return res;     } }",1,"187-repeated-dna-sequences/Solution.java:6:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
",0,0,0
"class Solution {     public int minSpeedOnTime(int[] dist, double hour) {         int n = dist.length;         // check if there is enough time to take all the trains         if (hour <= n - 1) {             return -1; // not enough time         }         int left = 1, right = 10000000; // set the lower and upper bounds of the speed         while (left < right) {             int mid = (left + right) / 2;             double time = 0;             for (int i = 0; i < n - 1; i++) {                 time += Math.ceil((double) dist[i] / mid);             }             time += (double) dist[n - 1] / mid; // last train don't need to wait             if (time > hour) {                 left = mid + 1; // speed is too low             } else {                 right = mid; // speed is high enough             }         }         return left; // left or right, both are correct here     } }",1,"1870-minimum-speed-to-arrive-on-time/Solution.java:8:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1870-minimum-speed-to-arrive-on-time/Solution.java:8:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public boolean canReach(String s, int minJump, int maxJump) {         int n = s.length();         boolean[] dp = new boolean[n];         dp[0] = true;         int prev = 0;         for(int i = 1; i < n; i++) {             if(i >= minJump && dp[i - minJump]) {                 prev++;             }             if(i > maxJump && dp[i - maxJump - 1]) {                 prev--;             }             dp[i] = prev > 0 && s.charAt(i) == '0';         }         return dp[n - 1];     } }",0,,0,0,0
"import java.util.Arrays;  class Solution {     public int minPairSum(int[] nums) {         // Sort the array in non-decreasing order         Arrays.sort(nums);          int max = 0;         int pairedIndex = nums.length - 1;          // Pair up the elements from the beginning and the end simultaneously         for (int i = 0; i < nums.length / 2; i++) {             int pairSum = nums[i] + nums[pairedIndex];             max = Math.max(max, pairSum); // Keep track of the maximum pair sum             pairedIndex--;         }          return max; // Return the minimized maximum pair sum     } }",0,,0,0,0
"class Solution {     public int[] getBiggestThree(int[][] grid) {                  int m = grid.length;         int n = grid[0].length;                  // To store distinct rhombus sums         TreeSet<Integer> set = new TreeSet<Integer>();                  for(int i=0;i<m;i++){             for(int j=0;j<n;j++){                                  // Add the central element to set                 set.add(grid[i][j]);                                  // Iterate over all possible rhombus sizes                 for(int size=1;size<=Math.min(i,Math.min(m-i-1,Math.min(j,n-j-1)));size++){                                          // Find the sum of border elements of the rhombus                     int sum = 0;                     for(int p=i-size,q=j;p<=i;p++){                         sum += grid[p][q];                         q++;                     }                     for(int p=i,q=j+size;p<=i+size;p++){                         sum += grid[p][q];                         q--;                     }                     for(int p=i+size,q=j;p>=i;p--){                         sum += grid[p][q];                         q++;                     }                     for(int p=i,q=j-size;p>=i-size;p--){                         sum += grid[p][q];                         q--;                     }                                          // Add the sum to the set                     set.add(sum);                                          // Remove the smallest element if set size > 3                     if(set.size()>3){                         set.pollFirst();                     }                 }             }         }                  // Convert the set to array and return in descending order         int[] ans = new int[set.size()];         int k = ans.length-1;         while(!set.isEmpty()){             ans[k--] = set.pollLast();         }         return ans;     } }",1,"1878-get-biggest-three-rhombus-sums-in-a-grid/Solution.java:21:	ForLoopVariableCount:	Too many control variables in the for statement
1878-get-biggest-three-rhombus-sums-in-a-grid/Solution.java:25:	ForLoopVariableCount:	Too many control variables in the for statement
1878-get-biggest-three-rhombus-sums-in-a-grid/Solution.java:29:	ForLoopVariableCount:	Too many control variables in the for statement
1878-get-biggest-three-rhombus-sums-in-a-grid/Solution.java:33:	ForLoopVariableCount:	Too many control variables in the for statement
",0,0,0
"class Solution {     public String maxValue(String n, int x) {         StringBuilder sb = new StringBuilder(n);         int i = 0;         // If n is a negative number, skip the first index which is the negative sign         if (n.charAt(0) == '-') {             i = 1;         }         // Traverse the string until we find a digit that is smaller than x         while (i < n.length() && n.charAt(i) - '0' >= x) {             i++;         }         // Insert x at the first index where the digit is smaller than x         sb.insert(i, x);         return sb.toString();     } }",0,,0,0,0
"class Solution {     public int[] assignTasks(int[] servers, int[] tasks) {         // Create a PriorityQueue for available servers. This will store          // servers with the following priority order:          // 1. server with the smallest weight followed by          // 2. server with the smallest index         PriorityQueue<int[]> availableServers = new PriorityQueue<>((a, b) -> {             if (a[0] != b[0]) {                 return a[0] - b[0];             }             return a[1] - b[1];         });                  // Create a PriorityQueue for tasks that are waiting to be processed.         // This will store tasks with the following priority order:         // 1. task with the smallest start time         PriorityQueue<int[]> waitingTasks = new PriorityQueue<>((a, b) -> a[0] - b[0]);                  // Create ans array to store the server index each task will be assigned to.         int[] ans = new int[tasks.length];                  // Add all the servers to the availableServers queue.         for (int i = 0; i < servers.length; i++) {             availableServers.offer(new int[]{servers[i], i});         }                  int time = 0;         // Process each task in the order they were added.         for (int i = 0; i < tasks.length; i++) {             // If there are no available servers, we need to wait             // until a server becomes available. We can do this by             // simulating time passing by increasing the current time.             while (availableServers.isEmpty()) {                 time = waitingTasks.peek()[0];                 processTasks(availableServers, waitingTasks, time);             }                          // Get the next task in the waitingTasks queue and assign             // it to the first available server.             int[] task = waitingTasks.isEmpty() ? new int[]{time + 1, i} : waitingTasks.poll();             int[] server = availableServers.poll();             ans[task[1]] = server[1];                          // Add the server and task to the processingTasks queue.             server[0] = time + tasks[task[1]];             waitingTasks.offer(task);             availableServers.offer(server);                          // Process any tasks that are now ready to be processed.             processTasks(availableServers, waitingTasks, time);         }                  return ans;     }          private void processTasks(PriorityQueue<int[]> availableServers, PriorityQueue<int[]> waitingTasks,                               int time) {         while (!waitingTasks.isEmpty() && waitingTasks.peek()[0] <= time) {             availableServers.offer(waitingTasks.poll());         }     }  }",0,,0,0,0
class Solution {     public int twoEggDrop(int n) {         int x = 1; // starting floor         int jumps = 0;                  while (true) {             if (x >= n) { // if we reached the top floor                 return jumps;             }             jumps++; // increment the number of jumps             x += jumps; // move to next floor to drop egg         }     } },0,,0,0,0
"class Solution {     public int reductionOperations(int[] nums) {         Arrays.sort(nums);         int n = nums.length;         int count = 0, ans = 0;         for (int i = n - 1; i > 0; i--) {             if (nums[i] == nums[i - 1])                 count++;             else {                 ans += count + 1;                 count = 0;             }         }         return ans + count;     } }",1,"1887-reduction-operations-to-make-the-array-elements-equal/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1887-reduction-operations-to-make-the-array-elements-equal/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int minFlips(String s) {         int n=s.length(), mis=0, mis1=0;         String str = s+s;         char arr[]= str.toCharArray();         for(int i=0;i<n*2;i++){             if((i&1) == (arr[i]-'0')) mis++;             else mis1++;         }         int ans= Math.min(mis,mis1);         if(n%2 == 1) ans= Math.min(ans, Math.min(mis,n-mis));         return ans;     } }",1,"1888-minimum-number-of-flips-to-make-the-binary-string-alternating/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1888-minimum-number-of-flips-to-make-the-binary-string-alternating/Solution.java:5:17: Array brackets at illegal position. [ArrayTypeStyle]
1888-minimum-number-of-flips-to-make-the-binary-string-alternating/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1888-minimum-number-of-flips-to-make-the-binary-string-alternating/Solution.java:5:17: Array brackets at illegal position. [ArrayTypeStyle]
",1,0,0
"class Solution {     public void rotate(int[] nums, int k) {         int n = nums.length;         int[] rotated = new int[n];                  // copy the last k elements to rotated array         for (int i = 0; i < k; i++) {             rotated[i] = nums[n - k + i];         }                  // copy the first n-k elements to rotated array         for (int i = k; i < n; i++) {             rotated[i] = nums[i - k];         }                  // copy the rotated array back to nums array         for (int i = 0; i < n; i++) {             nums[i] = rotated[i];         }     } }",1,"189-rotate-array/Solution.java:17:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
",0,0,0
"class Solution {     public int chalkReplacer(int[] chalk, int k) {         int n = chalk.length;         long totalChalk = 0; //To prevent overflow, use long instead of int         for(int i = 0; i < n; i++) {             totalChalk += chalk[i];         }         k %= totalChalk; //If k is greater than the total chalk available, we only need to count k mod total chalk         int i = 0; //Pointer to keep track of the student index         while(chalk[i] <= k && k > 0) { //If the current student can solve the problem with their chalk             k -= chalk[i]; //Subtract the chalk used             i++; //Next student             if(i == n) i = 0; //Reset to student 0 if all have been tried         }         return i; //The student index that replace the chalk     } }",1,"1894-find-the-student-that-will-replace-the-chalk/Solution.java:8:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'k'
",0,1,0
"class Solution {     public int largestMagicSquare(int[][] grid) {         int m = grid.length;         int n = grid[0].length;         int maxK = Math.min(m, n);         int largestMagicSquare = 1;                  // Iterate over all possible k values         for (int k = 2; k <= maxK; k++) {             // Iterate over all possible starting positions             for (int i = 0; i <= m - k; i++) {                 for (int j = 0; j <= n - k; j++) {                     int sum = rowSum(i, j, k, grid);                     boolean isMagicSquare = true;                                          // Check row sums                     for (int r = 1; r < k; r++) {                         int rowSum = rowSum(i+r, j, k, grid);                         if (rowSum != sum) {                             isMagicSquare = false;                             break;                         }                     }                                          if (!isMagicSquare) continue;                                          // Check column sums                     for (int c = 1; c < k; c++) {                         int colSum = colSum(i, j+c, k, grid);                         if (colSum != sum) {                             isMagicSquare = false;                             break;                         }                     }                                          if (!isMagicSquare) continue;                                          // Check diagonal sums                     int diag1Sum = diag1Sum(i, j, k, grid);                     if (diag1Sum != sum) continue;                                          int diag2Sum = diag2Sum(i, j, k, grid);                     if (diag2Sum != sum) continue;                                          // If all sums are equal, update largest magic square size                     largestMagicSquare = k;                 }             }         }                  return largestMagicSquare;     }          private int rowSum(int i, int j, int k, int[][] grid) {         int sum = 0;         for (int c = j; c < j + k; c++) {             sum += grid[i][c];         }         return sum;     }          private int colSum(int i, int j, int k, int[][] grid) {         int sum = 0;         for (int r = i; r < i + k; r++) {             sum += grid[r][j];         }         return sum;     }          private int diag1Sum(int i, int j, int k, int[][] grid) {         int sum = 0;         for (int d = 0; d < k; d++) {             sum += grid[i+d][j+d];         }         return sum;     }          private int diag2Sum(int i, int j, int k, int[][] grid) {         int sum = 0;         for (int d = 0; d < k; d++) {             sum += grid[i+d][j+k-d-1];         }         return sum;     } }",0,,0,0,0
"class Solution {     public int maximumRemovals(String s, String p, int[] removable) {         int left = 0, right = removable.length - 1, result = 0;                  // Binary search for k         while(left <= right) {             int mid = (left + right) / 2;             if(isValid(mid, s, p, removable)) {                 result = mid + 1;                 left = mid + 1;             } else {                 right = mid - 1;             }         }                  return result;     }          private boolean isValid(int k, String s, String p, int[] removable) {         // Create a boolean array to mark removed characters         boolean[] removed = new boolean[s.length()];         for(int i = 0; i <= k; i++) {             removed[removable[i]] = true;         }                  // Use two pointers to check if p is still a subsequence after removing k characters         int i = 0, j = 0;         while(i < s.length() && j < p.length()) {             if(!removed[i] && s.charAt(i) == p.charAt(j)) {                 j++;             }             i++;         }                  return j == p.length();     } }",1,"1898-maximum-number-of-removable-characters/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1898-maximum-number-of-removable-characters/Solution.java:27:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1898-maximum-number-of-removable-characters/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1898-maximum-number-of-removable-characters/Solution.java:27:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public boolean mergeTriplets(int[][] triplets, int[] target) {         // Initializing the triplet with minimum values so that our target triplet can be achieved         int[] maxTriplet = {0, 0, 0};                  for(int[] triplet : triplets) {             // If the triplet cannot be used to achieve the target triplet then skip to the next triplet             if(triplet[0] > target[0] || triplet[1] > target[1] || triplet[2] > target[2]) {                 continue;             }                          // Choose the maximum values from our current maxTriplet and triplet to form the new maxTriplet             maxTriplet[0] = Math.max(maxTriplet[0], triplet[0]);             maxTriplet[1] = Math.max(maxTriplet[1], triplet[1]);             maxTriplet[2] = Math.max(maxTriplet[2], triplet[2]);                          // If the new maxTriplet matches our target triplet then return true             if(Arrays.equals(maxTriplet, target)) {                 return true;             }         }                  return false;     } }",0,,0,0,0
"class Solution {     public int[] findPeakGrid(int[][] mat) {         int m = mat.length, n = mat[0].length;         int left = 0, right = m - 1;                  while (left < right) {             int mid = left + (right - left) / 2;             int maxVal = Integer.MIN_VALUE, maxIdx = -1;             for (int j = 0; j < n; j++) {                 if (mat[mid][j] > maxVal) {                     maxVal = mat[mid][j];                     maxIdx = j;                 }             }             if (maxVal < mat[mid + 1][maxIdx]) {                 left = mid + 1;             } else if (maxVal < mat[mid - 1][maxIdx]) {                 right = mid - 1;             } else {                 return new int[]{mid, maxIdx};             }         }                  int row = left;         int leftCol = 0, rightCol = n - 1;                  while (leftCol <= rightCol) {             int midCol = leftCol + (rightCol - leftCol) / 2;             if (mat[row][midCol] < mat[row][midCol + 1]) {                 leftCol = midCol + 1;             } else if (mat[row][midCol] < mat[row][midCol - 1]) {                 rightCol = midCol - 1;             } else {                 return new int[]{row, midCol};             }         }                  return null;     } }",1,"1901-find-a-peak-element-ii/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1901-find-a-peak-element-ii/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1901-find-a-peak-element-ii/Solution.java:8:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1901-find-a-peak-element-ii/Solution.java:25:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1901-find-a-peak-element-ii/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1901-find-a-peak-element-ii/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1901-find-a-peak-element-ii/Solution.java:8:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1901-find-a-peak-element-ii/Solution.java:25:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1901-find-a-peak-element-ii/Solution.java:38:	ReturnEmptyCollectionRatherThanNull:	Return an empty collection rather than null.
",1,0,0
"class Solution {     public int numberOfRounds(String loginTime, String logoutTime) {         // Parse the given times to integers         int login = Integer.parseInt(loginTime.replace("":"", """"));         int logout = Integer.parseInt(logoutTime.replace("":"", """"));                  // If logout time is earlier than login time, add a day (in minutes)         if (logout < login) {             logout += 24 * 60;         }                  // Round login and logout times to the nearest 15-minute boundary         int roundedLogin = (login + 14) / 15 * 15;         int roundedLogout = (logout / 15) * 15;                  // Calculate the number of full rounds played         int rounds = (roundedLogout - roundedLogin) / 15;                  return rounds;     } }",1,"1904-the-number-of-full-rounds-you-have-played/Solution.java:14:	UselessParentheses:	Useless parentheses.
1904-the-number-of-full-rounds-you-have-played/Solution.java:17:	UnnecessaryLocalBeforeReturn:	Consider simply returning the value vs storing it in local variable 'rounds'
",0,0,0
"class Solution {     private int[][] directions = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};          public int countSubIslands(int[][] grid1, int[][] grid2) {         int count = 0;         int m = grid1.length;         int n = grid1[0].length;                  for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 if (grid2[i][j] == 1 && dfs(grid1, grid2, i, j)) {                     count++;                 }             }         }         return count;     }          private boolean dfs(int[][] grid1, int[][] grid2, int i, int j) {         int m = grid1.length;         int n = grid1[0].length;                  if (i < 0 || i == m || j < 0 || j == n || grid2[i][j] == 0) {             return true;         }                  if (grid1[i][j] == 0) {             return false;         }                  grid2[i][j] = 0;                  boolean subIsland = true;         for (int[] direction : directions) {             int newRow = i + direction[0];             int newCol = j + direction[1];             subIsland &= dfs(grid1, grid2, newRow, newCol);         }         return subIsland;     } }",0,,0,0,0
"class Solution {     public int[] minDifference(int[] nums, int[][] queries) {                  int[] ans = new int[queries.length];                  for(int i=0; i<queries.length; i++){                          int li = queries[i][0];             int ri = queries[i][1];             int minDiff = Integer.MAX_VALUE;             boolean same = true;                          for(int j=li+1; j<=ri; j++){                 if(nums[j] != nums[j-1]){                     same = false;                     minDiff = Math.min(minDiff, nums[j]-nums[j-1]);                 }             }                          if(same){                 ans[i] = -1;             } else {                 ans[i] = minDiff;             }         }                  return ans;     } }",0,,0,0,0
"class Solution {     public String removeOccurrences(String s, String part) {         StringBuilder sb = new StringBuilder(s);         int index = sb.indexOf(part); // Find the leftmost occurrence of the substring          while (index != -1) {             int endIndex = index + part.length(); // Get the index of the end of the substring             sb.delete(index, endIndex); // Remove the substring from the StringBuilder             index = sb.indexOf(part); // Find the leftmost occurrence of the substring again         }          return sb.toString(); // Return the resulting string after removing all occurrences of the substring     } }",0,,0,0,0
"class Solution {     public long maxAlternatingSum(int[] nums) {         long evenSum = 0L;         long oddSum = 0L;                  for (int i = 0; i < nums.length; i++) {             if (i % 2 == 0) {                 evenSum += nums[i];             } else {                 oddSum += nums[i];             }         }                  long maxSum = evenSum;                  for (int i = 0; i < nums.length; i++) {             if (i % 2 == 0) {                 evenSum -= nums[i];             } else {                 oddSum -= nums[i];             }                          maxSum = Math.max(maxSum, evenSum + oddSum);         }                  return maxSum;     } }",0,,0,0,0
"class Solution {     public int[][] rotateGrid(int[][] grid, int k) {         int m = grid.length;         int n = grid[0].length;         int numOfLayers = Math.min(m, n) / 2;                // loop through each layer         for (int i = 0; i < numOfLayers; i++) {             int layerSize = 2 * (m + n - 4 * i) - 4; // calculate size of current layer             int[] layer = new int[layerSize]; // initialize array to store current layer             int count = 0;             // populate current layer array in counter-clockwise order             for (int j = i; j < n - i - 1; j++) layer[count++] = grid[i][j];             for (int j = i; j < m - i - 1; j++) layer[count++] = grid[j][n - i - 1];             for (int j = n - i - 1; j > i; j--) layer[count++] = grid[m - i - 1][j];             for (int j = m - i - 1; j > i; j--) layer[count++] = grid[j][i];              // perform rotation k % layerSize times on current layer             int rotateCount = k % layerSize;             int[] rotatedLayer = new int[layerSize];             for (int j = 0; j < layerSize; j++) {                 int newIndex = (j + rotateCount) % layerSize; // calculate new index after rotation                 rotatedLayer[newIndex] = layer[j];             }              // update grid with rotated layer             count = 0;             for (int j = i; j < n - i - 1; j++) grid[i][j] = rotatedLayer[count++];             for (int j = i; j < m - i - 1; j++) grid[j][n - i - 1] = rotatedLayer[count++];             for (int j = n - i - 1; j > i; j--) grid[m - i - 1][j] = rotatedLayer[count++];             for (int j = m - i - 1; j > i; j--) grid[j][i] = rotatedLayer[count++];         }         return grid;     } }",1,"1914-cyclically-rotating-a-grid/Solution.java:2:	NPathComplexity:	The method 'rotateGrid(int[][], int)' has an NPath complexity of 513, current threshold is 200
",0,0,0
class Solution {     public long wonderfulSubstrings(String word) {         // array to keep track of the count of each letter in the substring         int[] count = new int[1024];         count[0] = 1; // initialize with empty string count         long res = 0;         int mask = 0; // use binary mask to see if palindrome with just one odd count         for (int i = 0; i < word.length(); i++) {             int c = word.charAt(i) - 'a';             mask ^= 1 << c; // flip the c-th bit             res += count[mask]; // count how many palindromic substrings with mask as binary representation             for (int j = 0; j < 10; j++) {                 res += count[mask ^ (1 << j)]; // count substrings with mask that have at most one char with odd count             }             count[mask]++;         }         return res;     } },0,,0,0,0
"class Solution {     public int eliminateMaximum(int[] dist, int[] speed) {         int n = dist.length;         int[] time = new int[n];         for (int i = 0; i < n; i++) {             time[i] = (int) Math.ceil((double) dist[i] / speed[i]); // calculates the time required to reach city         }         Arrays.sort(time); // sorts the time in ascending order         for (int i = 0; i < n; i++) {             if (i >= time[i]) { // if any monster reaches before we can eliminate it, return the number of eliminated monsters                 return i;             }         }         return n; // if all monsters can be eliminated before they reach the city     } }",0,,0,0,0
"class Solution {          public int countGoodNumbers(long n) {         final int MOD = 1000000007;         int evenCount = (int) ((n+1)/2);         int oddCount = (int) (n - evenCount);         long evenPerm = power(5, evenCount, MOD);         long oddPerm = power(4, oddCount, MOD);         return (int) ((evenPerm*oddPerm) % MOD);     }          private long power(long x, long y, long m) {         long res = 1;         while (y > 0) {             if ((y & 1) == 1) {                 res = (res * x) % m;             }             x = (x * x) % m;             y >>= 1;         }         return res;     }      }",1,"1922-count-good-numbers/Solution.java:9:	UselessParentheses:	Useless parentheses.
1922-count-good-numbers/Solution.java:16:	UselessParentheses:	Useless parentheses.
1922-count-good-numbers/Solution.java:18:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'x'
1922-count-good-numbers/Solution.java:18:	UselessParentheses:	Useless parentheses.
1922-count-good-numbers/Solution.java:19:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'y'
",0,1,0
"class Solution {     public int nearestExit(char[][] maze, int[] entrance) {         int m = maze.length;         int n = maze[0].length;         Queue<int[]> queue = new LinkedList<>();         boolean[][] visited = new boolean[m][n];         int[] dirs = {-1, 0, 1, 0, -1};         int steps = 0;         queue.offer(entrance);         visited[entrance[0]][entrance[1]] = true;                  while (!queue.isEmpty()) {             int size = queue.size();             while (size-- > 0) {                 int[] curr = queue.poll();                 if (isExit(curr, m, n)) {                     return steps;                 }                 for (int d = 0; d < 4; d++) {                     int nr = curr[0] + dirs[d];                     int nc = curr[1] + dirs[d + 1];                     if (nr >= 0 && nr < m && nc >= 0 && nc < n                         && maze[nr][nc] == '.' && !visited[nr][nc]) {                         visited[nr][nc] = true;                         queue.offer(new int[]{nr, nc});                     }                 }             }             steps++;         }         return -1;     }          private boolean isExit(int[] cell, int m, int n) {         int r = cell[0];         int c = cell[1];         return r == 0 || c == 0 || r == m - 1 || c == n - 1;     } }",0,,0,0,0
"class Solution {     public boolean sumGame(String num) {                  int n = num.length();         int aliceFirstHalf = 0, bobFirstHalf = 0;         int aliceSecondHalf = 0, bobSecondHalf = 0;         int aliceQuestionMark = countQuestionMarks(num, 0, n / 2);         int bobQuestionMark = countQuestionMarks(num, n / 2, n);                  for(int i = 0; i < n / 2; i++) {             if(num.charAt(i) == '?') {                 aliceQuestionMark--;                 continue;             }             aliceFirstHalf += num.charAt(i) - '0';         }                  for(int i = n / 2; i < n; i++) {             if(num.charAt(i) == '?') {                 bobQuestionMark--;                 continue;             }             bobFirstHalf += num.charAt(i) - '0';         }                  if(aliceQuestionMark + bobQuestionMark == 0) {             return aliceFirstHalf != bobFirstHalf;         }                  aliceQuestionMark /= 2;         bobQuestionMark /= 2;                  return (aliceFirstHalf + aliceQuestionMark * 9) !=                (bobFirstHalf + bobQuestionMark * 9);     }          private int countQuestionMarks(String num, int start, int end) {         int count = 0;         for(int i = start; i < end; i++) {             if(num.charAt(i) == '?') {                 count++;             }         }         return count;     } }",1,"1927-sum-game/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1927-sum-game/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1927-sum-game/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1927-sum-game/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1927-sum-game/Solution.java:6:	UnusedLocalVariable:	Avoid unused local variables such as 'aliceSecondHalf'.
1927-sum-game/Solution.java:6:	UnusedLocalVariable:	Avoid unused local variables such as 'bobSecondHalf'.
",1,0,0
class Solution {     public int countPalindromicSubsequence(String s) {         int[][] freq = new int[26][s.length()];         for (int i = 0; i < s.length(); i++) {             freq[s.charAt(i) - 'a'][i]++;             if (i > 0) {                 for (int j = 0; j < 26; j++) {                     freq[j][i] += freq[j][i - 1];                 }             }         }         boolean[][] seen = new boolean[26][26];         int count = 0;         for (int i = 1; i < s.length() - 1; i++) {             int c = s.charAt(i) - 'a';             if (!seen[c][c]) {                 seen[c][c] = true;                 for (int j = 0; j < 26; j++) {                     int freq_j = freq[j][i - 1] - freq[j][0];                     if (freq_j > 0) {                         count++;                         seen[c][j] = seen[j][c] = true;                     }                 }             }         }         return count;     } },1,"1930-unique-length-3-palindromic-subsequences/Solution.java:22:49: Inner assignments should be avoided. [InnerAssignment]
1930-unique-length-3-palindromic-subsequences/Solution.java:22:49: Inner assignments should be avoided. [InnerAssignment]
",0,0,0
"class Solution {     public int addRungs(int[] rungs, int dist) {         int count = 0;         int prev_height = 0;         for(int i = 0; i < rungs.length; i++){             int diff = rungs[i] - prev_height;             if(diff > dist){                 count += ((diff - 1) / dist);             }             prev_height = rungs[i];         }         return count;     } }",1,"1936-add-minimum-number-of-rungs/Solution.java:5:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public long maxPoints(int[][] points) {         int m = points.length;         int n = points[0].length;         long[][] dp = new long[m][n];         for(int i=0; i<n; i++){             dp[0][i] = points[0][i];         }         for(int i=1; i<m; i++){             long[] leftMax = new long[n];             long[] rightMax = new long[n];             leftMax[0] = dp[i-1][0];             for(int j=1; j<n; j++){                 leftMax[j] = Math.max(leftMax[j-1]-1, dp[i-1][j]);             }             rightMax[n-1] = dp[i-1][n-1];             for(int j=n-2; j>=0; j--){                 rightMax[j] = Math.max(rightMax[j+1]-1, dp[i-1][j]);             }             for(int j=0; j<n; j++){                 dp[i][j] = Math.max(leftMax[j], rightMax[j]) + points[i][j];             }         }         long maxScore = 0;         for(int i=0; i<n; i++){             maxScore = Math.max(maxScore, dp[m-1][i]);         }         return maxScore;     } }",0,,0,0,0
"class Solution {     public int smallestChair(int[][] times, int targetFriend) {         int n = times.length;         // sort the times by arrival time         Arrays.sort(times, (a, b) -> a[0] - b[0]);         // create a priority queue to store the occupied chairs by their leaving time         PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);         // create an array to store the unoccupied chairs         boolean[] chairs = new boolean[n];         // loop through the times         for (int i = 0; i < n; i++) {             int arrivalTime = times[i][0], leavingTime = times[i][1];             // release the chairs that are no longer occupied             while (!pq.isEmpty() && pq.peek()[0] <= arrivalTime) chairs[pq.poll()[1]] = false;             // find the first unoccupied chair             int chair = findUnoccupied(chairs);             // occupy the chair             chairs[chair] = true;             // add the chair to the priority queue             pq.offer(new int[] {leavingTime, chair});             // return the chair number if we are at the target friend             if (i == targetFriend) return chair;         }         return -1;     }          private int findUnoccupied(boolean[] chairs) {         for (int i = 0; i < chairs.length; i++) {             if (!chairs[i]) return i;         }         return -1;     } }",1,"1942-the-number-of-the-smallest-unoccupied-chair/Solution.java:12:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1942-the-number-of-the-smallest-unoccupied-chair/Solution.java:12:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"import java.util.*;  class Solution {     public List<List<Long>> splitPainting(int[][] segments) {         List<List<Long>> res = new ArrayList<>();         int[] color = new int[100001];         // use a TreeMap to track the start and end points of each color section         TreeMap<Integer, Integer> map = new TreeMap<>();         for (int[] s : segments) {             color[s[0]] += s[2];             color[s[1]] -= s[2];             map.putIfAbsent(s[0], 0);             map.putIfAbsent(s[1], 0);             map.put(s[0], map.get(s[0]) + s[2]);             map.put(s[1], map.get(s[1]) - s[2]);         }         long prev = -1;         long sum = 0;         for (Map.Entry<Integer, Integer> e : map.entrySet()) {             if (prev >= 0 && sum > 0) {                 // add a new color section to the result                 List<Long> list = new ArrayList<>();                 list.add(prev);                 list.add((long)e.getKey());                 list.add(sum);                 res.add(list);             }             prev = e.getKey();             sum += e.getValue();         }         return res;     } }",1,"1943-describe-the-painting/Solution.java:8:	LooseCoupling:	Avoid using implementation types like 'TreeMap'; use the interface instead
",0,0,0
"class Solution {     public String maximumNumber(String num, int[] change) {         char[] chars = num.toCharArray();         boolean changed = false;                  for (int i = 0; i < chars.length; i++) {             int digit = chars[i] - '0';             if (change[digit] > digit) {                 chars[i] = (char) (change[digit] + '0');                 changed = true;             } else if (changed && change[digit] < digit) {                 break;             }         }                  return new String(chars);     } }",1,"1946-largest-number-after-mutating-substring/Solution.java:16:	StringInstantiation:	Avoid instantiating String objects; this is usually unnecessary.
",0,0,0
"class Solution {     public int maxCompatibilitySum(int[][] students, int[][] mentors) {         // number of students         int m = students.length;                  // number of questions in the survey         int n = students[0].length;          // Generate all possible permutations of indices of mentors         int[] mentorIdx = new int[m];         for (int i = 0; i < m; i++) {             mentorIdx[i] = i;         }                  List<int[]> possibleMentorIdx = new ArrayList<>();         permute(mentorIdx, possibleMentorIdx, 0, m - 1);                  int maxScore = 0;                  // Iterate over all possible mentor-student pairings         for (int[] pairing : possibleMentorIdx) {             int score = 0;                          // Calculate the compatibility score for each student-mentor pairing             for (int i = 0; i < m; i++) {                 int[] studentAnswers = students[i];                 int[] mentorAnswers = mentors[pairing[i]];                                  int compatibilityScore = 0;                                  for (int j = 0; j < n; j++) {                     if (studentAnswers[j] == mentorAnswers[j]) {                         compatibilityScore++;                     }                 }                                  score += compatibilityScore;             }                          maxScore = Math.max(maxScore, score);         }                  return maxScore;     }          // This function generates all possible permutations of indices of mentors     private void permute(int[] arr, List<int[]> result, int l, int r) {         if (l == r) {             int[] tmp = new int[arr.length];             System.arraycopy(arr, 0, tmp, 0, arr.length);             result.add(tmp);         } else {             for (int i = l; i <= r; i++) {                 swap(arr, l, i);                 permute(arr, result, l + 1, r);                 swap(arr, l, i);             }         }     }          // This function swaps two elements in an array     private void swap(int[] arr, int i, int j) {         int tmp = arr[i];         arr[i] = arr[j];         arr[j] = tmp;     } }",0,,0,0,0
"class Solution {     public long numberOfWeeks(int[] milestones) {         long total = 0;         long maxMilestone = 0;         for (int milestone : milestones) {             total += milestone;             maxMilestone = Math.max(maxMilestone, milestone);         }         long sumExcludeMaxMilestone = total - maxMilestone;         if (maxMilestone <= sumExcludeMaxMilestone + 1) {             return total;         }         return 2 * sumExcludeMaxMilestone + 1;     } }",0,,0,0,0
"class Solution {     public long minimumPerimeter(long neededApples) {         long i = 0, j = 1, total = 0;         while (total < neededApples) {             long row = i + j, apples = 2 * row * (row + 1);             total += apples;             i += 2 * j; j++;         }         return 8 * (j - 1);     } }",1,"1954-minimum-garden-perimeter-to-collect-enough-apples/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1954-minimum-garden-perimeter-to-collect-enough-apples/Solution.java:5:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1954-minimum-garden-perimeter-to-collect-enough-apples/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1954-minimum-garden-perimeter-to-collect-enough-apples/Solution.java:5:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public boolean checkMove(char[][] board, int rMove, int cMove, char color) {         // helper function to check if a line is good         boolean isGoodLine = (r1, c1, r2, c2, r3, c3) -> {             if (board[r1][c1] == '.' || board[r2][c2] == '.' || board[r3][c3] == '.') {                 return false; // at least one cell is free             }             char c = board[r1][c1];             if (c != board[r2][c2] || c != board[r3][c3]) {                 return false; // endpoints have different color than middle             }             return true;         };          // check if the move is legal in any direction         char oppColor = (color == 'B') ? 'W' : 'B';         boolean legal = false;         // check horizontal left         if (cMove > 1 && board[rMove][cMove-1] == oppColor) {             for (int c = cMove-2; c >= 0; c--) {                 if (board[rMove][c] == color) {                     legal |= isGoodLine.test(rMove, c+1, rMove, cMove-1, rMove, c);                     break; // found first same color cell in row                 } else if (board[rMove][c] == '.') {                     break; // reached a free cell                 }             }         }         // check horizontal right         if (cMove < 6 && board[rMove][cMove+1] == oppColor) {             for (int c = cMove+2; c < 8; c++) {                 if (board[rMove][c] == color) {                     legal |= isGoodLine.test(rMove, cMove+1, rMove, c-1, rMove, c);                     break; // found first same color cell in row                 } else if (board[rMove][c] == '.') {                     break; // reached a free cell                 }             }         }         // check vertical up         if (rMove > 1 && board[rMove-1][cMove] == oppColor) {             for (int r = rMove-2; r >= 0; r--) {                 if (board[r][cMove] == color) {                     legal |= isGoodLine.test(r+1, cMove, rMove-1, cMove, r, cMove);                     break; // found first same color cell in column                 } else if (board[r][cMove] == '.') {                     break; // reached a free cell                 }             }         }         // check vertical down         if (rMove < 6 && board[rMove+1][cMove] == oppColor) {             for (int r = rMove+2; r < 8; r++) {                 if (board[r][cMove] == color) {                     legal |= isGoodLine.test(rMove+1, cMove, r-1, cMove, r, cMove);                     break; // found first same color cell in column                 } else if (board[r][cMove] == '.') {                     break; // reached a free cell                 }             }         }         // check diagonal up-left         if (rMove > 1 && cMove > 1 && board[rMove-1][cMove-1] == oppColor) {             for (int d = 2; rMove-d >= 0 && cMove-d >= 0; d++) {                 if (board[rMove-d][cMove-d] == color) {                     legal |= isGoodLine.test(rMove-(d-1), cMove-(d-1), rMove-1, cMove-1, rMove, cMove);                     break; // found first same color cell in diagonal                 } else if (board[rMove-d][cMove-d] == '.') {                     break; // reached a free cell                 }             }         }         // check diagonal up-right         if (rMove > 1 && cMove < 6 && board[rMove-1][cMove+1] == oppColor) {             for (int d = 2; rMove-d >= 0 && cMove+d < 8; d++) {                 if (board[rMove-d][cMove+d] == color) {                     legal |= isGoodLine.test(rMove-(d-1), cMove+(d-1), rMove-1, cMove+1, rMove, cMove);                     break; // found first same color cell in diagonal                 } else if (board[rMove-d][cMove+d] == '.') {                     break; // reached a free cell                 }             }         }         // check diagonal down-left         if (rMove < 6 && cMove > 1 && board[rMove+1][cMove-1] == oppColor) {             for (int d = 2; rMove+d < 8 && cMove-d >= 0; d++) {                 if (board[rMove+d][cMove-d] == color) {                     legal |= isGoodLine.test(rMove+(d-1), cMove-(d-1), rMove+1, cMove-1, rMove, cMove);                     break; // found first same color cell in diagonal                 } else if (board[rMove+d][cMove-d] == '.') {                     break; // reached a free cell                 }             }         }         // check diagonal down-right         if (rMove < 6 && cMove < 6 && board[rMove+1][cMove+1] == oppColor) {             for (int d = 2; rMove+d < 8 && cMove+d < 8; d++) {                 if (board[rMove+d][cMove+d] == color) {                     legal |= isGoodLine.test(rMove+(d-1), cMove+(d-1), rMove+1, cMove+1, rMove, cMove);                     break; // found first same color cell in diagonal                 } else if (board[rMove+d][cMove+d] == '.') {                     break; // reached a free cell                 }             }         }         return legal;     } }",1,"1958-check-if-move-is-legal/Solution.java:2:	NcssCount:	The method 'checkMove(char[][], int, int, char)' has a NCSS line count of 75.
1958-check-if-move-is-legal/Solution.java:2:	NPathComplexity:	The method 'checkMove(char[][], int, int, char)' has an NPath complexity of 127401984, current threshold is 200
1958-check-if-move-is-legal/Solution.java:9:	SimplifyBooleanReturns:	This if statement can be replaced by `return !{condition};`
1958-check-if-move-is-legal/Solution.java:77:	UselessParentheses:	Useless parentheses.
1958-check-if-move-is-legal/Solution.java:88:	UselessParentheses:	Useless parentheses.
1958-check-if-move-is-legal/Solution.java:99:	UselessParentheses:	Useless parentheses.
1958-check-if-move-is-legal/Solution.java:99:	UselessParentheses:	Useless parentheses.
",0,0,0
"class Solution {     public int minSpaceWastedKResizing(int[] nums, int k) {         int n = nums.length;         int[][] dp = new int[n][k+1];         for(int i=0; i<n; i++) {             Arrays.fill(dp[i], -1);         }         return dfs(nums, 0, k, dp);     }          private int dfs(int[] nums, int i, int k, int[][] dp) {         int n = nums.length;         if(i == n) {             return 0;         }         if(k < 0) {             return Integer.MAX_VALUE/2;         }         if(dp[i][k] != -1) {             return dp[i][k];         }         int max = nums[i];         int sum = nums[i];         int ans = Integer.MAX_VALUE/2;         for(int j=i; j<n; j++) {             max = Math.max(max, nums[j]);             sum += nums[j];             int wasted = max * (j-i+1) - sum;             ans = Math.min(ans, wasted + dfs(nums, j+1, k-1, dp));         }         dp[i][k] = ans;         return ans;     } }",0,,0,0,0
"class Solution {     public int minStoneSum(int[] piles, int k) {         PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());         int sum = 0;         for (int stone : piles) {             sum += stone;             pq.offer(stone);         }         while (k-- > 0) {             int removed = pq.poll();             sum -= removed / 2;             pq.offer(removed - removed / 2);         }         return sum;     } }",1,"1962-remove-stones-to-minimize-the-total/Solution.java:9:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'k'
",0,1,0
class Solution {     public int minSwaps(String s) {         int swaps = 0;         int openBrackets = 0;         for (int i = 0; i < s.length(); i++) {             if (s.charAt(i) == '[') {                 openBrackets++;             } else if (openBrackets > 0) {                 openBrackets--;             } else {                 swaps++;             }         }         return swaps;     } },0,,0,0,0
"class Solution {     public int[] rearrangeArray(int[] nums) {         Arrays.sort(nums);         int n = nums.length;         int[] ans = new int[n];         int i = 0, j = n - 1;         for (int k = 0; k < n; k++) {             if (k % 2 == 0)                 ans[k] = nums[i++];             else                 ans[k] = nums[j--];         }         return ans;     } }",1,"1968-array-with-elements-not-equal-to-average-of-neighbors/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1968-array-with-elements-not-equal-to-average-of-neighbors/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"import java.math.BigInteger;  class Solution {     public int minNonZeroProduct(int p) {         BigInteger mod = BigInteger.valueOf(1000000007); // Modulus         BigInteger n = BigInteger.valueOf(2).pow(p).subtract(BigInteger.ONE); // Total numbers         BigInteger m = BigInteger.valueOf(2).pow(p - 1).subtract(BigInteger.ONE); // Count of swaps         BigInteger ans = n.subtract(BigInteger.ONE).modPow(m, mod);         ans = ans.multiply(n).mod(mod);         return ans.intValue();     } }",0,,0,0,0
class Solution {     public long maxMatrixSum(int[][] matrix) {                  int n = matrix.length;         long sum = 0;         int minNeg = Integer.MAX_VALUE;         int countNeg = 0;                  for(int i=0; i<n; i++) {             for(int j=0; j<n; j++) {                 int num = matrix[i][j];                                  // add absolute value of num to sum                 // count negative numbers                 if(num < 0) {                     countNeg++;                     num = -num;                 }                 sum += num;                                  // track minimum absolute value negative number                 if(num < minNeg) {                     minNeg = num;                 }             }         }                  // if there are an even number of negative numbers         // we can make all of them positive         if(countNeg % 2 == 0) {             return sum;         }                   // if there are an odd number of negative numbers         // we make one negative number positive to maximize sum         return sum - 2*minNeg;     } },0,,0,0,0
"class Solution {     public int countPaths(int n, int[][] roads) {         // initialize adjacency matrix         long[][] adjMatrix = new long[n][n];         for (int i = 0; i < n; i++) {             for (int j = 0; j < n; j++) {                 adjMatrix[i][j] = Long.MAX_VALUE;             }         }         for (int i = 0; i < n; i++) {             adjMatrix[i][i] = 0;         }         for (int[] road : roads) {             int u = road[0];             int v = road[1];             int time = road[2];             adjMatrix[u][v] = time;             adjMatrix[v][u] = time;         }         // Floyd-Warshall algorithm         for (int k = 0; k < n; k++) {             for (int i = 0; i < n; i++) {                 for (int j = 0; j < n; j++) {                     if (adjMatrix[i][k] != Long.MAX_VALUE && adjMatrix[k][j] != Long.MAX_VALUE) {                         adjMatrix[i][j] = Math.min(adjMatrix[i][j], adjMatrix[i][k] + adjMatrix[k][j]);                     }                 }             }         }         // count number of shortest paths using dynamic programming         int mod = 1000000007;         int[] numShortestPaths = new int[n];         numShortestPaths[0] = 1;         for (int i = 1; i < n; i++) {             for (int j = 0; j < i; j++) {                 if (adjMatrix[j][i] == adjMatrix[0][i] - adjMatrix[0][j]) {                     numShortestPaths[i] = (numShortestPaths[i] + numShortestPaths[j]) % mod;                 }             }         }         return numShortestPaths[n - 1];     } }",1,"1976-number-of-ways-to-arrive-at-destination/Solution.java:2:	NPathComplexity:	The method 'countPaths(int, int[][])' has an NPath complexity of 288, current threshold is 200
",0,0,0
"class Solution {     public int rob(int[] nums) {         int n = nums.length;         if (n == 1) {             return nums[0];         }         int[] dp = new int[n];         dp[0] = nums[0];         dp[1] = Math.max(nums[0], nums[1]);         for (int i = 2; i < n; i++) {             dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);         }         return dp[n - 1];     } }",0,,0,0,0
"class Solution {     public String findDifferentBinaryString(String[] nums) {         Set<String> set = new HashSet<>();         // Add all the binary strings to the set         for (String num : nums) {             set.add(num);         }         // Iterate over all the possible binary strings of length n         int n = nums[0].length();         for (int i = 0; i < Math.pow(2, n); i++) {             String binaryStr = Integer.toBinaryString(i);             // Pad with leading zeros if necessary             while (binaryStr.length() < n) {                 binaryStr = ""0"" + binaryStr;             }             if (!set.contains(binaryStr)) {                 return binaryStr;             }         }         return """";     } }",1,"1980-find-unique-binary-string/Solution.java:14:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
",0,0,0
"class Solution {     public int minimizeTheDifference(int[][] mat, int target) {         int m = mat.length;         int n = mat[0].length;         boolean[][] dp = new boolean[m][800 + 1]; // max target value is 800         for (int j = 0; j < n; j++) {             dp[0][mat[0][j]] = true; // initialize the first row         }         for (int i = 1; i < m; i++) {             for (int j = 0; j < n; j++) {                 for (int k = 0; k <= 800; k++) {                     if (dp[i - 1][k]) {                         dp[i][k+mat[i][j]] = true; // update the possible sum                     }                 }             }         }         int res = Integer.MAX_VALUE;         for (int k = 0; k <= 800; k++) {             if (dp[m-1][k]) {                 res = Math.min(res, Math.abs(k - target));             }         }         return res;     } }",0,,0,0,0
"import java.util.PriorityQueue;  class Solution {     public String kthLargestNumber(String[] nums, int k) {         PriorityQueue<String> pq = new PriorityQueue<>((a, b) -> {             if (a.length() != b.length()) {                 return a.length() - b.length();             } else {                 return a.compareTo(b);             }         });         for (String num : nums) {             pq.offer(num);             if (pq.size() > k) {                 pq.poll();             }         }         return pq.peek();     } }",1,"1985-find-the-kth-largest-integer-in-the-array/Solution.java:5:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
1985-find-the-kth-largest-integer-in-the-array/Solution.java:6:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",0,0,0
"class Solution {     int ans=Integer.MAX_VALUE;       public int minSessions(int[] tasks, int sessionTime) {         Arrays.sort(tasks);         backtrack(tasks,new int[tasks.length],sessionTime,0,0);         return ans;     }          void backtrack(int[] tasks,int[] freq,int sessionTime,int currTime,int numSessions){         if(numSessions>=ans) return;         boolean done=true;         for(int i=0;i<freq.length;i++){             if(freq[i]==0){                 done=false;                 break;             }         }         if(done){             ans=Math.min(ans,numSessions);             return;         }         for(int i=0;i<tasks.length;i++){             if(freq[i]==0&&currTime+tasks[i]<=sessionTime){                 freq[i]=1;                 backtrack(tasks,freq,sessionTime,currTime+tasks[i],numSessions);                 freq[i]=0;             }else if(currTime==0) continue;             else{                 backtrack(tasks,freq,sessionTime,0,numSessions+1);                 break;             }                          }     } }",1,"1986-minimum-number-of-work-sessions-to-finish-the-tasks/Solution.java:2:9: Variable 'ans' must be private and have accessor methods. [VisibilityModifier]
1986-minimum-number-of-work-sessions-to-finish-the-tasks/Solution.java:2:9: Variable 'ans' must be private and have accessor methods. [VisibilityModifier]
1986-minimum-number-of-work-sessions-to-finish-the-tasks/Solution.java:13:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"import java.util.ArrayList; import java.util.List;  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public List<Integer> rightSideView(TreeNode root) {         List<Integer> result = new ArrayList<>();         dfs(root, 0, result);         return result;     }          private void dfs(TreeNode node, int depth, List<Integer> result) {         if (node == null) {             return;         }                  if (depth == result.size()) {             // we haven't seen a node at this depth yet             result.add(node.val);         } else {             // we have seen a node at this depth             result.set(depth, node.val);         }                  dfs(node.left, depth + 1, result);         dfs(node.right, depth + 1, result);     } }",0,,0,0,0
"class Solution {     public int[][] findFarmland(int[][] land) {         List<int[]> groups = new ArrayList<>();         int m = land.length, n = land[0].length;                  for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 if (land[i][j] == 1) {                     int r1 = i, c1 = j;                     while (r1 < m && land[r1][j] == 1) {                         r1++;                     }                     r1--;                     while (c1 < n && land[i][c1] == 1) {                         c1++;                     }                     c1--;                     if (isValidGroup(land, i, j, r1, c1)) {                         groups.add(new int[]{i, j, r1, c1});                     }                 }             }         }         int[][] res = new int[groups.size()][4];         for (int i = 0; i < groups.size(); i++) {             res[i] = groups.get(i);         }         return res;     }          private boolean isValidGroup(int[][] land, int r1, int c1, int r2, int c2) {         for (int i = r1; i <= r2; i++) {             for (int j = c1; j <= c2; j++) {                 if (land[i][j] != 1) {                     return false;                 }             }         }         return true;     } }",1,"1992-find-all-groups-of-farmland/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1992-find-all-groups-of-farmland/Solution.java:9:21: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1992-find-all-groups-of-farmland/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1992-find-all-groups-of-farmland/Solution.java:9:21: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int[][] findFarmland(int[][] land) {         List<int[]> groups = new ArrayList<>();         int m = land.length, n = land[0].length;                  for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 if (land[i][j] == 1) {                     int r1 = i, c1 = j;                     while (r1 < m && land[r1][j] == 1) {                         r1++;                     }                     r1--;                     while (c1 < n && land[i][c1] == 1) {                         c1++;                     }                     c1--;                     if (isValidGroup(land, i, j, r1, c1)) {                         groups.add(new int[]{i, j, r1, c1});                     }                 }             }         }         int[][] res = new int[groups.size()][4];         for (int i = 0; i < groups.size(); i++) {             res[i] = groups.get(i);         }         return res;     }          private boolean isValidGroup(int[][] land, int r1, int c1, int r2, int c2) {         for (int i = r1; i <= r2; i++) {             for (int j = c1; j <= c2; j++) {                 if (land[i][j] != 1) {                     return false;                 }             }         }         return true;     } }",0,,0,0,0
"class Solution {     public int numberOfWeakCharacters(int[][] properties) {         Arrays.sort(properties, (a, b) -> {             if (a[0] != b[0]) {                 return b[0] - a[0];             } else {                 return a[1] - b[1];             }         });          int count = 0;         int maxDefense = 0;          for (int[] p : properties) {             if (p[1] < maxDefense) {                 count++;             } else {                 maxDefense = p[1];             }         }          return count;     } }",1,"1996-the-number-of-weak-characters-in-the-game/Solution.java:4:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",0,0,0
class Solution {     public int firstDayBeenInAllRooms(int[] nextVisit) {         int n = nextVisit.length;         int mod = (int) 1e9 + 7;         int[] dp = new int[n];         for (int i = 0; i < n - 1; i++) {             dp[i + 1] = (2 * dp[i] - dp[nextVisit[i]] + 2 + mod) % mod;         }         return dp[n - 1];     } },0,,0,0,0
"class Solution {     public int numIslands(char[][] grid) {         int m = grid.length;         int n = grid[0].length;         int count = 0;          for(int i = 0; i < m; i++) {             for(int j = 0; j < n; j++) {                 if(grid[i][j] == '1') {                     count++;                     dfs(grid, i, j);                 }             }         }          return count;     }      private void dfs(char[][] grid, int i, int j) {          if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == '0')             return;          grid[i][j] = '0';          dfs(grid, i+1, j);         dfs(grid, i-1, j);         dfs(grid, i, j+1);         dfs(grid, i, j-1);      } }",0,,0,0,0
"class Solution {     public long interchangeableRectangles(int[][] rectangles) {         Map<Double, Integer> map = new HashMap<>();         long count = 0;         for(int[] rectangle : rectangles) {             double ratio = (double) rectangle[0] / rectangle[1];             if(map.containsKey(ratio)) {                 count += map.get(ratio); // add the number of occurrences of this ratio to count             }             map.put(ratio, map.getOrDefault(ratio, 0) + 1); // update the ratio count in the map         }         return count;     } }",0,,0,0,0
"class Solution {     public int maxProduct(String s) {         int n = s.length();         int maxProd = 1;         for(int i = 0; i < (1<<n); i++) {             StringBuilder sb1 = new StringBuilder();             StringBuilder sb2 = new StringBuilder();             for(int j = 0; j < n; j++) {                 if(((i>>j)&1) == 1) {                     sb1.append(s.charAt(j));                 } else {                     sb2.append(s.charAt(j));                 }             }             if(isPalindrome(sb1.toString()) && isPalindrome(sb2.toString())) {                 maxProd = Math.max(maxProd, sb1.length() * sb2.length());             }         }         return maxProd;     }          public boolean isPalindrome(String s) {         int n = s.length();         for(int i = 0; i < n/2; i++) {             if(s.charAt(i) != s.charAt(n-i-1)) {                 return false;             }         }         return true;     } }",0,,0,0,0
"import java.util.*;  class Solution {     public int[] findOriginalArray(int[] changed) {         if (changed.length % 2 != 0) {             return new int[0]; // if the length of changed is odd, it can't be doubled         }                  Map<Integer, Integer> counts = new HashMap<>();         for (int num : changed) {             counts.put(num, counts.getOrDefault(num, 0) + 1);         }                  int[] original = new int[changed.length/2];         int index = 0;         for (int num : changed) {             int doubled = num * 2;             if (counts.getOrDefault(num, 0) == 0) {                 continue; // we've already used up all occurrences of num             } else if (counts.getOrDefault(doubled, 0) == 0) {                 return new int[0]; // no corresponding doubled element             } else {                 original[index++] = num;                 counts.put(num, counts.get(num) - 1);                 counts.put(doubled, counts.get(doubled) - 1);             }         }                  return original;     } }",1,"2007-find-original-array-from-doubled-array/Solution.java:9:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
",0,0,0
"class Solution {     public long maxTaxiEarnings(int n, int[][] rides) {         // sort rides by earliest end time         Arrays.sort(rides, (a, b) -> a[1] - b[1]);                  long[] dp = new long[n + 1]; // dp[i] is the max earnings at location i                  int rideIdx = 0; // pointer for rides                  for (int loc = 1; loc <= n; loc++) {             // calculate the max earnings without taking any rides from current location             dp[loc] = dp[loc - 1];                          // check if we can take any rides from the current location             while (rideIdx < rides.length && rides[rideIdx][1] == loc) {                 int start = rides[rideIdx][0];                 int end = rides[rideIdx][1];                 int tip = rides[rideIdx][2];                                  // update max earnings at location end                 dp[end] = Math.max(dp[end], dp[start] + end - start + tip);                                  // move to the next ride                 rideIdx++;             }         }                  return dp[n];     } }",1,"2008-maximum-earnings-from-taxi/Solution.java:10:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
",0,0,0
"class Solution {     public int rangeBitwiseAnd(int left, int right) {         int shift = 0; // initialize shift to 0                  // while left and right are not same         while(left != right){             left >>= 1; // shift right             right >>= 1; // shift right             shift++; // increment the shift count         }                  // return either left or right bit-shifted to the left by the shift count         return left << shift;     } }",1,"201-bitwise-and-of-numbers-range/Solution.java:7:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'left'
201-bitwise-and-of-numbers-range/Solution.java:8:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'right'
",0,1,0
"class Solution {     public int sumOfBeauties(int[] nums) {         int n = nums.length;         int[] maxFromLeft = new int[n];         int[] minFromRight = new int[n];                  maxFromLeft[0] = nums[0];         for (int i = 1; i < n; i++) {             maxFromLeft[i] = Math.max(maxFromLeft[i-1], nums[i]);         }                  minFromRight[n-1] = nums[n-1];         for (int i = n-2; i >= 0; i--) {             minFromRight[i] = Math.min(minFromRight[i+1], nums[i]);         }                  int sum = 0;         for (int i = 1; i < n-1; i++) {             if (nums[i] > maxFromLeft[i-1] && nums[i] < minFromRight[i+1]) {                 sum += 2;             } else if (nums[i] > nums[i-1] && nums[i] < nums[i+1]) {                 sum += 1;             }         }                  return sum;     } }",0,,0,0,0
"import java.util.*;  class DetectSquares {      Map<Integer, List<Integer>> xMap;      public DetectSquares() {         xMap = new HashMap<>();     }      public void add(int[] point) {         int x = point[0];         int y = point[1];                  if (!xMap.containsKey(x)) {             xMap.put(x, new ArrayList<>());         }         xMap.get(x).add(y);     }      public int count(int[] point) {         int x = point[0];         int y = point[1];         int count = 0;                  if (!xMap.containsKey(x)) {             return count;         }         List<Integer> yList = xMap.get(x);         for (int y1 : yList) {             if (y1 != y) {                 int dx = Math.abs(x - x1);                 int x2 = x + dx;                 int y2 = y1;                 int y3 = y + dx;                 if (xMap.containsKey(x2) && xMap.get(x2).contains(y2) && xMap.get(x2).contains(y3)) {                     count++;                 }                 y3 = y - dx;                 if (xMap.containsKey(x2) && xMap.get(x2).contains(y2) && xMap.get(x2).contains(y3)) {                     count++;                 }             }         }         return count;     } }  /**  * Your DetectSquares object will be instantiated and called as such:  * DetectSquares obj = new DetectSquares();  * obj.add(point);  * int param_2 = obj.count(point);  */",1,"2013-detect-squares/DetectSquares.java:5:33: Variable 'xMap' must be private and have accessor methods. [VisibilityModifier]
2013-detect-squares/DetectSquares.java:7:5: Redundant 'public' modifier. [RedundantModifier]
2013-detect-squares/DetectSquares.java:5:33: Variable 'xMap' must be private and have accessor methods. [VisibilityModifier]
2013-detect-squares/DetectSquares.java:7:5: Redundant 'public' modifier. [RedundantModifier]
",0,0,0
"class Solution {     public long gridGame(int[][] grid) {         int n = grid[0].length;         long[] preSumTop = new long[n+1];         long[] preSumBot = new long[n+1];                  // calculating prefix sums for top and bottom rows         for(int i=1; i<=n; i++){             preSumTop[i] = preSumTop[i-1] + (long)grid[0][i-1];             preSumBot[i] = preSumBot[i-1] + (long)grid[1][i-1];         }                  long ans = Long.MAX_VALUE;         // Trying all possible positions for the top robot         for(int i=0; i<n; i++){             long topScore = preSumBot[n] - preSumBot[i+1]; // score by top robot              long botScore = preSumTop[i]; // score by bottom robot             ans = Math.min(ans, Math.max(topScore, botScore)); // updating ans         }         return ans;     } }",1,"2017-grid-game/Solution.java:9:	UnnecessaryCast:	Unnecessary cast (long)
2017-grid-game/Solution.java:10:	UnnecessaryCast:	Unnecessary cast (long)
",0,0,0
"class Solution {     public boolean placeWordInCrossword(char[][] board, String word) {         int row = board.length;         int col = board[0].length;         //Horizontal check         for(int i=0; i<row; i++) {             for(int j=0; j<=col-word.length(); j++) {                 boolean is_valid = true;                 for(int k=0; k<word.length(); k++) {                     if(board[i][j+k] != ' ' && board[i][j+k] != word.charAt(k)) {                         is_valid = false;                         break;                     }                     if(i > 0 && board[i-1][j+k] != '#' && board[i-1][j+k] != ' ') {                         is_valid = false;                         break;                     }                     if(i < row-1 && board[i+1][j+k] != '#' && board[i+1][j+k] != ' ') {                         is_valid = false;                         break;                     }                 }                 if(is_valid) return true;             }         }                  //Vertical check         for(int i=0; i<=row-word.length(); i++) {             for(int j=0; j<col; j++) {                 boolean is_valid = true;                 for(int k=0; k<word.length(); k++) {                     if(board[i+k][j] != ' ' && board[i+k][j] != word.charAt(k)) {                         is_valid = false;                         break;                     }                     if(j > 0 && board[i+k][j-1] != '#' && board[i+k][j-1] != ' ') {                         is_valid = false;                         break;                     }                     if(j < col-1 && board[i+k][j+1] != '#' && board[i+k][j+1] != ' ') {                         is_valid = false;                         break;                     }                 }                 if(is_valid) return true;             }         }         return false;     } }",1,"2018-check-if-word-can-be-placed-in-crossword/Solution.java:2:	NPathComplexity:	The method 'placeWordInCrossword(char[][], String)' has an NPath complexity of 10000, current threshold is 200
",0,0,0
"class Solution {     public int numOfPairs(String[] nums, String target) {         int count = 0;         for (int i = 0; i < nums.length; i++) {             for (int j = 0; j < nums.length; j++) {                 if (i != j && (nums[i] + nums[j]).equals(target)) {                     count++;                 }             }         }         return count;     } }",0,,0,0,0
"class Solution {     public int maxConsecutiveAnswers(String answerKey, int k) {         int n = answerKey.length();         int maxCount = 0; // variable to store the maximum consecutive count of T or F         int left = 0; // left pointer for the window         int right = 0; // right pointer for the window         int tCount = 0; // variable to store the count of T in the window         int fCount = 0; // variable to store the count of F in the window                  // sliding window approach         while (right < n) {             if (answerKey.charAt(right) == 'T') {                 tCount++;             } else {                 fCount++;             }                          // if the number of falses in the window exceeds k, move the left pointer ahead and decrease the count of the answer it was pointing to. Set that answer to unvisited state.             while (fCount > k) {                 if (answerKey.charAt(left) == 'T') {                     tCount--;                 } else {                     fCount--;                 }                 left++;             }                          // if the number of trues in the window exceeds k, move the left pointer ahead and decrease the count of the answer it was pointing to. Set that answer to unvisited state.             while (tCount > k) {                 if (answerKey.charAt(left) == 'T') {                     tCount--;                 } else {                     fCount--;                 }                 left++;             }                          // update the maximum count             maxCount = Math.max(maxCount, tCount + fCount);                          // move the right pointer ahead             right++;         }                  return maxCount;     } }",0,,0,0,0
"class Solution {     public int[] missingRolls(int[] rolls, int mean, int n) {         int m = rolls.length;         int sum = 0;         for (int i = 0; i < m; i++) {             sum += rolls[i];         }         int totalSum = mean * (n + m);         int missingSum = totalSum - sum;         if (missingSum < n || missingSum > n * 6) {             return new int[0];         }         int[] result = new int[n];         int avgMissingVal = missingSum / n;         int leftOverMissingSum = missingSum % n;         for (int i = 0; i < n; i++) {             if (leftOverMissingSum > 0) {                 result[i] = avgMissingVal + 1;                 leftOverMissingSum--;             } else {                 result[i] = avgMissingVal;             }         }         return result;     } }",0,,0,0,0
"class Solution {     public boolean stoneGameIX(int[] stones) {         int[] cnt = new int[3];         for (int s : stones) {             cnt[s % 3]++;         }         int min = Math.min(cnt[1],cnt[2]);         int d = Math.abs(cnt[1]-cnt[2]);         if (d >= 3) {             return cnt[0] > 0;         } else if (d == 0) {             return cnt[0] % 2 == 0;         } else {             if (min == 0) {                 return false;             } else {                 return cnt[0] % 2 == 0 && min % 2 == 0;             }         }     } }",0,,0,0,0
"class Solution {     public int minOperations(int[][] grid, int x) {         int m = grid.length, n = grid[0].length;           int[] arr = new int[m * n];  // Flatten the grid into a 1D array         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 arr[i * n + j] = grid[i][j];             }         }         Arrays.sort(arr);  // Sort the array in ascending order         int median = arr[arr.length / 2];  // Get the median element         int operations = 0;         for (int num : arr) {             if (Math.abs(num - median) % x != 0) {  // Check if the difference is divisible by x                 return -1;             }             operations += Math.abs(num - median) / x;  // Calculate the number of operations required         }         return operations;     } }",1,"2033-minimum-operations-to-make-a-uni-value-grid/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2033-minimum-operations-to-make-a-uni-value-grid/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"import java.util.*;  class StockPrice {      private Map<Integer, Integer> prices;     private TreeSet<Integer> timestamps;      public StockPrice() {         prices = new HashMap<>();         timestamps = new TreeSet<>();     }          public void update(int timestamp, int price) {         if (prices.containsKey(timestamp)) {             timestamps.remove(timestamp);         }         prices.put(timestamp, price);         timestamps.add(timestamp);     }          public int current() {         return prices.get(timestamps.last());     }          public int maximum() {         return prices.entrySet().stream().max(Map.Entry.comparingByValue()).get().getValue();     }          public int minimum() {         return prices.entrySet().stream().min(Map.Entry.comparingByValue()).get().getValue();     } }  /**  * Your StockPrice object will be instantiated and called as such:  * StockPrice obj = new StockPrice();  * obj.update(timestamp,price);  * int param_2 = obj.current();  * int param_3 = obj.maximum();  * int param_4 = obj.minimum();  */",1,"2034-stock-price-fluctuation/StockPrice.java:8:5: Redundant 'public' modifier. [RedundantModifier]
2034-stock-price-fluctuation/StockPrice.java:8:5: Redundant 'public' modifier. [RedundantModifier]
2034-stock-price-fluctuation/StockPrice.java:6:	LooseCoupling:	Avoid using implementation types like 'TreeSet'; use the interface instead
",0,0,0
"class Solution {     public boolean winnerOfGame(String colors) {         int n = colors.length();         int aliceScore = 0, bobScore = 0;         for (int i = 1; i < n - 1; i++) {             // check for Alice's move             if (colors.charAt(i) == 'A' && colors.charAt(i - 1) == 'A' && colors.charAt(i + 1) == 'A') {                 aliceScore++;             }             // check for Bob's move             else if (colors.charAt(i) == 'B' && colors.charAt(i - 1) == 'B' && colors.charAt(i + 1) == 'B') {                 bobScore++;             }         }         return (aliceScore > bobScore);     } }",1,"2038-remove-colored-pieces-if-both-neighbors-are-the-same-color/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2038-remove-colored-pieces-if-both-neighbors-are-the-same-color/Solution.java:9:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2038-remove-colored-pieces-if-both-neighbors-are-the-same-color/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2038-remove-colored-pieces-if-both-neighbors-are-the-same-color/Solution.java:9:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2038-remove-colored-pieces-if-both-neighbors-are-the-same-color/Solution.java:15:	UselessParentheses:	Useless parentheses.
",1,0,0
"import java.util.*;  class Solution {     public int networkBecomesIdle(int[][] edges, int[] patience) {         // Build adjacency list to represent the network         int n = patience.length;         List<Integer>[] adjList = new List[n];         for (int i = 0; i < n; i++) {             adjList[i] = new ArrayList<>();         }         for (int[] edge : edges) {             int u = edge[0], v = edge[1];             adjList[u].add(v);             adjList[v].add(u);         }                  // BFS to compute the shortest distances to the master server         Queue<Integer> queue = new LinkedList<>();         queue.offer(0);         int[] dist = new int[n];         Arrays.fill(dist, Integer.MAX_VALUE);         dist[0] = 0;         while (!queue.isEmpty()) {             int u = queue.poll();             for (int v : adjList[u]) {                 if (dist[v] == Integer.MAX_VALUE) {                     dist[v] = dist[u] + 1;                     queue.offer(v);                 }             }         }                  // Compute the delivery times for each message         int maxTime = 0;         for (int i = 1; i < n; i++) {             int distToMaster = dist[i] * 2;             int numCycles = (distToMaster + patience[i] - 1) / patience[i];             int deliveryTime = numCycles * patience[i] + distToMaster;             maxTime = Math.max(maxTime, deliveryTime);         }                  // Compute the earliest second starting from which the network becomes idle         int idleTime = 2 * (maxTime - 1);         int numMessages = 0;         for (int i = 1; i < n; i++) {             int distToMaster = dist[i] * 2;             int numCycles = (idleTime + patience[i] - distToMaster - 1) / patience[i];             numMessages += numCycles + 1;         }         return idleTime + 1 + numMessages;     } }",1,"2039-the-time-when-the-network-becomes-idle/Solution.java:12:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2039-the-time-when-the-network-becomes-idle/Solution.java:12:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int countPrimes(int n) {         boolean[] primes = new boolean[n];          // initialize all elements of primes array to true         for (int i = 2; i < n; i++) {             primes[i] = true;         }          // sieve of Eratosthenes algorithm         for (int p = 2; p * p < n; p++) {             // If prime[p] is not changed, then it is a prime             if (primes[p] == true) {                 // Update all multiples of p                 for (int i = p * p; i < n; i += p) {                     primes[i] = false;                 }             }         }          int count = 0;          // Count the number of prime numbers less than n         for (int i = 2; i < n; i++) {             if (primes[i] == true) {                 count++;             }         }          return count;     } }",1,"204-count-primes/Solution.java:13:27: Expression can be simplified. [SimplifyBooleanExpression]
204-count-primes/Solution.java:25:27: Expression can be simplified. [SimplifyBooleanExpression]
204-count-primes/Solution.java:13:27: Expression can be simplified. [SimplifyBooleanExpression]
204-count-primes/Solution.java:25:27: Expression can be simplified. [SimplifyBooleanExpression]
204-count-primes/Solution.java:13:	SimplifyBooleanExpressions:	Avoid unnecessary comparisons in boolean expressions
204-count-primes/Solution.java:25:	SimplifyBooleanExpressions:	Avoid unnecessary comparisons in boolean expressions
",0,0,0
"class Bank {          private long[] balance; // array to store account balances          public Bank(long[] balance) {         this.balance = balance; // initialize balances     }          public boolean transfer(int account1, int account2, long money) {         // check if accounts are valid and have enough balance         if (validAccount(account1) && validAccount(account2) && balance[account1-1] >= money) {             balance[account1-1] -= money; // withdraw money from account1             balance[account2-1] += money; // deposit money to account2             return true;         }         return false; // invalid transaction     }          public boolean deposit(int account, long money) {         // check if account is valid         if (validAccount(account)) {             balance[account-1] += money; // deposit money to account             return true;         }         return false; // invalid transaction     }          public boolean withdraw(int account, long money) {         // check if account is valid and has enough balance         if (validAccount(account) && balance[account-1] >= money) {             balance[account-1] -= money; // withdraw money from account             return true;         }         return false; // invalid transaction     }          private boolean validAccount(int account) {         // check if account number is valid         return account >= 1 && account <= balance.length;     } }  /**  * Your Bank object will be instantiated and called as such:  * Bank obj = new Bank(balance);  * boolean param_1 = obj.transfer(account1,account2,money);  * boolean param_2 = obj.deposit(account,money);  * boolean param_3 = obj.withdraw(account,money);  */",1,"2043-simple-bank-system/Bank.java:5:5: Redundant 'public' modifier. [RedundantModifier]
2043-simple-bank-system/Bank.java:5:24: 'balance' hides a field. [HiddenField]
2043-simple-bank-system/Bank.java:5:5: Redundant 'public' modifier. [RedundantModifier]
2043-simple-bank-system/Bank.java:5:24: 'balance' hides a field. [HiddenField]
2043-simple-bank-system/Bank.java:6:	ArrayIsStoredDirectly:	The user-supplied array 'balance' is stored directly.
",0,0,0
class Solution {          public int countMaxOrSubsets(int[] nums) {         int maxOr = 0;         int countMaxOr = 0;         int len = nums.length;                  // loop through all possible subsets         for(int i=0; i<(1<<len); i++) {             int curOr = 0;             boolean isValidSubset = false;                          // loop through the numbers in the subset             for(int j=0; j<len; j++) {                                  // add the number to the subset if the jth bit is set in i                 if((i&(1<<j)) != 0) {                     curOr |= nums[j];                     isValidSubset = true;                 }             }                          // check if the current subset is valid and has maximum bitwise OR             if(isValidSubset && curOr > maxOr) {                 maxOr = curOr;                 countMaxOr = 1;             } else if(isValidSubset && curOr == maxOr) {                 countMaxOr++;             }         }                  return countMaxOr;     } },0,,0,0,0
 class Solution {     public int nextBeautifulNumber(int n) {         int[] freq = new int[10]; // store the frequency of each digit in n         int number = n + 1; // start from the next number         while (true) {             int num = number;             boolean isBalanced = true;             while (num > 0) {                 int digit = num % 10;                 freq[digit]++;                 num /= 10;             }             // check if the number is numerically balanced             for (int i = 0; i < 10; i++) {                 if ((freq[i] > 0 && freq[i] != i) || (freq[i] == 0 && i > 0)) {                     isBalanced = false;                     break;                 }             }             if (isBalanced) {                 return number;             }             // reset the frequency array for the next number             for (int i = 0; i < 10; i++) {                 freq[i] = 0;             }             number++; // check the next number         }     } }  ,0,,0,0,0
class Solution {     public int countHighestScoreNodes(int[] parents) {         int n = parents.length;         int[] subtreeSize = new int[n];         int[] score = new int[n];                  // Calculate subtree sizes bottom-up (start from leaves)         for (int i = n - 1; i >= 0; i--) {             if (subtreeSize[i] == 0) {                 subtreeSize[i] = 1;             }             if (parents[i] != -1) {                 subtreeSize[parents[i]] += subtreeSize[i];             }         }                  // Calculate scores top-down (start from root)         int maxScore = 0;         for (int i = 0; i < n; i++) {             if (subtreeSize[i] > 0 && parents[i] != -1) {                 score[i] = subtreeSize[0] - subtreeSize[i];                 score[i] *= subtreeSize[i];             }             if (score[i] > maxScore) {                 maxScore = score[i];             }         }                  // Count nodes with highest score         int count = 0;         for (int i = 0; i < n; i++) {             if (score[i] == maxScore) {                 count++;             }         }                  return count;     } },0,,0,0,0
"class Solution {     public int maxTwoEvents(int[][] events) {         int n = events.length;         int[][] dp = new int[n+1][3];         Arrays.fill(dp[0], Integer.MIN_VALUE);         Arrays.sort(events, (a, b) -> a[1] - b[1]);                   for(int i=1; i<=n; i++) {             for(int j=0; j<3; j++) {                 int end = events[i-1][0], value = events[i-1][2];                 int event = Arrays.binarySearch(events, new int[]{0, end+1, 0},                                                   (a, b) -> a[1] - b[1]);                 event = event < 0 ? -(event+1) : event+1;                                  if(j < 2) dp[i][j] = Math.max(dp[i][j], dp[i-1][j]);                 if(event <= n) dp[event][j%2+1] = Math.max(dp[event][j%2+1], dp[i-1][j]+value);             }         }         return Math.max(dp[n][1], dp[n][2]);     } }",1,"2054-two-best-non-overlapping-events/Solution.java:10:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2054-two-best-non-overlapping-events/Solution.java:10:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int[] platesBetweenCandles(String s, int[][] queries) {         int n = s.length();         int[] leftCandles = new int[n];         int[] rightCandles = new int[n];          // find leftmost candle of each plate         int leftCandleIdx = -1;         for (int i = 0; i < n; i++) {             if (s.charAt(i) == '|') {                 leftCandleIdx = i;             } else if (s.charAt(i) == '*') {                 leftCandles[i] = leftCandleIdx;             }         }          // find rightmost candle of each plate         int rightCandleIdx = -1;         for (int i = n - 1; i >= 0; i--) {             if (s.charAt(i) == '|') {                 rightCandleIdx = i;             } else if (s.charAt(i) == '*') {                 rightCandles[i] = rightCandleIdx;             }         }          // answer queries         int[] answer = new int[queries.length];         for (int i = 0; i < queries.length; i++) {             int left = queries[i][0];             int right = queries[i][1];             int count = 0;             for (int j = left + 1; j < right; j++) {                 if (s.charAt(j) == '*'                     && leftCandles[j] >= left                     && rightCandles[j] <= right) {                     count++;                 }             }             answer[i] = count;         }         return answer;     } }",0,,0,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ import java.util.ArrayList;  class Solution {     public int[] nodesBetweenCriticalPoints(ListNode head) {         ArrayList<Integer> criticalPoints = new ArrayList<>();         ListNode prev = head, curr = head.next;         int index = 1;         while (curr != null && curr.next != null) {             if ((prev.val < curr.val && curr.val > curr.next.val) || (prev.val > curr.val && curr.val < curr.next.val)) {                 criticalPoints.add(index);             }             prev = prev.next;             curr = curr.next;             index++;         }         int n = criticalPoints.size();         if (n < 2) {             return new int[]{-1, -1};         }         int minDistance = Integer.MAX_VALUE, maxDistance = Integer.MIN_VALUE;         for (int i = 0; i < n - 1; i++) {             int distance = criticalPoints.get(i + 1) - criticalPoints.get(i);             if (distance < minDistance) {                 minDistance = distance;             }             if (distance > maxDistance) {                 maxDistance = distance;             }         }         return new int[]{minDistance, maxDistance};     } }",1,"2058-find-the-minimum-and-maximum-number-of-nodes-between-critical-points/ListNode.java:16:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2058-find-the-minimum-and-maximum-number-of-nodes-between-critical-points/ListNode.java:30:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2058-find-the-minimum-and-maximum-number-of-nodes-between-critical-points/ListNode.java:16:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2058-find-the-minimum-and-maximum-number-of-nodes-between-critical-points/ListNode.java:30:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2058-find-the-minimum-and-maximum-number-of-nodes-between-critical-points/ListNode.java:15:	LooseCoupling:	Avoid using implementation types like 'ArrayList'; use the interface instead
",1,0,0
"class Solution {     static int minimumOperations(int[] nums, int start, int goal) {         if(start == goal)  // if start and goal are equal             return 0;         Set<Integer> set = new HashSet<>();  //use a set to keep track of visited numbers         Queue<Integer> queue = new LinkedList<>();  //for implementing bfs         queue.offer(start);         set.add(start);         int step = 0;  //to return the minimum number of operations needed to reach goal         while(!queue.isEmpty()){             int size = queue.size();             while(size-- > 0){  //while there are nodes left in the queue                 int curr = queue.poll();                 if(curr == goal) //if we reach goal we return the minimum number of operations                     return step;                 for(int num : nums){                     int next = curr + num;                     if(!set.contains(next) && next <= 1000){  //if next is a new number that hasn't been visited                         set.add(next);  //add it to set                         queue.offer(next);  //add it to queue                     }                     next = curr - num;                     if(!set.contains(next) && next >= 0){  //if next is a new number that hasn't been visited                         set.add(next);  //add it to set                         queue.offer(next);  //add it to queue                     }                     next = curr ^ num;                     if(!set.contains(next)){  //if next is a new number that hasn't been visited                         set.add(next);  //add it to set                         queue.offer(next);  //add it to queue                     }                 }             }             step++; //increment step after each level of bfs         }         return -1; // if goal isn't found     } }",1,"2059-minimum-operations-to-convert-number/Solution.java:1:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
2059-minimum-operations-to-convert-number/Solution.java:1:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
2059-minimum-operations-to-convert-number/Solution.java:1:	UseUtilityClass:	This utility class has a non-private constructor
",0,0,0
"class Solution {     public long countVowels(String word) {         long count = 0;         for(int i=0; i<word.length(); i++){             if(word.charAt(i) == 'a' || word.charAt(i) == 'e' || word.charAt(i) == 'i' || word.charAt(i) == 'o' || word.charAt(i) == 'u'){                 count += (long)(i+1) * (word.length()-i);             }         }         return count;     } }     /* For every vowel, we find the number of substrings in which it appears.     The number of substrings in which it appears is given by (i+1)*(n-i), where n is length of the original string and i is the index of the vowel.    We multiply by (long) to handle the large constraints. */",0,,0,0,0
"class Solution {     public int minimizedMaximum(int n, int[] quantities) {         int low = 0, high = (int)1e9;         while (low < high) {             int mid = (low + high) / 2, stores = 0;             for (int q : quantities) {                 stores += (q + mid - 1) / mid;             }             if (stores > n) {                 low = mid + 1;             } else {                 high = mid;             }         }         return low;     } }",1,"2064-minimized-maximum-of-products-distributed-to-any-store/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2064-minimized-maximum-of-products-distributed-to-any-store/Solution.java:5:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2064-minimized-maximum-of-products-distributed-to-any-store/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2064-minimized-maximum-of-products-distributed-to-any-store/Solution.java:5:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Robot {     private int width;     private int height;     private int x;     private int y;     private int direction;          public Robot(int width, int height) {         this.width = width;         this.height = height;         this.x = 0;         this.y = 0;         this.direction = 1; // 1 for East, 2 for North, 3 for West, 4 for South     }          public void step(int num) {         while (num > 0) {             if (this.direction == 1) {                 if (this.x + 1 < this.width) {                     this.x++;                     num--;                 } else {                     this.direction = 2;                 }             } else if (this.direction == 2) {                 if (this.y + 1 < this.height) {                     this.y++;                     num--;                 } else {                     this.direction = 3;                 }             } else if (this.direction == 3) {                 if (this.x - 1 >= 0) {                     this.x--;                     num--;                 } else {                     this.direction = 4;                 }             } else {                 if (this.y - 1 >= 0) {                     this.y--;                     num--;                 } else {                     this.direction = 1;                 }             }         }     }          public int[] getPos() {         return new int[]{x, y};     }          public String getDir() {         if (direction == 1) {             return ""East"";         } else if (direction == 2) {             return ""North"";         } else if (direction == 3) {             return ""West"";         } else {             return ""South"";         }     } }",1,"2069-walking-robot-simulation-ii/Robot.java:8:5: Redundant 'public' modifier. [RedundantModifier]
2069-walking-robot-simulation-ii/Robot.java:8:22: 'width' hides a field. [HiddenField]
2069-walking-robot-simulation-ii/Robot.java:8:33: 'height' hides a field. [HiddenField]
2069-walking-robot-simulation-ii/Robot.java:8:5: Redundant 'public' modifier. [RedundantModifier]
2069-walking-robot-simulation-ii/Robot.java:8:22: 'width' hides a field. [HiddenField]
2069-walking-robot-simulation-ii/Robot.java:8:33: 'height' hides a field. [HiddenField]
2069-walking-robot-simulation-ii/Robot.java:21:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'num'
",0,1,0
"class Solution {     public boolean canFinish(int numCourses, int[][] prerequisites) {         // Create array to keep track of incoming edges         int[] incomingEdges = new int[numCourses];                  // Create adjacency list to represent courses and prerequisites         List<List<Integer>> adjacencyList = new ArrayList<>();         for (int i = 0; i < numCourses; i++) {             adjacencyList.add(new ArrayList<>());         }                  // Populate incomingEdges and adjacencyList         for (int[] prerequisite : prerequisites) {             int course = prerequisite[0];             int prerequisiteCourse = prerequisite[1];             incomingEdges[course]++;             adjacencyList.get(prerequisiteCourse).add(course);         }                  // Create queue for courses with no prerequisites         Queue<Integer> queue = new LinkedList<>();         for (int i = 0; i < numCourses; i++) {             if (incomingEdges[i] == 0) {                 queue.offer(i);             }         }                  // Process courses with no prerequisites         int coursesFinished = 0;         while (!queue.isEmpty()) {             int currentCourse = queue.poll();             coursesFinished++;             for (int course : adjacencyList.get(currentCourse)) {                 incomingEdges[course]--;                 if (incomingEdges[course] == 0) {                     queue.offer(course);                 }             }         }                  // Check if all courses were finished         return coursesFinished == numCourses;     } }",0,,0,0,0
"import java.util.*;  class Solution {     public int[] maximumBeauty(int[][] items, int[] queries) {         int n = queries.length;         int[] ans = new int[n];                  // create a map of prices and corresponding set of beauties         Map<Integer, Set<Integer>> map = new TreeMap<>();         for (int[] item : items) {             int price = item[0];             int beauty = item[1];                          Set<Integer> beautySet = map.getOrDefault(price, new HashSet<>());             beautySet.add(beauty);             map.put(price, beautySet);         }                  // iterate over queries and find max beauty for each query         for (int i = 0; i < n; i++) {             int price = queries[i];             int maxBeauty = 0;                          // iterate over lower prices in the map             for (int key : map.keySet()) {                 if (key > price) {                     break;                 }                                  Set<Integer> beautySet = map.get(key);                 if (beautySet.isEmpty()) {                     continue;                 }                                  // find max beauty from the set of beauties                 maxBeauty = Math.max(maxBeauty, Collections.max(beautySet));             }                          ans[i] = maxBeauty;         }                  return ans;     } }",1,"2070-most-beautiful-item-for-each-query/Solution.java:9:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
",0,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public ListNode reverseEvenLengthGroups(ListNode head) {         ListNode current = head;         ListNode previous = null;         ListNode next = null;         int count = 0;         while (current != null) {             ListNode temp = current;             int length = 0;             while (temp != null && length <= count) {                 temp = temp.next;                 length++;             }             if (length == count && length % 2 == 0) {                 temp = current;                 while (length-- > 0) {                     next = temp.next;                     temp.next = previous;                     previous = temp;                     temp = next;                 }                 if (count == 0) {                     head = previous;                 } else {                     current.next = previous;                 }                 current = next;             } else {                 current = current.next;             }             count++;             previous = null;         }         return head;     } }",1,"2074-reverse-nodes-in-even-length-groups/ListNode.java:33:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'head'
2074-reverse-nodes-in-even-length-groups/ListNode.java:42:	NullAssignment:	Assigning an Object to null is a code smell.  Consider refactoring.
",0,1,0
"class Solution {     public String decodeCiphertext(String encodedText, int rows) {         char[] encodedChars = encodedText.toCharArray();         int len = encodedChars.length;         int cols = (len - 1) / (2 * rows - 2) + 1;         char[][] matrix = new char[rows][cols];         int idx = 0;         for (int j = 0; j < cols; j++) {             for (int i = 0; i < rows && idx < len; i++) {                 if (j % 2 == 0) {                     matrix[i][j] = encodedChars[idx++];                 } else {                     matrix[rows - 1 - i][j] = encodedChars[idx++];                 }             }         }         StringBuilder sb = new StringBuilder();         for (int i = 0; i < rows; i++) {             for (int j = 0; j < cols; j++) {                 if (matrix[i][j] == '\0') {                     continue;                 }                 sb.append(matrix[i][j]);             }         }         return sb.toString();     } }",0,,0,0,0
"class Solution {     public int wateringPlants(int[] plants, int capacity) {         int n = plants.length;         int steps = 0;         int left = 0;         int right = n - 1;         int waterInCan = capacity;                  while (left <= right) {             if (waterInCan >= plants[left]) {                 // if we have enough water in can, water left plant                 waterInCan -= plants[left];                 left += 1;             } else if (waterInCan >= plants[right]) {                 // if we don't have enough water in can to water left plant,                  // but have enough water to water right plant, water right plant                 // and refill water can from river                 waterInCan = capacity - plants[right];                 right -= 1;             } else {                 // if we don't have enough water in can to water both left and right plants,                 // refill water can from river                 waterInCan = capacity;                 steps += 1;             }             steps += 1;         }         return steps;     } }",0,,0,0,0
class TrieNode {     boolean isWord;     TrieNode[] children;          public TrieNode() {         isWord = false;         children = new TrieNode[26];     } }  class Trie {     TrieNode root;          public Trie() {         root = new TrieNode();     }          public void insert(String word) {         TrieNode node = root;         for (char c : word.toCharArray()) {             if (node.children[c-'a'] == null) {                 node.children[c-'a'] = new TrieNode();             }             node = node.children[c-'a'];         }         node.isWord = true;     }          public boolean search(String word) {         TrieNode node = root;         for (char c : word.toCharArray()) {             if (node.children[c-'a'] == null) {                 return false;             }             node = node.children[c-'a'];         }         return node.isWord;     }          public boolean startsWith(String prefix) {         TrieNode node = root;         for (char c : prefix.toCharArray()) {             if (node.children[c-'a'] == null) {                 return false;             }             node = node.children[c-'a'];         }         return true;     } },1,"208-implement-trie-prefix-tree/TrieNode.java:2:13: Variable 'isWord' must be private and have accessor methods. [VisibilityModifier]
208-implement-trie-prefix-tree/TrieNode.java:3:16: Variable 'children' must be private and have accessor methods. [VisibilityModifier]
208-implement-trie-prefix-tree/TrieNode.java:5:5: Redundant 'public' modifier. [RedundantModifier]
208-implement-trie-prefix-tree/TrieNode.java:12:14: Variable 'root' must be private and have accessor methods. [VisibilityModifier]
208-implement-trie-prefix-tree/TrieNode.java:14:5: Redundant 'public' modifier. [RedundantModifier]
208-implement-trie-prefix-tree/TrieNode.java:2:13: Variable 'isWord' must be private and have accessor methods. [VisibilityModifier]
208-implement-trie-prefix-tree/TrieNode.java:3:16: Variable 'children' must be private and have accessor methods. [VisibilityModifier]
208-implement-trie-prefix-tree/TrieNode.java:5:5: Redundant 'public' modifier. [RedundantModifier]
208-implement-trie-prefix-tree/TrieNode.java:12:14: Variable 'root' must be private and have accessor methods. [VisibilityModifier]
208-implement-trie-prefix-tree/TrieNode.java:14:5: Redundant 'public' modifier. [RedundantModifier]
",0,0,0
"class RangeFreqQuery {     private int[] arr;     private int[][] freqArr;      public RangeFreqQuery(int[] nums) {         this.arr = nums;         this.freqArr = new int[nums.length][10001];          for (int i = 0; i < nums.length; i++) {             if (i > 0) {                //if the current element in the previous row, copy that value                 for (int j = 0; j < 10001; j++) {                     this.freqArr[i][j] = this.freqArr[i-1][j];                 }              }             //count the current element             this.freqArr[i][nums[i]]++;            }     }      public int query(int left, int right, int value) {         int freq = 0;         //array to hold the frequency of each number in the given range          int[] tempArr = new int[10001];          //copying the freqs[row][col] value to the tempArr for efficient calculation of the frequency of given value in the given range         if (left > 0) {             for (int i = 0; i < 10001; i++) {                 tempArr[i] = this.freqArr[right][i] - this.freqArr[left-1][i];             }         } else {             tempArr = this.freqArr[right];         }          //finding out the frequency of the given value in the given range         freq = tempArr[value];          return freq;     } }",1,"2080-range-frequency-queries/RangeFreqQuery.java:5:5: Redundant 'public' modifier. [RedundantModifier]
2080-range-frequency-queries/RangeFreqQuery.java:5:5: Redundant 'public' modifier. [RedundantModifier]
2080-range-frequency-queries/RangeFreqQuery.java:2:	UnusedPrivateField:	Avoid unused private fields such as 'arr'.
2080-range-frequency-queries/RangeFreqQuery.java:6:	ArrayIsStoredDirectly:	The user-supplied array 'nums' is stored directly.
2080-range-frequency-queries/RangeFreqQuery.java:22:	UnusedAssignment:	The initializer for variable 'freq' is never used (overwritten on line 36)
",0,0,0
class Solution {     public int minimumBuckets(String hamsters) {         int countHamsters = 0;         for (int i = 0; i < hamsters.length(); i++) {             if (hamsters.charAt(i) == 'H') {                 countHamsters++;             }         }         int countBuckets = 0;         for (int i = 0; i < hamsters.length(); i++) {             if (hamsters.charAt(i) == '.') {                 if ((i == 0 || hamsters.charAt(i - 1) != '.') && (i == hamsters.length() - 1 || hamsters.charAt(i + 1) != '.')) {                     return -1;                 }                 if ((i > 0 && hamsters.charAt(i - 1) == 'H') || (i < hamsters.length() - 1 && hamsters.charAt(i + 1) == 'H')) {                     countBuckets++;                 }             }         }         return countHamsters == 0 ? 0 : countBuckets + (countHamsters - countBuckets);     } },1,"2086-minimum-number-of-food-buckets-to-feed-the-hamsters/Solution.java:2:	NPathComplexity:	The method 'minimumBuckets(String)' has an NPath complexity of 243, current threshold is 200
2086-minimum-number-of-food-buckets-to-feed-the-hamsters/Solution.java:20:	UselessParentheses:	Useless parentheses.
",0,0,0
"class Solution {     public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {         int m = rowCosts.length;         int n = colCosts.length;         int[][] dp = new int[m][n];         int sr = startPos[0];         int sc = startPos[1];         int hr = homePos[0];         int hc = homePos[1];         // fill top row         for (int c = sc; c <= hc; c++) {             if (c == sc) {                 dp[sr][c] += rowCosts[sr];             } else {                 dp[sr][c] += dp[sr][c - 1] + colCosts[c - 1];             }         }         // fill left column         for (int r = sr + 1; r < m; r++) {             dp[r][sc] = dp[r - 1][sc] + rowCosts[r - 1];         }         // fill remaining grid         for (int r = sr + 1; r < m; r++) {             for (int c = sc + 1; c <= hc; c++) {                 int cost = Math.min(dp[r - 1][c], dp[r][c - 1]);                 dp[r][c] = cost + (c == hc ? rowCosts[r] : colCosts[c - 1]);             }         }         return dp[hr][hc];     } }",0,,0,0,0
"class Solution {     public int minSubArrayLen(int target, int[] nums) {         int left = 0;         int sum = 0;         int minLength = Integer.MAX_VALUE;                  for (int right = 0; right < nums.length; right++) {             sum += nums[right];                          // check if sum has crossed target and update minLength accordingly             while (sum >= target) {                 minLength = Math.min(minLength, right - left + 1);                                  // remove the leftmost element from the subarray and update sum                 sum -= nums[left];                 left++;             }         }                  // if minLength has not been updated, it means there is no subarray with sum equal to or greater than target         return minLength == Integer.MAX_VALUE ? 0 : minLength;     } }",0,,0,0,0
"class Solution {     public int[] getAverages(int[] nums, int k) {         int n = nums.length;         int[] avgs = new int[n];                  for (int i = 0; i < n; i++) {             int sum = 0;             int count = 0;                          for (int j = i - k; j <= i + k; j++) {                 if (j >= 0 && j < n) {                     sum += nums[j];                     count++;                 }             }                          if (count < 2*k+1) { // there are less than k elements before or after the index i                 avgs[i] = -1;             } else {                 avgs[i] = sum / count;             }         }                  return avgs;     } }",0,,0,0,0
class Solution {     public int minimumDeletions(int[] nums) {         int len = nums.length;         int minIndex = 0;         int maxIndex = 0;                  //Finding minimum and maximum element         for(int i=1; i<len; i++){             if(nums[i] < nums[minIndex]){                 minIndex = i;             }             if(nums[i] > nums[maxIndex]){                 maxIndex = i;             }         }                  //Minimum number of deletions         int minDel = len - (maxIndex+1) + minIndex;         if(maxIndex>minIndex){             minDel--;         }                  return minDel;     } },0,,0,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public ListNode deleteMiddle(ListNode head) {         if(head == null || head.next == null) {             // If given list is empty or has only one or zero nodes, return the same head             return head;         }         ListNode slow = head, fast = head;         ListNode prev = slow;         while(fast != null && fast.next != null) {             // Traverse the list using two pointers. Slow pointer moves one step at a time and fast pointer moves two steps at a time             prev = slow;             slow = slow.next;             fast = fast.next.next;         }         // When fast pointer reaches the end of the list, slow pointer will be pointing to the middle node         prev.next = slow.next;         // Remove the middle node by setting the next node of previous node of slow pointer as slow pointer's next node         return head;         // Return the head of modified linked list     } }",1,"2095-delete-the-middle-node-of-a-linked-list/ListNode.java:17:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2095-delete-the-middle-node-of-a-linked-list/ListNode.java:17:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */  import java.util.*;  class Solution {          public String getDirections(TreeNode root, int startValue, int destValue) {         TreeNode startNode = findNode(root, startValue);         TreeNode destNode = findNode(root, destValue);                  // find the path from the start node to the root         List<Character> startPath = getPath(startNode, root);                  // find the path from the destination node to the root         List<Character> destPath = getPath(destNode, root);                  // reverse both paths         Collections.reverse(startPath);         Collections.reverse(destPath);                  // find the common ancestor node         TreeNode commonAncestor = findCommonAncestor(startNode, destNode);                  // combine the paths from the start node to the common ancestor node         StringBuilder sb = new StringBuilder();         for (int i = 1; i < startPath.size() && startPath.get(i) != null && startPath.get(i) != destPath.get(i); i++) {             sb.append(startPath.get(i));         }                  // add the path from the common ancestor node to the destination node         for (int i = destPath.size() - 2; i >= 0 && destPath.get(i) != null; i--) {             if (destPath.get(i) != sb.charAt(sb.length() - 1)) {                 sb.append(destPath.get(i) == 'L' ? 'R' : 'L');             }         }                  return sb.toString();     }          private TreeNode findNode(TreeNode node, int val) {         if (node == null || node.val == val) return node;         TreeNode leftNode = findNode(node.left, val);         return leftNode != null ? leftNode : findNode(node.right, val);     }          private List<Character> getPath(TreeNode node, TreeNode root) {         LinkedList<Character> path = new LinkedList<>();         while (node != root) {             TreeNode parent = findParent(node, root);             if (parent.left == node) path.add('L');             else path.add('R');             node = parent;         }         path.add('U');         return path;     }          private TreeNode findParent(TreeNode node, TreeNode root) {         if (node == root) return null;         LinkedList<TreeNode> stack = new LinkedList<>();         stack.push(root);         while (!stack.isEmpty()) {             TreeNode curr = stack.pop();             if (curr.left == node || curr.right == node) {                 return curr;             }             if (curr.right != null) {                 stack.push(curr.right);             }             if (curr.left != null) {                 stack.push(curr.left);             }         }         return null;     }          private TreeNode findCommonAncestor(TreeNode node1, TreeNode node2) {         Set<TreeNode> ancestors = new HashSet<>();         while (node1 != null) {             ancestors.add(node1);             node1 = findParent(node1, null);         }         while (node2 != null) {             if (ancestors.contains(node2)) {                 return node2;             }             node2 = findParent(node2, null);         }         return null;     } }",1,"2096-step-by-step-directions-from-a-binary-tree-node-to-another/TreeNode.java:36:	UnusedLocalVariable:	Avoid unused local variables such as 'commonAncestor'.
2096-step-by-step-directions-from-a-binary-tree-node-to-another/TreeNode.java:40:	CompareObjectsWithEquals:	Use equals() to compare object references.
2096-step-by-step-directions-from-a-binary-tree-node-to-another/TreeNode.java:61:	LooseCoupling:	Avoid using implementation types like 'LinkedList'; use the interface instead
2096-step-by-step-directions-from-a-binary-tree-node-to-another/TreeNode.java:66:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'node'
2096-step-by-step-directions-from-a-binary-tree-node-to-another/TreeNode.java:74:	LooseCoupling:	Avoid using implementation types like 'LinkedList'; use the interface instead
2096-step-by-step-directions-from-a-binary-tree-node-to-another/TreeNode.java:95:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'node1'
2096-step-by-step-directions-from-a-binary-tree-node-to-another/TreeNode.java:101:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'node2'
",0,1,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */  import java.util.*;  class Solution {          public String getDirections(TreeNode root, int startValue, int destValue) {         TreeNode startNode = findNode(root, startValue);         TreeNode destNode = findNode(root, destValue);                  // find the path from the start node to the root         List<Character> startPath = getPath(startNode, root);                  // find the path from the destination node to the root         List<Character> destPath = getPath(destNode, root);                  // reverse both paths         Collections.reverse(startPath);         Collections.reverse(destPath);                  // find the common ancestor node         TreeNode commonAncestor = findCommonAncestor(startNode, destNode);                  // combine the paths from the start node to the common ancestor node         StringBuilder sb = new StringBuilder();         for (int i = 1; i < startPath.size() && startPath.get(i) != null && startPath.get(i) != destPath.get(i); i++) {             sb.append(startPath.get(i));         }                  // add the path from the common ancestor node to the destination node         for (int i = destPath.size() - 2; i >= 0 && destPath.get(i) != null; i--) {             if (destPath.get(i) != sb.charAt(sb.length() - 1)) {                 sb.append(destPath.get(i) == 'L' ? 'R' : 'L');             }         }                  return sb.toString();     }          private TreeNode findNode(TreeNode node, int val) {         if (node == null || node.val == val) return node;         TreeNode leftNode = findNode(node.left, val);         return leftNode != null ? leftNode : findNode(node.right, val);     }          private List<Character> getPath(TreeNode node, TreeNode root) {         LinkedList<Character> path = new LinkedList<>();         while (node != root) {             TreeNode parent = findParent(node, root);             if (parent.left == node) path.add('L');             else path.add('R');             node = parent;         }         path.add('U');         return path;     }          private TreeNode findParent(TreeNode node, TreeNode root) {         if (node == root) return null;         LinkedList<TreeNode> stack = new LinkedList<>();         stack.push(root);         while (!stack.isEmpty()) {             TreeNode curr = stack.pop();             if (curr.left == node || curr.right == node) {                 return curr;             }             if (curr.right != null) {                 stack.push(curr.right);             }             if (curr.left != null) {                 stack.push(curr.left);             }         }         return null;     }          private TreeNode findCommonAncestor(TreeNode node1, TreeNode node2) {         Set<TreeNode> ancestors = new HashSet<>();         while (node1 != null) {             ancestors.add(node1);             node1 = findParent(node1, null);         }         while (node2 != null) {             if (ancestors.contains(node2)) {                 return node2;             }             node2 = findParent(node2, null);         }         return null;     } }",0,,0,0,0
"import java.util.ArrayList; import java.util.List;  class Solution {     public List<Integer> goodDaysToRobBank(int[] security, int time) {         List<Integer> goodDays = new ArrayList<>();         for (int i = 0; i < security.length; i++) {             boolean goodDay = true;             // Check if there are enough days before and after i             if (i - time < 0 || i + time >= security.length) {                 continue;             }             // Check for non-increasing security values before i             for (int j = i - 1; j >= i - time; j--) {                 if (security[j] < security[j + 1]) {                     goodDay = false;                     break;                 }             }             // Check for non-decreasing security values after i             for (int j = i + 1; j <= i + time; j++) {                 if (security[j] < security[j - 1]) {                     goodDay = false;                     break;                 }             }             if (goodDay) {                 goodDays.add(i);             }         }         return goodDays;     } }",0,,0,0,0
"import java.util.*;  class Solution {     public int maximumDetonation(int[][] bombs) {         int maxDetonation = 1; // at least one bomb can be detonated         int n = bombs.length;                  // loop through all bombs as the detonation source         for (int i = 0; i < n; i++) {             int currDetonation = 1; // the current number of bombs that can be detonated             // loop through all other bombs to check if they are within the range of the current bomb             for (int j = 0; j < n; j++) {                 if (j == i) continue; // skip the current bomb                 int dx = bombs[i][0] - bombs[j][0];                 int dy = bombs[i][1] - bombs[j][1];                 int distance = dx * dx + dy * dy; // squared distance to optimize performance                 int range = bombs[i][2] * bombs[i][2]; // squared range to optimize performance                 if (distance <= range) currDetonation++;             }             maxDetonation = Math.max(maxDetonation, currDetonation);         }         return maxDetonation;     } }",1,"2101-detonate-the-maximum-bombs/Solution.java:1:	UnnecessaryImport:	Unused import 'java.util.*'
",0,0,0
"class Solution {     public long subArrayRanges(int[] nums) {                  int n = nums.length;         long ans = nums[0];         long res = nums[0];                  for(int i = 1; i < n; i++){             ans += nums[i];             res += i*nums[i];         }                  long maxSum = res;                  for(int i = 1; i < n; i++){             res = res - (long) n*nums[n-i] + ans;             maxSum = Math.max(maxSum, res);         }         return maxSum;     } }",0,,0,0,0
"class Solution {     public int minimumRefill(int[] plants, int capacityA, int capacityB) {         int n = plants.length;         int refillA = 0, refillB = 0;         int waterA = capacityA, waterB = capacityB;         int i = 0, j = n-1;                  while (i <= j) {             // Check if Alice can water the current plant             if (waterA >= plants[i]) {                 waterA -= plants[i];                 i++;             } else {                 // Refill watering can and count the refill                 refillA++;                 waterA = capacityA;             }                          // Check if Bob can water the current plant             if (waterB >= plants[j]) {                 waterB -= plants[j];                 j--;             } else {                 // Refill watering can and count the refill                 refillB++;                 waterB = capacityB;             }         }                  // Return the total number of refills required         return refillA + refillB;     } }",1,"2105-watering-plants-ii/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2105-watering-plants-ii/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2105-watering-plants-ii/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2105-watering-plants-ii/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2105-watering-plants-ii/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2105-watering-plants-ii/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public String addSpaces(String s, int[] spaces) {         StringBuilder sb = new StringBuilder(s);         int offset = 0; // keeps track of the offset caused by adding spaces          for (int space : spaces) {             sb.insert(space + offset, "" ""); // insert a space at the specified index             offset++; // increment the offset by 1 for each added space         }          return sb.toString();     } }",0,,0,0,0
"class WordDictionary {          // Trie node class     class TrieNode {         TrieNode[] children;         boolean isEndOfWord;                  public TrieNode() {             children = new TrieNode[26];             isEndOfWord = false;         }     }          private TrieNode root;          public WordDictionary() {         root = new TrieNode();     }          // Function to insert a word into the trie     public void addWord(String word) {         TrieNode current = root;         for (char ch: word.toCharArray()) {             int index = ch - 'a';             // Create a new node if the path doesn't exist             if (current.children[index] == null) {                 current.children[index] = new TrieNode();             }             // Move to the next level of the trie             current = current.children[index];         }         // Mark the end of a word         current.isEndOfWord = true;     }          // Recursive function to search a word in the trie     private boolean searchWord(String word, int index, TrieNode current) {         if (index == word.length()) {             return current.isEndOfWord;         }         char ch = word.charAt(index);         if (ch == '.') {             // If the character is '.', search in all possible directions             for (TrieNode child: current.children) {                 // If a match is found, return true                 if (child != null && searchWord(word, index+1, child)) {                     return true;                 }             }         } else {             int pos = ch - 'a';             // If the character is a lowercase letter             if (current.children[pos] == null) {                 // If the path doesn't exist, return false                 return false;             }             // If a match is found, move to the next level of the trie             return searchWord(word, index+1, current.children[pos]);         }         return false;     }          // Function to search a word in the trie     public boolean search(String word) {         return searchWord(word, 0, root);     } }",1,"211-design-add-and-search-words-data-structure/WordDictionary.java:5:20: Variable 'children' must be private and have accessor methods. [VisibilityModifier]
211-design-add-and-search-words-data-structure/WordDictionary.java:6:17: Variable 'isEndOfWord' must be private and have accessor methods. [VisibilityModifier]
211-design-add-and-search-words-data-structure/WordDictionary.java:8:9: Redundant 'public' modifier. [RedundantModifier]
211-design-add-and-search-words-data-structure/WordDictionary.java:16:5: Redundant 'public' modifier. [RedundantModifier]
211-design-add-and-search-words-data-structure/WordDictionary.java:5:20: Variable 'children' must be private and have accessor methods. [VisibilityModifier]
211-design-add-and-search-words-data-structure/WordDictionary.java:6:17: Variable 'isEndOfWord' must be private and have accessor methods. [VisibilityModifier]
211-design-add-and-search-words-data-structure/WordDictionary.java:8:9: Redundant 'public' modifier. [RedundantModifier]
211-design-add-and-search-words-data-structure/WordDictionary.java:16:5: Redundant 'public' modifier. [RedundantModifier]
211-design-add-and-search-words-data-structure/WordDictionary.java:14:	FieldDeclarationsShouldBeAtStartOfClass:	Fields should be declared at the top of the class, before any method declarations, constructors, initializers or inner classes.
211-design-add-and-search-words-data-structure/WordDictionary.java:53:	SimplifyBooleanReturns:	This if statement can be replaced by `return !{condition} || {elseBranch};`
",0,0,0
class Solution {     public long getDescentPeriods(int[] prices) {         int n = prices.length;         long count = 0;         for(int i=0; i<n; i++){             int diff = 0;             int j = i;             while(j<n-1 && (prices[j+1] + diff + 1 == prices[j])){                 diff++;                 j++;             }             count += ((diff+1) * (diff+2)) / 2;             i = j;         }         return count;     } }  /*     Time Complexity: O(n)     Space Complexity: O(1) */,1,"2110-number-of-smooth-descent-periods-of-a-stock/Solution.java:12:	UselessParentheses:	Useless parentheses.
",0,0,0
"import java.util.*;  class Solution {     public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {         // Map to store the ingredients needed to make a recipe         Map<String, Set<String>> recipeMap = new HashMap<>();         for (int i = 0; i < recipes.length; i++) {             recipeMap.put(recipes[i], new HashSet<>(ingredients.get(i)));         }          // Set to keep track of the recipes that can be made         Set<String> canMake = new HashSet<>();          // Queue to process the ingredients that we have and check what recipes can be made         Queue<String> queue = new LinkedList<>(Arrays.asList(supplies));         while (!queue.isEmpty()) {             String supply = queue.poll();             for (String recipe : recipeMap.keySet()) {                 Set<String> ingredientsNeeded = recipeMap.get(recipe);                 // Check if the supply can be used to make a needed ingredient for the recipe                 if (ingredientsNeeded.contains(supply)) {                     ingredientsNeeded.remove(supply);                     if (ingredientsNeeded.isEmpty()) {                         // recipe can be made                         canMake.add(recipe);                         // add the ingredients of the recipe to the queue to check for more recipes                         queue.addAll(ingredients.get(Arrays.asList(recipes).indexOf(recipe)));                     }                 }             }         }          return new ArrayList<>(canMake);     } }",1,"2115-find-all-possible-recipes-from-given-supplies/Solution.java:6:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
2115-find-all-possible-recipes-from-given-supplies/Solution.java:12:	LinguisticNaming:	Linguistics Antipattern - The variable 'canMake' indicates linguistically it is a boolean, but it is 'Set<String>'
",0,0,0
"class Solution {     public boolean canBeValid(String s, String locked) {         int n = s.length();         boolean[] dp = new boolean[n];                  // Initialize the first character in dp[] array         dp[0] = s.charAt(0) == '(';         for(int i=1; i<n; i++)         {             // If the character is locked, skip it             if(locked.charAt(i) == '1')                 dp[i] = dp[i-1] && s.charAt(i) == '(';             // Calculate dp[i] using the formula mentioned             else if(s.charAt(i) == '(')                 dp[i] = dp[i-1];             else if(i>0 && s.charAt(i-1) == '(')                 dp[i] = dp[i-1];             else if(i>1 && dp[i-2])                 dp[i] = true;            }                  return dp[n-1];     } }",1,"2116-check-if-a-parentheses-string-can-be-valid/Solution.java:9:9: '{' at column 9 should be on the previous line. [LeftCurly]
2116-check-if-a-parentheses-string-can-be-valid/Solution.java:9:9: '{' at column 9 should be on the previous line. [LeftCurly]
",0,0,0
"class Solution {     public int[] executeInstructions(int n, int[] startPos, String s) {         int m = s.length();         int[] answer = new int[m];         char[] instructions = s.toCharArray();                  // Loop through each instruction and find the furthest position reachable from         // the starting position when executing from that instruction.         for (int i = 0; i < m; i++) {             int row = startPos[0];             int col = startPos[1];             int j = i;             while (j < m) {                 char direction = instructions[j];                 if (direction == 'L' && col > 0) {                     col--;                 } else if (direction == 'R' && col < n - 1) {                     col++;                 } else if (direction == 'U' && row > 0) {                     row--;                 } else if (direction == 'D' && row < n - 1) {                     row++;                 } else {                     // The robot can't move in this direction anymore, so break.                     break;                 }                 j++;             }             answer[i] = j - i; // Number of instructions executed is the difference in indices.         }         return answer;     } }",0,,0,0,0
"class Solution {     public int[] getDistances(int[] arr) {         int n = arr.length;         Map<Integer,List<Integer>> numToIndices = new HashMap<>();         int[] result = new int[n];                  // loop through array and add indices to a hashmap         for (int i = 0; i < n; i++) {             int num = arr[i];             if (!numToIndices.containsKey(num)) {                 numToIndices.put(num, new ArrayList<Integer>());             }             numToIndices.get(num).add(i);         }                  // calculate the sum of intervals for each index         for (int i = 0; i < n; i++) {             int num = arr[i];             List<Integer> indices = numToIndices.get(num);             int sum = 0;             for (int j = 0; j < indices.size(); j++) {                 sum += Math.abs(indices.get(j) - i);             }             result[i] = sum;              }         return result;     } }",0,,0,0,0
class Solution {     public int numberOfBeams(String[] bank) {         int rows = bank.length;         int columns = bank[0].length();         int numLasers = 0;          // iterate over every security device         for (int i = 0; i < rows; i++) {             for (int j = 0; j < columns; j++) {                 if (bank[i].charAt(j) == '1') {                     // check for laser beams on the same column                     for (int k = i + 1; k < rows; k++) {                         if (bank[k].charAt(j) == '1') {                             boolean hasObstacle = false;                             // check for obstacles between the two devices                             for (int l = i + 1; l < k; l++) {                                 if (bank[l].charAt(j) == '1') {                                     hasObstacle = true;                                     break;                                 }                             }                             if (!hasObstacle) {                                 numLasers++;                             }                         }                     }                 }             }         }          return numLasers;     } },1,"2125-number-of-laser-beams-in-a-bank/Solution.java:17:	AvoidDeeplyNestedIfStmts:	Deeply nested if..then statements are hard to read
2125-number-of-laser-beams-in-a-bank/Solution.java:22:	AvoidDeeplyNestedIfStmts:	Deeply nested if..then statements are hard to read
",0,0,0
"class Solution {     public boolean asteroidsDestroyed(int mass, int[] asteroids) {         Stack<Integer> stack = new Stack<>();         for (int asteroid : asteroids) {             while (!stack.isEmpty() && asteroid < 0 && stack.peek() > 0) {                 int prevMass = stack.pop();                 if (prevMass > -asteroid) {                     asteroid = prevMass;                 } else if (prevMass == -asteroid) {                     asteroid = 0;                 }             }             if (asteroid != 0) {                 stack.push(asteroid);             } else {                 mass += asteroid;             }             if (mass < 0) {                 return false;             }         }         return true;     } }",1,"2126-destroying-asteroids/Solution.java:13:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
2126-destroying-asteroids/Solution.java:16:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'mass'
",0,1,0
"class Solution {     public int rob(int[] nums) {         int n = nums.length;                  // Edge cases         if(n == 0){             return 0;         }         if(n == 1){             return nums[0];         }         if(n == 2){             return Math.max(nums[0], nums[1]);         }                  // Case 1 - Rob first house but not the last one         int[] dp1 = new int[n];         dp1[0] = nums[0];         dp1[1] = Math.max(nums[0], nums[1]);         for(int i=2;i<n-1;i++){             dp1[i] = Math.max(dp1[i-1], dp1[i-2] + nums[i]);         }         int max1 = dp1[n-2];                  // Case 2 - Rob last house but not the first one         int[] dp2 = new int[n];         dp2[1] = nums[1];         dp2[2] = Math.max(nums[1], nums[2]);         for(int i=3;i<n;i++){             dp2[i] = Math.max(dp2[i-1], dp2[i-2] + nums[i]);         }         int max2 = dp2[n-1];                  // Final answer will be maximum of these two cases         return Math.max(max1, max2);     } }",0,,0,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public int pairSum(ListNode head) {         int[] map = new int[100001]; // stores the frequency count of each value         ListNode current = head;         while (current != null) {             map[current.val]++;             current = current.next;         }         int maxSum = 0;         current = head;         while (current != null) {             int twinIndex = map.length - 1 - current.val; // calculate the index of the twin node             if (map[twinIndex] > 0) { // if twin is present in the list                 int twinSum = current.val + twinIndex;                 maxSum = Math.max(maxSum, twinSum); // update the maximum twin sum                 map[twinIndex]--; // decrease the frequency count of the twin value             }             current = current.next;         }         return maxSum;     } }",0,,0,0,0
"class Solution {     public int longestPalindrome(String[] words) {                  int[] charFreq = new int[26]; // frequency of each alphabet                  int palindromeLength = 0;         boolean oddFrequencyFound = false;          for(String word : words){             charFreq[word.charAt(0) - 'a']++; // increment frequency of first letter             if(charFreq[word.charAt(0) - 'a'] == 2){ // if we have two such letters, then they can form a palindrome                 palindromeLength += 2;                 charFreq[word.charAt(0) - 'a'] = 0; // reset frequency of these letters             }         }          for(int freq : charFreq){ // if there is any character with odd frequency, it can be placed in the mid of the palindrome             if(freq > 0){                 palindromeLength++;                 oddFrequencyFound = true;             }         }          return oddFrequencyFound ? palindromeLength : Math.max(0, palindromeLength - 1); // if odd frequency is found, add 1 to palindrome length otherwise subtract 1     } }",0,,0,0,0
"class Solution {     public int minSwaps(int[] nums) {         int n = nums.length;         int ones = 0;         int minSwaps = Integer.MAX_VALUE;                  // Count the number of 1's in the array         for (int i = 0; i < n; i++) {             if (nums[i] == 1) {                 ones++;             }         }          // If there are less than 2 numbers, then we don't need to do anything         if (ones < 2) {             return 0;         }          int left = 0, right = 0, windowsOnes = 0;          // Initialize the first window         while (right < ones - 1) {             if (nums[right] == 1) {                 windowsOnes++;             }             right++;         }          // Slide the window through the array         while (right < n + ones) {             if (nums[right % n] == 1) {                 windowsOnes++;             }              // If the window moves beyond the boundaries of the array, decrement the window count             if (nums[left % n] == 1) {                 windowsOnes--;             }              // If the number of 1's in the current window is greater than the maximum seen so far,             // then we update the maximum             if (windowsOnes > minSwaps) {                 minSwaps = windowsOnes;             }              left++;             right++;         }          // Return the number of swaps required         return ones - minSwaps;     } }",1,"2134-minimum-swaps-to-group-all-1s-together-ii/Solution.java:19:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2134-minimum-swaps-to-group-all-1s-together-ii/Solution.java:19:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2134-minimum-swaps-to-group-all-1s-together-ii/Solution.java:5:	PrematureDeclaration:	Declaration of 'minSwaps' can be moved closer to its usages
",1,0,0
"class Solution {     public int wordCount(String[] startWords, String[] targetWords) {         int count = 0;         for (String targetWord : targetWords) {             boolean found = false;             for (String startWord : startWords) {                 if (isConvertible(startWord, targetWord)) {                     found = true;                     break;                 }             }             if (found) {                 count++;             }         }         return count;     }          private boolean isConvertible(String startWord, String targetWord) {         int[] startCharCount = new int[26];         int[] targetCharCount = new int[26];                  for (char ch : startWord.toCharArray()) {             startCharCount[ch - 'a']++;         }                  for (char ch : targetWord.toCharArray()) {             targetCharCount[ch - 'a']++;         }                  for (int i = 0; i < 26; i++) {             if (targetCharCount[i] > startCharCount[i]) {                 return false;             }         }                  return true;     } }",0,,0,0,0
"class Solution {     public int minMoves(int target, int maxDoubles) {         int curr = 1;         int moves = 0;         while (curr < target) {             if (maxDoubles > 0 && curr * 2 <= target) {                 // if we can double and reach target or go beyond                 curr *= 2;                 maxDoubles--;             } else {                 // increment by 1                 curr += 1;             }             moves++;         }         return moves;         } }",1,"2139-minimum-moves-to-reach-target-score/Solution.java:9:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'maxDoubles'
",0,1,0
"class Solution {     public long mostPoints(int[][] questions) {         int n = questions.length;         long[] dp = new long[n]; // dp[i] represents the maximum points that can be earned till question i         dp[0] = questions[0][0]; // base case                  for(int i = 1; i < n; i++) {             long pointsIfSkipped = dp[i-1]; // if we skip ith question, we earn the same points as till the previous question             long pointsIfSolved = questions[i][0]; // if we solve ith question, we earn pointsi                          // calculate the points we will earn if we skip the next brainpoweri questions after solving ith question             for(int j = i+1; j <= Math.min(n-1, i+questions[i][1]); j++) {                 pointsIfSolved += questions[j][0];             }                          dp[i] = Math.max(pointsIfSkipped, pointsIfSolved);         }                  return dp[n-1];     } }",0,,0,0,0
"class Solution {     public int numberOfArrays(int[] differences, int lower, int upper) {         int n = differences.length;         long[] dp = new long[n + 1]; // dp[i] represents the number of possible hidden sequence of length i         dp[0] = 1; // empty sequence is always possible         for (int i = 1; i <= n; i++) {             long sum = 0;             for (int j = i - 1; j >= 0 && j >= i - upper; j--) {                 sum += differences[j];                 if (sum < lower) {                     break; // optimization: if the sum is already below lower, no need to continue                 }                 if (sum > upper) {                     continue; // if the sum is above upper, the following sums will also be above upper, so continue to the next iteration                 }                 dp[i] += dp[j];                 dp[i] %= 1_000_000_007; // modulo 10^9 + 7 to avoid integer overflow             }         }         return (int) dp[n];     } }",0,,0,0,0
"import java.util.*;  class Solution {     public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {         int m = grid.length, n = grid[0].length; // size of the grid                  // Step 1. Create 2D array priceList.         List<List<Integer>>[] priceList = new List[106]; // 0 <= grid[i][j] <= 105         for (int i = 0; i <= 105; i++) {             priceList[i] = new ArrayList<>();         }         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 int price = grid[i][j];                 // Add the indices of all indices with prices within [low, high] in a corresponding list in priceList.                 if (price >= pricing[0] && price <= pricing[1]) {                     priceList[price].add(Arrays.asList(i, j));                 }             }         }                  // Step 2. Using BFS, find the distance of all items in the grid from the start cell.         int[][] distance = new int[m][n];         for (int i = 0; i < m; i++) {             Arrays.fill(distance[i], Integer.MAX_VALUE);         }         int startRow = start[0], startCol = start[1];         distance[startRow][startCol] = 0; // set the distance of the starting cell to 0                  Queue<int[]> queue = new LinkedList<>();         queue.add(new int[]{startRow, startCol});                  int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};         while (!queue.isEmpty()) {             int[] curr = queue.poll();             int currRow = curr[0], currCol = curr[1];             for (int[] dir : dirs) {                 int newRow = currRow + dir[0], newCol = currCol + dir[1];                 // Check if the cell is within the grid and it is reachable and the distance beats the previously calculated score                 if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && grid[newRow][newCol] != 0 && distance[newRow][newCol] > distance[currRow][currCol] + 1) {                     distance[newRow][newCol] = distance[currRow][currCol] + 1;                     queue.add(new int[]{newRow, newCol});                 }             }         }                  // Step 3. Traverse through priceList in non-increasing order of item prices, add neighbours in a prioritized manner to PriorityQueue.         PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {             int distA = distance[a[0]][a[1]], distB = distance[b[0]][b[1]];             int priceA = grid[a[0]][a[1]], priceB = grid[b[0]][b[1]];             if (distA != distB) {                 return distA - distB;             } else if (priceA != priceB) {                 return priceA - priceB;             } else if (a[0] != b[0]) {                 return a[0] - b[0];             } else {                 return a[1] - b[1];             }         });         for (int i = 105; i >= 0; i--) {             // If priceList[i] is not empty, add the distances of each item and its neighbours in order to pq.             if (!priceList[i].isEmpty()) {                 for (List<Integer> item : priceList[i]) {                     int itemRow = item.get(0), itemCol = item.get(1);                     if (distance[itemRow][itemCol] != Integer.MAX_VALUE) { // if the item is reachable from the start cell                         pq.add(new int[]{itemRow, itemCol});                         if (pq.size() > k) { // We only need to store the k highest-ranked items                             pq.poll();                         }                     }                 }             }         }                  // Step 4. Return k highest-ranked items from PriorityQueue as a list of int.         List<List<Integer>> result = new ArrayList<>();         while (!pq.isEmpty()) {             int[] item = pq.poll();             result.add(Arrays.asList(item[0], item[1]));         }         Collections.reverse(result); // the list of items in the PriorityQueue is sorted in ascending order of ranks, hence reverse it         return result;     } }",1,"2146-k-highest-ranked-items-within-a-price-range/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2146-k-highest-ranked-items-within-a-price-range/Solution.java:27:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2146-k-highest-ranked-items-within-a-price-range/Solution.java:36:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2146-k-highest-ranked-items-within-a-price-range/Solution.java:38:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2146-k-highest-ranked-items-within-a-price-range/Solution.java:49:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2146-k-highest-ranked-items-within-a-price-range/Solution.java:50:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2146-k-highest-ranked-items-within-a-price-range/Solution.java:65:21: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2146-k-highest-ranked-items-within-a-price-range/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2146-k-highest-ranked-items-within-a-price-range/Solution.java:27:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2146-k-highest-ranked-items-within-a-price-range/Solution.java:36:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2146-k-highest-ranked-items-within-a-price-range/Solution.java:38:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2146-k-highest-ranked-items-within-a-price-range/Solution.java:49:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2146-k-highest-ranked-items-within-a-price-range/Solution.java:50:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2146-k-highest-ranked-items-within-a-price-range/Solution.java:65:21: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2146-k-highest-ranked-items-within-a-price-range/Solution.java:4:	NPathComplexity:	The method 'highestRankedKItems(int[][], int[], int[], int)' has an NPath complexity of 8640, current threshold is 200
2146-k-highest-ranked-items-within-a-price-range/Solution.java:48:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
2146-k-highest-ranked-items-within-a-price-range/Solution.java:51:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
2146-k-highest-ranked-items-within-a-price-range/Solution.java:53:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
2146-k-highest-ranked-items-within-a-price-range/Solution.java:55:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",1,0,0
class Solution {     public int[] rearrangeArray(int[] nums) {         int n = nums.length;         Arrays.sort(nums); // sort the array                  int[] res = new int[n];         int j = 1; // index of positive numbers         int k = 0; // index of negative numbers                  // assign positive numbers to odd indexes of the result array         for (int i = 0; i < n; i++) {             if (nums[i] > 0 && j < n) {                 res[j] = nums[i];                 j += 2;             }         }                  // assign negative numbers to even indexes of the result array         for (int i = 0; i < n; i++) {             if (nums[i] <= 0 && k < n) {                 res[k] = nums[i];                 k += 2;             }         }                  return res;     } },0,,0,0,0
"class Solution {     public int findKthLargest(int[] nums, int k) {         int left = 0;         int right = nums.length - 1;         while (true) {             // pick a random pivot index             int pivotIndex = left + (int) (Math.random() * (right - left + 1));             // partition the array around the pivot             pivotIndex = partition(nums, left, right, pivotIndex);             // if the pivot is in its final position, return it             if (pivotIndex == nums.length - k) {                 return nums[pivotIndex];             // otherwise, update the boundaries and continue the search             } else if (pivotIndex < nums.length - k) {                 left = pivotIndex + 1;             } else {                 right = pivotIndex - 1;             }         }     }          private int partition(int[] nums, int left, int right, int pivotIndex) {         int pivotValue = nums[pivotIndex];         int storeIndex = left;         // move the pivot to the end of the array         swap(nums, pivotIndex, right);         for (int i = left; i < right; i++) {             if (nums[i] < pivotValue) {                 swap(nums, i, storeIndex);                 storeIndex++;             }         }         // move the pivot back to its final position         swap(nums, storeIndex, right);         return storeIndex;     }          private void swap(int[] nums, int i, int j) {         int temp = nums[i];         nums[i] = nums[j];         nums[j] = temp;     } }",0,,0,0,0
import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set;  class Solution {     public List<Integer> findLonely(int[] nums) {         List<Integer> result = new ArrayList<Integer>();         Set<Integer> adjacent = new HashSet<Integer>();         Set<Integer> seen = new HashSet<Integer>();         for (int num : nums) {             if (seen.contains(num)) {                 adjacent.add(num - 1);                 adjacent.add(num + 1);             } else {                 seen.add(num);                 if (!adjacent.contains(num - 1) && !adjacent.contains(num + 1)) {                     result.add(num);                 }             }         }         return result;     } },1,"2150-find-all-lonely-numbers-in-the-array/Solution.java:8:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new ArrayList<>()`
2150-find-all-lonely-numbers-in-the-array/Solution.java:9:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new HashSet<>()`
2150-find-all-lonely-numbers-in-the-array/Solution.java:10:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new HashSet<>()`
",0,0,0
import java.util.ArrayList; import java.util.List;  public class Solution {     public List<Integer> maxScoreIndices(int[] nums) {         int n = nums.length;         int[] zerosLeft = new int[n+1]; // number of zeros to the left of i (inclusive)         int[] onesRight = new int[n+1]; // number of ones to the right of i (inclusive)         for (int i = 0; i < n; i++) {             zerosLeft[i+1] = zerosLeft[i] + (nums[i] == 0 ? 1 : 0);         }         for (int i = n-1; i >= 0; i--) {             onesRight[i] = onesRight[i+1] + (nums[i] == 1 ? 1 : 0);         }         int maxScore = -1;         List<Integer> maxIndices = new ArrayList<>();         for (int i = 0; i <= n; i++) {             int score = zerosLeft[i] + onesRight[i];             if (score > maxScore) {                 maxScore = score;                 maxIndices.clear();             }             if (score == maxScore) {                 maxIndices.add(i);             }         }         return maxIndices;     } },0,,0,0,0
"import java.util.ArrayList; import java.util.List;  class Solution {     public List<List<Integer>> combinationSum3(int k, int n) {         List<List<Integer>> result = new ArrayList<>();         backtrack(result, new ArrayList<>(), k, n, 1);         return result;     }      private void backtrack(List<List<Integer>> result, List<Integer> temp, int k, int remainingSum, int start) {         if (temp.size() == k && remainingSum == 0) {             result.add(new ArrayList<>(temp));             return;         }         if (temp.size() == k || remainingSum <= 0) {             return;         }         for (int i = start; i <= 9; i++) {             temp.add(i);             backtrack(result, temp, k, remainingSum - i, i + 1);             temp.remove(temp.size() - 1);         }     } }",0,,0,0,0
"class Solution {     public int[] pivotArray(int[] nums, int pivot) {         int n = nums.length;         int start = 0, end = n-1, i = 0;         while(i <= end){             if(nums[i] < pivot){                 swap(nums, i, start);                 start++;                 i++;             }else if(nums[i] > pivot){                 swap(nums, i, end);                 end--;             }else{                 i++;             }         }         return nums;     }          private void swap(int[] nums, int i, int j){         int temp = nums[j];         nums[j] = nums[i];         nums[i] = temp;     } }  class Main {     public static void main(String[] args) {         Solution s = new Solution();         int[] nums = {9,12,5,10,14,3,10};         int pivot = 10;         int[] output = s.pivotArray(nums, pivot);         for(int i=0;i<output.length;i++){             System.out.print(output[i]+"" "");         }     } }",1,"2161-partition-array-according-to-given-pivot/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2161-partition-array-according-to-given-pivot/Solution.java:27:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
2161-partition-array-according-to-given-pivot/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2161-partition-array-according-to-given-pivot/Solution.java:27:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
2161-partition-array-according-to-given-pivot/Solution.java:27:	UseUtilityClass:	This utility class has a non-private constructor
2161-partition-array-according-to-given-pivot/Solution.java:33:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",1,0,1
"class Solution {     public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {         int totalTime = (targetSeconds % 60) + (targetSeconds / 60) * 100; // Normalize time to four digits, minutes in first two digits and seconds in last two digits         int currDigit = startAt; // Initialize currDigit as startAt         int minCost = Integer.MAX_VALUE; // Initialize minCost as max value of integer type         int cost, minutes, seconds;         for (int i = 0; i < 4; i++) { // Four digits can be pushed at most             minutes = currDigit * 10 + (totalTime / 100) % 10; // Calculate minutes             seconds = (totalTime % 100) * 10 + (currDigit ^ 9); // Calculate seconds             cost = (i * moveCost) + (Math.abs(currDigit - ((totalTime / (int) Math.pow(10, 3 - i)) % 10)) * pushCost); // Calculate cost of setting time             minCost = Math.min(minCost, cost); // Update minCost             currDigit = (i < 2) ? currDigit : 9 - currDigit; // Update currDigit based on position in the four digit input         }         return minCost;     } }",1,"2162-minimum-cost-to-set-cooking-time/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2162-minimum-cost-to-set-cooking-time/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2162-minimum-cost-to-set-cooking-time/Solution.java:3:	UselessParentheses:	Useless parentheses.
2162-minimum-cost-to-set-cooking-time/Solution.java:6:	UnusedLocalVariable:	Avoid unused local variables such as 'minutes'.
2162-minimum-cost-to-set-cooking-time/Solution.java:6:	UnusedLocalVariable:	Avoid unused local variables such as 'seconds'.
2162-minimum-cost-to-set-cooking-time/Solution.java:8:	UnusedAssignment:	The value assigned to variable 'minutes' is never used (reassigned every iteration)
2162-minimum-cost-to-set-cooking-time/Solution.java:8:	UselessParentheses:	Useless parentheses.
2162-minimum-cost-to-set-cooking-time/Solution.java:9:	UnusedAssignment:	The value assigned to variable 'seconds' is never used (reassigned every iteration)
2162-minimum-cost-to-set-cooking-time/Solution.java:9:	UselessParentheses:	Useless parentheses.
2162-minimum-cost-to-set-cooking-time/Solution.java:10:	UselessParentheses:	Useless parentheses.
",1,0,0
"class Solution {     public long smallestNumber(long num) {         if (num == 0) {             return 0;         }         StringBuilder sb = new StringBuilder(Long.toString(num));         int n = sb.length();         int i;         if (num > 0) {             i = 0;         } else {             i = 1;         }         while (i < n && sb.charAt(i) <= '0') {             i++;         }         if (i == n) {             i--;         }         char min = sb.charAt(i);         int minIndex = i;         for (int j = i + 1; j < n; j++) {             char ch = sb.charAt(j);             if (ch < min) {                 min = ch;                 minIndex = j;             }         }         sb.deleteCharAt(minIndex);         sb.insert(0, min);         long ans = Long.parseLong(sb.toString());         if (num < 0) {             ans *= -1;         }         return ans;     } }",0,,0,0,0
class Bitset {     private int[] bits;          public Bitset(int size) {         bits = new int[(size + 31) / 32]; // round up to multiple of 32     }          public void fix(int idx) {         bits[idx / 32] |= (1 << (idx % 32));     }          public void unfix(int idx) {         bits[idx / 32] &= ~(1 << (idx % 32));     }          public void flip() {         for (int i = 0; i < bits.length; i++) {             bits[i] = ~bits[i];         }     }          public boolean all() {         for (int i = 0; i < bits.length - 1; i++) {             if (bits[i] != -1) {                 return false;             }         }         int last = bits[bits.length - 1] & ((1 << (bits.length * 32 % bits.length)) - 1);         return last == ((1 << bits.length * 32 % bits.length) - 1);     }          public boolean one() {         for (int i = 0; i < bits.length; i++) {             if (bits[i] != 0) {                 return true;             }         }         return false;     }          public int count() {         int count = 0;         for (int i = 0; i < bits.length; i++) {             count += Integer.bitCount(bits[i]);         }         return count;     }          public String toString() {         StringBuilder sb = new StringBuilder();         for (int i = 0; i < bits.length * 32; i++) {             sb.append((bits[i / 32] & (1 << (i % 32))) != 0 ? '1' : '0');         }         return sb.toString();     } },1,"2166-design-bitset/Bitset.java:4:5: Redundant 'public' modifier. [RedundantModifier]
2166-design-bitset/Bitset.java:4:5: Redundant 'public' modifier. [RedundantModifier]
2166-design-bitset/Bitset.java:33:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
2166-design-bitset/Bitset.java:43:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
2166-design-bitset/Bitset.java:49:	MissingOverride:	The method 'toString()' is missing an @Override annotation.
2166-design-bitset/Bitset.java:52:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",0,0,1
"class Solution {     public int minimumOperations(int[] nums) {         int even = 0, odd = 0;         for (int i = 0; i < nums.length; i++) {             if (i % 2 == 0) {                 even += nums[i] % 2;                 odd += (nums[i] + 1) % 2;             } else {                 even += (nums[i] + 1) % 2;                 odd += nums[i] % 2;             }         }         return Math.min(even, odd);     } }",1,"2170-minimum-operations-to-make-the-array-alternating/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2170-minimum-operations-to-make-the-array-alternating/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
class Solution {     public long minimumRemoval(int[] beans) {         int sum = 0;         for(int i=0; i<beans.length; i++) {             sum += beans[i];         }         int average = sum / beans.length;         int remainder = sum % beans.length;         Arrays.sort(beans);         int index = 0;         int count = 0;         while(index < beans.length - remainder) {             count += average - beans[index];             index++;         }         while(index < beans.length) {             count += average - 1 - beans[index];             index++;         }         return count;     } },1,"2171-removing-minimum-number-of-magic-beans/Solution.java:4:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
class Solution {     public int[] sumOfThree(int num) {         int[] result = new int[3];         int limit = num / 3;         for(int i = -limit; i <= limit; i++) {             int sum = i + (i + 1) + (i + 2);             if(sum == num) {                 result[0] = i;                 result[1] = i + 1;                 result[2] = i + 2;                 return result;             }         }         return new int[0];     } } ,1,"2177-find-three-consecutive-integers-that-sum-to-a-given-number/Solution.java:6:	UselessParentheses:	Useless parentheses.
2177-find-three-consecutive-integers-that-sum-to-a-given-number/Solution.java:6:	UselessParentheses:	Useless parentheses.
",0,0,0
import java.util.ArrayList; import java.util.List;  public class Solution {     public List<Long> maximumEvenSplit(long finalSum) {         List<Long> result = new ArrayList<>();         long remainingSum = finalSum;         for (long i = 2; i <= finalSum && remainingSum > 0; i += 2) {             if (remainingSum >= i) {                 result.add(i);                 remainingSum -= i;             } else {                 break;             }         }         if (remainingSum == 0 && result.size() > 1 && isUnique(result)) {             return result; // valid solution found         } else {             return new ArrayList<>(); // no valid solution found         }     }          private boolean isUnique(List<Long> list) {         for (int i = 0; i < list.size(); i++) {             for (int j = i + 1; j < list.size(); j++) {                 if (list.get(i).equals(list.get(j))) {                     return false;                 }             }         }         return true;     } },0,,0,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public ListNode mergeNodes(ListNode head) {         ListNode dummyHead = new ListNode(0);         dummyHead.next = head;          ListNode curr = dummyHead;         int sum;          while (curr.next != null && curr.next.next != null) {             if (curr.next.val == 0 && curr.next.next.val == 0) {                 sum = 0;                 ListNode temp = curr.next;                  while (temp.next != null && temp.next.val != 0) {                     sum += temp.next.val;                     temp = temp.next;                 }                 curr.next.next = temp.next;                 curr.next.val = sum;             } else {                 curr = curr.next;             }         }         return dummyHead.next;     } }",0,,0,0,0
"class Solution {     public String repeatLimitedString(String s, int repeatLimit) {         int[] counts = new int[26]; // array to store the count of each character         int n = s.length();         StringBuilder sb = new StringBuilder(); // StringBuilder to build the answer string                  // loop through the characters of the string s         for (int i = 0; i < n; ) {             int j = i;                          // count the number of consecutive occurrences of the current character             while (j < n && s.charAt(i) == s.charAt(j) && j - i + 1 <= repeatLimit) {                 j++;             }                          // append the current character to the answer string             for (int k = 0; k < Math.min(j - i, repeatLimit); k++) {                 sb.append(s.charAt(i));             }                          // update the count of the current character             counts[s.charAt(i) - 'a'] += j - i;                          // move to the next character             i = j;         }                  // loop through the characters of the answer string and rearrange them (if needed)         for (int i = 1; i < sb.length(); i++) {             if (sb.charAt(i) == sb.charAt(i - 1) && counts[sb.charAt(i) - 'a'] > repeatLimit) {                 // if the current character is the same as the previous one, and its count is greater than repeatLimit,                 // then we need to find another character (that is lexicographically larger) to replace it                 int index = i;                 char c = sb.charAt(i);                                  for (int j = 'z'; j >= c; j--) {                     if (counts[j - 'a'] < repeatLimit) {                         // we found a suitable replacement character                         sb.setCharAt(i, (char)j);                         counts[j - 'a']++;                         counts[c - 'a']--;                         break;                     }                 }             }         }                  return sb.toString();     } }",1,"2182-construct-string-with-repeat-limit/Solution.java:8:32: ';' is followed by whitespace. [EmptyForIteratorPad]
2182-construct-string-with-repeat-limit/Solution.java:8:32: ';' is followed by whitespace. [EmptyForIteratorPad]
2182-construct-string-with-repeat-limit/Solution.java:33:	UnusedLocalVariable:	Avoid unused local variables such as 'index'.
",0,0,0
"class Solution {     public int minSteps(String s, String t) {         int[] sCount = new int[26];         int[] tCount = new int[26];                  // Count the frequency of each character in s and t         for (char c : s.toCharArray()) {             sCount[c - 'a']++;         }         for (char c : t.toCharArray()) {             tCount[c - 'a']++;         }                  int diff = 0;         // Calculate the number of characters that need to be changed in s         for (int i = 0; i < 26; i++) {             diff += Math.abs(sCount[i] - tCount[i]);         }                  return diff;     } }",0,,0,0,0
"class Solution {     public static long minimumTime(int[] time, int totalTrips) {         long minTime = 0;         long maxTime = (long) 1e18;         while (minTime < maxTime) {             long midTime = minTime + (maxTime - minTime) / 2;             long completedTrips = 0;             for (int t : time) {                 completedTrips += midTime / t;                 if (completedTrips >= totalTrips) {                     break;                 }             }             if (completedTrips >= totalTrips) {                 maxTime = midTime;             } else {                 minTime = midTime + 1;             }         }         return minTime;     } }",1,"2187-minimum-time-to-complete-trips/Solution.java:1:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
2187-minimum-time-to-complete-trips/Solution.java:1:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
2187-minimum-time-to-complete-trips/Solution.java:1:	UseUtilityClass:	This utility class has a non-private constructor
",0,0,0
"import java.util.Arrays;  class Solution {     public int[] sortJumbled(int[] mapping, int[] nums) {         Map<Integer, String> map = new HashMap<>(); // Map to store mapped values and their corresponding number         for (int num : nums) {             String s = String.valueOf(num); // Convert number to string             StringBuilder sb = new StringBuilder();             for (char c : s.toCharArray()) {                 sb.append(mapping[c - '0']); // Replace each digit with its mapped value             }             String mappedValue = sb.toString();             map.put(num, mappedValue); // Add to map         }         Arrays.sort(nums, (a, b) -> map.get(a).compareTo(map.get(b))); // Sort the original array based on mapped values         return nums;     } }",0,,0,0,0
"import java.util.*;  class Solution {     public List<List<Integer>> getAncestors(int n, int[][] edges) {         List<List<Integer>> answer = new ArrayList<>();         // Create a graph using adjacency list         List<Integer>[] graph = new ArrayList[n];         // Initialize each list to store the ancestors of node i in the ith corresponding position         for (int i = 0; i < n; i++) {             graph[i] = new ArrayList<Integer>();         }         // Create the graph using the edges given         for (int[] edge : edges) {             graph[edge[1]].add(edge[0]);         }         // Traverse each node and find its ancestors         for (int i = 0; i < n; i++) {             List<Integer> ancestors = new ArrayList<>();             boolean[] visited = new boolean[n];             dfs(i, graph, ancestors, visited);             Collections.sort(ancestors);             answer.add(ancestors);         }         return answer;     }     // Recursive dfs to find ancestors     public void dfs(int node, List<Integer>[] graph, List<Integer> ancestors, boolean[] visited) {         // If this node has already been visited, there is no need to visit it again         if (visited[node]) {             return;         }         visited[node] = true;         for (int parent : graph[node]) {             ancestors.add(parent);             dfs(parent, graph, ancestors, visited);         }     } }",1,"2192-all-ancestors-of-a-node-in-a-directed-acyclic-graph/Solution.java:10:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new ArrayList<>()`
",0,0,0
"class Solution {     public long minimalKSum(int[] nums, int k) {         Set<Integer> set = new HashSet<>();         for(int num : nums) {             set.add(num);         }         long sum = 0;         int i = 1;         while(k > 0) {             if(!set.contains(i)) {                 sum += i;                 k--;             }             i++;         }         return sum;     } }",1,"2195-append-k-integers-with-minimal-sum/Solution.java:12:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'k'
",0,1,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public TreeNode createBinaryTree(int[][] descriptions) {         HashMap<Integer, TreeNode> map = new HashMap<>(); // keep track of nodes                  // First pass: create nodes without linking them         for(int[] desc : descriptions) {             int parentVal = desc[0];             int childVal = desc[1];             boolean isLeft = desc[2] == 1;                          TreeNode parent = map.getOrDefault(parentVal, new TreeNode(parentVal));             TreeNode child = map.getOrDefault(childVal, new TreeNode(childVal));                          if(isLeft) {                 parent.left = child;             } else {                 parent.right = child;             }             map.put(parentVal, parent);             map.put(childVal, child);         }                  // Second pass: find the root         TreeNode root = null;         for(int[] desc : descriptions) {             int parentVal = desc[0];             if(!map.containsKey(parentVal)) {                 root = map.get(desc[1]);                 break;             }         }                  return root;     } }",0,,0,0,0
"class Solution {     public int digArtifacts(int n, int[][] artifacts, int[][] dig) {         // Initialize a set to keep track of uncovered cells         Set<String> uncovered = new HashSet<>();         // Initialize a map to keep track of artifacts and their parts         Map<Integer, List<String>> artifactParts = new HashMap<>();         // Loop through artifacts and mark cells as covered         for (int i = 0; i < artifacts.length; i++) {             int r1 = artifacts[i][0];             int c1 = artifacts[i][1];             int r2 = artifacts[i][2];             int c2 = artifacts[i][3];             for (int r = r1; r <= r2; r++) {                 for (int c = c1; c <= c2; c++) {                     uncovered.add(r + "","" + c);                     if (!artifactParts.containsKey(i)) {                         artifactParts.put(i, new ArrayList<>());                     }                     artifactParts.get(i).add(r + "","" + c);                 }             }         }         // Loop through dig commands and mark cells as uncovered         for (int i = 0; i < dig.length; i++) {             int r = dig[i][0];             int c = dig[i][1];             uncovered.remove(r + "","" + c);         }         // Initialize a count for fully uncovered artifacts         int count = 0;         // Loop through artifacts and count fully uncovered ones         for (int i = 0; i < artifacts.length; i++) {             boolean uncoveredAll = true;             for (String part : artifactParts.get(i)) {                 if (uncovered.contains(part)) {                     uncoveredAll = false;                     break;                 }             }             if (uncoveredAll) {                 count++;             }         }         return count;     } }",1,"2201-count-artifacts-that-can-be-extracted/Solution.java:24:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int maximumTop(int[] nums, int k) {         int n = nums.length;          // edge case         if (k == n) {             return Arrays.stream(nums).max().getAsInt();         }          // calculate the prefix sum         long[] prefixSum = new long[n + 1];         for (int i = 1; i <= n; i++) {             prefixSum[i] = prefixSum[i - 1] + nums[i - 1];         }          // binary search to find the largest value of x such that there exists a j         // satisfying X*j - prefixSum[j] + prefixSum[n] - prefixSum[j] <= k         int left = 0, right = n;         while (left < right) {             int mid = left + (right - left + 1) / 2;             boolean check = false;             for (int j = mid; j <= n; j++) {                 long sum = (long) mid * (j - mid) - prefixSum[j] + prefixSum[mid];                 if (sum <= k) {                     check = true;                     break;                 }             }             if (check) {                 left = mid;             } else {                 right = mid - 1;             }         }         if (right == 0) {             return -1;         }         return Arrays.stream(nums, right - 1, n).max().getAsInt();     } }",1,"2202-maximize-the-topmost-element-after-k-moves/Solution.java:18:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2202-maximize-the-topmost-element-after-k-moves/Solution.java:18:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int maximumSubsequenceCount(String text, String pattern) {         int count1 = 0, count2 = 0, count3 = 0, count4 = 0;         // count1: count of pattern[0] followed by pattern[1]         // count2: count of pattern[1] followed by pattern[0]         // count3: count of pattern[0] followed by pattern[0]         // count4: count of pattern[1] followed by pattern[1]         for(int i = 0; i < text.length(); i++){             char ch = text.charAt(i);             if(ch == pattern.charAt(0)){                 if(i+1<text.length() && text.charAt(i+1) == pattern.charAt(1))                     count1++;                 else                     count3++;             }             else if(ch == pattern.charAt(1)){                 if(i+1<text.length() && text.charAt(i+1) == pattern.charAt(0))                     count2++;                 else                     count4++;             }         }         int ans = 0;         ans = Math.max(ans, Math.max(count3, count4)); // count of the pattern already in the text         ans = Math.max(ans, count1 + count2 + 2); // count by adding either pattern[0] or pattern[1] in the middle of the text         ans = Math.max(ans, count1 + count2 + count3 + 1); // count by adding pattern[0] in the beginning and pattern[1] in the end         ans = Math.max(ans, count1 + count2 + count4 + 1); // count by adding pattern[1] in the beginning and pattern[0] in the end         return ans;     } }",1,"2207-maximize-number-of-subsequences-in-a-string/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2207-maximize-number-of-subsequences-in-a-string/Solution.java:15:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2207-maximize-number-of-subsequences-in-a-string/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2207-maximize-number-of-subsequences-in-a-string/Solution.java:15:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",1,0,0
"class Solution {     public int halveArray(int[] nums) {         int sum = 0;         for(int num : nums){             sum += num;         }                  PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a,b)-> b-a);                  for(int num : nums){             pq.offer(num);         }                  int ops = 0;         int curSum = sum;         while(curSum >= sum/2){             int num = pq.poll();             curSum -= num;             pq.offer(num/2);             curSum += num/2;             ops++;         }         return ops;     } }",0,,0,0,0
"class Solution {     public int maximalSquare(char[][] matrix) {         int rows = matrix.length;         int cols = matrix[0].length;         int maxSquareLen = 0;         int[][] dp = new int[rows + 1][cols + 1];          for(int i = 1; i <= rows; i++){             for(int j = 1; j <= cols; j++){                 if(matrix[i-1][j-1] == '1'){                     dp[i][j] = 1 + Math.min(Math.min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]);                     maxSquareLen = Math.max(maxSquareLen, dp[i][j]);                 }             }         }          return maxSquareLen * maxSquareLen;     } }",0,,0,0,0
"import java.util.*;  class Solution {     public int countCollisions(String directions) {         Stack<Integer> leftCars = new Stack<>(); // stack to store left-moving cars         int collisions = 0; // counter for collisions                  for (int i = 0; i < directions.length(); i++) {             char dir = directions.charAt(i); // direction of the current car                          if (dir == 'L') {                 leftCars.push(i); // add the index of the left-moving car to the stack             }             else if (dir == 'R') {                 while (!leftCars.empty()) {                     int leftCar = leftCars.pop(); // get the index of the left-moving car                     if (leftCar < i) { // check if the left-moving car is before the current car                         collisions += 2; // if so, increase the collision count by 2                     }                     else { // if the left-moving car is after the current car, put it back in the stack                         leftCars.push(leftCar);                         break;                     }                 }             }             else { // if the car is stationary, check for collisions with left-moving cars                 while (!leftCars.empty()) {                     int leftCar = leftCars.peek();                     if (leftCar < i) { // check if the left-moving car is before the current car                         collisions++; // if so, increase the collision count by 1                         leftCars.pop(); // and remove the left-moving car from the stack                     }                     else { // if the left-moving car is after the current car, stop checking for collisions                         break;                     }                 }             }         }                  return collisions;     } }",1,"2211-count-collisions-on-a-road/Solution.java:13:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2211-count-collisions-on-a-road/Solution.java:19:21: '}' at column 21 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2211-count-collisions-on-a-road/Solution.java:25:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2211-count-collisions-on-a-road/Solution.java:32:21: '}' at column 21 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2211-count-collisions-on-a-road/Solution.java:13:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2211-count-collisions-on-a-road/Solution.java:19:21: '}' at column 21 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2211-count-collisions-on-a-road/Solution.java:25:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2211-count-collisions-on-a-road/Solution.java:32:21: '}' at column 21 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2211-count-collisions-on-a-road/Solution.java:5:	LooseCoupling:	Avoid using implementation types like 'Stack'; use the interface instead
2211-count-collisions-on-a-road/Solution.java:5:	ReplaceVectorWithList:	Consider replacing this Vector with the newer java.util.List
2211-count-collisions-on-a-road/Solution.java:5:	ReplaceVectorWithList:	Consider replacing this Vector with the newer java.util.List
",0,0,0
"class Solution {     public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {         int[] bobArrows = new int[12]; // initialize Bob's arrow count array         int totalBobPoints = 0; // initialize Bob's total points to 0                  // iterate through each scoring section         for (int k = 0; k < 12; k++) {             // calculate how many arrows Bob needs to shoot to maximize his points on this section             int bobNeeds = numArrows - aliceArrows[k];             bobNeeds = Math.min(bobNeeds, numArrows/2); // Bob cannot shoot more arrows than available, or more than Alice                          // add Bob's points to his total             totalBobPoints += bobNeeds * k;                          // set Bob's arrow count for this section             bobArrows[k] = bobNeeds;         }                  return bobArrows;     } }",1,"2212-maximum-points-in-an-archery-competition/Solution.java:4:	UnusedLocalVariable:	Avoid unused local variables such as 'totalBobPoints'.
",0,0,0
class Solution {     public int minDeletion(int[] nums) {         int count = 0;         for(int i=0; i<nums.length-1; i+=2) {             if(nums[i] == nums[i+1]) {                 count++;             }         }         return count;     } },0,,0,0,0
"import java.util.ArrayList;  class Solution {     public long[] kthPalindrome(int[] queries, int intLength) {         // Create ArrayList to store all palindromes of length intLength         ArrayList<Long> palindromes = new ArrayList<>();                  // Loop through all possible length/2 combinations to create palindromes         for(int i = (int)Math.pow(10, intLength-1); i < (int)Math.pow(10, intLength); i++) {             String s = Integer.toString(i);             StringBuilder sb = new StringBuilder(s);                          // Create palindrome using the first half of the number             for(int j = intLength/2-1; j >= 0; j--) {                 sb.append(s.charAt(j));             }                          // Convert back to long and add to ArrayList             long num = Long.parseLong(sb.toString());             palindromes.add(num);         }                  // Create answer array         long[] answer = new long[queries.length];                  // Loop through queries and find the kth smallest palindrome         for(int i = 0; i < queries.length; i++) {             int index = queries[i] - 1;                          if(index >= palindromes.size()) {                 answer[i] = -1;             } else {                 answer[i] = palindromes.get(index);             }         }                  return answer;     } }",1,"2217-find-palindrome-with-fixed-length/Solution.java:6:	LooseCoupling:	Avoid using implementation types like 'ArrayList'; use the interface instead
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public int countNodes(TreeNode root) {         if (root == null) {  // If the tree is empty             return 0;         }         int leftHeight = getLeftHeight(root.left);  // Get the height of left subtree         int rightHeight = getRightHeight(root.right);  // Get the height of right subtree                  if (leftHeight == rightHeight) {  // If left and right subtrees have same height             return (1 << leftHeight) + countNodes(root.right);  // Use bit manipulation technique to calculate number of nodes         } else {  // If left and right subtrees have different heights             return (1 << rightHeight) + countNodes(root.left);  // Use bit manipulation technique to calculate number of nodes         }     }          // Function to get the height of left subtree     private int getLeftHeight(TreeNode node) {         int height = 0;         while (node != null) {             height++;             node = node.left;         }         return height;     }          // Function to get the height of right subtree     private int getRightHeight(TreeNode node) {         int height = 0;         while (node != null) {             height++;             node = node.right;         }         return height;     } }",1,"222-count-complete-tree-nodes/TreeNode.java:36:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'node'
222-count-complete-tree-nodes/TreeNode.java:46:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'node'
",0,1,0
class Solution {     public int triangularSum(int[] nums) {         int n = nums.length;         while (n > 1) {             int[] newNums = new int[n - 1];             for (int i = 0; i < n - 1; i++) {                 newNums[i] = (nums[i] + nums[i + 1]) % 10;             }             nums = newNums;             n = nums.length;         }         return nums[0];     } },1,"2221-find-triangular-sum-of-an-array/Solution.java:9:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'nums'
",0,1,0
"class Solution {     public long numberOfWays(String s) {         int n = s.length();         int count0 = 0, count1 = 0;         // Counting number of 0's and 1's in the given string         for(int i=0; i<n; i++) {             if(s.charAt(i) == '0') count0++;             else count1++;         }         long ans = 0;         // selecting 3 buildings with no two consecutive buildings of the same type         for(int i=0; i<n; i++) {             if(s.charAt(i) == '0') {                 if(i+2 < n && s.charAt(i+1) == '1' && s.charAt(i+2) == '0') ans += (count1-1)*(count0-2);             }             else {                 if(i+2 < n && s.charAt(i+1) == '0' && s.charAt(i+2) == '1') ans += (count1-2)*(count0-1);             }         }         return ans;     } }",1,"2222-number-of-ways-to-select-buildings/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2222-number-of-ways-to-select-buildings/Solution.java:15:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2222-number-of-ways-to-select-buildings/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2222-number-of-ways-to-select-buildings/Solution.java:15:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",1,0,0
"class Solution {     public List<List<Integer>> findWinners(int[][] matches) {         List<List<Integer>> answer = new ArrayList<>();         Map<Integer, Integer> map = new HashMap<>();         Set<Integer> players = new HashSet<>();         for(int[] match: matches) {             int winner = match[0];             int loser = match[1];             if(!map.containsKey(loser)) players.add(loser);             map.put(winner, map.getOrDefault(winner, 0) + 1);             map.put(loser, map.getOrDefault(loser, 0));         }         List<Integer> notLost = new ArrayList<>();         List<Integer> lostOnce = new ArrayList<>();         for(int player: map.keySet()) {             int numberOfLosses = map.get(player);             if(numberOfLosses == 0) notLost.add(player);             else if(numberOfLosses == 1) lostOnce.add(player);         }         Collections.sort(notLost);         Collections.sort(lostOnce);         answer.add(notLost);         answer.add(lostOnce);         return answer;     } }",0,,0,0,0
"class Solution {     public int maximumCandies(int[] candies, long k) {         int n = candies.length;         int maxCandies = 0;         for (int i = 0; i < n; i++) {             maxCandies += candies[i];         }         int left = 0, right = maxCandies;         while (left <= right) {             int mid = (left + right) / 2;             if (isValid(mid, candies, k)) {                 left = mid + 1;             } else {                 right = mid - 1;             }         }         return right;     }          private boolean isValid(int target, int[] candies, long k) {         long count = 0;         for (int i = 0; i < candies.length; i++) {             count += candies[i] / target;         }         return count >= k;     } }",1,"2226-maximum-candies-allocated-to-k-children/Solution.java:8:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2226-maximum-candies-allocated-to-k-children/Solution.java:8:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2226-maximum-candies-allocated-to-k-children/Solution.java:22:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",1,0,1
"public class Solution {     public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {         // Compute the area of the first rectangle         int area1 = (ax2 - ax1) * (ay2 - ay1);         // Compute the area of the second rectangle         int area2 = (bx2 - bx1) * (by2 - by1);         // Compute the overlapping area         int overlap = Math.max(0, Math.min(ax2, bx2) - Math.max(ax1, bx1)) * Math.max(0, Math.min(ay2, by2) - Math.max(ay1, by1));         // Compute and return the total area         return area1 + area2 - overlap;     } }",1,"223-rectangle-area/Solution.java:2:16: More than 7 parameters (found 8). [ParameterNumber]
223-rectangle-area/Solution.java:2:16: More than 7 parameters (found 8). [ParameterNumber]
",0,0,0
"class Solution {     public String minimizeResult(String expression) {         // Splitting the input string based on '+'         String[] parts = expression.split(""\\+"");                  // Getting the two numbers from the split parts         int num1 = Integer.parseInt(parts[0]);         int num2 = Integer.parseInt(parts[1]);                  // Calculating three possible combinations of brackets - num1+num2, (num1+num2), num1+(num2)         int value1 = num1 + num2;         int value2 = num1 * 10 + num2;         int value3 = num1 + num2 * 10;                  // Comparing the values obtained from the above combinations and returning the corresponding string         if(value1 <= value2 && value1 <= value3) {             return num1 + ""+"" + num2;         }         else if(value2 <= value1 && value2 <= value3) {             return num1 + "" + "" + num2;         }         else {             return num1 + ""+"" + "" "" + num2;         }     } }",1,"2232-minimize-result-by-adding-parentheses-to-expression/Solution.java:18:9: '}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2232-minimize-result-by-adding-parentheses-to-expression/Solution.java:21:9: '}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2232-minimize-result-by-adding-parentheses-to-expression/Solution.java:18:9: '}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2232-minimize-result-by-adding-parentheses-to-expression/Solution.java:21:9: '}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
"class Solution {     public int maximumProduct(int[] nums, int k) {         long maxProd = 1;         long mod = 1000000007;                  Arrays.sort(nums);                  // case 1: if k is even         if(k % 2 == 0) {             int left = 0, right = nums.length - 1;             while(k > 0) {                 if(nums[left] * nums[left+1] > nums[right] * nums[right-1]) {                     maxProd = (maxProd * nums[left] % mod * nums[left+1] % mod) % mod;                     left += 2;                 } else {                     maxProd = (maxProd * nums[right] % mod * nums[right-1] % mod) % mod;                     right -= 2;                 }                 k -= 2;             }         } else { // case 2: if k is odd             int left = 0, right = nums.length - 1;             maxProd = nums[right];             right--;             k--;             while(k > 0) {                 if(nums[left] * nums[left+1] > nums[right] * nums[right-1]) {                     maxProd = (maxProd * nums[left] % mod * nums[left+1] % mod) % mod;                     left += 2;                 } else {                     maxProd = (maxProd * nums[right] % mod * nums[right-1] % mod) % mod;                     right -= 2;                 }                 k -= 2;             }         }                  return (int) maxProd;     } }",1,"2233-maximum-product-after-k-increments/Solution.java:10:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2233-maximum-product-after-k-increments/Solution.java:22:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2233-maximum-product-after-k-increments/Solution.java:10:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2233-maximum-product-after-k-increments/Solution.java:22:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2233-maximum-product-after-k-increments/Solution.java:13:	UselessParentheses:	Useless parentheses.
2233-maximum-product-after-k-increments/Solution.java:16:	UselessParentheses:	Useless parentheses.
2233-maximum-product-after-k-increments/Solution.java:19:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'k'
2233-maximum-product-after-k-increments/Solution.java:28:	UselessParentheses:	Useless parentheses.
2233-maximum-product-after-k-increments/Solution.java:31:	UselessParentheses:	Useless parentheses.
",1,1,0
"class Solution {     public long waysToBuyPensPencils(int total, int cost1, int cost2) {         long distinctWays = 0; //to keep track of distinct ways to buy pens and pencils         for(int i=0; i<=total/cost1; i++){ //iterate through all possible quantities of pens             for(int j=0; j<=total/cost2; j++){ //iterate through all possible quantities of pencils                 if((i*cost1 + j*cost2) == total){ //if the total cost of pens and pencils is equal to the total money you have                     distinctWays++; //increment distinct ways counter                 }             }         }         return distinctWays; //return the total number of distinct ways to buy pens and pencils     } }",0,,0,0,0
"import java.util.*;  class ATM {      private int[] banknotesCount;      public ATM() {         banknotesCount = new int[5];     }      public void deposit(int[] banknotesCount) {         for (int i = 0; i < 5; i++) {             this.banknotesCount[i] += banknotesCount[i];         }     }      public int[] withdraw(int amount) {         int[] result = new int[5];         int remaining = amount;         int[] tempBanknotes = banknotesCount.clone();          for (int i = 4; i >= 0; i--) {             result[i] = Math.min(tempBanknotes[i], remaining / getBanknoteValue(i));             tempBanknotes[i] -= result[i];             remaining -= result[i] * getBanknoteValue(i);         }          if (remaining != 0) {             return new int[] {-1};         }          banknotesCount = tempBanknotes.clone();         return result;     }      private int getBanknoteValue(int index) {         return new int[] {20, 50, 100, 200, 500}[index];     } }  /**  * Your ATM object will be instantiated and called as such:  * ATM obj = new ATM();  * obj.deposit(banknotesCount);  * int[] param_2 = obj.withdraw(amount);  */",1,"2241-design-an-atm-machine/ATM.java:7:5: Redundant 'public' modifier. [RedundantModifier]
2241-design-an-atm-machine/ATM.java:11:31: 'banknotesCount' hides a field. [HiddenField]
2241-design-an-atm-machine/ATM.java:7:5: Redundant 'public' modifier. [RedundantModifier]
2241-design-an-atm-machine/ATM.java:11:31: 'banknotesCount' hides a field. [HiddenField]
2241-design-an-atm-machine/ATM.java:1:	UnnecessaryImport:	Unused import 'java.util.*'
",0,0,0
"class Solution {     public int minimumRounds(int[] tasks) {         Map<Integer, Integer> taskCount = new HashMap<>();                  // count the number of tasks of each difficulty level         for (int task : tasks) {             taskCount.put(task, taskCount.getOrDefault(task, 0) + 1);         }                  int rounds = 0;         while (!taskCount.isEmpty()) {             boolean completed = false;             // try to complete tasks of difficulty level 4 first             if (taskCount.containsKey(4)) {                 int count = taskCount.get(4);                 if (count >= 3) { // complete 3 tasks of difficulty level 4 in one round                     completed = true;                     taskCount.put(4, count - 3);                 } else if (count == 2 && taskCount.size() == 1) { // final round with only 2 tasks of difficulty level 4 remaining                     completed = true;                     taskCount.put(4, count - 2);                 }             }             // if 3 tasks of difficulty level 4 cannot be completed, try to complete 2 or 3 tasks of any other difficulty level             if (!completed) {                 for (int diffLevel : taskCount.keySet()) {                     int count = taskCount.get(diffLevel);                     if (count >= 3) { // complete 3 tasks of the same difficulty level                         completed = true;                         taskCount.put(diffLevel, count - 3);                         break;                     } else if (count == 2 && taskCount.size() == 1) { // final round with only 2 tasks of any difficulty level remaining                         completed = true;                         taskCount.put(diffLevel, count - 2);                         break;                     }                 }             }             // if no tasks can be completed, it is impossible to complete all tasks             if (!completed) {                 return -1;             }             // delete difficulty levels with 0 remaining tasks             taskCount.entrySet().removeIf(entry -> entry.getValue() == 0);             rounds++;         }         return rounds;     } }",0,,0,0,0
"class Solution {     private int maxTrailingZeros = 0;      public int maxTrailingZeros(int[][] grid) {         int m = grid.length;         int n = grid[0].length;         boolean[][] visited = new boolean[m][n];         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 dfs(grid, visited, i, j, i, j, 0, true);             }         }         return maxTrailingZeros;     }          private void dfs(int[][] grid, boolean[][] visited, int i, int j, int startI, int startJ, int trailingZeros, boolean horizontal) {         if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length) {             return;         }         if (visited[i][j]) {             return;         }         visited[i][j] = true;         int currentTrailingZeros = trailingZeros + countTrailingZeros(grid[i][j]);         maxTrailingZeros = Math.max(maxTrailingZeros, currentTrailingZeros);         if (i != startI && j != startJ) {             // A turn has occurred, switch direction             horizontal = !horizontal;         }         if (horizontal) {             // Move horizontally             dfs(grid, visited, i, j-1, startI, startJ, currentTrailingZeros, horizontal);             dfs(grid, visited, i, j+1, startI, startJ, currentTrailingZeros, horizontal);         } else {             // Move vertically             dfs(grid, visited, i-1, j, startI, startJ, currentTrailingZeros, horizontal);             dfs(grid, visited, i+1, j, startI, startJ, currentTrailingZeros, horizontal);         }         visited[i][j] = false;     }          private int countTrailingZeros(int n) {         int count = 0;         while (n > 0 && n % 10 == 0) {             count++;             n /= 10;         }         return count;     } }",1,"2245-maximum-trailing-zeros-in-a-cornered-path/Solution.java:16:18: More than 7 parameters (found 8). [ParameterNumber]
2245-maximum-trailing-zeros-in-a-cornered-path/Solution.java:16:18: More than 7 parameters (found 8). [ParameterNumber]
2245-maximum-trailing-zeros-in-a-cornered-path/Solution.java:2:	AvoidFieldNameMatchingMethodName:	Field maxTrailingZeros has the same name as a method
2245-maximum-trailing-zeros-in-a-cornered-path/Solution.java:28:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'horizontal'
2245-maximum-trailing-zeros-in-a-cornered-path/Solution.java:46:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
",0,1,0
class Solution {     public int countLatticePoints(int[][] circles) {         int result = 0;         for(int i=0; i<circles.length; i++){             int xi = circles[i][0];             int yi = circles[i][1];             int ri = circles[i][2];             for(int x=xi-ri; x<=xi+ri; x++){                 for(int y=yi-ri; y<=yi+ri; y++){                     if((x-xi)*(x-xi) + (y-yi)*(y-yi) <= ri*ri){                         result++;                     }                 }             }         }         return result;     } },1,"2249-count-lattice-points-inside-a-circle/Solution.java:4:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int[] countRectangles(int[][] rectangles, int[][] points) {         int[] result = new int[points.length];         for(int i=0; i<points.length; i++){             int count = 0;             for(int j=0; j<rectangles.length; j++){                 int[] rectangle = rectangles[j];                 int x = points[i][0];                 int y = points[i][1];                 if(x>=0 && x<=rectangle[0] && y>=0 && y<=rectangle[1]){                     count++;                 }             }             result[i] = count;         }         return result;     } }",1,"2250-count-number-of-rectangles-containing-each-point/Solution.java:6:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
class Solution {     public int minimumAverageDifference(int[] nums) {         int n = nums.length;         int[] prefixSum = new int[n + 1];         for (int i = 0; i < n; i++) {             prefixSum[i + 1] = prefixSum[i] + nums[i];         }         int[] minDiffIndices = new int[n];         int minDiffIndex = 0;         for (int i = 0; i < n; i++) {             int firstAvg = prefixSum[i + 1] / (i + 1);             int lastAvg = (prefixSum[n] - prefixSum[i + 1]) / (n - i - 1);             int diff = Math.abs(firstAvg - lastAvg);             minDiffIndices[i] = diff;             if (diff < minDiffIndices[minDiffIndex]) {                 minDiffIndex = i;             }         }         return minDiffIndex;     } },0,,0,0,0
"class Solution {     public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {         boolean[][] grid = new boolean[m][n]; // initialize boolean grid to keep track of guards and walls         int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // 4 cardinal directions         for (int[] wall : walls) {             grid[wall[0]][wall[1]] = true; // mark walls as true in the grid         }         for (int[] guard : guards) {             for (int[] dir : dirs) {                 int i = guard[0] + dir[0];                 int j = guard[1] + dir[1];                 while (i >= 0 && i < m && j >= 0 && j < n && !grid[i][j]) {                     grid[i][j] = true; // mark cells as true if they can be seen by the current guard                     i += dir[0];                     j += dir[1];                 }             }         }         int count = 0;         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 if (!grid[i][j]) {                     count++; // count unguarded cells                 }             }         }         return count;     } }",0,,0,0,0
"class Solution {     public int minimumCardPickup(int[] cards) {         Map<Integer, Integer> lastOccurrences = new HashMap<>();         int minCardPickup = Integer.MAX_VALUE;         for (int i = 0; i < cards.length; i++) {             int card = cards[i];             if (lastOccurrences.containsKey(card)) {                 minCardPickup = Math.min(minCardPickup, i - lastOccurrences.get(card) + 1);             }             lastOccurrences.put(card, i);         }         return minCardPickup == Integer.MAX_VALUE ? -1 : minCardPickup;     } }",0,,0,0,0
"class Solution {     public int countDistinct(int[] nums, int k, int p) {         int n = nums.length;         int[] prefixCount = new int[n];         int count = 0, ans = 0;         Map<Integer, Integer> map = new HashMap<>();         map.put(0, 1);         for (int i = 0; i < n; i++) {             if (nums[i] % p == 0) {                 count++;             }             prefixCount[i] = count;             int target = (count - k < 0) ? 0 : count - k;             ans += map.getOrDefault(prefixCount[i] - target, 0);             map.put(prefixCount[i], map.getOrDefault(prefixCount[i], 0) + 1);         }         return ans;     } }",1,"2261-k-divisible-elements-subarrays/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2261-k-divisible-elements-subarrays/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public int averageOfSubtree(TreeNode root) {         if (root == null) {             return 0;         }          int[] result = new int[1];         dfs(root, result);          return result[0];     }      private int[] dfs(TreeNode node, int[] result) {         int count = 1;         int sum = node.val;          if (node.left != null) {             int[] values = dfs(node.left, result);             count += values[0];             sum += values[1];         }          if (node.right != null) {             int[] values = dfs(node.right, result);             count += values[0];             sum += values[1];         }          if (node.val * count == sum) {             result[0]++;         }          return new int[]{count, sum};     } }",0,,0,0,0
"class Solution {     public int countTexts(String pressedKeys) {         int mod = (int)(1e9+7);                  // creating a 2D array to store the mapping of digits to the corresponding letters         char[][] keypad = {{'0', '0', '0'}, {'1', '1', '1'}, {'a', 'b', 'c'}, {'d', 'e', 'f'},                            {'g', 'h', 'i'}, {'j', 'k', 'l'}, {'m', 'n', 'o'}, {'p', 'q', 'r', 's'},                            {'t', 'u', 'v'}, {'w', 'x', 'y', 'z'}};                  // initializing variables to store the count of possible text messages and the previous count         long totalCount = 1;         long prevCount = 0;                  // looping through the pressed keys and calculating the possible text messages         for(int i=0; i<pressedKeys.length(); i++) {             int key = Character.getNumericValue(pressedKeys.charAt(i));             int letterCount = keypad[key].length;             if(key == 0 || key == 1)                 continue;             if(i > 0 && pressedKeys.charAt(i-1) == pressedKeys.charAt(i)) {                 // if the current key is the same as the previous key, the count of possible text messages remains the same                 // this is because we can only add the same letter to the previous text message, and we have already accounted for it in the previous iteration                 totalCount = prevCount;             }             else {                 // if the current key is different from the previous key, we calculate the new count of possible text messages                 prevCount = totalCount;                 totalCount = (totalCount * letterCount) % mod;             }         }                  // returning the count of possible text messages         return (int)totalCount;     } }",1,"2266-count-number-of-texts/Solution.java:24:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2266-count-number-of-texts/Solution.java:24:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2266-count-number-of-texts/Solution.java:28:	UselessParentheses:	Useless parentheses.
",0,0,0
class Solution {     public int calculate(String s) {         Stack<Integer> stack = new Stack<>();         int num = 0;         char sign = '+';         for (int i = 0; i < s.length(); i++) {             char c = s.charAt(i);             if (Character.isDigit(c)) {                 num = num * 10 + (c - '0');             }             if ((!Character.isDigit(c) && c != ' ') || i == s.length() - 1) {                 if (sign == '+') {                     stack.push(num);                 } else if (sign == '-') {                     stack.push(-num);                 } else if (sign == '*') {                     stack.push(stack.pop() * num);                 } else if (sign == '/') {                     stack.push(stack.pop() / num);                 }                 sign = c;                 num = 0;             }         }         int res = 0;         for (int n : stack) {             res += n;         }         return res;     } },1,"227-basic-calculator-ii/Solution.java:9:	UselessParentheses:	Useless parentheses.
",0,0,0
"class Solution {     public int waysToSplitArray(int[] nums) {         int n = nums.length;         int[] prefixSum = new int[n];         long totalSum = 0;         for (int i = 0; i < n; i++) {             totalSum += nums[i];             prefixSum[i] = (i > 0) ? prefixSum[i - 1] + nums[i] : nums[i];         }         int ans = 0;         for (int i = 1; i < n - 1; i++) {             // using binary search to find suitable ranges for j and k             int left = i, right = n - 2, res = -1;             while (left <= right) {                 int mid = left + (right - left) / 2;                 int prefixSumLeft = prefixSum[mid - 1] - prefixSum[i - 1];                 int prefixSumRight = prefixSum[n - 1] - prefixSum[mid - 1];                 if (prefixSumLeft <= prefixSumRight && prefixSumLeft + totalSum - prefixSum[mid - 1] >= prefixSumRight) {                     res = mid;                     left = mid + 1;                 } else {                     right = mid - 1;                 }             }             if (res != -1) {                 ans += res - i;             }         }         return ans;     } }",1,"2270-number-of-ways-to-split-array/Solution.java:13:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2270-number-of-ways-to-split-array/Solution.java:13:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int maximumWhiteTiles(int[][] tiles, int carpetLen) {         int maxTiles = 0;         int i = 0;         int n = tiles.length;         // traverse the tiles array         while (i < n) {             int li = tiles[i][0];             int ri = tiles[i][1];             // calculate the possible starting positions of the carpet on this tile             int start = li + carpetLen - 1;             int end = ri - carpetLen + 1;             // calculate the maximum number of white tiles that can be covered by carpet starting on each position             int maxStart = Math.min(start, end);             int maxTilesStart = Math.min(maxStart + carpetLen - 1, ri) - maxStart + 1;             if (maxTilesStart > maxTiles) {                 maxTiles = maxTilesStart;             }             i++;         }         return maxTiles;     } }",0,,0,0,0
"class Solution {     public int maxConsecutive(int bottom, int top, int[] special) {         Arrays.sort(special); // sort special floors in ascending order                  int maxConsecutiveFloors = 0;         int lastFloor = bottom - 1; // set lastFloor to one floor below bottom                  for (int i = 0; i < special.length; i++) {             int currentFloor = special[i];             int consecutiveFloors = currentFloor - lastFloor - 1;             maxConsecutiveFloors = Math.max(maxConsecutiveFloors, consecutiveFloors);             lastFloor = currentFloor;         }                  // Check distance between last special floor and top floor         if (lastFloor < top) {             int consecutiveFloors = top - lastFloor;             maxConsecutiveFloors = Math.max(maxConsecutiveFloors, consecutiveFloors);         }                  return maxConsecutiveFloors;     } }",1,"2274-maximum-consecutive-floors-without-special-floors/Solution.java:8:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
class Solution {     public int largestCombination(int[] candidates) {         int n = candidates.length;         int maxCombinationSize = 0;                  // loop through all possible combinations of candidates         for (int i = 0; i < (1 << n); i++) {             int andResult = candidates[0];             int combinationSize = 1;                          // calculate bitwise AND of the current combination and its size             for (int j = 1; j < n; j++) {                 if ((i & (1 << j)) != 0) {                     andResult &= candidates[j];                     combinationSize++;                 }             }             // update maxCombinationSize if the current combination has a greater bitwise AND             if (andResult > 0 && combinationSize > maxCombinationSize) {                 maxCombinationSize = combinationSize;             }         }         return maxCombinationSize;     } },0,,0,0,0
"class Solution {     public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {         int n = capacity.length;         int maxBags = 0;         int totalRocks = 0;         int[] remainingCapacity = new int[n];         for (int i = 0; i < n; i++) {             remainingCapacity[i] = capacity[i] - rocks[i];             maxBags += (rocks[i] == capacity[i] ? 1 : 0);             totalRocks += rocks[i];         }         if (additionalRocks <= 0) return maxBags;         if (totalRocks + additionalRocks == n * capacity[0]) return n;         Arrays.sort(remainingCapacity);         int i = 0;         while (i < n && remainingCapacity[i] <= additionalRocks) {             additionalRocks -= remainingCapacity[i];             i++;             maxBags++;         }         if (i < n && additionalRocks > 0) {             int remainingBags = n - maxBags;             maxBags += (additionalRocks / remainingBags);         }         return maxBags;     } }",1,"2279-maximum-bags-with-full-capacity-of-rocks/Solution.java:17:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'additionalRocks'
",0,1,0
class Solution {     public int minimumLines(int[][] stockPrices) {         int n = stockPrices.length;         if(n <= 2) return n;         int lines = 1;         int dx = stockPrices[1][0] - stockPrices[0][0];         int dy = stockPrices[1][1] - stockPrices[0][1];         for(int i=2;i<n;i++) {             if((stockPrices[i][1] - stockPrices[i-1][1]) * dx != (dy) * (stockPrices[i][0] - stockPrices[i-1][0])) {                 lines++;                 dx = stockPrices[i][0] - stockPrices[i-1][0];                 dy = stockPrices[i][1] - stockPrices[i-1][1];             }         }         return lines;     } },1,"2280-minimum-lines-to-represent-a-line-chart/Solution.java:9:	UselessParentheses:	Useless parentheses.
",0,0,0
"class Solution {     public String largestWordCount(String[] messages, String[] senders) {         Map<String, Integer> wordCountMap = new HashMap<>();         for (int i = 0; i < messages.length; i++) {             int count = messages[i].split("" "").length;             String sender = senders[i];             wordCountMap.put(sender, wordCountMap.getOrDefault(sender, 0) + count);         }         String largestSender = null;         int largestCount = 0;         for (Map.Entry<String, Integer> entry : wordCountMap.entrySet()) {             String sender = entry.getKey();             int count = entry.getValue();             if (count > largestCount || (count == largestCount && (largestSender == null || sender.compareTo(largestSender) > 0))) {                 largestSender = sender;                 largestCount = count;             }         }         return largestSender;     } }",0,,0,0,0
"class Solution {     public long maximumImportance(int n, int[][] roads) {         Map<Integer, List<Integer>> graph = new HashMap<>();         for (int[] road : roads) {             int u = road[0], v = road[1];             graph.computeIfAbsent(u, x -> new ArrayList<>()).add(v);             graph.computeIfAbsent(v, x -> new ArrayList<>()).add(u);         }         int[] values = new int[n];         boolean[] visited = new boolean[n];         dfs(graph, values, visited, 0, 1);         long ans = 0;         for (int[] road : roads) {             int u = road[0], v = road[1];             ans += values[u] * values[v];         }         return ans;     }          private void dfs(Map<Integer, List<Integer>> graph, int[] values, boolean[] visited, int u, int val) {         values[u] = val;         visited[u] = true;         for (int v : graph.getOrDefault(u, new ArrayList<>())) {             if (!visited[v]) {                 dfs(graph, values, visited, v, val + 1);             }         }     } }",1,"2285-maximum-total-importance-of-roads/Solution.java:5:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2285-maximum-total-importance-of-roads/Solution.java:14:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2285-maximum-total-importance-of-roads/Solution.java:5:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2285-maximum-total-importance-of-roads/Solution.java:14:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public String discountPrices(String sentence, int discount) {         String[] words = sentence.split("" "");                  for(int i=0; i<words.length; i++){             String word = words[i];             if(word.startsWith(""$"")){                 String numStr = word.substring(1);                 if(numStr.matches(""^\\d+$"")){ //checking if the string contains only digits                     double num = Double.parseDouble(numStr);                     num = num - (num * discount / 100.0);                     words[i] = String.format(""$%.2f"", num);                 }             }         }                  String result = String.join("" "",words);         return result;     } }",1,"2288-apply-discount-to-prices/Solution.java:17:	UnnecessaryLocalBeforeReturn:	Consider simply returning the value vs storing it in local variable 'result'
",0,0,0
class Solution {     public int totalSteps(int[] nums) {         if (nums == null || nums.length < 2) {             return 0;         }         int count = 0;         boolean flag = true;         while (flag) {             flag = false;             for (int i = 1; i < nums.length; i++) {                 if (nums[i] < nums[i - 1]) {                     int j = i;                     while (j > 0 && nums[j] < nums[j - 1]) {                         int temp = nums[j];                         nums[j] = nums[j - 1];                         nums[j - 1] = temp;                         j--;                     }                     count++;                     flag = true;                 }             }         }         return count;     } },1,"2289-steps-to-make-array-non-decreasing/Solution.java:8:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
2289-steps-to-make-array-non-decreasing/Solution.java:10:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
2289-steps-to-make-array-non-decreasing/Solution.java:13:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
",0,0,0
"import java.util.*;  public class Solution {     public List<Integer> majorityElement(int[] nums) {                  List<Integer> res = new ArrayList<>();                  int n = nums.length;         int count1 = 0, count2 = 0;         int candidate1 = Integer.MIN_VALUE, candidate2 = Integer.MIN_VALUE;                  for (int num : nums) {             if (num == candidate1) {                 count1++;             } else if (num == candidate2) {                 count2++;             } else if (count1 == 0) {                 candidate1 = num;                 count1 = 1;             } else if (count2 == 0) {                 candidate2 = num;                 count2 = 1;             } else {                 count1--;                 count2--;             }         }                  count1 = count2 = 0;         for (int num : nums) {             if (num == candidate1) {                 count1++;             } else if (num == candidate2) {                 count2++;             }         }                  if (count1 > n/3) {             res.add(candidate1);         }                  if (count2 > n/3) {             res.add(candidate2);         }                  return res;     } }",1,"229-majority-element-ii/Solution.java:9:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
229-majority-element-ii/Solution.java:10:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
229-majority-element-ii/Solution.java:29:25: Inner assignments should be avoided. [InnerAssignment]
229-majority-element-ii/Solution.java:9:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
229-majority-element-ii/Solution.java:10:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
229-majority-element-ii/Solution.java:29:25: Inner assignments should be avoided. [InnerAssignment]
",1,0,0
"class Solution {     public int partitionArray(int[] nums, int k) {         Map<Integer, Integer> freqMap = new HashMap<>();         for (int num : nums) {             freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);         }         Map<Integer, Integer> usedMap = new HashMap<>();         int count = 0;         for (int num : nums) {             if (freqMap.get(num) == 0) {                 continue;             }             if (usedMap.getOrDefault(num, 0) > 0) {                 usedMap.put(num, usedMap.get(num) - 1);                 usedMap.put(num + 1, usedMap.getOrDefault(num + 1, 0) + 1);             } else if (freqMap.getOrDefault(num + 1, 0) > 0 && freqMap.getOrDefault(num + 2, 0) > 0) {                 freqMap.put(num + 1, freqMap.get(num + 1) - 1);                 freqMap.put(num + 2, freqMap.get(num + 2) - 1);                 usedMap.put(num + 3, usedMap.getOrDefault(num + 3, 0) + 1);             } else {                 return -1;             }             freqMap.put(num, freqMap.get(num) - 1);             count++;         }         return count;     } }",0,,0,0,0
"class Solution {     public int[] arrayChange(int[] nums, int[][] operations) {         Map<Integer, Integer> map = new HashMap<>();         for (int i = 0; i < nums.length; i++) {             map.put(nums[i], i);         }         for (int[] operation : operations) {             int i = map.get(operation[0]);             nums[i] = operation[1];             map.remove(operation[0]);             map.put(operation[1], i);         }         return nums;     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public int kthSmallest(TreeNode root, int k) {         List<Integer> values = new ArrayList<>();         inorderTraversal(root, values);         return values.get(k-1);     }          private void inorderTraversal(TreeNode node, List<Integer> values) {         if (node == null) {             return;         }         inorderTraversal(node.left, values);         values.add(node.val);         inorderTraversal(node.right, values);     } }",0,,0,0,0
"class Solution {     public int[] successfulPairs(int[] spells, int[] potions, long success) {         int n = spells.length;         int m = potions.length;         int[] pairs = new int[n];         for(int i=0; i<n; i++) {             for(int j=0; j<m; j++) {                 long prod = (long)spells[i] * (long)potions[j];                 if(prod >= success) {                     pairs[i]++;                 }             }         }         return pairs;     } }",1,"2300-successful-pairs-of-spells-and-potions/Solution.java:8:	UnnecessaryCast:	Unnecessary cast (long)
2300-successful-pairs-of-spells-and-potions/Solution.java:8:	UnnecessaryCast:	Unnecessary cast (long)
",0,0,0
"class Solution {     public int minPathCost(int[][] grid, int[][] moveCost) {         int m = grid.length;         int n = grid[0].length;         int[][] cost = new int[m][n];         for (int i = 0; i < n; i++) {             cost[0][i] = grid[0][i];         }         for (int i = 1; i < m; i++) {             for (int j = 0; j < n; j++) {                 cost[i][j] = Integer.MAX_VALUE;                 for (int k = 0; k < n; k++) {                     cost[i][j] = Math.min(cost[i][j], cost[i-1][k] + moveCost[grid[i-1][k]][j] + grid[i][j]);                 }             }         }         int ans = Integer.MAX_VALUE;         for (int i = 0; i < n; i++) {             ans = Math.min(ans, cost[m-1][i]);         }         return ans;     } }",0,,0,0,0
"class Solution {     public int distributeCookies(int[] cookies, int k) {         // Sort the cookies array in ascending order         Arrays.sort(cookies);                  int minUnfairness = Integer.MAX_VALUE;         int n = cookies.length;                  // Iterate over all possible starting points for the k children         for(int i = 0; i <= n-k; i++) {             int j = i + k - 1;             int unfairness = cookies[j] - cookies[i];             minUnfairness = Math.min(minUnfairness, unfairness);         }                  return minUnfairness;     } }",0,,0,0,0
"class Solution {     public int minimumNumbers(int num, int k) {         if (num < k) {             return -1;         }         if (num == k) {             return 1;         }         if (k == 0) {             return num == 0 ? 0 : -1;         }         int unitsDigitSum = k;         int setCount = 1;         while (unitsDigitSum <= num) {             unitsDigitSum += 10 - k;             setCount++;         }         return unitsDigitSum - (10 - k) == num ? setCount : -1;     } }",0,,0,0,0
"class Solution {     public int longestSubsequence(String s, int k) {         int maxLen = 0;         for (int i = 0; i < (1 << s.length()); i++) {             String subStr = """";             int num = 0;             for (int j = 0; j < s.length(); j++) {                 if ((i & (1 << j)) > 0) {                     subStr += s.charAt(j);                 }             }             if (subStr.equals("""")) {                 num = 0;             } else {                 num = Integer.parseInt(subStr, 2);             }             if (num <= k && subStr.length() > maxLen) {                 maxLen = subStr.length();             }         }         return maxLen;     } }",1,"2311-longest-binary-subsequence-less-than-or-equal-to-k/Solution.java:6:	UnusedAssignment:	The initializer for variable 'num' is never used (overwritten on lines 13 and 15)
2311-longest-binary-subsequence-less-than-or-equal-to-k/Solution.java:9:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
2311-longest-binary-subsequence-less-than-or-equal-to-k/Solution.java:12:	LiteralsFirstInComparisons:	Position literals first in String comparisons
",0,0,0
"class Solution {     public int countPairs(int n, int[][] edges) {         int[] degrees = new int[n]; // to store degree of each node         for (int[] edge : edges) { // count degree of both nodes in each edge             degrees[edge[0]]++;             degrees[edge[1]]++;         }                  int[] parent = new int[n]; // to perform union-find operations         int[] size = new int[n]; // size[i] stores the size of the set represented by i's root         for (int i = 0; i < n; i++) {             parent[i] = i; // initialize every node as its own parent             size[i] = 1; // every set initially has size 1         }                  int components = n; // initially there are n connected components         for (int[] edge : edges) {             int u = edge[0], v = edge[1];             if (union(u, v, parent, size)) { // if the edges join two different components                 components--; // reduce the number of components by 1             }         }                  int unreachablePairs = 0; // to count the number of unreachable pairs         for (int i = 0; i < n; i++) {             for (int j = i + 1; j < n; j++) {                 if (parent[i] != parent[j]) { // if i and j belong to different components                     unreachablePairs += size[parent[i]] * size[parent[j]]; // add the product of their set sizes to the result                 }             }         }                  return n * (n - 1) / 2 - unreachablePairs; // total number of pairs - unreachable pairs = reachable pairs     }          private int find(int u, int[] parent) { // find the root of u's set         while (parent[u] != u) {             parent[u] = parent[parent[u]]; // path compression             u = parent[u];         }         return u;     }          private boolean union(int u, int v, int[] parent, int[] size) { // union u and v's sets         int uRoot = find(u, parent);         int vRoot = find(v, parent);         if (uRoot == vRoot) { // if both nodes are already in the same set             return false;         }         if (size[uRoot] > size[vRoot]) { // always attach a smaller set under a larger set to keep the tree balanced             int temp = uRoot;             uRoot = vRoot;             vRoot = temp;         }         parent[uRoot] = vRoot; // attach u's set under v's set         size[vRoot] += size[uRoot]; // update the size of v's set         return true;     } }",1,"2316-count-unreachable-pairs-of-nodes-in-an-undirected-graph/Solution.java:18:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2316-count-unreachable-pairs-of-nodes-in-an-undirected-graph/Solution.java:18:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2316-count-unreachable-pairs-of-nodes-in-an-undirected-graph/Solution.java:16:	UnusedLocalVariable:	Avoid unused local variables such as 'components'.
2316-count-unreachable-pairs-of-nodes-in-an-undirected-graph/Solution.java:39:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'u'
",1,1,0
"class Solution {     public int maximumXOR(int[] nums) {         int maxNum = 0, maxXOR = 0;                  // iterate through all the bits from 31 to 0         for (int i = 30; i >= 0; i--) {             maxNum <<= 1;             // get the set of numbers that have ith bit set             Set<Integer> set = new HashSet<>();             for (int num : nums) {                 set.add(num >> i);             }             // try to set ith bit in the answer             int tmp = maxXOR | (1 << i);             for (int prefix : set) {                 if (set.contains(tmp ^ prefix)) { // if we can get XOR of two prefixes that equals to tmp                     maxXOR = tmp; // ith bit can be set                     break;                 }             }         }          return maxXOR;     } }",1,"2317-maximum-xor-after-operations/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2317-maximum-xor-after-operations/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2317-maximum-xor-after-operations/Solution.java:3:	UnusedLocalVariable:	Avoid unused local variables such as 'maxNum'.
",1,0,0
class Solution {     public int countHousePlacements(int n) {         int mod = 1000000007;         int[] dp = new int[n + 1];         dp[0] = 1; // no house placed         dp[1] = 2; // one house placed         for (int i = 2; i <= n; i++) {             dp[i] = (dp[i - 1] + dp[i - 2]) % mod; // new house placed on different side         }         int result = dp[n];         for (int i = 2; i <= n; i++) {             result = (result + (long) dp[i - 1] * dp[n - i]) % mod; // new house placed on same side         }         return result;     } },0,,0,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public int[][] spiralMatrix(int m, int n, ListNode head) {         int[][] matrix = new int[m][n];         int[] arr = new int[m * n];         ListNode node = head;                  // copy linked list values to array         int i = 0;         while (node != null) {             arr[i] = node.val;             i++;             node = node.next;         }                  // set boundaries         int l = 0, r = n - 1, t = 0, b = m - 1;         int k = 0;                  // fill matrix in spiral order         while (l <= r && t <= b) {             // fill top row             for (i = l; i <= r && k < m * n; i++) {                 matrix[t][i] = arr[k];                 k++;             }             t++;                          // fill right column             for (i = t; i <= b && k < m * n; i++) {                 matrix[i][r] = arr[k];                 k++;             }             r--;                          // fill bottom row             for (i = r; i >= l && k < m * n; i--) {                 matrix[b][i] = arr[k];                 k++;             }             b--;                          // fill left column             for (i = b; i >= t && k < m * n; i--) {                 matrix[i][l] = arr[k];                 k++;             }             l++;         }                  // fill remaining spaces with -1         for (i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 if (matrix[i][j] == 0) {                     matrix[i][j] = -1;                 }             }         }                  return matrix;     } }",1,"2326-spiral-matrix-iv/ListNode.java:26:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2326-spiral-matrix-iv/ListNode.java:26:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2326-spiral-matrix-iv/ListNode.java:12:	NPathComplexity:	The method 'spiralMatrix(int, int, ListNode)' has an NPath complexity of 664, current threshold is 200
",1,0,0
"class Solution {     public int peopleAwareOfSecret(int n, int delay, int forget) {         int MOD = 1000000007;         int[] memo = new int[n+1];         int total = 0;         memo[0] = 1;                  for (int i = 1; i <= n; i++) {             memo[i] = memo[i - 1];             if (i > delay) {                 memo[i] = (memo[i] + memo[i - delay - 1]) % MOD;             }             if (i > forget) {                 memo[i] = (memo[i] - memo[i - forget - 1] + MOD) % MOD;             }             total = (total + memo[i]) % MOD;         }                  return total;     } }",1,"2327-number-of-people-aware-of-a-secret/Solution.java:8:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
",0,0,0
"class Solution {     public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {         int n = buses.length;         int m = passengers.length;         int lo = 0;         int hi = (int) 1e9;         int ans = 0;         Arrays.sort(buses);         Arrays.sort(passengers);         while (lo <= hi) {             int mid = (lo + hi) / 2;             int i = 0;             for (int j = 0; j < n; j++) {                 int seats = capacity;                 while (i < m && passengers[i] <= buses[j]) {                     if (passengers[i] < mid && seats == 0) break;                     i++;                     seats--;                 }             }             if (i == m) {                 ans = mid;                 lo = mid + 1;             } else {                 hi = mid - 1;             }         }         return ans;     } }",0,,0,0,0
"class Solution {     public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {         int n = nums1.length;         long sum = 0;         // Calculate the initial sum of squared difference without modifying any array         for (int i = 0; i < n; i++) {             sum += (long) Math.pow(nums1[i] - nums2[i], 2);         }         // Sort the arrays in non-decreasing order         Arrays.sort(nums1);         Arrays.sort(nums2);         int i = 0, j = 0;         // Modify the arrays to minimize the sum of squared difference         while (k1 > 0 || k2 > 0) {             if (i == n) { // nums1 has been completely modified                 int diff = nums2[j + k2 - 1] - nums2[j];                 sum -= (long) Math.pow(diff, 2);                 k2 = 0;             } else if (j == n) { // nums2 has been completely modified                 int diff = nums1[i + k1 - 1] - nums1[i];                 sum -= (long) Math.pow(diff, 2);                 k1 = 0;             } else if (nums1[i] <= nums2[j]) { // Modify nums1                 int diff = nums1[i + k1 - 1] - nums1[i];                 if (diff <= nums2[j] - nums1[i]) {                     // Modifying nums1[0] gives a smaller difference than modifying nums2[j]                     sum -= (long) Math.pow(diff, 2);                     k1 = 0;                 } else {                     // Modifying nums2[j]                     sum -= (long) Math.pow(nums2[j] - nums1[i], 2);                     k2--;                     i++;                 }             } else { // Modify nums2                 int diff = nums2[j + k2 - 1] - nums2[j];                 if (diff <= nums1[i] - nums2[j]) {                     // Modifying nums2[0] gives a smaller difference than modifying nums1[i]                     sum -= (long) Math.pow(diff, 2);                     k2 = 0;                 } else {                     // Modifying nums1[i]                     sum -= (long) Math.pow(nums1[i] - nums2[j], 2);                     k1--;                     j++;                 }             }         }         return sum;     } }",1,"2333-minimum-sum-of-squared-difference/Solution.java:12:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2333-minimum-sum-of-squared-difference/Solution.java:12:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2333-minimum-sum-of-squared-difference/Solution.java:18:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'k2'
2333-minimum-sum-of-squared-difference/Solution.java:22:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'k1'
",1,1,0
import java.util.*;  class SmallestInfiniteSet {     private TreeSet<Integer> infiniteSet;     private int smallestInt;      public SmallestInfiniteSet() {         infiniteSet = new TreeSet<Integer>();         smallestInt = 1;     }      public int popSmallest() {         int smallest = smallestInt;         if (!infiniteSet.isEmpty()) {             smallest = infiniteSet.pollFirst();         }         if (smallest == smallestInt) {             smallestInt++;         }         return smallest;     }      public void addBack(int num) {         if (num < smallestInt) {             return;         }         infiniteSet.add(num);     } },1,"2336-smallest-number-in-infinite-set/SmallestInfiniteSet.java:7:5: Redundant 'public' modifier. [RedundantModifier]
2336-smallest-number-in-infinite-set/SmallestInfiniteSet.java:7:5: Redundant 'public' modifier. [RedundantModifier]
2336-smallest-number-in-infinite-set/SmallestInfiniteSet.java:4:	LooseCoupling:	Avoid using implementation types like 'TreeSet'; use the interface instead
2336-smallest-number-in-infinite-set/SmallestInfiniteSet.java:8:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new TreeSet<>()`
",0,0,0
"class Solution {     public boolean canChange(String start, String target) {         int n = start.length();         int leftPos = -1, rightPos = -1; // indices of available blank spaces                  // check if it's possible to reach the target         for (int i = 0; i < n; i++) {             if (start.charAt(i) != '_') {                 if (target.charAt(i) != start.charAt(i)) {                     return false; // character is not same in both strings, can't reach target                 }             } else {                 if (leftPos == -1) {                     leftPos = i; // found first available blank space to the left                 } else {                     rightPos = i; // found second available blank space to the right                 }             }         }                  // check if it's possible to move the required pieces to reach the target         for (int i = 0; i < n; i++) {             if (target.charAt(i) != '_') {                 if (start.charAt(i) == '_') {                     // move required piece to the blank space                     if (target.charAt(i) == 'L' && i < rightPos) {                         return false; // can't move 'L' to the right of the right blank space                     } else if (target.charAt(i) == 'R' && i > leftPos) {                         return false; // can't move 'R' to the left of the left blank space                     }                      // update the available blank space                     if (i < leftPos) {                         leftPos--;                         rightPos--;                     } else if (i < rightPos) {                         rightPos--;                     } else {                         leftPos++;                     }                 } else {                     // already occupied, can't reach target                     return false;                 }             }         }         return true;     } }",1,"2337-move-pieces-to-obtain-a-string/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2337-move-pieces-to-obtain-a-string/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2337-move-pieces-to-obtain-a-string/Solution.java:8:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",1,0,0
"class Solution {     public int maximumSum(int[] nums) {         int res = -1;         Map<Integer, Integer> map = new HashMap<>();         for (int num : nums) {             int digitSum = calculateSumOfDigits(num);             if (map.containsKey(9 - digitSum)) {                 int otherNum = map.get(9 - digitSum);                 res = Math.max(res, num + otherNum);             }             map.putIfAbsent(digitSum, num);         }         return res;     }          private int calculateSumOfDigits(int num) {         int sum = 0;         while (num > 0) {             sum += num % 10;             num /= 10;         }         return sum;     } }",1,"2342-max-sum-of-a-pair-with-equal-sum-of-digits/Solution.java:20:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'num'
",0,1,0
"import java.util.Arrays;  class Solution {     public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {         int n = nums.length;         int k = queries.length;         int[] result = new int[k];                  // Convert the string array to integer array.         int[][] numsInt = new int[n][nums[0].length()];         for (int i = 0; i < n; i++) {             for (int j = 0; j < nums[i].length(); j++) {                 numsInt[i][j] = nums[i].charAt(j) - '0';             }         }                  // For each query, trim the numbers to the rightmost 'trimi' digits and find the k-th smallest number.         for (int i = 0; i < k; i++) {             int ki = queries[i][0];             int trimi = queries[i][1];                          // Trim the numbers by keeping only the rightmost 'trimi' digits.             for (int j = 0; j < n; j++) {                 for (int p = 0; p < numsInt[j].length - trimi; p++) {                     numsInt[j][p] = -1;  // Set the leftmost digits to -1.                 }             }                          // Sort the trimmed array to get the k-th smallest number.             int[] arr = new int[n];             for (int j = 0; j < n; j++) {                 arr[j] = convertToInt(numsInt[j]);             }             Arrays.sort(arr);                          // Find the k-th smallest number and its index in the original array.             int kthSmallest = arr[ki - 1];             int index = -1;             for (int j = 0; j < n; j++) {                 if (convertToInt(numsInt[j]) == kthSmallest) {                     index = j;                     break;                 }             }                          // Update the result.             result[i] = index;                          // Reset the numbers to their original length.             for (int j = 0; j < n; j++) {                 for (int p = 0; p < numsInt[j].length - trimi; p++) {                     numsInt[j][p] = numsInt[j][p + trimi];                     numsInt[j][p + trimi] = -1;                 }             }         }                  return result;     }          // Helper function to convert an integer array to integer.     private int convertToInt(int[] arr) {         int num = 0;         for (int i = 0; i < arr.length; i++) {             int digit = arr[i];             if (digit == -1) {                 continue;             }             num = num * 10 + digit;         }         return num;     } }",1,"2343-query-kth-smallest-trimmed-number/Solution.java:64:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
class Solution {     public long zeroFilledSubarray(int[] nums) {         int n = nums.length;         long count = 0; // use long to avoid overflow                  for (int i = 0; i < n; i++) {             if (nums[i] == 0) {                 int j = i + 1;                 while (j < n && nums[j] == 0) { // look for consecutive zeros                     j++;                 }                 int k = j - i; // number of consecutive zeros                 count += k * (k + 1) / 2; // add count of subarrays with k zeros                 i = j - 1; // skip already counted zeros             }         }                  return count;     } },0,,0,0,0
"import java.util.HashMap; import java.util.Map;  class NumberContainers {     // Map to store the index of each number in the container system     Map<Integer, Integer> numberIndexMap;      public NumberContainers() {         numberIndexMap = new HashMap<Integer, Integer>();     }      public void change(int index, int number) {         // Update the map with the new number and its index         numberIndexMap.put(number, index);     }      public int find(int number) {         // Check if the map contains the given number         if (numberIndexMap.containsKey(number)) {             return numberIndexMap.get(number);         }         return -1;     } }  /**  * Your NumberContainers object will be instantiated and called as such:  * NumberContainers obj = new NumberContainers();  * obj.change(index,number);  * int param_2 = obj.find(number);  */",1,"2349-design-a-number-container-system/NumberContainers.java:6:27: Variable 'numberIndexMap' must be private and have accessor methods. [VisibilityModifier]
2349-design-a-number-container-system/NumberContainers.java:8:5: Redundant 'public' modifier. [RedundantModifier]
2349-design-a-number-container-system/NumberContainers.java:6:27: Variable 'numberIndexMap' must be private and have accessor methods. [VisibilityModifier]
2349-design-a-number-container-system/NumberContainers.java:8:5: Redundant 'public' modifier. [RedundantModifier]
2349-design-a-number-container-system/NumberContainers.java:9:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new HashMap<>()`
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode(int x) { val = x; }  * }  */ class Solution {     public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {         if (root == null) {             return null;         }                  // If both nodes are smaller than the root, the LCA must be in the left subtree         if (p.val < root.val && q.val < root.val) {             return lowestCommonAncestor(root.left, p, q);         }         // If both nodes are greater than the root, the LCA must be in the right subtree         else if (p.val > root.val && q.val > root.val) {             return lowestCommonAncestor(root.right, p, q);         }         // Otherwise, the LCA must be the root (or one of its children)         else {             return root;         }     } }",1,"235-lowest-common-ancestor-of-a-binary-search-tree/TreeNode.java:19:9: '}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
235-lowest-common-ancestor-of-a-binary-search-tree/TreeNode.java:23:9: '}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
235-lowest-common-ancestor-of-a-binary-search-tree/TreeNode.java:19:9: '}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
235-lowest-common-ancestor-of-a-binary-search-tree/TreeNode.java:23:9: '}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
"class Solution {     public int equalPairs(int[][] grid) {         int n = grid.length;         int count = 0;                  // Traverse each row         for(int i = 0; i < n; i++) {             // Check with other rows             for(int j = i+1; j < n; j++) {                 // Check if rows i,j are equal                 boolean rowEqual = true;                 for(int k = 0; k < n; k++) {                     if(grid[i][k] != grid[j][k]) {                         // If mismatch in elements                         rowEqual = false;                         break;                     }                 }                                  if(rowEqual) {                     // If rows are equal, check with columns                     for(int l = 0; l < n; l++) {                         boolean colEqual = true;                         for(int m = 0; m < n; m++) {                             if(grid[m][l] != grid[i][m]) {                                 // If mismatch in elements                                 colEqual = false;                                 break;                             }                         }                                                  // If columns are also equal                         if(colEqual) {                             count++;                             break;                         }                     }                 }             }         }                  return count;     } }",0,,0,0,0
"import java.util.*;  class FoodRatings {          // Map to store the food items by cuisine type     Map<String, List<FoodItem>> cuisineMap;          public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {         cuisineMap = new HashMap<>();         for(int i=0; i<foods.length; i++) {             String cuisine = cuisines[i];             FoodItem foodItem = new FoodItem(foods[i], ratings[i]);             if(!cuisineMap.containsKey(cuisine)) {                 cuisineMap.put(cuisine, new ArrayList<>());             }             cuisineMap.get(cuisine).add(foodItem);         }                  // Sort the food item list for each cuisine by rating in descending order         for(List<FoodItem> foodItems : cuisineMap.values()) {             Collections.sort(foodItems);         }     }          public void changeRating(String food, int newRating) {         for(List<FoodItem> foodItems : cuisineMap.values()) {             for(FoodItem foodItem : foodItems) {                 if(foodItem.name.equals(food)) {                     foodItem.rating = newRating;                     // Sort the food item list for this cuisine by rating in descending order after update                     Collections.sort(foodItems);                     return;                 }             }         }     }          public String highestRated(String cuisine) {         List<FoodItem> foodItems = cuisineMap.get(cuisine);         return foodItems.get(0).name;     }          // Inner class to represent a food item     class FoodItem implements Comparable<FoodItem> {         String name;         int rating;                  public FoodItem(String name, int rating) {             this.name = name;             this.rating = rating;         }                  @Override         public int compareTo(FoodItem other) {             if(this.rating == other.rating) {                 return this.name.compareTo(other.name);             }             return other.rating - this.rating;         }     } }  /**  * Your FoodRatings object will be instantiated and called as such:  * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);  * obj.changeRating(food,newRating);  * String param_2 = obj.highestRated(cuisine);  */",1,"2353-design-a-food-rating-system/FoodRatings.java:6:33: Variable 'cuisineMap' must be private and have accessor methods. [VisibilityModifier]
2353-design-a-food-rating-system/FoodRatings.java:8:5: Redundant 'public' modifier. [RedundantModifier]
2353-design-a-food-rating-system/FoodRatings.java:45:16: Variable 'name' must be private and have accessor methods. [VisibilityModifier]
2353-design-a-food-rating-system/FoodRatings.java:46:13: Variable 'rating' must be private and have accessor methods. [VisibilityModifier]
2353-design-a-food-rating-system/FoodRatings.java:48:9: Redundant 'public' modifier. [RedundantModifier]
2353-design-a-food-rating-system/FoodRatings.java:48:32: 'name' hides a field. [HiddenField]
2353-design-a-food-rating-system/FoodRatings.java:48:42: 'rating' hides a field. [HiddenField]
2353-design-a-food-rating-system/FoodRatings.java:6:33: Variable 'cuisineMap' must be private and have accessor methods. [VisibilityModifier]
2353-design-a-food-rating-system/FoodRatings.java:8:5: Redundant 'public' modifier. [RedundantModifier]
2353-design-a-food-rating-system/FoodRatings.java:45:16: Variable 'name' must be private and have accessor methods. [VisibilityModifier]
2353-design-a-food-rating-system/FoodRatings.java:46:13: Variable 'rating' must be private and have accessor methods. [VisibilityModifier]
2353-design-a-food-rating-system/FoodRatings.java:48:9: Redundant 'public' modifier. [RedundantModifier]
2353-design-a-food-rating-system/FoodRatings.java:48:32: 'name' hides a field. [HiddenField]
2353-design-a-food-rating-system/FoodRatings.java:48:42: 'rating' hides a field. [HiddenField]
",0,0,0
class Solution {     public int maximumGroups(int[] grades) {         Arrays.sort(grades); // sort the grades in ascending order         int groups = 0;         int currentSum = 0;         int currentCount = 1;         for (int i = 0; i < grades.length; i++) {             currentSum += grades[i];             if (i == grades.length - 1 || currentSum + grades[i+1] > currentCount * (currentCount + 1) / 2) {                 groups++; // increment groups formed                 currentSum = 0; // reset sum and count for next group                 currentCount = 1;             } else {                 currentCount++;             }         }         return groups;     } },0,,0,0,0
"import java.util.*;  class Solution {     public int closestMeetingNode(int[] edges, int node1, int node2) {         int n = edges.length;         Map<Integer, List<Integer>> graph = new HashMap<>();         for (int i = 0; i < n; i++) {             if (edges[i] != -1) {                 if (!graph.containsKey(i)) {                     graph.put(i, new ArrayList<>());                 }                 graph.get(i).add(edges[i]);             }         }                  Queue<Integer> queue = new LinkedList<>();         boolean[] visited1 = new boolean[n];         boolean[] visited2 = new boolean[n];         queue.offer(node1);         visited1[node1] = true;         int distance1 = 0;         while (!queue.isEmpty()) {             int size = queue.size();             for (int i = 0; i < size; i++) {                 int curr = queue.poll();                 if (curr == node2) {                     return curr;                 }                 if (graph.containsKey(curr)) {                     for (int next : graph.get(curr)) {                         if (!visited1[next]) {                             queue.offer(next);                             visited1[next] = true;                         }                     }                 }             }             distance1++;         }                  queue = new LinkedList<>();         queue.offer(node2);         visited2[node2] = true;         int distance2 = 0;         while (!queue.isEmpty()) {             int size = queue.size();             for (int i = 0; i < size; i++) {                 int curr = queue.poll();                 if (visited1[curr]) {                     return curr;                 }                 if (graph.containsKey(curr)) {                     for (int next : graph.get(curr)) {                         if (!visited2[next]) {                             queue.offer(next);                             visited2[next] = true;                         }                     }                 }             }             distance2++;         }                  return -1;     } }",1,"2359-find-closest-node-to-given-two-nodes/Solution.java:4:	NPathComplexity:	The method 'closestMeetingNode(int[], int, int)' has an NPath complexity of 400, current threshold is 200
2359-find-closest-node-to-given-two-nodes/Solution.java:6:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
2359-find-closest-node-to-given-two-nodes/Solution.java:21:	UnusedLocalVariable:	Avoid unused local variables such as 'distance1'.
2359-find-closest-node-to-given-two-nodes/Solution.java:44:	UnusedLocalVariable:	Avoid unused local variables such as 'distance2'.
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode(int x) { val = x; }  * }  */ class Solution {     public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {         if (root == null || p == root || q == root) {             return root;         }         TreeNode left = lowestCommonAncestor(root.left, p, q);         TreeNode right = lowestCommonAncestor(root.right, p, q);         if (left != null && right != null) {             return root;         } else {             return left != null ? left : right;         }     } }",0,,0,0,0
"class Solution {     public long countBadPairs(int[] nums) {         int n = nums.length;         long count = 0;         for (int i = 0; i < n; i++) {             for (int j = i+1; j < n; j++) {                 if (i < j && j - i != nums[j] - nums[i]) {                     count++;                 }             }         }         return count;     } }   // Test cases public class Main {     public static void main(String[] args) {         Solution solution = new Solution();          int[] nums1 = {4, 1, 3, 3};  // Output: 5         System.out.println(solution.countBadPairs(nums1));          int[] nums2 = {1, 2, 3, 4, 5};  // Output: 0         System.out.println(solution.countBadPairs(nums2));     } }",1,"2364-count-number-of-bad-pairs/Main.java:17:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
2364-count-number-of-bad-pairs/Main.java:17:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
2364-count-number-of-bad-pairs/Main.java:17:	UseUtilityClass:	This utility class has a non-private constructor
",0,0,0
"public class Solution {     public long taskSchedulerII(int[] tasks, int space) {         // Initialize a hashmap to store the frequency of each task         Map<Integer, Integer> taskFreq = new HashMap<>();         for(int task : tasks) {             taskFreq.put(task, taskFreq.getOrDefault(task, 0) + 1);         }                  // Initialize a priority queue to store the tasks in descending order of frequency         PriorityQueue<Map.Entry<Integer, Integer>> maxHeap = new PriorityQueue<>((a, b) -> b.getValue() - a.getValue());         maxHeap.addAll(taskFreq.entrySet());                  // Initialize a counter for the number of days elapsed         int daysElapsed = 0;                  // Loop until all tasks are completed         while(!maxHeap.isEmpty()) {             // Initialize a temporary list to store tasks performed in a day             List<Map.Entry<Integer, Integer>> temp = new ArrayList<>();                          // Loop for space+1 times or until all tasks are performed for the day             for(int i = 0; i <= space; i++) {                 if(!maxHeap.isEmpty()) {                     Map.Entry<Integer, Integer> currTask = maxHeap.poll();                     currTask.setValue(currTask.getValue() - 1);                     if(currTask.getValue() > 0) {                         temp.add(currTask);                     }                     daysElapsed++;                 } else if(temp.isEmpty()) {                     break;                 } else {                     daysElapsed++;                 }             }                          // Add the uncompleted tasks back to the priority queue             maxHeap.addAll(temp);         }                  return daysElapsed;     } }",1,"2365-task-scheduler-ii/Solution.java:23:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",0,0,0
"class Solution {     public int reachableNodes(int n, int[][] edges, int[] restricted) {         // create adjacency matrix for the graph         int[][] graph = new int[n][n];         for (int[] edge : edges) {             int u = edge[0], v = edge[1];             graph[u][v] = graph[v][u] = 1;         }                  // mark restricted nodes         boolean[] isRestricted = new boolean[n];         for (int node : restricted) {             isRestricted[node] = true;         }                  // implementation of Dijkstra's algorithm using PriorityQueue         PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[1] - a[1]);         pq.offer(new int[]{0, n}); // [node, remaining steps from node 0]         boolean[] visited = new boolean[n];         int ans = 0;                  while (!pq.isEmpty()) {             int[] top = pq.poll();             int node = top[0], steps = top[1];             if (visited[node]) continue; // already visited             visited[node] = true;             if (isRestricted[node]) continue; // node is restricted                         ans++;                                      // continue exploration if there are still remaining steps             // but mark how many steps can be taken from each unvisited neighboring node             // considering nodes that have to be skipped to reach it             if (steps > 0) {                 for (int i = 0; i < n; i++) {                     if (graph[node][i] == 1) {                         int dist = steps - 1;                         if (isRestricted[i]) {                             dist = Math.min(dist, graph[i][node] - 1); // no more than the remaining steps from the other side                         }                         pq.offer(new int[]{i, dist});                         graph[node][i] = graph[i][node] = Math.max(graph[node][i] - steps, 0);                     }                 }             }         }         return ans;     } }",1,"2368-reachable-nodes-with-restrictions/Solution.java:6:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2368-reachable-nodes-with-restrictions/Solution.java:7:39: Inner assignments should be avoided. [InnerAssignment]
2368-reachable-nodes-with-restrictions/Solution.java:24:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2368-reachable-nodes-with-restrictions/Solution.java:41:57: Inner assignments should be avoided. [InnerAssignment]
2368-reachable-nodes-with-restrictions/Solution.java:6:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2368-reachable-nodes-with-restrictions/Solution.java:7:39: Inner assignments should be avoided. [InnerAssignment]
2368-reachable-nodes-with-restrictions/Solution.java:24:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2368-reachable-nodes-with-restrictions/Solution.java:41:57: Inner assignments should be avoided. [InnerAssignment]
2368-reachable-nodes-with-restrictions/Solution.java:11:	LinguisticNaming:	Linguistics Antipattern - The variable 'isRestricted' indicates linguistically it is a boolean, but it is 'boolean[]'
2368-reachable-nodes-with-restrictions/Solution.java:37:	AvoidDeeplyNestedIfStmts:	Deeply nested if..then statements are hard to read
",1,0,0
class Solution {     public boolean validPartition(int[] nums) {         int n = nums.length;         boolean[] dp = new boolean[n];         for(int i=0; i<n; i++) {             for(int j=i-1; j>=0 && j>=i-2; j--) {                 if(i-j==1) {                     dp[i] = (nums[i] == nums[j]);                 }                 else if(i-j == 2) {                     dp[i] = (nums[i] == nums[j] && nums[i] == nums[i-1]);                 }                 else {                     dp[i] = (dp[i] || (dp[j] && nums[i] == nums[i-1] + 1 && nums[i-1] == nums[j+1]));                 }                 if(dp[i]) break;             }         }         return dp[n-1];     } },1,"2369-check-if-there-is-a-valid-partition-for-the-array/Solution.java:9:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2369-check-if-there-is-a-valid-partition-for-the-array/Solution.java:12:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2369-check-if-there-is-a-valid-partition-for-the-array/Solution.java:9:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2369-check-if-there-is-a-valid-partition-for-the-array/Solution.java:12:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode(int x) { val = x; }  * }  */ class Solution {     public void deleteNode(ListNode node) {         node.val = node.next.val;         node.next = node.next.next;     } },0,,0,0,0
"class Solution {     public int longestIdealString(String s, int k) {         int n = s.length();         int[][] dp = new int[n][26];         int maxLen = 0;                  // Calculate dp values for each character in the string         for (int i = 0; i < n; i++) {             int currChar = s.charAt(i) - 'a';             for (int j = 0; j < 26; j++) {                 if (i > 0) {                      // Check if the absolute difference between the two characters is less than or equal to k                     int diff = Math.abs(currChar - j);                     if (diff <= k) {                         dp[i][currChar] = Math.max(dp[i][currChar], dp[i-1][j] + 1);                     }                 }                 else {                     dp[i][currChar] = 1;                 }                                  // Track the maximum length so far                 maxLen = Math.max(maxLen, dp[i][currChar]);             }         }                  return maxLen;     } }",1,"2370-longest-ideal-subsequence/Solution.java:17:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2370-longest-ideal-subsequence/Solution.java:17:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
"class Solution {     public int edgeScore(int[] edges) {         int n = edges.length;         int[] inDegree = new int[n]; // stores the in-degree of each node         int[] score = new int[n]; // stores the edge score of each node                  // calculate the in-degree of each node         for (int i = 0; i < n; i++) {             inDegree[edges[i]]++;         }                  // calculate the edge score of each node         for (int i = 0; i < n; i++) {             if (inDegree[i] == 0) { // there is no incoming edge to this node                 continue;             }             int prevNode = i;             while (inDegree[prevNode] > 0) { // traverse back to all incoming nodes                 int nextNode = edges[prevNode];                 score[nextNode] += i; // add the label of the previous node to the score                 prevNode = nextNode;             }         }                  int maxScore = 0, maxIndex = 0;         for (int i = 0; i < n; i++) {             if (score[i] > maxScore) {                 maxScore = score[i];                 maxIndex = i;             }         }         return maxIndex;     } }",1,"2374-node-with-highest-edge-score/Solution.java:25:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2374-node-with-highest-edge-score/Solution.java:25:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public String smallestNumber(String pattern) {         // Length of the pattern         int n = pattern.length();          // Array to store digits from 1 to 9         int[] digits = new int[10];          // Array to store the result         int[] result = new int[n + 1];           // Start filling the result array from the end         int i = n, j;         for (j = 9; j >= 0; j--) {             // If the pattern has 'I' at the end, set the last digit as 9             if (pattern.charAt(n - 1) == 'I' && j < 9) continue;              digits[j] = 1; // Mark the digit as used             result[i] = j; // Add the digit to the result             i--; // Move to the previous index             break;         }          // Traverse the remaining pattern         for (int k = n - 2; k >= 0; k--) {             if (pattern.charAt(k) == 'D') {                 // If the pattern has 'D', add the smallest available digit to the result                 result[i] = getSmallestUnusedDigit(digits);             } else {                 // If the pattern has 'I', add the next larger digit to the result                 for (j = result[i + 1] - 1; j >= 0; j--) {                     if (digits[j] == 1) continue; // Skip the already used digits                     digits[j] = 1; // Mark the digit as used                     result[i] = j; // Add the digit to the result                     i--; // Move to the previous index                     break;                 }             }         }          StringBuilder sb = new StringBuilder();         for (int digit: result) {             sb.append(digit);         }         return sb.toString();     }      // Utility function to get the smallest unused digit from 1 to 9     private int getSmallestUnusedDigit(int[] digits) {         for (int i = 0; i < 10; i++) {             if (digits[i] == 0) {                 digits[i] = 1;                 return i;             }         }         return -1;     } }",1,"2375-construct-smallest-number-from-di-string/Solution.java:11:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2375-construct-smallest-number-from-di-string/Solution.java:11:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2375-construct-smallest-number-from-di-string/Solution.java:18:	AvoidBranchingStatementAsLastInLoop:	Avoid using a branching statement as the last in a loop.
2375-construct-smallest-number-from-di-string/Solution.java:33:	AvoidBranchingStatementAsLastInLoop:	Avoid using a branching statement as the last in a loop.
",1,0,0
class Solution {     public int[] productExceptSelf(int[] nums) {         int n = nums.length;         int[] left = new int[n];         int[] right = new int[n];         int[] answer = new int[n];                  left[0] = 1;         for (int i = 1; i < n; i++) {             left[i] = nums[i - 1] * left[i - 1];         }                  right[n-1] = 1;         for (int i = n - 2; i >= 0; i--) {             right[i] = nums[i + 1] * right[i + 1];         }                  for (int i = 0; i < n; i++) {             answer[i] = left[i] * right[i];         }                  return answer;     } },0,,0,0,0
"class Solution {     public int secondsToRemoveOccurrences(String s) {         int count = 0;         while (s.contains(""01"")) { //checking for the presence of ""01"" in the string             s = s.replaceAll(""01"", ""10""); //replacing all ""01"" with ""10""             count++; //incrementing the count of seconds         }         return count; //returning the number of seconds     } }",1,"2380-time-needed-to-rearrange-a-binary-string/Solution.java:5:	AvoidReassigningParameters:	Avoid reassigning parameters such as 's'
",0,1,0
"class Solution {     public String shiftingLetters(String s, int[][] shifts) {                  int n = s.length();         int[] finalShift = new int[n];         StringBuilder sb = new StringBuilder();                  // Calculating the total shift for each index         for(int i=n-1; i>=0; i--) {             if(i == n-1) {                 finalShift[i] = shifts[i][2] == 0 ? -shifts[i][1] : shifts[i][1];             }             else {                 finalShift[i] = finalShift[i+1];                 if(shifts[i][2] == 0) {                     finalShift[i] -= shifts[i][1];                 }                 else {                     finalShift[i] += shifts[i][1];                 }             }         }                  // Shifting each character by the total shift calculated         for(int i=0; i<n; i++) {             char c = (char) (((int)s.charAt(i) - 97 + finalShift[i]%26)%26 + 97);             sb.append(c);         }                  return sb.toString();     } }",1,"2381-shifting-letters-ii/Solution.java:12:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2381-shifting-letters-ii/Solution.java:17:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2381-shifting-letters-ii/Solution.java:12:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2381-shifting-letters-ii/Solution.java:17:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2381-shifting-letters-ii/Solution.java:9:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
2381-shifting-letters-ii/Solution.java:26:	UnnecessaryCast:	Unnecessary cast (int)
",0,0,0
"class Solution {     public String largestPalindromic(String num) {         int[] frequency = new int[10];         int len = num.length();         int sum = 0;         for(int index = 0; index < len; index++) {             int digit = num.charAt(index) - '0';             frequency[digit]++;             sum += digit;         }                  if(sum == 0) {             return ""0"";         }                  StringBuilder sb = new StringBuilder();         int oddDigit = -1;                  for(int index = 9; index >= 0; index--) {             while(frequency[index] > 0) {                 if(index % 2 != 0) {                     oddDigit = index;                 }                 sb.append(index);                 frequency[index]--;             }         }                  if(oddDigit != -1) {             sb.append(oddDigit);         }                  return sb.toString();     } }",0,,0,0,0
"import java.util.*;  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public int amountOfTime(TreeNode root, int start) {         Map<TreeNode, TreeNode> parent = new HashMap<>();         Queue<TreeNode> queue = new LinkedList<>();         Set<TreeNode> visited = new HashSet<>();                  // BFS to find the start node and build the parent map         TreeNode startNode = null;         queue.offer(root);         while (!queue.isEmpty()) {             TreeNode curr = queue.poll();             if (curr.val == start) {                 startNode = curr;             }             if (curr.left != null) {                 parent.put(curr.left, curr);                 queue.offer(curr.left);             }             if (curr.right != null) {                 parent.put(curr.right, curr);                 queue.offer(curr.right);             }         }                  // BFS to infect all nodes and determine the maximum depth         queue.offer(startNode);         visited.add(startNode);         int depth = -1;         while (!queue.isEmpty()) {             int size = queue.size();             depth++;             for (int i = 0; i < size; i++) {                 TreeNode curr = queue.poll();                 if (curr.left != null && !visited.contains(curr.left)) {                     queue.offer(curr.left);                     visited.add(curr.left);                 }                 if (curr.right != null && !visited.contains(curr.right)) {                     queue.offer(curr.right);                     visited.add(curr.right);                 }                 TreeNode par = parent.get(curr);                 if (par != null && !visited.contains(par)) {                     queue.offer(par);                     visited.add(par);                 }             }         }                  return depth;     } }",1,"2385-amount-of-time-for-binary-tree-to-be-infected/TreeNode.java:19:	NPathComplexity:	The method 'amountOfTime(TreeNode, int)' has an NPath complexity of 261, current threshold is 200
2385-amount-of-time-for-binary-tree-to-be-infected/TreeNode.java:20:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
",0,0,0
class Solution {     public String removeStars(String s) {         StringBuilder sb = new StringBuilder();         int lastNonStarIndex = -1;         for (int i = 0; i < s.length(); i++) {             if (s.charAt(i) == '*') {                 int j = i - 1;                 while (j > lastNonStarIndex && s.charAt(j) == '*') {                     j--;                 }                 if (j <= lastNonStarIndex) {                     continue;                 }                 sb.deleteCharAt(j);                 sb.deleteCharAt(j);                 lastNonStarIndex = j - 1;             } else {                 sb.append(s.charAt(i));                 lastNonStarIndex = i;             }         }         return sb.toString();     } },0,,0,0,0
"class Solution {     public int garbageCollection(String[] garbage, int[] travel) {         int metal = 0, paper = 0, glass = 0; // stores the count of garbage types         int metalTime = 0, paperTime = 0, glassTime = 0; // stores the time required to collect each garbage type         int totalTime = 0; // overall time required to collect all garbage                  for (int i = 0; i < garbage.length; i++) {             String curr = garbage[i];             for (int j = 0; j < curr.length(); j++) {                 char c = curr.charAt(j);                 if (c == 'M') {                     metal++;                 } else if (c == 'P') {                     paper++;                 } else if (c == 'G') {                     glass++;                 }             }             if (i != garbage.length - 1) { // if not last house, add the travel time to next house                 int travelTime = travel[i];                 metalTime += travelTime;                 paperTime += travelTime;                 glassTime += travelTime;             }         }                  // calculate the time required to collect each garbage type         if (metal > 0) {             metalTime += metal + 1;         }         if (paper > 0) {             paperTime += paper + 1;         }         if (glass > 0) {             glassTime += glass + 1;         }                  // calculate the total time required         totalTime = Math.max(metalTime, Math.max(paperTime, glassTime));         totalTime -= Math.max(0, metalTime - metal - 1); // adjust for any unused time on metal         totalTime -= Math.max(0, paperTime - paper - 1); // adjust for any unused time on paper         totalTime -= Math.max(0, glassTime - glass - 1); // adjust for any unused time on glass                  return totalTime;     } }",1,"2391-minimum-amount-of-time-to-collect-garbage/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2391-minimum-amount-of-time-to-collect-garbage/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2391-minimum-amount-of-time-to-collect-garbage/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2391-minimum-amount-of-time-to-collect-garbage/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2391-minimum-amount-of-time-to-collect-garbage/Solution.java:5:	UnusedAssignment:	The initializer for variable 'totalTime' is never used (overwritten on line 39)
",1,0,0
"class Solution {     public boolean isStrictlyPalindromic(int n) {         //iterating through all possible bases (2 to n-2)         for(int base=2;base<=n-2;base++){             int temp=n;             String num="""";             //converting the number to base(b)             while(temp>0){                 int rem=temp%base;                 num=rem+num;                 temp/=base;             }             //checking for palindrome             if(!isPalindrome(num)){                 return false;             }         }         return true;     }          //helper function to check if a string is palindrome or not     public boolean isPalindrome(String s){         int i=0;         int j=s.length()-1;         while(i<=j){             if(s.charAt(i)!=s.charAt(j)){                 return false;             }             i++;             j--;         }         return true;     } }",1,"2396-strictly-palindromic-number/Solution.java:10:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
",0,0,0
"class Solution {     public int maximumRows(int[][] matrix, int numSelect) {         int m = matrix.length;         int n = matrix[0].length;         int maxRows = 0;          for (int i = 0; i < (1 << n); i++) {             Set<Integer> cols = new HashSet<>();             int count = 0;              for (int j = 0; j < n; j++) {                 if ((i & (1 << j)) != 0) {                     cols.add(j);                 }             }              for (int k = 0; k < m; k++) {                 boolean covered = true;                 for (int col : cols) {                     if (matrix[k][col] == 0) {                         covered = false;                         break;                     }                 }                 if (covered) {                     count++;                 }             }             maxRows = Math.max(maxRows, count);         }         return maxRows;     } }",0,,0,0,0
"class Solution {     public boolean searchMatrix(int[][] matrix, int target) {         int i = 0; // row pointer         int j = matrix[0].length - 1; // column pointer starting from rightmost column of row 1                  while(i < matrix.length && j >= 0) { // till pointer stays within the matrix bounds             if(matrix[i][j] < target)                 i++; // move to next row as value couldn't be present in current row             else if(matrix[i][j] > target)                 j--; // move to previous column as value couldn't be present in current column             else                 return true; // value found         }                  return false; // value not found     } }",0,,0,0,0
"class Solution {     public int numberOfWays(int startPos, int endPos, int k) {         int mod = 1000000007;         int[][] dp = new int[1001][1001];         dp[0][startPos] = 1;         for (int i = 1; i <= k; i++) {             for (int j = 1; j <= 1000; j++) {                 dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j + 1]) % mod;             }         }         return dp[k][endPos];     } }",0,,0,0,0
"class Solution {     public int longestNiceSubarray(int[] nums) {         int n = nums.length;         int longestSubarray = 0;         for(int i=0;i<n;i++){             for(int j=i;j<n;j++){                 if(isNice(nums,i,j)){                     longestSubarray = Math.max(longestSubarray,j-i+1);                 }             }         }         return longestSubarray;     }     private boolean isNice(int[] nums,int l,int r){         if(r-l<1){             return true;         }         Set<Integer> set = new HashSet<>();         for(int i=l;i<=r;i++){             set.add(nums[i]);         }         for(int i=l;i<=r;i++){             for(int j=l;j<=r;j++){                 if(i!=j && (nums[i]&nums[j])==0){                     return false;                 }             }         }         return true;     } }",0,,0,0,0
"import java.util.*;  class Solution {          public int partitionString(String s) {                  Map<Character, Integer> lastIdx = new HashMap<>();         int start = 0, end = 0, n = s.length(), parts = 0;                  for(int i = 0; i < n; i++) {             lastIdx.put(s.charAt(i), i);         }                  while(end < n) {             char ch = s.charAt(end);             end++;             if(lastIdx.get(ch) > end) {                 end = lastIdx.get(ch);             }             if(end == n) {                 parts++;                 break;             }             int j = end;             while(j > start) {                 char curr = s.charAt(j-1);                 if(lastIdx.get(curr) > end)                     end = lastIdx.get(curr);                 j--;             }               start = end;             parts++;              }                  return parts;     } }",1,"2405-optimal-partition-of-string/Solution.java:8:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2405-optimal-partition-of-string/Solution.java:8:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2405-optimal-partition-of-string/Solution.java:7:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
",1,0,0
"class Solution {     public int minGroups(int[][] intervals) {         // Sort the intervals by the start time         Arrays.sort(intervals, (a, b) -> a[0] - b[0]);                  // Use a priority queue to keep track of the end times of the current groups         PriorityQueue<Integer> pq = new PriorityQueue<>();                  for (int[] interval : intervals) {             // If the current interval doesn't overlap with any existing groups, add it to a new group             if (pq.isEmpty() || pq.peek() >= interval[1]) {                 pq.offer(interval[1]);             } else {                 // Otherwise, merge the interval with the group that has the earliest end time                 pq.poll();                 pq.offer(interval[1]);             }         }                  return pq.size();     } }",0,,0,0,0
"import java.util.ArrayList; import java.util.List;  public class Solution {     public List<Integer> diffWaysToCompute(String expression){         List<Integer> result = new ArrayList<>();         for(int i=0; i<expression.length(); i++){             char c = expression.charAt(i);             if(c == '+' || c == '-' || c == '*'){                 String left = expression.substring(0, i);                 String right = expression.substring(i+1);                 List<Integer> leftValues = diffWaysToCompute(left);                 List<Integer> rightValues = diffWaysToCompute(right);                 for(int leftValue : leftValues){                     for(int rightValue : rightValues){                         if(c == '+'){                             result.add(leftValue + rightValue);                         }                         else if(c == '-'){                             result.add(leftValue - rightValue);                         }                         else{                             result.add(leftValue * rightValue);                         }                     }                 }             }         }         if(result.isEmpty()){   // only single number left in the expression             result.add(Integer.parseInt(expression));         }         return result;     } }",1,"241-different-ways-to-add-parentheses/Solution.java:18:25: '}' at column 25 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
241-different-ways-to-add-parentheses/Solution.java:21:25: '}' at column 25 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
241-different-ways-to-add-parentheses/Solution.java:18:25: '}' at column 25 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
241-different-ways-to-add-parentheses/Solution.java:21:25: '}' at column 25 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
"class Solution {     public int matchPlayersAndTrainers(int[] players, int[] trainers) {         Arrays.sort(players); // sort players in increasing order of their abilities         Arrays.sort(trainers); // sort trainers in increasing order of their training capacity                  int maxMatchings = 0;         int i = 0, j = 0; // pointers to keep track of which player and trainer are being considered         while (i < players.length && j < trainers.length) {             if (players[i] <= trainers[j]) { // player can be matched with trainer                 maxMatchings++; // increment number of matchings                 i++; // move to next player                 j++; // move to next trainer             } else { // player's ability is greater than trainer's training capacity                 j++; // move to next trainer and try to find a better match for the current player             }         }         return maxMatchings;     } }",1,"2410-maximum-matching-of-players-with-trainers/Solution.java:7:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2410-maximum-matching-of-players-with-trainers/Solution.java:7:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"import java.util.Arrays;  class Solution {     public int[] smallestSubarrays(int[] nums) {         int n = nums.length;         int[] answer = new int[n];         Arrays.fill(answer, n);          // Iterate over all possible bit positions in a number         for (int b = 0; b <= 30; b++) {             int last = -1;             // Iterate over all elements of the array             for (int i = 0; i < n; i++) {                 // If current element has the current bit set                 if ((nums[i] & (1 << b)) != 0) {                     // Check if we have already seen an element with this bit set before                     if (last != -1) {                         answer[i] = Math.min(answer[i], i - last);                     }                     // Update last occurrence of this bit                     last = i;                 }             }             // If no element with current bit set, move to next bit             if (last == -1) {                 continue;             }             // Update all elements not covered by the last subarray             for (int i = 0; i < n; i++) {                 if (answer[i] == n && (nums[i] & (1 << b)) == 0) {                     answer[i] = i - last + 1;                 }             }         }          return answer;     } }",0,,0,0,0
"class Solution {     public int longestContinuousSubstring(String s) {         int maxLen = 1;         int curLen = 1;         for (int i = 1; i < s.length(); i++) {             if (s.charAt(i) - s.charAt(i-1) == 1) {                 curLen++;             } else {                 maxLen = Math.max(maxLen, curLen);                 curLen = 1;             }         }         return Math.max(maxLen, curLen);     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public TreeNode reverseOddLevels(TreeNode root) {         reverseLevel(root, 1);         return root;     }          private void reverseLevel(TreeNode node, int level) {         if (node == null) {             return;         }                  if (level % 2 != 0) {             reverseLevel(node.left, level+1);             reverseLevel(node.right, level+1);             swap(node);         } else {             reverseLevel(node.left, level+1);             reverseLevel(node.right, level+1);         }     }          private void swap(TreeNode node) {         TreeNode temp = node.left;         node.left = node.right;         node.right = temp;     } }",1,"2415-reverse-odd-levels-of-binary-tree/TreeNode.java:27:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",0,0,0
"class Solution {     public int longestSubarray(int[] nums) {         int res = 0;         int n = nums.length;         for(int i = 0; i < n; i++) {             int and = nums[i];             int len = 1;             if(and > res) {                 for(int j = i + 1; j < n; j++) {                     if((and & nums[j]) == and) {                         len++;                     } else {                         break;//if there is any element which is not common we break the loop                     }                 }                 res = Math.max(res, len);             }         }         return res;     } }",0,,0,0,0
"class Solution {     public List<Integer> goodIndices(int[] nums, int k) {         List<Integer> goodIndices = new ArrayList<>();         int[] prefixMax = new int[nums.length]; // to store the max till i from left.          int[] suffixMin = new int[nums.length]; // to store the min from i to end of array.                  // caluculate prefix max         prefixMax[k-1] = nums[k-1];         for(int i=k;i<nums.length;i++) {             prefixMax[i] = Math.max(prefixMax[i-1], nums[i]);         }                  // calculate suffix min         suffixMin[nums.length - k] = nums[nums.length - k];         for(int i=nums.length-k-1; i>=0; i--) {             suffixMin[i] = Math.min(suffixMin[i+1], nums[i]);         }                  // check for good indices         for(int i=k;i<nums.length-k;i++) {             if(prefixMax[i-k] >= nums[i] && nums[i] <= suffixMin[i+k]) {                 goodIndices.add(i);             }         }                  return goodIndices;     } }",0,,0,0,0
class LUPrefix {     int[] videos;     int longestUploadedPrefix;      public LUPrefix(int n) {         videos = new int[n];         longestUploadedPrefix = 0;     }      public void upload(int video) {         videos[video - 1] = 1;         int currentLength = calculateLength();         if (currentLength > longestUploadedPrefix) {             longestUploadedPrefix = currentLength;         }     }      public int longest() {         return longestUploadedPrefix;     }      private int calculateLength() {         int count = 0;         for (int i = 0; i < videos.length; i++) {             if (videos[i] == 1) {                 count++;             } else {                 break;             }         }         return count;     } }  /**  * Your LUPrefix object will be instantiated and called as such:  * LUPrefix obj = new LUPrefix(n);  * obj.upload(video);  * int param_2 = obj.longest();  */,1,"2424-longest-uploaded-prefix/LUPrefix.java:2:11: Variable 'videos' must be private and have accessor methods. [VisibilityModifier]
2424-longest-uploaded-prefix/LUPrefix.java:3:9: Variable 'longestUploadedPrefix' must be private and have accessor methods. [VisibilityModifier]
2424-longest-uploaded-prefix/LUPrefix.java:5:5: Redundant 'public' modifier. [RedundantModifier]
2424-longest-uploaded-prefix/LUPrefix.java:2:11: Variable 'videos' must be private and have accessor methods. [VisibilityModifier]
2424-longest-uploaded-prefix/LUPrefix.java:3:9: Variable 'longestUploadedPrefix' must be private and have accessor methods. [VisibilityModifier]
2424-longest-uploaded-prefix/LUPrefix.java:5:5: Redundant 'public' modifier. [RedundantModifier]
2424-longest-uploaded-prefix/LUPrefix.java:24:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int xorAllNums(int[] nums1, int[] nums2) {         int xor = 0; // initialize the bitwise XOR variable         for(int i=0; i<nums1.length; i++) { // loop through nums1 array             for(int j=0; j<nums2.length; j++) { // loop through nums2 array                 xor ^= nums1[i] ^ nums2[j]; // calculate the pairwise XOR and update the result             }         }         return xor; // return the final bitwise XOR of all the integers     } }",1,"2425-bitwise-xor-of-all-pairings/Solution.java:4:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
2425-bitwise-xor-of-all-pairings/Solution.java:5:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int maxSum(int[][] grid) {                  int maxSum = Integer.MIN_VALUE; //initialize with minimum integer value                  int rows = grid.length;         int cols = grid[0].length;                  //loop through the grid         for(int i=0; i<rows-2; i++){             for(int j=0; j<cols-2; j++){                                  //calculate the hourglass sum for current position (i,j)                 int hourglassSum = grid[i][j] + grid[i][j+1] + grid[i][j+2] +                                     grid[i+1][j+1] +                                    grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];                                  //check if this hourglass sum is greater than previous maxSum                 maxSum = Math.max(maxSum, hourglassSum);              }         }                  //return the maximum sum of the hourglass         return maxSum;     } }",0,,0,0,0
"class Solution {     public int minimizeXor(int num1, int num2) {         int bitCount = Integer.bitCount(num2); // getting the set bit count of num2         int min = Integer.MAX_VALUE, x = 0;         for(int i=0; i<=(1<<bitCount)-1; i++){             int temp = (num2 ^ getVal(num1, bitCount, i)); // calculating the XOR value             if(temp < min){ // updating the minimum value of XOR                 min = temp;                 x = getVal(num1, bitCount, i);             }         }         return x;     }          // helper function to convert int to binary string     private String intToBinary(int x, int bitCount){         String str = Integer.toBinaryString(x);         while(str.length() < bitCount)             str = ""0"" + str;         return str;     }          // helper function to get integer from binary string     private int getVal(int num, int bitCount, int i){         String str = intToBinary(num, 32);         int index = bitCount-1;         char[] arr = str.toCharArray();         for(int j=arr.length-1; j>=0; j--){             if(arr[j] == '1'){                 if(index == i){                     return Integer.parseUnsignedInt(str, 2);                 }                 index--;             }         }         return Integer.parseUnsignedInt(str, 2);     } }",1,"2429-minimize-xor/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2429-minimize-xor/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2429-minimize-xor/Solution.java:6:	UselessParentheses:	Useless parentheses.
2429-minimize-xor/Solution.java:19:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
",1,0,0
class Solution {     public int[] findArray(int[] pref) {         // Initialize the XOR of array elements         int xorElements = 0;         for(int i=0; i < pref.length; i++){             xorElements ^= pref[i];         }                  int[] result = new int[pref.length];         result[0] = xorElements;                  // Find the remaining array elements using the XOR with previous element         for(int i=1; i < pref.length; i++){             result[i] = result[i-1] ^ pref[i-1];         }                  return result;     } }  // Time Complexity: O(n) // Space Complexity: O(n),1,"2433-find-the-original-array-of-prefix-xor/Solution.java:5:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public String robotWithString(String s) {         String t = """"; // The robot initially holds an empty string t         StringBuilder p = new StringBuilder(); // Use a StringBuilder to construct the output string          // Keep looping until both s and t are empty         while (!s.isEmpty() || !t.isEmpty()) {             // If t is empty, we can only select the first character of s and add it to t             if (t.isEmpty()) {                 t += s.charAt(0);                 s = s.substring(1); // Remove the first character of s             } else if (s.isEmpty()) {                 // If s is empty, we can only select the last character of t and add it to the output string p                 p.append(t.charAt(t.length() - 1));                 t = t.substring(0, t.length() - 1); // Remove the last character of t             } else if (s.charAt(0) < t.charAt(t.length() - 1)) {                 // If the first character of s is lexicographically smaller than the last character of t, we add it to t                 t += s.charAt(0);                 s = s.substring(1); // Remove the first character of s             } else {                 // Otherwise, we select the last character of t and add it to the output string p                 p.append(t.charAt(t.length() - 1));                 t = t.substring(0, t.length() - 1); // Remove the last character of t             }         }         return p.toString(); // Return the lexicographically smallest string that can be written on the paper     } }  ",1,"2434-using-a-robot-to-print-the-lexicographically-smallest-string/Solution.java:10:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
2434-using-a-robot-to-print-the-lexicographically-smallest-string/Solution.java:11:	AvoidReassigningParameters:	Avoid reassigning parameters such as 's'
2434-using-a-robot-to-print-the-lexicographically-smallest-string/Solution.java:18:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
",0,1,0
"import java.util.*;  class Solution {     static int MOD = 1000000007;      public int[] productQueries(int n, int[][] queries) {         int[] powers = calcPowers(n);         int[] answers = new int[queries.length];         for (int i = 0; i < queries.length; i++) {             int left = queries[i][0];             int right = queries[i][1];             int product = 1;             for (int j = left; j <= right; j++) {                 product = (int) ((long) product * powers[j] % MOD);             }             answers[i] = product;         }         return answers;     }      private int[] calcPowers(int n) {         List<Integer> powers = new ArrayList<>();         while (n > 0) {             int power = getLargestPower(n);             powers.add(power);             n -= 1 << power;         }         int[] arr = new int[powers.size()];         for (int i = 0; i < arr.length; i++) {             arr[i] = 1 << powers.get(i);         }         return arr;     }      private int getLargestPower(int n) {         int power = 0;         while ((1 << power) <= n) {             power++;         }         return power - 1;     } }",1,"2438-range-product-queries-of-powers/Solution.java:4:16: Variable 'MOD' must be private and have accessor methods. [VisibilityModifier]
2438-range-product-queries-of-powers/Solution.java:4:16: Variable 'MOD' must be private and have accessor methods. [VisibilityModifier]
2438-range-product-queries-of-powers/Solution.java:4:	MutableStaticState:	Do not use non-final non-private static fields
2438-range-product-queries-of-powers/Solution.java:26:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
",0,1,0
"class Solution {     public int minimizeArrayValue(int[] nums) {         int n = nums.length;         int max = 0;         for (int i = 1; i < n; i++) {             if (nums[i] > 0) {                 int diff = Math.min(nums[i], nums[i - 1] + nums[i] - nums[i - 1]);                 nums[i] -= diff;                 nums[i - 1] += diff;             }         }         for (int num : nums) {             max = Math.max(max, num);         }         return max;     } }",0,,0,0,0
"class Solution {     public int countDistinctIntegers(int[] nums) {         Set<Integer> set = new HashSet<>();         for(int num : nums) {             int reversedNum = 0;             while(num > 0) {                 reversedNum = reversedNum * 10 + num % 10;                 num = num / 10;             }             set.add(reversedNum);         }         return set.size();     } }  // Time Complexity: O(n*k), where n is the length of the array and k is the length of the maximum integer in the array // Space Complexity: O(n)",0,,0,0,0
class Solution {     public boolean sumOfNumberAndReverse(int num) {         int original = num;         int reverse = 0;         while(num>0) {             int lastDigit = num%10;             reverse = reverse*10 + lastDigit;             num = num/10;         }         int sum = original + reverse;         int temp = sum;         int reverseSum = 0;         while(temp>0) {             int lastDigit = temp%10;             reverseSum = reverseSum*10 + lastDigit;             temp = temp/10;         }         return sum == reverseSum;     } },1,"2443-sum-of-number-and-its-reverse/Solution.java:8:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'num'
",0,1,0
"class Solution {     public int subarrayGCD(int[] nums, int k) {         int n = nums.length;         int count = 0;         int[][] dp = new int[n][n];         for (int i = 0; i < n; i++) { // Initialize dp array             dp[i][i] = nums[i];             if (dp[i][i] == k) count++;         }         for (int len = 2; len <= n; len++) {             for (int i = 0, j = len - 1; j < n; i++, j++) {                 dp[i][j] = gcd(dp[i][j - 1], nums[j]);                 if (dp[i][j] == k) count++;             }         }         return count;     }      public int gcd(int a, int b) {         if (b == 0) return a;         return gcd(b, a % b);     } }",1,"2447-number-of-subarrays-with-gcd-equal-to-k/Solution.java:11:	ForLoopVariableCount:	Too many control variables in the for statement
",0,0,0
"import java.util.ArrayList; import java.util.List;  class Solution {     public List<String> twoEditWords(String[] queries, String[] dictionary) {         List<String> result = new ArrayList<>();          for (String query : queries) {             if (dictionaryContains(query, dictionary)) {                 result.add(query);             }         }          return result;     }      private boolean dictionaryContains(String query, String[] dictionary) {         if (dictionary == null || dictionary.length == 0) {             return false;         }          for (String dictWord : dictionary) {             if (query.equals(dictWord)) {                 return true;             }              if (isWithinOneEditDistance(query, dictWord)) {                 return true;             }              for (int i = 0; i < query.length(); i++) {                 StringBuilder sb = new StringBuilder(query);                 sb.setCharAt(i, dictWord.charAt(i));                  if (isWithinOneEditDistance(sb.toString(), dictWord)) {                     return true;                 }             }         }          return false;     }      private boolean isWithinOneEditDistance(String s1, String s2) {         int diffCount = 0;          for (int i = 0; i < s1.length(); i++) {             if (s1.charAt(i) != s2.charAt(i)) {                 diffCount++;             }              if (diffCount > 1) {                 return false;             }         }          return diffCount == 1;     } }",0,,0,0,0
"class Solution {     public int destroyTargets(int[] nums, int space) {         Arrays.sort(nums); // Sorting the array, to perform binary search         int n = nums.length;         int maxTargetsDestroyed = 0;         int ans = nums[0];  // ans is the minimum value of nums[i]         for (int i = 0; i < n; i++) {             int currTarget = nums[i];             int currMaxTargetsDestroyed = 0;             int left = i, right = n - 1;             while (left <= right) {                 int mid = left + (right - left) / 2;                 int count = getCount(nums, i, mid, currTarget, space);                 currMaxTargetsDestroyed = Math.max(currMaxTargetsDestroyed, count);                 if (count >= maxTargetsDestroyed) {  // Updating the answer if more targets can be destroyed                     if (currMaxTargetsDestroyed > maxTargetsDestroyed || currTarget < ans) {                         ans = currTarget;                     }                     maxTargetsDestroyed = count;                 }                 if (count == 0) {                     break;                 } else if (count < currMaxTargetsDestroyed || mid == left || mid == right) {                     break;                 } else if (count < maxTargetsDestroyed) {                     right = mid - 1;                 } else {                     left = mid + 1;                 }             }         }         return ans;     }          // This method returns the number of targets that can be destroyed     // by seeding the machine with the value of nums[index],     // and considering only the targets between the indices start and end,     // which are spaced by multiples of space from nums[index]     private int getCount(int[] nums, int index, int end, int target, int space) {         int start = index;         while (start < end && nums[start] < target) {             start++;         }         while (end >= start && nums[end] > target + (end - index) * space) {             end--;         }         return end - start + 1;     } }",1,"2453-destroy-sequential-targets/Solution.java:10:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2453-destroy-sequential-targets/Solution.java:10:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2453-destroy-sequential-targets/Solution.java:45:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'end'
",1,1,0
"import java.util.*;  class Solution {     public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {         Map<String, Integer> creatorViewsMap = new HashMap<>(); // map to store each creator's views         Map<String, String> creatorMostPopularVideoMap = new HashMap<>(); // map to store each creator's most popular video                  // iterate through the given array and update the maps         for (int i = 0; i < creators.length; i++) {             String creator = creators[i];             int viewCount = views[i];             String id = ids[i];                          // update the creator's total views             creatorViewsMap.put(creator, creatorViewsMap.getOrDefault(creator, 0) + viewCount);                          // update the creator's most popular video             String previousMostPopularVideo = creatorMostPopularVideoMap.getOrDefault(creator, """");             if (previousMostPopularVideo.equals("""") || viewCount > views[Arrays.asList(ids).indexOf(previousMostPopularVideo)]) {                 creatorMostPopularVideoMap.put(creator, id);             }             else if (viewCount == views[Arrays.asList(ids).indexOf(previousMostPopularVideo)] && id.compareTo(previousMostPopularVideo) < 0) {                 creatorMostPopularVideoMap.put(creator, id);             }         }                  // find the creators with the highest popularity by iterating through the creatorViewsMap         int maxViews = 0;         for (int viewCount : creatorViewsMap.values()) {             maxViews = Math.max(maxViews, viewCount);         }                  // add the creators with the highest popularity and their most popular videos to the answer list         List<List<String>> answer = new ArrayList<>();         for (String creator : creatorViewsMap.keySet()) {             int viewsCount = creatorViewsMap.get(creator);             if (viewsCount == maxViews) {                 String mostPopularVideo = creatorMostPopularVideoMap.get(creator);                 List<String> pair = new ArrayList<>();                 pair.add(creator);                 pair.add(mostPopularVideo);                 answer.add(pair);             }         }                  return answer;     } }",1,"2456-most-popular-video-creator/Solution.java:21:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2456-most-popular-video-creator/Solution.java:21:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2456-most-popular-video-creator/Solution.java:5:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
2456-most-popular-video-creator/Solution.java:6:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
2456-most-popular-video-creator/Solution.java:19:	LiteralsFirstInComparisons:	Position literals first in String comparisons
",0,0,0
"class Solution {     public long makeIntegerBeautiful(long n, int target) {         if (n < target) {             return 0; // no need to add any digits as n is already beautiful         }         String strN = Long.toString(n);         int sum = 0;         for (char ch : strN.toCharArray()) {             sum += ch - '0'; // calculating the sum of digits in n         }         if (sum <= target) {             return 0; // no need to add any digits as n is already beautiful         }         int diff = sum - target;         Long x = Long.parseLong(""1"" + ""0"".repeat(strN.length() - 1)); // finding the minimum non-negative integer with the same number of digits as n         while (diff > 0) {             int digit = Character.getNumericValue(Long.toString(x).charAt(0)); // getting the first digit of x             int reduceBy = Math.min(digit, diff); // calculating the amount by which we need to reduce x to make n beautiful             x -= reduceBy * (long) Math.pow(10, Long.toString(x).length() - 1); // reducing x by the required amount             diff -= reduceBy; // updating the remaining difference         }         return x - n; // returning the minimum non-negative value of x which makes n beautiful     } }",0,,0,0,0
"class Solution {     public long maximumSubarraySum(int[] nums, int k) {         if(k > nums.length) {             return 0;         }                  long maxSum = Long.MIN_VALUE;         int left = 0;         int right = 0;         Set<Integer> set = new HashSet<>();                  while(right < nums.length) {             while(set.contains(nums[right])) {                 set.remove(nums[left]);                 left++;             }                          set.add(nums[right]);             right++;                          if(right - left == k) {                 long currSum = 0;                 for(int i = left; i < right; i++) {                     currSum += nums[i];                 }                 maxSum = Math.max(maxSum, currSum);                                  set.remove(nums[left]);                 left++;             }         }                  return maxSum == Long.MIN_VALUE ? 0 : maxSum;     } }",0,,0,0,0
"class Solution {     public long totalCost(int[] costs, int k, int candidates) {         int n = costs.length;         int[][] workers = new int[n][2];         for (int i = 0; i < n; i++) {             workers[i][0] = costs[i];             workers[i][1] = i;         }         Arrays.sort(workers, (a, b) -> a[0] - b[0]);          PriorityQueue<Integer> pq = new PriorityQueue<>();         long totalCost = 0;         for (int i = 0; i < k; i++) {             int start = i * candidates;             int end = Math.min(n - 1, start + candidates - 1);             int minCost = Integer.MAX_VALUE;             int minIndex = -1;             for (int j = start; j <= end; j++) {                 if (!pq.contains(workers[j][1])) {                     minCost = workers[j][0];                     minIndex = workers[j][1];                     break;                 }             }             if (minIndex == -1) {                 minCost = workers[start][0];                 minIndex = workers[start][1];             }             pq.offer(minIndex);             totalCost += minCost;         }          return totalCost;     } }",0,,0,0,0
"class Solution {     public int countGoodStrings(int low, int high, int zero, int one) {         int mod = 1000000007;         int n = high - low + 1;         long[][][] dp = new long[n + 1][zero + 1][one + 1];         dp[0][0][0] = 1;         for (int i = 1; i <= n; i++) {             int l = i + low - 1;             for (int j = 0; j <= zero; j++) {                 for (int k = 0; k <= one; k++) {                     long a = 0, b = 0;                     if (j >= 1) {                         a = dp[i - 1][j - 1][k];                     }                     if (k >= 1) {                         b = dp[i - 1][j][k - 1];                     }                     dp[i][j][k] = (a + b) % mod;                 }             }         }         long ans = 0;         for (int i = 0; i <= zero; i++) {             for (int j = 0; j <= one; j++) {                 if (low <= i + j && i + j <= high) {                     ans += dp[n][i][j];                     ans %= mod;                                      }             }         }         return (int)ans;     } }",1,"2466-count-ways-to-build-good-strings/Solution.java:11:21: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2466-count-ways-to-build-good-strings/Solution.java:11:21: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2466-count-ways-to-build-good-strings/Solution.java:8:	UnusedLocalVariable:	Avoid unused local variables such as 'l'.
",1,0,0
"class Solution {     public int mostProfitablePath(int[][] edges, int bob, int[] amount) {         // Build the adjacency list graph         List<List<Integer>> graph = new ArrayList<>();         for (int i = 0; i < amount.length; i++) {             graph.add(new ArrayList<>());         }         for (int[] edge : edges) {             graph.get(edge[0]).add(edge[1]);             graph.get(edge[1]).add(edge[0]);         }                  // Run depth-first search from the root node         int[] aliceNetIncome = dfs(graph, 0, bob, amount, new boolean[amount.length]);         return aliceNetIncome[0];     }      private int[] dfs(List<List<Integer>> graph, int node, int bob, int[] amount, boolean[] visited) {         visited[node] = true;         int aliceNetIncome = (amount[node] >= 0) ? amount[node] : 0;         int aliceMaxIncome = 0;         for (int neighbor : graph.get(node)) {             if (visited[neighbor]) {                 continue;             }             int[] neighborIncome = dfs(graph, neighbor, bob, amount, visited);                          // Calculate the net income for Alice and Bob at the current node             int aliceIncomeAtNode = aliceNetIncome + neighborIncome[1];             int bobIncomeAtNode = neighborIncome[0] - aliceNetIncome;                          // Calculate the maximum net income for Alice after reaching the leaf nodes             if (neighborIncome[2] >= 0) {                 aliceMaxIncome = Math.max(aliceMaxIncome, aliceIncomeAtNode + neighborIncome[2]);             }                          // Update the net income and max income for Alice and Bob             if (aliceIncomeAtNode < bobIncomeAtNode) {                 aliceNetIncome = neighborIncome[1];             } else {                 aliceNetIncome = (aliceIncomeAtNode + bobIncomeAtNode) / 2;             }         }                  // Return the net income and max income for Alice and Bob at the current node         int bobNetIncome = 0;         if (node == bob) {             bobNetIncome = aliceNetIncome;             aliceNetIncome = 0;         }         return new int[] {bobNetIncome + aliceNetIncome, aliceMaxIncome, amount[node]};     } }",1,"2467-most-profitable-path-in-a-tree/Solution.java:5:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int subarrayLCM(int[] nums, int k) {         int count = 0;         for (int i = 0; i < nums.length; i++) {             int lcm = nums[i];             if (lcm == k) {                 count++;             }             for (int j = i + 1; j < nums.length; j++) {                 lcm = getLCM(lcm, nums[j]);                 if (lcm == k) {                     count++;                 }             }         }         return count;     }          private int getLCM(int a, int b) {         return a * b / getGCD(a, b);     }          private int getGCD(int a, int b) {         if (b == 0) {             return a;         }         return getGCD(b, a % b);     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     private int minOperations;      public int minimumOperations(TreeNode root) {         minOperations = 0;         List<List<Integer>> levels = new ArrayList<>();         collectLevels(root, 0, levels);         for (List<Integer> level : levels) {             if (!isIncreasing(level)) {                 minOperations += sortLevel(level);             }         }         return minOperations;     }      private void collectLevels(TreeNode node, int level, List<List<Integer>> levels) {         if (node == null) {             return;         }         if (level >= levels.size()) {             levels.add(new ArrayList<>());         }         levels.get(level).add(node.val);         collectLevels(node.left, level + 1, levels);         collectLevels(node.right, level + 1, levels);     }      private boolean isIncreasing(List<Integer> level) {         for (int i = 1; i < level.size(); i++) {             if (level.get(i) <= level.get(i - 1)) {                 return false;             }         }         return true;     }      private int sortLevel(List<Integer> level) {         int ops = 0;         Queue<Integer> queue = new LinkedList<>(level);         while (!isIncreasing(level)) {             for (int i = 0, n = queue.size(); i < n; i++) {                 int x = queue.poll();                 if (i == 0 || x >= queue.peek()) {                     queue.offer(x);                 } else {                     queue.offer(queue.poll());                     queue.offer(x);                 }             }             ops++;             level.clear();             level.addAll(queue);         }         minOperations += ops;         return ops;     } }",1,"2471-minimum-number-of-operations-to-sort-a-binary-tree-by-level/TreeNode.java:56:	ForLoopVariableCount:	Too many control variables in the for statement
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public int[][] closestNodes(TreeNode root, int[] queries) {         int[][] answer = new int[queries.length][2]; // initialize answer array                  for (int i = 0; i < queries.length; i++) {             int query = queries[i];             TreeNode node = root;             int mini = -1;             int maxi = -1;                          while (node != null) {                 if (node.val <= query) {                     mini = node.val;                     node = node.right;                 } else {                     maxi = node.val;                     node = node.left;                 }             }                          answer[i][0] = mini;             answer[i][1] = maxi;         }                  return answer;     } }",0,,0,0,0
"class Solution {     public long minimumFuelCost(int[][] roads, int seats) {         int n = roads.length + 1; // number of cities         List<Integer>[] graph = new List[n];         for (int i = 0; i < n; i++) {             graph[i] = new ArrayList<>();         }         for (int[] road : roads) {             int u = road[0], v = road[1];             graph[u].add(v);             graph[v].add(u);         }         long[] dist = new long[n]; // minimum fuel cost to reach each city         dfs(0, -1, graph, dist, seats);         return dist[0]; // return the fuel cost to reach the capital city     }      private void dfs(int u, int parent, List<Integer>[] graph, long[] dist, int seats) {         dist[u] = 0;         for (int v : graph[u]) {             if (v != parent) {                 dfs(v, u, graph, dist, seats);                 long fuel = (long) Math.ceil(dist[v] / (double) seats); // fuel cost to travel from v to u                 dist[u] += fuel;             }         }     } }",1,"2477-minimum-fuel-cost-to-report-to-the-capital/Solution.java:9:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2477-minimum-fuel-cost-to-report-to-the-capital/Solution.java:9:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int[][] onesMinusZeros(int[][] grid) {         int m = grid.length;         int n = grid[0].length;         int[][] diff = new int[m][n];         int[] onesRow = new int[m];         int[] onesCol = new int[n];         int[] zerosRow = new int[m];         int[] zerosCol = new int[n];                  // Calculate onesRow, onesCol, zerosRow, zerosCol arrays         for(int i=0; i<m; i++) {             for(int j=0; j<n; j++) {                 if(grid[i][j] == 1) {                     onesRow[i]++;                     onesCol[j]++;                 } else {                     zerosRow[i]++;                     zerosCol[j]++;                 }             }         }                  // Calculate diff matrix         for(int i=0; i<m; i++) {             for(int j=0; j<n; j++) {                 diff[i][j] = onesRow[i] + onesCol[j] - zerosRow[i] - zerosCol[j];             }         }                  return diff;     } }",0,,0,0,0
class Solution {     public int bestClosingTime(String customers) {         int n = customers.length();         int penalty = n;         int hour = n;         int open = 0;         int close = n;         for (int i = 0; i < n; i++) {             if (customers.charAt(i) == 'Y') {                 open++;                 int current_penalty = open;                 for (int j = i + 1; j < n; j++) {                     if (customers.charAt(j) == 'N') {                         current_penalty++;                     }                     else {                         current_penalty--;                     }                     if (current_penalty < penalty) {                         penalty = current_penalty;                         hour = j;                     }                 }             }             else {                 close--;             }         }         return hour;     } },1,"2483-minimum-penalty-for-a-shop/Solution.java:15:21: '}' at column 21 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2483-minimum-penalty-for-a-shop/Solution.java:24:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2483-minimum-penalty-for-a-shop/Solution.java:15:21: '}' at column 21 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2483-minimum-penalty-for-a-shop/Solution.java:24:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2483-minimum-penalty-for-a-shop/Solution.java:7:	UnusedLocalVariable:	Avoid unused local variables such as 'close'.
",0,0,0
"class Solution {     public int appendCharacters(String s, String t) {         int i = 0, j = 0;         while (i < s.length() && j < t.length()) {             if (s.charAt(i) == t.charAt(j)) {                 j++;             }             i++;         }         return t.length() - j;     } }",1,"2486-append-characters-to-string-to-make-subsequence/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2486-append-characters-to-string-to-make-subsequence/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"/**   * Definition for singly-linked list.   * public class ListNode {   *     int val;   *     ListNode next;   *     ListNode() {}   *     ListNode(int val) { this.val = val; }   *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }   * }   */ class Solution {     public ListNode removeNodes(ListNode head) {         ListNode curr = head; // current node         ListNode prev = null; // previous node                  while(curr != null) {             ListNode temp = curr.next; // store next node as a temporary variable             boolean flag = false; // flag to mark if the current node is to be deleted or not                          // loop through all the nodes to the right of the current node             while(temp != null) {                 if(temp.val > curr.val) { // if any node to the right of current node is greater in value                     flag = true; // mark the current node for deletion                     break;                 }                 temp = temp.next; // move ahead to next node             }                          if(flag) { // if the current node is to be deleted                 if(curr == head) { // if current node is the head                     head = head.next; // move the head to the next node                 } else {                     prev.next = curr.next; // skip the current node by linking previous node to next node                 }             } else {                 // if current node is not to be deleted, set it as the previous node and move ahead                 prev = curr;             }             curr = curr.next; // move ahead to the next node in the list         }                  return head; // return the modified head of the linked list     } }",1,"2487-remove-nodes-from-linked-list/ListNode.java:31:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'head'
",0,1,0
"class Solution {     public long dividePlayers(int[] skill) {         int n = skill.length;         int sum = 0, maxSkill = 0;         for (int i = 0; i < n; i++) {             sum += skill[i];             maxSkill = Math.max(maxSkill, skill[i]);         }         if (sum % (n/2) != 0) {             return -1; // cannot divide equally into teams         }         int target = sum / (n/2);         if (maxSkill > target) {             return -1; // the maximum skill is greater than the target, so can't be divided equally         }         Arrays.sort(skill);         int left = 0, right = n-1;         long chemistrySum = 0;         while (left < right) {             int teamSum = skill[left] + skill[right];             if (teamSum != target) {                 return -1; // can't form equal teams             }             chemistrySum += (long)skill[left] * (long)skill[right];             left++;             right--;         }         return chemistrySum;     } }",1,"2491-divide-players-into-teams-of-equal-skill/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2491-divide-players-into-teams-of-equal-skill/Solution.java:17:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2491-divide-players-into-teams-of-equal-skill/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2491-divide-players-into-teams-of-equal-skill/Solution.java:17:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2491-divide-players-into-teams-of-equal-skill/Solution.java:24:	UnnecessaryCast:	Unnecessary cast (long)
2491-divide-players-into-teams-of-equal-skill/Solution.java:24:	UnnecessaryCast:	Unnecessary cast (long)
",1,0,0
"import java.util.ArrayList; import java.util.Arrays; import java.util.LinkedList; import java.util.Queue;  class Solution {     ArrayList<int[]>[] adjList;     boolean[] visited;     int[] minDist;      @SuppressWarnings(""unchecked"")     public int minScore(int n, int[][] roads) {         adjList = new ArrayList[n + 1];         visited = new boolean[n + 1];         minDist = new int[n + 1];          for (int i = 0; i < n + 1; i++) {             adjList[i] = new ArrayList<int[]>();         }          // Create Graph         for (int[] road : roads) {             int from = road[0];             int to = road[1];             int dist = road[2];             adjList[from].add(new int[] { to, dist });             adjList[to].add(new int[] { from, dist });         }          for (int i = 0; i < n + 1; i++) {             minDist[i] = Integer.MAX_VALUE;         }          return bfs(1, n);     }      public int bfs(int start, int end) {         Queue<Integer> queue = new LinkedList<>();         queue.offer(start);         visited[start] = true;         minDist[start] = 0;          while (!queue.isEmpty()) {             int node = queue.poll();              for (int[] neighbor : adjList[node]) {                 int neighborNode = neighbor[0];                 int neighborDist = neighbor[1];                  if (!visited[neighborNode]) {                     queue.offer(neighborNode);                     visited[neighborNode] = true;                     minDist[neighborNode] = Math.min(minDist[node], neighborDist);                 }             }         }          return minDist[end];     } }",1,"2492-minimum-score-of-a-path-between-two-cities/Solution.java:2:8: Unused import - java.util.Arrays. [UnusedImports]
2492-minimum-score-of-a-path-between-two-cities/Solution.java:7:24: Variable 'adjList' must be private and have accessor methods. [VisibilityModifier]
2492-minimum-score-of-a-path-between-two-cities/Solution.java:8:15: Variable 'visited' must be private and have accessor methods. [VisibilityModifier]
2492-minimum-score-of-a-path-between-two-cities/Solution.java:9:11: Variable 'minDist' must be private and have accessor methods. [VisibilityModifier]
2492-minimum-score-of-a-path-between-two-cities/Solution.java:2:8: Unused import - java.util.Arrays. [UnusedImports]
2492-minimum-score-of-a-path-between-two-cities/Solution.java:7:24: Variable 'adjList' must be private and have accessor methods. [VisibilityModifier]
2492-minimum-score-of-a-path-between-two-cities/Solution.java:8:15: Variable 'visited' must be private and have accessor methods. [VisibilityModifier]
2492-minimum-score-of-a-path-between-two-cities/Solution.java:9:11: Variable 'minDist' must be private and have accessor methods. [VisibilityModifier]
2492-minimum-score-of-a-path-between-two-cities/Solution.java:2:	UnnecessaryImport:	Unused import 'java.util.Arrays'
2492-minimum-score-of-a-path-between-two-cities/Solution.java:7:	LooseCoupling:	Avoid using implementation types like 'ArrayList'; use the interface instead
2492-minimum-score-of-a-path-between-two-cities/Solution.java:18:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new ArrayList<>()`
",0,0,0
"class Solution {     public int maxStarSum(int[] vals, int[][] edges, int k) {         int n = vals.length;         int[] degree = new int[n];         int maxVal = Integer.MIN_VALUE;         int centerVal = 0; // value of the center node         // Store degree of each node and maximum value of node         for (int i = 0; i < n; i++) {             degree[i] = 0;             if (vals[i] > maxVal) {                 maxVal = vals[i];                 centerVal = i;             }         }         // Calculate degree of each node         for (int i = 0; i < edges.length; i++) {             int u = edges[i][0];             int v = edges[i][1];             degree[u]++;             degree[v]++;         }         // Check if k is 0, then return the center value         if (k == 0) {             return vals[centerVal];         }         // Sort the degree of nodes         Arrays.sort(degree);         int sum = 0;         // Pick nodes with highest degree and add their values to sum         for (int i = n - 1; i >= 0 && k > 0; i--, k--) {             sum += vals[degree[i]];         }         return sum;     } }",1,"2497-maximum-star-sum-of-a-graph/Solution.java:16:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
2497-maximum-star-sum-of-a-graph/Solution.java:30:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'k'
",0,1,1
"class Solution {          public int maxJump(int[] stones) {         int n = stones.length;         int[][] dp = new int[n][n];         for (int i = n - 2; i >= 0; i--) {             for (int j = i + 1; j < n; j++) {                 int dist = stones[j] - stones[i];                 dp[i][j] = Math.max(dist, Math.min(dp[i + 1][j - 1], Math.max(dp[i + 1][j], dp[i][j - 1])));             }         }         return dp[0][n - 1];     } }",0,,0,0,0
"class Solution {     public int longestSquareStreak(int[] nums) {         int n = nums.length;         int longestStreak = -1;          // Try all possible subsequences of nums         for(int mask = 0; mask < (1 << n); mask++) {             List<Integer> subsequence = new ArrayList<>();             // Use bits in mask to select elements for subsequence             for(int i = 0; i < n; i++) {                 if((mask & (1 << i)) != 0) {                     subsequence.add(nums[i]);                 }             }             if(subsequence.size() >= 2 && isSquareStreak(subsequence)) {                 longestStreak = Math.max(longestStreak, subsequence.size());             }         }          return longestStreak;     }      // Check if the given subsequence is a square streak     private boolean isSquareStreak(List<Integer> subsequence) {         Collections.sort(subsequence);         for(int i = 1; i < subsequence.size(); i++) {             if(subsequence.get(i) != subsequence.get(i-1)*subsequence.get(i-1)) {                 return false;             }         }         return true;     } }",0,,0,0,0
"class Allocator {     private int[] memory;     private Map<Integer, Set<Integer>> allocated;          public Allocator(int n) {         memory = new int[n];         allocated = new HashMap<>();     }          public int allocate(int size, int mID) {         for (int i = 0; i <= memory.length - size; i++) {             boolean isFree = true;             for (int j = i; j < i + size; j++) {                 if (memory[j] != 0) {                     isFree = false;                     break;                 }             }             if (isFree) {                 for (int j = i; j < i + size; j++) {                     memory[j] = mID;                 }                 allocated.computeIfAbsent(mID, k -> new HashSet<>()).addAll(IntStream.range(i, i + size).boxed().collect(Collectors.toList()));                 return i;             }         }         return -1;     }          public int free(int mID) {         Set<Integer> positions = allocated.getOrDefault(mID, new HashSet<>());         for (int pos : positions) {             memory[pos] = 0;         }         allocated.remove(mID);         return positions.size();     } }  /**  * Your Allocator object will be instantiated and called as such:  * Allocator obj = new Allocator(n);  * int param_1 = obj.allocate(size,mID);  * int param_2 = obj.free(mID);  */",1,"2502-design-memory-allocator/Allocator.java:5:5: Redundant 'public' modifier. [RedundantModifier]
2502-design-memory-allocator/Allocator.java:5:5: Redundant 'public' modifier. [RedundantModifier]
",0,0,0
import java.util.*;  class Solution {     public int smallestValue(int n) {         Set<Integer> primes = new HashSet<>();  //to store prime factors                while (true) {             primes = primeFactors(n);   //find prime factors of n             if (primes.size() == 1) {                 return primes.iterator().next();   //return the smallest prime factor             }             n = primes.stream().mapToInt(Integer::intValue).sum();   //find sum of prime factors                   }     }      private Set<Integer> primeFactors(int n) {         Set<Integer> factors = new HashSet<Integer>();         int temp = n;         for (int i = 2; i <= n / i; i++) {             while (temp % i == 0) {                 factors.add(i);                 temp /= i;             }         }         if (temp > 1) {             factors.add(temp);         }         return factors;     } }  public class Main {     public static void main(String[] args) {         Solution sol = new Solution();         System.out.println(sol.smallestValue(15)); // output: 5         System.out.println(sol.smallestValue(3));  // output: 3     } },1,"2507-smallest-value-after-replacing-with-sum-of-prime-factors/Main.java:31:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
2507-smallest-value-after-replacing-with-sum-of-prime-factors/Main.java:31:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
2507-smallest-value-after-replacing-with-sum-of-prime-factors/Main.java:5:	UnusedAssignment:	The initializer for variable 'primes' is never used (overwritten on line 7)
2507-smallest-value-after-replacing-with-sum-of-prime-factors/Main.java:11:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
2507-smallest-value-after-replacing-with-sum-of-prime-factors/Main.java:16:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new HashSet<>()`
2507-smallest-value-after-replacing-with-sum-of-prime-factors/Main.java:31:	UseUtilityClass:	This utility class has a non-private constructor
",0,1,0
"import java.util.*;  class Solution {     public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {         Map<Integer, Integer> scores = new HashMap<>();         Set<String> posSet = new HashSet<>(Arrays.asList(positive_feedback));         Set<String> negSet = new HashSet<>(Arrays.asList(negative_feedback));                  for(int i=0; i<report.length; i++) {             String[] words = report[i].split("" "");             int student = student_id[i];             int score = scores.getOrDefault(student, 0);                          for(String word : words) {                 if(posSet.contains(word))                     score += 3;                 else if(negSet.contains(word))                     score -= 1;             }             scores.put(student, score);         }                  // Create a list of entries from HashMap         List<Map.Entry<Integer, Integer>> list = new ArrayList<>(scores.entrySet());                  // Sort the list         Collections.sort(list, (a,b) -> {             // Compare scores in descending order             int cmp = b.getValue().compareTo(a.getValue());                          // If scores are equal, compare IDs in ascending order             return cmp == 0 ? a.getKey().compareTo(b.getKey()) : cmp;         });                  // Return top k students         List<Integer> result = new ArrayList<>();         for(int i=0; i<k; i++) {             result.add(list.get(i).getKey());         }         return result;     } }",1,"2512-reward-top-k-students/Solution.java:5:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
",0,0,0
"class Solution {     public int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {         // initializations         int maxNum = Math.max(divisor1, divisor2);          int lcm = (divisor1 * divisor2) / gcd(divisor1, divisor2);         int totalUniqueCnt = uniqueCnt1 + uniqueCnt2;          int maxPossibleNum = totalUniqueCnt * maxNum + lcm;         int ans = Integer.MAX_VALUE;                  // loop from lcm to maxPossibleNum in increments of lcm         for(int i = lcm; i <= maxPossibleNum; i += lcm) {             int cnt1 = countNumbers(i, divisor1);             int cnt2 = countNumbers(i, divisor2);              if(cnt1 <= uniqueCnt1 && cnt2 <= uniqueCnt2) {                 ans = Math.min(ans, i);                 break;             }              int cntc = countNumbers(i, lcm);             if((cnt1 - cntc) <= uniqueCnt1 && (cnt2 - cntc) <= uniqueCnt2) {                 ans = Math.min(ans, i);                 break;             }         }         return ans;     }      // function to count numbers that are multiple of a given divisor     private int countNumbers(int n, int divisor) {         return n / divisor;     }      // function to calculate gcd of two numbers     private int gcd(int a, int b) {         if(b == 0) return a;          return gcd(b, a % b);     } }",1,"2513-minimize-the-maximum-of-two-arrays/Solution.java:5:	UselessParentheses:	Useless parentheses.
",0,0,0
"class Solution {     public int takeCharacters(String s, int k) {          int[] count = new int[3]; // array to store frequency of 'a', 'b' and 'c'         int distinctChars = 0; // variable to store number of distinct characters         int n = s.length();           // loop through the string to count frequency of each character         for (int i = 0; i < n; i++) {             char c = s.charAt(i);             if (count[c - 'a'] == 0) { // if this is the first occurrence of this character                 distinctChars++;             }             count[c - 'a']++; // increment the frequency of this character         }          if (distinctChars < 3 || k > n) { // if any one of the characters is missing or k is greater than string length             return -1; // not possible to take k of each character.         }          int left = 0, right = n - 1;         int aCount = 0, bCount = 0, cCount = 0;         int ans = n;          // loop through the string from left and right alternatively         while (left <= right) {             char leftChar = s.charAt(left);             char rightChar = s.charAt(right);              // check if we can take leftChar             if (aCount < k || bCount < k || cCount < k) {                 count[leftChar - 'a']--;                 if (count[leftChar - 'a'] == 0) { // if there are no more leftChar's in the string                     distinctChars--;                 }                 if (leftChar == 'a') {                     aCount++;                 } else if (leftChar == 'b') {                     bCount++;                 } else {                     cCount++;                 }                 left++; // move left pointer to right             } else if (aCount >= k && bCount >= k && cCount >= k) { // if we have already taken at least k of each character                 ans = Math.min(ans, right - left + 1); // update the answer if required                 if (ans == 3 * k) { // if we have already taken k of each character from both end                     break; // no need to continue                 }                 // check if we can take rightChar                 if (count[rightChar - 'a'] > 0) { // if rightChar is still available in the string                     count[rightChar - 'a']--;                     if (count[rightChar - 'a'] == 0) { // if there are no more rightChar's in the string                         distinctChars--;                     }                     if (rightChar == 'a') {                         aCount++;                     } else if (rightChar == 'b') {                         bCount++;                     } else {                         cCount++;                     }                 }                 right--; // move right pointer to left             }         }          if (aCount < k || bCount < k || cCount < k || distinctChars < 3) { // if we couldn't take k of all characters             return -1; // not possible to take k of each character.         }          return ans;     } }",1,"2516-take-k-of-each-character-from-left-and-right/Solution.java:21:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2516-take-k-of-each-character-from-left-and-right/Solution.java:22:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2516-take-k-of-each-character-from-left-and-right/Solution.java:21:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2516-take-k-of-each-character-from-left-and-right/Solution.java:22:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2516-take-k-of-each-character-from-left-and-right/Solution.java:2:	NPathComplexity:	The method 'takeCharacters(String, int)' has an NPath complexity of 1170, current threshold is 200
",1,0,0
"class Solution {     public int maximumTastiness(int[] price, int k) {         Arrays.sort(price);         int n = price.length;         int[] dp = new int[1 << n];         Arrays.fill(dp, -1);         dp[0] = 0;         for (int mask = 0; mask < (1 << n) - 1; mask++) {             int cnt = Integer.bitCount(mask);             if (cnt == k) {                 int minDiff = Integer.MAX_VALUE;                 for (int i = 0; i < n; i++) {                     if ((mask & (1 << i)) == 0)                         continue;                     for (int j = i + 1; j < n; j++) {                         if ((mask & (1 << j)) == 0)                             continue;                         minDiff = Math.min(minDiff, Math.abs(price[i] - price[j]));                     }                 }                 for (int i = 0; i < n; i++) {                     if ((mask & (1 << i)) == 0)                         continue;                     int prevMask = mask ^ (1 << i);                     if (dp[prevMask] != -1) {                         dp[mask] = Math.max(dp[mask], dp[prevMask] + minDiff);                     }                 }             }         }         return dp[(1 << n) - 1];     } }",0,,0,0,0
class Solution {     public int distinctPrimeFactors(int[] nums) {         Set<Integer> factors = new HashSet<Integer>();         int product = 1;         for(int num : nums) {             product *= num;         }         for(int i=2; i<=product; i++) {             if(product % i == 0) {                 factors.add(i);                 product /= i;                 i--;             }         }         return factors.size();     } },0,,0,0,0
"class Solution {     public int minimumPartition(String s, int k) {         int n = s.length();         int[] dp = new int[n];         dp[0] = s.charAt(0) - '0';         if (dp[0] > k) {             return -1; // the first character itself is greater than k         }         for (int i = 1; i < n; i++) {             int val = s.charAt(i) - '0';             if (val > k) {                 return -1; // a digit is greater than k             }             dp[i] = val; // current digit as a substring             for (int j = i - 1; j >= 0; j--) {                 val = val * 10 + s.charAt(j) - '0'; // add more digits to the substring                 if (val > k) {                     break;                 }                 dp[i] = Math.min(dp[i], dp[j - 1] + 1); // update with the minimum number of substrings             }         }         return dp[n - 1];     } }",0,,0,0,0
"import java.util.*;  class Solution {     public int[] closestPrimes(int left, int right) {         int[] result = new int[2];         int minGap = Integer.MAX_VALUE;          int prevPrime = 0;         for (int i = left; i <= right; i++) {             if (isPrime(i)) {                 if (prevPrime > 0 && i - prevPrime < minGap) {                     result[0] = prevPrime;                     result[1] = i;                     minGap = i - prevPrime;                 }                 prevPrime = i;             }         }          return (result[0] == 0 && result[1] == 0) ? new int[] {-1, -1} : result;     }      private boolean isPrime(int num) {         if (num <= 1) {             return false;         }          for (int i = 2; i <= Math.sqrt(num); i++) {             if (num % i == 0) {                 return false;             }         }          return true;     } }",1,"2523-closest-prime-numbers-in-range/Solution.java:1:	UnnecessaryImport:	Unused import 'java.util.*'
",0,0,0
"class DataStream {     Queue<Integer> queue;     int k;     int value;      public DataStream(int value, int k) {         queue = new LinkedList<>();         this.k = k;         this.value = value;     }          public boolean consec(int num) {         queue.offer(num);          if (queue.size() < k) {             return false;         }          int count = 0;         for (int i : queue) {             if (i == value) {                 count++;             }         }          if (count == k) {             return true;         } else {             queue.poll();             return false;         }     } }  /**  * Your DataStream object will be instantiated and called as such:  * DataStream obj = new DataStream(value, k);  * boolean param_1 = obj.consec(num);  */",1,"2526-find-consecutive-integers-from-a-data-stream/DataStream.java:2:20: Variable 'queue' must be private and have accessor methods. [VisibilityModifier]
2526-find-consecutive-integers-from-a-data-stream/DataStream.java:3:9: Variable 'k' must be private and have accessor methods. [VisibilityModifier]
2526-find-consecutive-integers-from-a-data-stream/DataStream.java:4:9: Variable 'value' must be private and have accessor methods. [VisibilityModifier]
2526-find-consecutive-integers-from-a-data-stream/DataStream.java:6:5: Redundant 'public' modifier. [RedundantModifier]
2526-find-consecutive-integers-from-a-data-stream/DataStream.java:6:27: 'value' hides a field. [HiddenField]
2526-find-consecutive-integers-from-a-data-stream/DataStream.java:6:38: 'k' hides a field. [HiddenField]
2526-find-consecutive-integers-from-a-data-stream/DataStream.java:2:20: Variable 'queue' must be private and have accessor methods. [VisibilityModifier]
2526-find-consecutive-integers-from-a-data-stream/DataStream.java:3:9: Variable 'k' must be private and have accessor methods. [VisibilityModifier]
2526-find-consecutive-integers-from-a-data-stream/DataStream.java:4:9: Variable 'value' must be private and have accessor methods. [VisibilityModifier]
2526-find-consecutive-integers-from-a-data-stream/DataStream.java:6:5: Redundant 'public' modifier. [RedundantModifier]
2526-find-consecutive-integers-from-a-data-stream/DataStream.java:6:27: 'value' hides a field. [HiddenField]
2526-find-consecutive-integers-from-a-data-stream/DataStream.java:6:38: 'k' hides a field. [HiddenField]
",0,0,0
class Solution {     public int xorBeauty(int[] nums) {         int n = nums.length;         int ans = 0;         int[] freq = new int[32];                  for(int i=0; i<n; i++) {             for(int j=i+1; j<n; j++) {                 for(int k=j+1; k<n; k++) {                     int beauty = ((nums[i] | nums[j]) & nums[k]);                     ans ^= beauty;                     for(int bit=0; bit<32; bit++) {                         if((beauty & (1 << bit)) != 0) {                             freq[bit]++;                         }                     }                 }             }         }         for(int bit=0; bit<32; bit++) {             if(freq[bit] % 2 != 0) {                 ans ^= (1 << bit);             }         }         return ans;     } },1,"2527-find-xor-beauty-of-array/Solution.java:10:	UselessParentheses:	Useless parentheses.
",0,0,0
"class Solution {     public long maxKelements(int[] nums, int k) {         long score = 0;         PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());                  for (int i = 0; i < nums.length; i++) {             pq.offer(nums[i]);         }                  while (k > 0) {             int maxElement = pq.poll();             score += maxElement;             int ceil = (int) Math.ceil(maxElement / 3.0);             pq.offer(ceil);             k--;         }                  return score;     } }  /* Time Complexity: O(k log n) where n is the size of the input array. Space Complexity: O(n) where n is the size of the input array. */",1,"2530-maximal-score-after-applying-k-operations/Solution.java:6:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
2530-maximal-score-after-applying-k-operations/Solution.java:15:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'k'
",0,1,1
"class Solution {     public boolean isItPossible(String word1, String word2) {         int[] freq1 = new int[26];         int[] freq2 = new int[26];                 // count frequency of characters in word1         for (char c : word1.toCharArray()) {             freq1[c - 'a']++;         }                 // count frequency of characters in word2         for (char c : word2.toCharArray()) {             freq2[c - 'a']++;         }                 // count number of distinct characters in word1 and word2         int distinct1 = 0;         int distinct2 = 0;         for (int i = 0; i < 26; i++) {             if (freq1[i] > 0) {                 distinct1++;             }             if (freq2[i] > 0) {                 distinct2++;             }         }                 // check if they already have equal distinct characters         if (distinct1 == distinct2) {             return true;         }                 // check if it is possible to have equal distinct characters with one move         int count = 0;         for (int i = 0; i < 26; i++) {             if (freq1[i] > 0 && freq2[i] == 0) {                 count += freq1[i];             }             if (freq1[i] == 0 && freq2[i] > 0) {                 count += freq2[i];             }         }         return count == 2;     } }",1,"2531-make-number-of-distinct-characters-equal/Solution.java:2:	NPathComplexity:	The method 'isItPossible(String, String)' has an NPath complexity of 400, current threshold is 200
",0,0,0
"class Solution {     public int[][] rangeAddQueries(int n, int[][] queries) {         int[][] mat = new int[n][n];                  // loop through each query         for(int i=0; i<queries.length; i++) {             int row1 = queries[i][0];             int col1 = queries[i][1];             int row2 = queries[i][2];             int col2 = queries[i][3];                          // add 1 to all elements in the specified submatrix             for(int j=row1; j<=row2; j++) {                 for(int k=col1; k<=col2; k++) {                     mat[j][k]++;                 }             }         }                  return mat;     } }",1,"2536-increment-submatrices-by-one/Solution.java:6:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public long countGood(int[] nums, int k) {         long res = 0; // Initialize the result         for (int i = 0; i < nums.length; i++) {             Map<Integer, Integer> map = new HashMap<>();             int pairCount = 0;             for (int j = i; j < nums.length; j++) {                 int num = nums[j];                 map.put(num, map.getOrDefault(num, 0) + 1);                 int freq = map.get(num);                 if (freq == 2) { // If a pair is found                     pairCount++;                 }                 if (pairCount >= k) { // If we have k pairs                     res += nums.length - j;                     break;                 }             }         }         return res;     } }",0,,0,0,0
"class Solution {     public long minOperations(int[] nums1, int[] nums2, int k) {         int n = nums1.length;         int[] freq = new int[11];         // counting the difference in frequency between the corresponding elements in the two arrays         for (int i = 0; i < n; i++) {             int diff = nums2[i] - nums1[i];             if (diff > 0) {                 freq[diff]++;             } else if (diff < 0) {                 freq[-diff + 5]++;             }         }         int minOps = 0;         int currDiff = 0;         // performing operations in increasing order of the difference in frequency         for (int i = 0; i < 5; i++) {             int j = 0;             while (currDiff < i - 5 && j < freq[i]) {                 currDiff += 5;                 minOps++;                 j++;             }         }         for (int i = 6; i <= 10; i++) {             int j = 0;             while (currDiff < i - 5 && j < freq[i]) {                 currDiff += 5;                 minOps++;                 j++;             }         }         // checking if all the elements are equal         for (int i = 0; i < n; i++) {             int diff = nums2[i] - nums1[i] + currDiff;             if (diff != 0) {                 return -1;             }         }         return minOps;     } }",0,,0,0,0
"class Solution {     public long maxScore(int[] nums1, int[] nums2, int k) {         int n = nums1.length;         long[] preSum1 = new long[n];         long[] preSum2 = new long[n];         preSum1[0] = nums1[0];         preSum2[0] = nums2[0];         for (int i = 1; i < n; i++) {             preSum1[i] = preSum1[i - 1] + nums1[i];             preSum2[i] = preSum2[i - 1] + nums2[i];         }         long res = 0;         for (int len1 = 0; len1 <= k; len1++) {             int len2 = k - len1;             if (len1 > n || len2 > n) {                 continue;             }             long sum1 = len1 == 0 ? 0 : preSum1[len1 - 1];             long sum2 = len2 == 0 ? 0 : preSum2[len2 - 1];             if (len1 + len2 == k) {                 res = Math.max(res, (sum1 + sum2) * Math.min(len1 == 0 ? Integer.MAX_VALUE : nums2[len1 - 1],                         len2 == 0 ? Integer.MAX_VALUE : nums2[len2 - 1]));             }         }         return res;     } }",0,,0,0,0
"class Solution {     public int[][] sortTheStudents(int[][] score, int k) {         Arrays.sort(score, (a,b) -> b[k] - a[k]);         return score;     } }",0,,0,0,0
"class Solution {     public boolean makeStringsEqual(String s, String target) {         int[] sChar = new int[26]; // array to count the frequency of each alphabet in s         int[] targetChar = new int[26]; // array to count the frequency of each alphabet in target                  // loop to count the frequency of each alphabet in s         for(char c : s.toCharArray()){             sChar[c-97]++;         }                  // loop to count the frequency of each alphabet in target         for(char c : target.toCharArray()){             targetChar[c-97]++;         }                  // loop to check if the frequency of each alphabet in s and target is equal         for(int i=0; i<26; i++){             if(sChar[i] != targetChar[i]){                 return false; // if frequency is not equal, return false             }         }                  return true; // if frequency is equal, return true     } }",0,,0,0,0
class Solution {     public int monkeyMove(int n) {         long[] dp = new long[n + 1];         dp[3] = 1;         dp[4] = 2;         for (int i = 5; i <= n; i++) {             dp[i] = (dp[i - 1] * (i - 2) % 1000000007 + dp[i - 2] * (i - 2) % 1000000007) % 1000000007;         }         return (int) dp[n];     } },0,,0,0,0
"	class Solution { 	    public int maxCount(int[] banned, int n, int maxSum) { 	        // Sort the banned numbers 	        Arrays.sort(banned); 	        // Number of banned numbers 	        int bCount = banned.length; 	        // The maximum number of integers that can be chosen 	        int maxCount = 0; 	        // The sum of the chosen integers 	        int sum = 0; 	        // The index of the next number to consider in the banned array 	        int i = 0; 	        // Consider all numbers from 1 to n 	        for (int j = 1; j <= n; j++) { 	            // If the current number is banned, move to the next banned number 	            while (i < bCount && banned[i] == j) { 	                i++; 	            } 	            // If the current number is not banned and its sum with the previous chosen numbers does not exceed maxSum, increment the count and add it to the sum 	            if (i == bCount && sum + j <= maxSum) { 	                maxCount++; 	                sum += j; 	            } 	        } 	        return maxCount; 	    } 	}",1,"2554-maximum-number-of-integers-to-choose-from-a-range-i/Solution.java:1:1: File contains tab characters (this is the first instance). [FileTabCharacter]
2554-maximum-number-of-integers-to-choose-from-a-range-i/Solution.java:1:1: File contains tab characters (this is the first instance). [FileTabCharacter]
",0,0,0
"public class Solution {     public int maximizeWin(int[] prizePositions, int k) {         int n = prizePositions.length;         int[] prefix = new int[n]; // Prefix Max Array         int[] suffix = new int[n]; // Suffix Max Array                  int left = 0;         for (int right = 0; right < n; right++) {             // Create a window of size k             while (prizePositions[right] - prizePositions[left] > k) {                 left++;             }                          // Prefix Max Array             prefix[right] = Math.max(prefix[right - 1], right - left + 1);         }                  int right = n - 1;         for (int left = n - 1; left >= 0; left--) {             while (prizePositions[right] - prizePositions[left] > k) {                 right--;             }                          // Suffix Max Array             suffix[left] = Math.max(suffix[left + 1], right - left + 1);         }                  int ans = 0;         for (int i = 0; i < n - 1; i++) {             ans = Math.max(ans, prefix[i] + suffix[i + 1]);         }          ans = Math.max(ans, prefix[n - 1]);         ans = Math.max(ans, suffix[0]);                  return ans;     } }",0,,0,0,0
"class Solution {     public boolean isPossibleToCutPath(int[][] grid) {         int m = grid.length;         int n = grid[0].length;         boolean[][] visited = new boolean[m][n];                  // Check if there is a path from (0,0) to (m-1, n-1)         if (!dfs(grid, visited, 0, 0, m, n)) {             return true; // There is no path, so the matrix is already disconnected         }                  // Otherwise, we need to try flipping each cell and check if the matrix becomes disconnected         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 if ((i == 0 && j == 0) || (i == m - 1 && j == n - 1)) {                     continue; // Cannot flip the start or end cells                 }                                  // Flip the current cell                 grid[i][j] = 1 - grid[i][j];                                  // Check if the matrix is disconnected now                 boolean[][] newVisited = new boolean[m][n];                 if (!dfs(grid, newVisited, 0, 0, m, n)) {                     return true; // The matrix is disconnected now, so we can return true                 }                                  // Flip the cell back if it doesn't make the matrix disconnected                 grid[i][j] = 1 - grid[i][j];             }         }                  // If we couldn't disconnect the matrix with a single flip, return false         return false;     }          // Depth-first search to check if there is a path from (row, col) to (m-1, n-1)     private boolean dfs(int[][] grid, boolean[][] visited, int row, int col, int m, int n) {         if (row == m - 1 && col == n - 1) {             return true; // Reached the end cell         }                  visited[row][col] = true;                  // Check the neighbors         if (row + 1 < m && grid[row + 1][col] == 1 && !visited[row + 1][col]) {             if (dfs(grid, visited, row + 1, col, m, n)) {                 return true;             }         }         if (col + 1 < n && grid[row][col + 1] == 1 && !visited[row][col + 1]) {             if (dfs(grid, visited, row, col + 1, m, n)) {                 return true;             }         }                  return false; // No path found     } }",1,"2556-disconnect-path-in-a-binary-matrix-by-at-most-one-flip/Solution.java:47:	CollapsibleIfStatements:	This if statement could be combined with its parent
2556-disconnect-path-in-a-binary-matrix-by-at-most-one-flip/Solution.java:52:	CollapsibleIfStatements:	This if statement could be combined with its parent
",0,0,0
"class Solution {     public int[] vowelStrings(String[] words, int[][] queries) {         int n = queries.length;         int[] ans = new int[n];                  for (int i = 0; i < n; i++) {             int li = queries[i][0];             int ri = queries[i][1];             int count = 0;                          for (int j = li; j <= ri; j++) {                 String word = words[j];                                  if (isVowel(word.charAt(0)) && isVowel(word.charAt(word.length() - 1))) {                     count++;                 }             }                          ans[i] = count;         }                  return ans;     }          private boolean isVowel(char c) {         return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';     } }",0,,0,0,0
"class Solution {     public int minCapability(int[] nums, int k) {         int n = nums.length;         int[][] dp = new int[k + 1][n];          for (int i = 1; i <= k; i++) {             for (int j = 0; j < n; j++) {                 if (i == 1) {                     dp[i][j] = (j == 0) ? nums[0] : Math.max(dp[i][j - 1], nums[j]);                    } else {                     dp[i][j] = Integer.MAX_VALUE;                     for (int x = 0; x < j - 1; x++) {                         dp[i][j] = Math.min(dp[i][j], Math.max(dp[i - 1][x], nums[j]));                     }                 }             }         }          return dp[k][n - 1];     } }",0,,0,0,0
"class Solution {     public long countFairPairs(int[] nums, int lower, int upper) {         int n = nums.length;         int[] presum = new int[n];         int count = 0;         TreeSet<Integer> set = new TreeSet<>();         set.add(0);         for (int i = 0; i < n; i++) {             presum[i] = i == 0 ? nums[i] : presum[i - 1] + nums[i];             int gap1 = presum[i] - upper;             int gap2 = presum[i] - lower;             Integer ceil = set.ceiling(gap1);             Integer floor = set.floor(gap2);             if (ceil != null && ceil <= floor) {                 count += set.subSet(ceil, true, floor, true).size();             }             set.add(presum[i]);         }         return count;     } }",0,,0,0,0
"class Solution {     public int[][] substringXorQueries(String s, int[][] queries) {         int n = s.length();         int[] prefix = new int[n];         prefix[0] = s.charAt(0) - '0';         for (int i = 1; i < n; i++) {             prefix[i] = prefix[i - 1] ^ (s.charAt(i) - '0');         }         int[][] ans = new int[queries.length][2];         for (int i = 0; i < queries.length; i++) {             int left = queries[i][0];             int right = queries[i][1];             if (left == right && (prefix[left] ^ left) == queries[i][1]) {                 ans[i] = new int[]{left, left};             } else if (left == right || prefix[left] == prefix[right] ^ (left == 0 ? 0 : prefix[left - 1])) {                 ans[i] = new int[]{-1, -1};             } else {                 int l = left, r = right;                 while (l < r) {                     int mid = (l + r) >>> 1;                     if (prefix[mid] ^ (left == 0 ? 0 : prefix[left - 1]) >= queries[i][1]) {                         r = mid;                     } else {                         l = mid + 1;                     }                 }                 ans[i][0] = l;                 l = left;                 r = right;                 while (l < r) {                     int mid = (l + r + 1) >>> 1;                     if (prefix[mid] ^ (left == 0 ? 0 : prefix[left - 1]) > queries[i][1]) {                         r = mid - 1;                     } else {                         l = mid;                     }                 }                 ans[i][1] = l;             }         }         return ans;     } }",1,"2564-substring-xor-queries/Solution.java:18:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2564-substring-xor-queries/Solution.java:18:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int minimizeSum(int[] nums) {         int n = nums.length;         int lowScore = Integer.MAX_VALUE, highScore = Integer.MIN_VALUE;         int[] candidate = new int[4]; // stores the candidates for the 2 values to be changed         Arrays.fill(candidate, -1);                  // compute current low score         for (int i = 1; i < n; i++) {             lowScore = Math.min(lowScore, Math.abs(nums[i] - nums[i-1]));         }                  // compute current high score and find candidate values to be changed         for (int i = 0; i < n; i++) {             for (int j = i+1; j < n; j++) {                 int score = Math.abs(nums[i] - nums[j]);                 if (score > highScore) {                     highScore = score;                     candidate[0] = i;                     candidate[1] = j;                     candidate[2] = -1;                     candidate[3] = -1;                 }             }         }                  // try changing 1 value first         for (int i = 0; i < n; i++) {             int[] temp = nums.clone();             temp[candidate[0]] = i+1;             int currHighScore = Integer.MIN_VALUE;             for (int j = 0; j < n; j++) {                 if (j != candidate[0]) {                     currHighScore = Math.max(currHighScore, Math.abs(temp[candidate[1]] - temp[j]));                 }             }             if (currHighScore < highScore) {                 highScore = currHighScore;                 candidate[2] = i;             }         }                  // try changing 2 values next         for (int i = 0; i < n; i++) {             for (int j = i+1; j < n; j++) {                 int[] temp = nums.clone();                 temp[candidate[0]] = i+1;                 temp[candidate[1]] = j+1;                 int currHighScore = Integer.MIN_VALUE;                 for (int k = 0; k < n; k++) {                     if (k != candidate[0] && k != candidate[1]) {                         currHighScore = Math.max(currHighScore, Math.abs(temp[candidate[1]] - temp[k]));                     }                 }                 if (currHighScore < highScore) {                     highScore = currHighScore;                     candidate[2] = i;                     candidate[3] = j;                 }             }         }                  // compute updated low score         int updatedLowScore = Integer.MAX_VALUE;         for (int i = 1; i < n; i++) {             updatedLowScore = Math.min(updatedLowScore, Math.abs(nums[i] - nums[i-1]));         }                  return updatedLowScore + highScore;     } }",1,"2567-minimum-score-by-changing-two-elements/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2567-minimum-score-by-changing-two-elements/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2567-minimum-score-by-changing-two-elements/Solution.java:2:	NPathComplexity:	The method 'minimizeSum(int[])' has an NPath complexity of 1120, current threshold is 200
",1,0,0
class Solution {     public int minImpossibleOR(int[] nums) {         int maxPossible = 0;          for (int num : nums) {             maxPossible |= num; // OR operation          }                  boolean[] dp = new boolean[maxPossible + 1];          dp[0] = true;          for (int num : nums) {             for (int i = maxPossible; i >= num; i--) {                 dp[i] |= dp[i - num];                 // If we find that the number is possible by any subarray till now then its dp index is true             }         }                  for (int i = 1; i <= maxPossible; i++) {             if (!dp[i]) {                 // If a valid boolean index is not possible through given subsequence                 // then return as it is first smallest integer being checked                 return i;              }         }         return maxPossible + 1;      } },0,,0,0,0
"class Solution {     public int minOperations(int n) {         int operations = 0;         while (n > 0) {             if (n % 2 == 0) {                 n /= 2; // divide by 2             } else {                 n--; // subtract 1             }             operations++;         }         return operations;     } }  /* Explanation: To minimize the number of operations it's optimal to divide by 2 as much as possible. If the number is odd we subtract 1, since it's not optimal to add a power of 2.  We continue the loop until the number is equal to zero.  The number of operations needed is the number of times the loop was executed. */",1,"2571-minimum-operations-to-reduce-an-integer-to-0/Solution.java:6:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
",0,1,0
"class Solution {      public int squareFreeSubsets(int[] nums) {         int n = nums.length;           long[] dp = new long[1 << n];          // dp[(mask)] means the number of square-free subsets          // whose elements are in a the subset mask of nums          // In this way, all masks with a set bit count of 1 are base cases.          int MOD = 1000000007;           dp[0] = 1; // The empty set is always square-free          // Fill in the dp array by counting the square-free subsets with dynamic programming         for (int mask = 1; mask < (1 << n); mask++) {             int idx = -1;              // Find the rightmost element not included in Mask.              for (int i = 0; i < n; i++) {                 if ((mask & (1 << i)) == 0) {                     idx = i;                  }             }              if (idx == -1) {                 continue;              }              int newMask = mask ^ (1 << idx);               // Check if the subset containing only idx is square-free             boolean squareFree = true;              for (int i = 2; i * i <= nums[idx]; i++) {                 if (nums[idx] % (i * i) == 0) {                     squareFree = false;                      break;                  }             }              if (squareFree) {                 dp[mask] = (dp[newMask] + dp[mask ^ (1 << idx)]) % MOD;              } else {                 dp[mask] = dp[newMask];              }         }          return (int)dp[(1 << n) - 1];      } }",0,,0,0,0
"class Solution {     public int[] divisibilityArray(String word, int m) {         int n = word.length();         int[] div = new int[n];         int prefix = 0;         for (int i = 0; i < n; i++) {             prefix = (prefix * 10 + (word.charAt(i) - '0')) % m;             if (prefix == 0) {                 div[i] = 1;             }         }         int suffix = 0;         int power = 1;         for (int i = n - 1; i >= 0; i--) {             suffix = (suffix + power * (word.charAt(i) - '0')) % m;             power = (power * 10) % m;             if (suffix == 0) {                 div[i] = 1;             }         }         return div;     } }",1,"2575-find-the-divisibility-array-of-a-string/Solution.java:7:	UselessParentheses:	Useless parentheses.
2575-find-the-divisibility-array-of-a-string/Solution.java:16:	UselessParentheses:	Useless parentheses.
",0,0,0
class Solution {     public int maxNumOfMarkedIndices(int[] nums) {         int n = nums.length;         int marked = 0; //number of marked indices         boolean[] isMarked = new boolean[n];          Arrays.sort(nums); //sort the array to make sure nums[j] always >= nums[i]          for (int j = 1; j < n; j++) {             for (int i = 0; i < j; i++) {                 if (!isMarked[i] && !isMarked[j] && 2 * nums[i] <= nums[j]) {                     marked += 2;                     isMarked[i] = true;                     isMarked[j] = true; //mark indices i and j                     break;                 }             }         }          return marked;     } },1,"2576-find-the-maximum-number-of-marked-indices/Solution.java:5:	LinguisticNaming:	Linguistics Antipattern - The variable 'isMarked' indicates linguistically it is a boolean, but it is 'boolean[]'
",0,0,0
"class Solution {     public long coloredCells(int n) {         // Initialize a HashSet to keep track of the blue cells         HashSet<String> blueCells = new HashSet<String>();                  // Add an initial blue cell         blueCells.add(""0,0"");                  // Loop through n minutes         for (int i = 0; i < n; i++) {             // Initialize a new HashSet for the newly colored cells             HashSet<String> newBlueCells = new HashSet<String>();                          // Loop through the current blue cells             for (String cell : blueCells) {                 int row = Integer.parseInt(cell.split("","")[0]);                 int col = Integer.parseInt(cell.split("","")[1]);                                  // Color all neighboring cells blue                 newBlueCells.add((row-1) + "","" + col);                 newBlueCells.add(row + "","" + (col-1));                 newBlueCells.add(row + "","" + (col+1));                 newBlueCells.add((row+1) + "","" + col);             }                          // Update the blueCells HashSet with the newly colored cells             blueCells.addAll(newBlueCells);         }                  // Return the size of the blueCells HashSet         return blueCells.size();     } }",0,,0,0,0
class Solution {     public int countWays(int[][] ranges) {         int mod = 1000000007;         int n = ranges.length;                  // check for overlapping ranges         boolean[][] overlap = new boolean[n][n];         for(int i = 0; i < n; i++) {             for(int j = i + 1; j < n; j++) {                 if(!(ranges[i][0] > ranges[j][1] || ranges[i][1] < ranges[j][0])) {                     overlap[i][j] = overlap[j][i] = true;                 }             }         }                  // use dp to count the number of ways         int[][] dp = new int[n+1][n+1];         dp[n][0] = 1;         for(int i = n-1; i >= 0; i--) {             for(int j = 0; j <= n; j++) {                 dp[i][j] = dp[i+1][j];                 if(j > 0) {                     int cnt = 0;                     for(int k = i+1; k < n; k++) {                         if(overlap[i][k]) {                             cnt++;                         }                         dp[i][j] = (dp[i][j] + (int)(((long)cnt*dp[k+1][j-1])%mod))%mod;                     }                 }             }         }                  return dp[0][n/2];     } },1,"2580-count-ways-to-group-overlapping-ranges/Solution.java:11:51: Inner assignments should be avoided. [InnerAssignment]
2580-count-ways-to-group-overlapping-ranges/Solution.java:11:51: Inner assignments should be avoided. [InnerAssignment]
2580-count-ways-to-group-overlapping-ranges/Solution.java:28:	UselessParentheses:	Useless parentheses.
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public int kthLargestLevelSum(TreeNode root, int k) {         if (root == null) {             return -1;         }         Queue<TreeNode> queue = new LinkedList<>();         queue.offer(root);         Map<Integer, Integer> levelSumMap = new HashMap<>();         int maxLevelSum = Integer.MIN_VALUE;         while (!queue.isEmpty()) {             int size = queue.size();             int levelSum = 0;             for (int i = 0; i < size; i++) {                 TreeNode node = queue.poll();                 levelSum += node.val;                 if (node.left != null) {                     queue.offer(node.left);                 }                 if (node.right != null) {                     queue.offer(node.right);                 }             }             levelSumMap.put(levelSumMap.size(), levelSum);             maxLevelSum = Math.max(maxLevelSum, levelSum);         }         if (k > levelSumMap.size()) {             return -1;         }         List<Integer> levelSums = new ArrayList<>(levelSumMap.values());         Collections.sort(levelSums, Collections.reverseOrder());         return levelSums.get(k - 1);     } }",0,,0,0,0
"class Solution {     public int maxScore(int[] nums) {         int[] positiveNums = Arrays.stream(nums).filter(n -> n > 0).sorted().toArray(); // get all positive nums and sort them         int[] prefix = new int[nums.length];         int count = 0;         for (int i = 0; i < nums.length; i++) {             if (nums[i] > 0) { // if num is positive                 prefix[i] = (i > 0 ? prefix[i-1] : 0) + nums[i]; // calculate prefix sum                 count++; // increment count of positive nums             } else {                 prefix[i] = (i > 0 ? prefix[i-1] : 0); // prefix sum remains the same             }         }         int maxScore = count;         int j = count - 1;         for (int i = nums.length - 1; i >= 0; i--) {             if (nums[i] > 0) { // if num is positive                 while (j >= 0 && positiveNums[j] > nums[i]) { // find the largest positive num that can replace nums[i]                     j--;                 }                 if (j < 0) { // no more positive nums to replace                     break;                 }                 int newScore = prefix[i-1] + count - (j + 1); // calculate new score                 maxScore = Math.max(maxScore, newScore); // update max score if necessary             }         }         return maxScore;     } }",0,,0,0,0
"class Solution {     public long beautifulSubarrays(int[] nums) {         long ans = 0;         int n = nums.length;                  // Count the number of odd numbers in the array         int numOdds = 0;         for(int num: nums) {             if(num % 2 != 0) {                 numOdds++;             }         }                  // Case 1: All elements in subarray are odd         // For each odd-length subarray, we can make all elements equal to 0 by choosing the kth bit to be the rightmost set bit         // and subtracting 2^k from both numbers. There are numOdds odd numbers in the array, so there are numOdds choose 1,         // numOdds choose 3, numOdds choose 5, ... ways to choose an odd-length subarray.         for(int i = 1; i <= numOdds; i += 2) {             long count = 1;             int j = 1;             while(j <= i) {                 count *= (numOdds - (i - j));                 count /= j;                 j += 2;             }             ans += count;         }                  // Case 2: All elements in subarray are even         // We can make all elements equal to 0 by choosing the kth bit to be the rightmost set bit and subtracting 2^k         // from both numbers, until all remaining bits in the numbers are 0s. There is only one even-length subarray.         int numEvens = n - numOdds;         if(numEvens > 0 && numOdds == 0) {             ans++;         }                  // Case 3: Subarray contains both odd and even elements         // For each even-length subarray, we can choose one element to add to the odd subarray on the left, and one element         // to add to the odd subarray on the right. This leaves an odd-length subarray in between, which can be transformed         // into a beautiful subarray as in Case 1. There are numOdds choose 1, numEvens choose 2, numOdds choose 1 ways to         // choose an even-length subarray.         for(int i = 2; i <= numEvens; i += 2) {             long count = 1;             int j = 1;             while(j <= i) {                 count *= (numEvens - (i - j));                 count /= j;                 j++;             }             ans += count * numOdds * numOdds;         }                  return ans;     } }",0,,0,0,0
"class Solution {     public int maximizeGreatness(int[] nums) {         int[] counts = new int[1000000001]; // to keep track of count of each number         int max = 0;         for(int num: nums) {             counts[num]++;             max = Math.max(max, num);         }                  int greatness = 0;         int currMax = max;         for(int i = nums.length-1; i >= 0; i--) {             if(nums[i] >= currMax) { // if current number is greater than or equal to current maximum, decrement current maximum                 currMax--;             }             else { // else increment the greatness since this number can be permuted to attain greatness                 greatness++;             }         }         return greatness;     } }",1,"2592-maximize-greatness-of-an-array/Solution.java:15:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2592-maximize-greatness-of-an-array/Solution.java:15:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
class Solution {     public long findScore(int[] nums) {         int n = nums.length;         boolean[] marked = new boolean[n];   // marking if element of input array is marked or not         long score = 0;                      // score is initialized to 0          while (true) {             int minIndex = -1;               //index of minimum unmarked integer             for (int i = 0; i < n; i++) {                 if (!marked[i] && (minIndex == -1 || nums[i] < nums[minIndex])) {                     minIndex = i;                 }             }             if (minIndex == -1) {            //if all the elements are marked:                 break;             }             score += nums[minIndex];             marked[minIndex] = true;             if (minIndex > 0) {             //mark the left adjacent element                 marked[minIndex - 1] = true;             }             if (minIndex < n - 1) {         //mark the right adjacent element                 marked[minIndex + 1] = true;             }         }         return score;                        //return the accumulated score     } },0,,0,0,0
"class Solution {     public long repairCars(int[] ranks, int cars) {         int n = ranks.length;         Arrays.sort(ranks);  // Sort ranks of mechanics         long total_time = Long.MAX_VALUE;                  for (int i = n - 1; i >= 0; i--) {  // Iterate over mechanics starting from the one with highest rank             long time = 0;             int cars_left = cars;  // Count of cars left to be repaired                          for (int j = i; j < n && cars_left > 0; j++) {  // Iterate over remaining mechanics                 int available_cars = Math.min((ranks[j] * ranks[j]) - 1, cars_left);  // Maximum number of cars a mechanic can repair                 time += (long) available_cars * ranks[j];  // Total time taken by a mechanic to repair available cars                 cars_left -= available_cars;  // Update count of cars left to be repaired             }                          if (cars_left == 0) {  // All cars have been repaired                 total_time = Math.min(total_time, time);             }         }                  return total_time;     } }",0,,0,0,0
"class Solution {     private final int[][] moves = new int[][]{{-2,-1},{-2,1},{-1,-2},{-1,2},{1,-2},{1,2},{2,-1},{2,1}};          public boolean checkValidGrid(int[][] grid) {         int n = grid.length;         boolean[] visited = new boolean[n*n];         int curr = 0;                  // find start position         int row = 0, col = 0;         for (int i = 0; i < n; i++) {             for (int j = 0; j < n; j++) {                 if (grid[i][j] == 0) {                     row = i;                     col = j;                     break;                 }             }         }                  visited[0] = true;         for (int i = 1; i < n*n; i++) {             int[] nextMove = getNextMove(grid, row, col, visited);             if (nextMove == null) {                 return false;             }             row = nextMove[0];             col = nextMove[1];             visited[i] = true;         }                  return true;     }          private int[] getNextMove(int[][] grid, int row, int col, boolean[] visited) {         for (int[] move : moves) {             int x = row + move[0];             int y = col + move[1];             if (x >= 0 && x < grid.length && y >= 0 && y < grid.length && !visited[grid[x][y]]) {                 int[] nextMove = new int[]{x, y};                 return nextMove;             }         }         return null;     } }",1,"2596-check-knight-tour-configuration/Solution.java:10:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2596-check-knight-tour-configuration/Solution.java:10:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2596-check-knight-tour-configuration/Solution.java:7:	UnusedLocalVariable:	Avoid unused local variables such as 'curr'.
2596-check-knight-tour-configuration/Solution.java:40:	UnnecessaryLocalBeforeReturn:	Consider simply returning the value vs storing it in local variable 'nextMove'
2596-check-knight-tour-configuration/Solution.java:44:	ReturnEmptyCollectionRatherThanNull:	Return an empty collection rather than null.
",1,0,0
"class Solution {     public int beautifulSubsets(int[] nums, int k) {         int count = 0;         int n = nums.length;         int subsetCount = (int)Math.pow(2, n);                  for(int i = 1;i<subsetCount;i++){             int[] subset = new int[n];             int index = 0;             for(int j=0;j<n;j++){                 if((i & (1<<j))>0){                     subset[index++] = nums[j];                 }             }             if(isBeautiful(subset,k)){                 count++;             }         }         return count;     }          public boolean isBeautiful(int[] subset,int k){         for(int i=0;i<subset.length-1;i++){             for(int j=i+1;j<subset.length;j++){                 if(Math.abs(subset[i]-subset[j])==k){                     return false;                 }             }         }         return true;     } }",0,,0,0,0
"class Solution {     public int findMaxMEX(int[] nums, int value) {         // Creating a HashSet to store all the unique numbers in nums         HashSet<Integer> set = new HashSet<>();         for(int num : nums) {             set.add(num);         }                  int maxMEX = 0;         // Check MEX for all numbers between 0 to |nums|+value         for(int i = 0; i <= nums.length + value; i++) {             // If the number is present in the set, exclude it             if(set.contains(i)) {                 continue;             }             int currMex = 0;             // Check the MEX after applying operation to each number in nums             for(int num : nums) {                 int diff = Math.abs(i - num);                 if(diff <= value) {                     int numAfterOp = num + ((num > i) ? -value : value);                     if(numAfterOp < 0) {                         currMex++; // Since we are only considering non-negative integers                     } else if(numAfterOp == i) {                         break; // We found the minimum excluded integer                     }                 } else {                     currMex++;                 }             }             maxMEX = Math.max(maxMEX, currMex);         }         return maxMEX;     } }",0,,0,0,0
class Solution {     public int[] singleNumber(int[] nums) {         // Find the XOR of the two unique numbers         int x = 0;         for (int num : nums) {             x ^= num;         }                  // Find the rightmost set bit in x         int mask = x & -x;                  // Partition the nums array based on the value of the mask bit         int[] result = new int[2];         for (int num : nums) {             if ((num & mask) == 0) {                 result[0] ^= num;             } else {                 result[1] ^= num;             }         }                  return result;     } },0,,0,0,0
"class Solution {     public boolean primeSubOperation(int[] nums) {         // initialize boolean variable to track if the array is already sorted         boolean sorted = true;                  // iterate through the array to check if it's already sorted         for (int i = 1; i < nums.length; i++) {             if (nums[i] <= nums[i-1]) {                 sorted = false;                 break;             }         }                  // if it's already sorted, return true         if (sorted) {             return true;         }                  // iterate through the array to check if it can be sorted         for (int i = 0; i < nums.length; i++) {             // find all the prime numbers less than nums[i]             List<Integer> primes = new ArrayList<>();             for (int j = 2; j < nums[i]; j++) {                 if (isPrime(j)) {                     primes.add(j);                 }             }                          // try subtracting each prime number from nums[i]             for (int prime : primes) {                 int temp = nums[i] - prime;                 // if the resulting number is less than or equal to the previous element, skip                 if (i != 0 && temp <= nums[i-1]) {                     continue;                 }                 // update nums[i] and check if the array is sorted                 nums[i] = temp;                 sorted = true;                 for (int j = 1; j < nums.length; j++) {                     if (nums[j] <= nums[j-1]) {                         sorted = false;                         break;                     }                 }                 // if the array is sorted, return true                 if (sorted) {                     return true;                 }             }             // reset nums[i] to its original value             nums[i] += primes.get(primes.size()-1);         }         // if it couldn't be sorted, return false         return false;     }          // helper function to check if a number is prime     private boolean isPrime(int num) {         if (num == 2) {             return true;         }         if (num < 2 || num % 2 == 0) {             return false;         }         for (int i = 3; i <= Math.sqrt(num); i += 2) {             if (num % i == 0) {                 return false;             }         }         return true;     } }",1,"2601-prime-subtraction-operation/Solution.java:2:	NPathComplexity:	The method 'primeSubOperation(int[])' has an NPath complexity of 348, current threshold is 200
",0,0,0
"import java.util.*;  class Solution {     public List<Long> minOperations(int[] nums, int[] queries) {         List<Long> answer = new ArrayList<>();         int maxNum = 0;         for (int num : nums) {             maxNum = Math.max(maxNum, num);         }         int[] freq = new int[maxNum+1];         for (int num : nums) {             freq[num]++;         }         for (int target : queries) {             long operations = 0;             for (int i = 1; i <= maxNum; i++) {                 if (freq[i] == 0) {                     continue;                 }                 if (i > target) {                     operations += (long) (i - target) * freq[i];                 } else if (i < target) {                     operations += (long) (target - i) * freq[i];                 }             }             answer.add(operations);         }         return answer;     } }",0,,0,0,0
"class Solution {     public int maximumCostSubstring(String s, String chars, int[] vals) {         int maxCost = 0; // variable to store maximum cost of substring         Set<Character> charSet = new HashSet<>(); // creating set of characters in chars         for (char c : chars.toCharArray()) {             charSet.add(c);         }         int length = s.length();         for (int i = 0; i < length; i++) {             for (int j = i; j < length; j++) {                 String subStr = s.substring(i, j + 1);                 int cost = 0;                 for (char c : subStr.toCharArray()) {                     if (charSet.contains(c)) {                         cost += vals[chars.indexOf(c)];                     } else {                         cost += c - 'a' + 1;                     }                 }                 maxCost = Math.max(maxCost, cost);             }         }         return maxCost;     } }",0,,0,0,0
"class Solution {     public long makeSubKSumEqual(int[] arr, int k) {         int n = arr.length;         long[] prefixSum = new long[n];         long[] currentSum = new long[k];         for (int i = 0; i < n; i++) {             prefixSum[i] = arr[i] + (i == 0 ? 0 : prefixSum[i - 1]);             if (i < k) {                 currentSum[i] = prefixSum[i];             }         }         long res = Long.MAX_VALUE;         for (int i = 0; i < k; i++) {             long targetSum = i == 0 ? currentSum[k - 1] : currentSum[k - 1] - currentSum[i - 1];             long diff = targetSum - currentSum[i] + (i == 0 ? 0 : currentSum[i - 1]) + (i == 0 ? 0 : prefixSum[n - 1] - prefixSum[k - i - 1]);             long op = Math.abs(diff) / k + (Math.abs(diff) % k == 0 ? 0 : 1);             res = Math.min(res, op);         }         return res;     } }",1,"2607-make-k-subarray-sums-equal/Solution.java:6:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
",0,0,0
"import java.util.*;  class Solution {     public List<List<Integer>> findMatrix(int[] nums) {         List<List<Integer>> result = new ArrayList<>();         Map<Integer, Integer> freqMap = new HashMap<>();         for (int num : nums) {             freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);         }          int numRows = Collections.max(freqMap.values());         List<Integer>[] matrix = new List[numRows];         for (int i = 0; i < numRows; i++) {             matrix[i] = new ArrayList<>();         }          for (int i = 0; i < nums.length; i++) {             int num = nums[i];             for (int j = 0; j < numRows; j++) {                 if (freqMap.get(num) > 0 && !matrix[j].contains(num)) {                     matrix[j].add(num);                     freqMap.put(num, freqMap.get(num) - 1);                     break;                 }             }         }          for (int i = 0; i < numRows; i++) {             result.add(matrix[i]);         }          return result;     } }",1,"2610-convert-an-array-into-a-2d-array-with-conditions/Solution.java:6:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
2610-convert-an-array-into-a-2d-array-with-conditions/Solution.java:17:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int miceAndCheese(int[] reward1, int[] reward2, int k) {         int n = reward1.length;         // Sort the cheese by the difference in reward1 and reward2 in decreasing order         Integer[] indices = new Integer[n];         for (int i = 0; i < n; i++) {             indices[i] = i;         }         Arrays.sort(indices, (a, b) -> Integer.compare(reward2[b] - reward1[b], reward2[a] - reward1[a]));                  // Calculate the prefix sums of the maximum reward for the first mouse and the second mouse respectively         int[] prefix1 = new int[n+1]; // prefix1[i] is the maximum reward for the first mouse after eating i cheese         int[] prefix2 = new int[n+1]; // prefix2[i] is the maximum reward for the second mouse after eating i cheese         for (int i = 1; i <= n; i++) {             int index = indices[i-1];             prefix1[i] = prefix1[i-1];             prefix2[i] = prefix2[i-1];             if (i <= k) { // The first mouse has not eaten k cheese yet                 prefix1[i] = Math.max(prefix1[i], prefix2[i-1] + reward1[index]);             }             if (i + k - 1 <= n) { // The second mouse has not eaten k cheese yet                 prefix2[i] = Math.max(prefix2[i], prefix1[i-1] + reward2[index]);             }         }         // Return the maximum reward after the mice have eaten k cheese each         int maxReward = 0;         for (int i = 0; i <= k; i++) {             maxReward = Math.max(maxReward, prefix1[i] + prefix2[n-k+i]);         }         return maxReward;     } }",0,,0,0,0
class Solution {     public long[] distance(int[] nums) {         int n = nums.length;         long[] arr = new long[n];                  for (int i = 0; i < n; i++) {             long sum = 0;             boolean flag = false;                          for (int j = 0; j < n; j++) {                 if (i != j && nums[i] == nums[j]) {                     sum += Math.abs(i - j);                     flag = true;                 }             }                          if (flag) {                 arr[i] = sum;             } else {                 arr[i] = 0;             }         }                  return arr;     } },0,,0,0,0
"class Solution {     public int minimizeMax(int[] nums, int p) {         Arrays.sort(nums); // Sort the array to make finding the maximum difference easier                  int n = nums.length;         int maxDiff = nums[n - 1] - nums[0]; // Set the initial maximum difference to the difference between the largest and smallest elements of the array                  // Binary search to find the minimum maximum difference         int left = 0;         int right = maxDiff;         while (left < right) {             int mid = (left + right) / 2;             int count = countPairs(nums, mid);             if (count >= p) {                 right = mid;             } else {                 left = mid + 1;             }         }                  return left;     }          private int countPairs(int[] nums, int targetDiff) {         int n = nums.length;         int count = 0;         int left = 0;         int right = 0;         while (right < n) {             while (nums[right] - nums[left] > targetDiff) {                 left++; // Move the left pointer to make the difference smaller             }             count += right - left; // Count the number of pairs between left and right pointers             right++; // Move the right pointer to try to include more pairs         }         return count;     } }",0,,0,0,0
"class Solution {     public int nthUglyNumber(int n) {         int[] uglyNumbers = new int[n];         uglyNumbers[0] = 1;         int nextUglyNumberIndex = 1;         int index2 = 0, index3 = 0, index5 = 0;         while (nextUglyNumberIndex < n) {             int nextUglyNumberCandidate = Math.min(uglyNumbers[index2] * 2, Math.min(uglyNumbers[index3] * 3, uglyNumbers[index5] * 5));             uglyNumbers[nextUglyNumberIndex] = nextUglyNumberCandidate;             if (nextUglyNumberCandidate == uglyNumbers[index2] * 2) {                 index2++;             }             if (nextUglyNumberCandidate == uglyNumbers[index3] * 3) {                 index3++;             }             if (nextUglyNumberCandidate == uglyNumbers[index5] * 5) {                 index5++;             }             nextUglyNumberIndex++;         }         return uglyNumbers[n - 1];     } }",1,"264-ugly-number-ii/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
264-ugly-number-ii/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
class Solution {     public int hIndex(int[] citations) {         int n = citations.length;         int[] count = new int[n+1];                  // Calculate the count of citations for each paper         for(int i=0; i<n; i++) {             if(citations[i]>n) {                 count[n]++;             }             else {                 count[citations[i]]++;             }         }                  // Calculate the h-index         int sum = 0;         for(int i=n; i>=0; i--) {             sum += count[i];             if(sum>=i) {                 return i;             }         }                  return 0;     } },1,"274-h-index/Solution.java:10:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
274-h-index/Solution.java:10:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
"class Solution {     public int hIndex(int[] citations) {         int n = citations.length;         int left = 0, right = n - 1;         while (left <= right) {             int mid = left + (right - left) / 2;             if (citations[mid] >= n - mid) {                 right = mid - 1;             } else {                 left = mid + 1;             }         }         return n - left;     } }",1,"275-h-index-ii/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
275-h-index-ii/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int numSquares(int n) {         int[] dp = new int[n+1]; // Initialize an array to store minimum count of perfect square numbers         for(int i=1; i<=n; i++){             dp[i] = i; // Since the worst case is to choose all 1's i.e. i numbers             for(int j=1; j*j<=i; j++){                 dp[i] = Math.min(dp[i], 1+dp[i-j*j]); // Recurrence relation to find the minimum number of perfect square numbers             }         }         return dp[n]; // Return the minimum count of perfect square numbers that sum to n     } }",0,,0,0,0
import java.util.Iterator;  class PeekingIterator implements Iterator<Integer> {     private Iterator<Integer> iterator;     private Integer nextElement;      public PeekingIterator(Iterator<Integer> iterator) {         this.iterator = iterator;         if (iterator.hasNext()) {             nextElement = iterator.next();         }     }      @Override     public Integer peek() {         return nextElement;     }      @Override     public Integer next() {         Integer currentElement = nextElement;         if (iterator.hasNext()) {             nextElement = iterator.next();         } else {             nextElement = null;         }         return currentElement;     }      @Override     public boolean hasNext() {         return nextElement != null;     } },1,"284-peeking-iterator/Solution.java:7:5: Redundant 'public' modifier. [RedundantModifier]
284-peeking-iterator/Solution.java:7:46: 'iterator' hides a field. [HiddenField]
284-peeking-iterator/Solution.java:7:5: Redundant 'public' modifier. [RedundantModifier]
284-peeking-iterator/Solution.java:7:46: 'iterator' hides a field. [HiddenField]
284-peeking-iterator/Solution.java:25:	NullAssignment:	Assigning an Object to null is a code smell.  Consider refactoring.
",0,0,0
class Solution {     public int findDuplicate(int[] nums) {         int slow = nums[0];         int fast = nums[0];                  do {             slow = nums[slow];             fast = nums[nums[fast]];         } while (slow != fast);                  slow = nums[0];                  while (slow != fast) {             slow = nums[slow];             fast = nums[fast];         }                  return slow;     } },0,,0,0,0
"class Solution {     public void gameOfLife(int[][] board) {         int rows = board.length;         int cols = board[0].length;                  // Go through each cell and modify it according to the rules         for(int i=0; i<rows; i++) {             for(int j=0; j<cols; j++) {                 int liveNeighbors = countLiveNeighbors(board, i, j);                                  // Rule 1: Any live cell with fewer than two live neighbors dies                 if(board[i][j] == 1 && liveNeighbors < 2) {                     board[i][j] = -1; // Set as -1 to represent a cell that was live but will die                 }                                  // Rule 2: Any live cell with two or three live neighbors lives on                 if(board[i][j] == 1 && (liveNeighbors == 2 || liveNeighbors == 3)) {                     // No change needed                 }                                  // Rule 3: Any live cell with more than three live neighbors dies                 if(board[i][j] == 1 && liveNeighbors > 3) {                     board[i][j] = -1; // Set as -1                 }                                  // Rule 4: Any dead cell with exactly three live neighbors becomes a live cell                 if(board[i][j] == 0 && liveNeighbors == 3) {                     board[i][j] = 2; // Set as 2 to represent a cell that was dead but will come back to life                 }             }         }                  // Go through the board again and update the cells based on the new values         for(int i=0; i<rows; i++) {             for(int j=0; j<cols; j++) {                 if(board[i][j] == -1) {                     board[i][j] = 0; // Cell is now dead                 }                 if(board[i][j] == 2) {                     board[i][j] = 1; // Cell is now alive                 }             }         }     }          // Helper function to count the number of live neighbors     private int countLiveNeighbors(int[][] board, int row, int col) {         int count = 0;         int rows = board.length;         int cols = board[0].length;                  // Check all 8 neighbors and count the live ones         for(int i=-1; i<=1; i++) {             for(int j=-1; j<=1; j++) {                 int r = row+i;                 int c = col+j;                                  if(r>=0 && r<rows && c>=0 && c<cols && !(i==0 && j==0)) {                     // Cell is in bounds and is not the current cell                     if(board[r][c] == 1 || board[r][c] == -1) {                         count++;                     }                 }             }         }                  return count;     } }",1,"289-game-of-life/Solution.java:17:84: Must have at least one statement. [EmptyBlock]
289-game-of-life/Solution.java:17:84: Must have at least one statement. [EmptyBlock]
289-game-of-life/Solution.java:2:	NPathComplexity:	The method 'gameOfLife(int[][])' has an NPath complexity of 660, current threshold is 200
289-game-of-life/Solution.java:17:	EmptyControlStatement:	Empty if statement
289-game-of-life/Solution.java:60:	CollapsibleIfStatements:	This if statement could be combined with its parent
",0,0,0
"class Solution {     public String getHint(String secret, String guess) {         int bulls = 0;         int cows = 0;         int[] numbers = new int[10];         for (int i = 0; i < secret.length(); i++) {             int s = Character.getNumericValue(secret.charAt(i));             int g = Character.getNumericValue(guess.charAt(i));             if (s == g) {                 bulls++;             } else {                 if (numbers[s] < 0) {                     cows++;                 }                 if (numbers[g] > 0) {                     cows++;                 }                 numbers[s]++;                 numbers[g]--;             }         }         return bulls + ""A"" + cows + ""B"";     } }",0,,0,0,0
"class Solution {     public int lengthOfLIS(int[] nums) {         int n = nums.length;         if(n == 0) return 0; // Empty array case          int[] dp = new int[n];         Arrays.fill(dp,1); // initialize dp with 1, the lowest increasing subsequence length          for(int i=1; i<n; i++) {             for(int j=0; j<i; j++) {                 if(nums[j] < nums[i])                     dp[i] = Math.max(dp[i], dp[j] + 1); // If a larger subsequence is found, update dp value             }         }          return Arrays.stream(dp).max().getAsInt(); // Return the maximum value from dp array     } }",0,,0,0,0
"class NumMatrix {     int[][] preSum;      public NumMatrix(int[][] matrix) {         int m = matrix.length;         if (m > 0) {             int n = matrix[0].length;             preSum = new int[m + 1][n + 1];             for (int i = 1; i <= m; i++) {                 for (int j = 1; j <= n; j++) {                     preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1]                             - preSum[i - 1][j - 1] + matrix[i - 1][j - 1];                 }             }         }     }      public int sumRegion(int row1, int col1, int row2, int col2) {         return preSum[row2 + 1][col2 + 1] - preSum[row2 + 1][col1]                 - preSum[row1][col2 + 1] + preSum[row1][col1];     } }  /**  * Your NumMatrix object will be instantiated and called as such:  * NumMatrix obj = new NumMatrix(matrix);  * int param_1 = obj.sumRegion(row1,col1,row2,col2);  */",1,"304-range-sum-query-2d-immutable/NumMatrix.java:2:13: Variable 'preSum' must be private and have accessor methods. [VisibilityModifier]
304-range-sum-query-2d-immutable/NumMatrix.java:4:5: Redundant 'public' modifier. [RedundantModifier]
304-range-sum-query-2d-immutable/NumMatrix.java:2:13: Variable 'preSum' must be private and have accessor methods. [VisibilityModifier]
304-range-sum-query-2d-immutable/NumMatrix.java:4:5: Redundant 'public' modifier. [RedundantModifier]
",0,0,0
"class Solution {     public boolean isAdditiveNumber(String num) {         int n = num.length();         for (int i = 1; i <= n / 2; i++) {             if (num.charAt(0) == '0' && i > 1) { // to handle zeros                 break;             }             long num1 = Long.parseLong(num.substring(0, i));             for (int j = 1; Math.max(i, j) <= n - i - j; j++) {                 if (num.charAt(i) == '0' && j > 1) { // to handle zeros                     break;                 }                 long num2 = Long.parseLong(num.substring(i, i + j));                 if (isAdditiveSequence(num.substring(i + j), num1, num2)) {                     return true;                 }             }         }         return false;     }      private boolean isAdditiveSequence(String remaining, long num1, long num2) {         if (remaining.equals("""")) {             return true;         }         long sum = num1 + num2;         String sumS = Long.toString(sum);         if (!remaining.startsWith(sumS)) {             return false;         }         return isAdditiveSequence(remaining.substring(sumS.length()), num2, sum);     } }",1,"306-additive-number/Solution.java:23:	LiteralsFirstInComparisons:	Position literals first in String comparisons
306-additive-number/Solution.java:28:	SimplifyBooleanReturns:	This if statement can be replaced by `return !{condition} || {elseBranch};`
",0,0,0
"class NumArray {     private int[] nums;     private int[] tree;     private int n;      public NumArray(int[] nums) {         this.n = nums.length;         this.nums = nums;         this.tree = new int[n * 2];          for (int i = n; i < tree.length; i++) {             tree[i] = nums[i-n];         }          for (int i = n - 1; i > 0; i--) {             tree[i] = tree[2 * i] + tree[2 * i + 1];         }     }      public void update(int index, int val) {         index += n;         tree[index] = val;          while (index > 0) {             int left = index;             int right = index;              if (index % 2 == 0) {                 right = index + 1;             } else {                 left = index - 1;             }              tree[index / 2] = tree[left] + tree[right];             index /= 2;         }     }      public int sumRange(int left, int right) {         left += n;         right += n;         int sum = 0;          while (left <= right) {             if (left % 2 == 1) {                 sum += tree[left];                 left++;             }              if (right % 2 == 0) {                 sum += tree[right];                 right--;             }              left /= 2;             right /= 2;         }          return sum;     } }",1,"307-range-sum-query-mutable/NumArray.java:6:5: Redundant 'public' modifier. [RedundantModifier]
307-range-sum-query-mutable/NumArray.java:6:27: 'nums' hides a field. [HiddenField]
307-range-sum-query-mutable/NumArray.java:6:5: Redundant 'public' modifier. [RedundantModifier]
307-range-sum-query-mutable/NumArray.java:6:27: 'nums' hides a field. [HiddenField]
307-range-sum-query-mutable/NumArray.java:2:	UnusedPrivateField:	Avoid unused private fields such as 'nums'.
307-range-sum-query-mutable/NumArray.java:8:	ArrayIsStoredDirectly:	The user-supplied array 'nums' is stored directly.
307-range-sum-query-mutable/NumArray.java:21:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'index'
307-range-sum-query-mutable/NumArray.java:40:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'left'
307-range-sum-query-mutable/NumArray.java:41:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'right'
",0,1,0
"class Solution {     public int maxProfit(int[] prices) {         int n = prices.length;         int[] buy = new int[n];         int[] sell = new int[n];         int[] cooldown = new int[n];                  buy[0] = -prices[0];         sell[0] = 0;         cooldown[0] = 0;                  for (int i = 1; i < n; i++) {             buy[i] = Math.max(buy[i-1], cooldown[i-1] - prices[i]);             sell[i] = Math.max(sell[i-1], buy[i-1] + prices[i]);             cooldown[i] = Math.max(cooldown[i-1], sell[i-1]);         }                  return Math.max(sell[n-1], cooldown[n-1]);     } } ",0,,0,0,0
"import java.util.*;  class Solution {     public List<Integer> findMinHeightTrees(int n, int[][] edges) {         List<Integer> result = new ArrayList<>();         if(n <= 1) {    // If there is only one node, it will be the root having height 0             result.add(0);             return result;         }         int[] degrees = new int[n]; // To track the degree of each node         Map<Integer, Set<Integer>> graph = new HashMap<>();  // To store the Graph                  // Create the Graph         for(int[] edge : edges) {             int u = edge[0];             int v = edge[1];             degrees[u]++;             degrees[v]++;             graph.computeIfAbsent(u, k -> new HashSet<>()).add(v);             graph.computeIfAbsent(v, k -> new HashSet<>()).add(u);         }                  // Create a queue of leaf nodes         Queue<Integer> leaves = new LinkedList<>();         for(int i=0; i<n; i++) {             if(degrees[i] == 1) {                 leaves.offer(i);             }         }                  while(n > 2) {  // Continue the process until there are only 2 or less nodes             int size = leaves.size();             n -= size;             for(int i=0; i<size; i++) {                 int leaf = leaves.poll();                 degrees[leaf]--;                 Set<Integer> neighbors = graph.get(leaf);                 for(int neighbor : neighbors) {                     degrees[neighbor]--;                     graph.get(neighbor).remove(leaf);                     if(degrees[neighbor] == 1) {                         leaves.offer(neighbor);                     }                 }             }         }         return new ArrayList<>(leaves);     } }",1,"310-minimum-height-trees/Solution.java:11:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
310-minimum-height-trees/Solution.java:33:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
",0,1,0
"class Solution {     public int nthSuperUglyNumber(int n, int[] primes) {         int[] ugly = new int[n];         int[] ptr = new int[primes.length];         ugly[0] = 1;         for (int i = 1; i < n; i++) {             // Find the minimum ugly number.             int min = Integer.MAX_VALUE;             for (int j = 0; j < primes.length; j++) {                 min = Math.min(min, primes[j] * ugly[ptr[j]]);             }             ugly[i] = min;             // Update the pointers to make sure that they point to the next eligible number.             for (int j = 0; j < ptr.length; j++) {                 if (primes[j] * ugly[ptr[j]] == min) {                     ptr[j]++;                 }             }         }         return ugly[n-1];     } }",0,,0,0,0
"class Solution {     public String removeDuplicateLetters(String s) {         int[] freq = new int[26]; // to keep track of frequency of characters in string s         boolean[] visited = new boolean[26]; // to keep track of visited characters         // Populating the frequency count         for (char c : s.toCharArray()) {             freq[c - 'a']++;         }                  StringBuilder sb = new StringBuilder();         for (char c : s.toCharArray()) {             int index = c - 'a';             freq[index]--; // decrementing the frequency count of c as it is being processed             if (visited[index]) { // if we have already visited this character                 continue;             }             // Checking for the lexicographically smaller character             while (sb.length() > 0 && sb.charAt(sb.length() - 1) > c && freq[sb.charAt(sb.length() - 1) - 'a'] > 0) {                 visited[sb.charAt(sb.length() - 1) - 'a'] = false; // marking the character as not visited in visited array                 sb.deleteCharAt(sb.length() - 1); // removing the last character, which is lexicographically larger than c             }             visited[index] = true; // marking the character as visited in visited array             sb.append(c); // appending c to the result string         }                  return sb.toString();     } }",0,,0,0,0
"class Solution {     public int maxProduct(String[] words) {         int n = words.length;         int[] bitMasks = new int[n];                  // Creating a bitmask for each word         for(int i=0; i<n; i++){             String word = words[i];             int bitMask = 0;             for(int j=0; j<word.length(); j++){                 int bit = word.charAt(j) - 'a';                 bitMask |= (1<<bit);             }             bitMasks[i] = bitMask;         }                  int maxProduct = 0;                  // Comparing each pair of words and calculating the product of their lengths         for(int i=0; i<n; i++){             for(int j=i+1; j<n; j++){                 int len1 = words[i].length();                 int len2 = words[j].length();                 if((bitMasks[i] & bitMasks[j]) == 0){ // If the two words do not share common letters                     maxProduct = Math.max(maxProduct, len1*len2);                 }             }         }                  return maxProduct;     } }",0,,0,0,0
class Solution {     public int bulbSwitch(int n) {         return (int) Math.sqrt(n);     } },0,,0,0,0
"class Solution {     public int coinChange(int[] coins, int amount) {         int max = amount + 1;         int[] dp = new int[max];         Arrays.fill(dp, max);         dp[0] = 0;         for (int i = 1; i <= amount; i++) {             for (int j = 0; j < coins.length; j++) {                 if (coins[j] <= i) {                     dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);                 }             }         }         return dp[amount] > amount ? -1 : dp[amount];     } }",1,"322-coin-change/Solution.java:8:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public void wiggleSort(int[] nums) {         for(int i=0; i<nums.length-1; i++){             if(i%2==0){                 if(nums[i]>nums[i+1]){                     swap(nums, i, i+1);                 }             }else{                 if(nums[i]<nums[i+1]){                     swap(nums, i, i+1);                 }             }         }     }          public void swap(int[] nums, int i, int j){         int temp = nums[i];         nums[i] = nums[j];         nums[j] = temp;     } }   /* Explanation:  In this solution, we swap adjacent elements to ensure the wiggle pattern. If the index is even, check if its element is greater than the one at the next index, and swap it if true. If the index is odd, check if its element is smaller than the one at the next index, and swap it if true. The time complexity of this solution is O(n) and it is in-place with O(1) extra space. */",0,,0,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public ListNode oddEvenList(ListNode head) {         if(head == null) return head;   // If list is empty, return the head                  ListNode evenHead = head.next;  // Separate even list from the start of the original list         ListNode odd = head, even = evenHead;                  while(even != null && even.next != null){             odd.next = even.next;       // Link odd list to the next odd element             odd = odd.next;                          even.next = odd.next;       // Link even list to the next even element             even = even.next;         }         odd.next = evenHead;            // Combine the odd and even lists         return head;                    // Return the starting point     } }",1,"328-odd-even-linked-list/ListNode.java:16:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
328-odd-even-linked-list/ListNode.java:16:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public boolean isValidSerialization(String preorder) {         // Split the preorder string by commas         String[] arr = preorder.split("","");         int diff = 1;         // Traverse through the nodes in the preorder array         for (String node : arr) {             if (--diff < 0) {                 // If the difference goes below 0, return false                 return false;             }             if (!node.equals(""#"")) {                 // For a non-null node, add 2 to the difference                 diff += 2;             }         }         return diff == 0;     } }",1,"331-verify-preorder-serialization-of-a-binary-tree/Solution.java:8:	AssignmentInOperand:	Avoid assignments in operands
331-verify-preorder-serialization-of-a-binary-tree/Solution.java:12:	LiteralsFirstInComparisons:	Position literals first in String comparisons
",0,0,0
"class Solution {     public boolean increasingTriplet(int[] nums) {         int n = nums.length;         if(n <= 2) //if the given array has less than three elements, no triplet can be formed             return false;         int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE; //initialize two variables with a maximum value of integer         for(int i = 0; i < n; i++){             if(nums[i] <= min1) //if current element is smaller than min1                 min1 = nums[i]; //update min1             else if(nums[i] <= min2) //if current element is greater than or equal to min1, but smaller than or equal to min2                 min2 = nums[i]; //update min2             else //if current element is greater than min2, return true                 return true;         }         return false; //if no such triplet exists, return false     } }",1,"334-increasing-triplet-subsequence/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
334-increasing-triplet-subsequence/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public int rob(TreeNode root) {         if(root == null) return 0;         int[]ans = robHouse(root);         return Math.max(ans[0], ans[1]);     }     public int[] robHouse(TreeNode root){         if(root == null) return new int[2];         int[] res = new int[2];         int[] left = robHouse(root.left);         int[] right = robHouse(root.right);         //res[0] will have the max value if we dont rob the root.         res[0] = Math.max(left[0],left[1])                 + Math.max(right[0],right[1]);         //res[1] will have the max value if we rob the root.         res[1] = root.val + left[0] + right[0];         return res;     } }",0,,0,0,0
import java.util.*;  public class NestedIterator implements Iterator<Integer> {     private Stack<NestedInteger> stack;      public NestedIterator(List<NestedInteger> nestedList) {         stack = new Stack<>();         for (int i = nestedList.size() - 1; i >= 0; i--) {             stack.push(nestedList.get(i));         }     }      @Override     public Integer next() {         if (!hasNext()) {             throw new NoSuchElementException();         }         return stack.pop().getInteger();     }      @Override     public boolean hasNext() {         while (!stack.isEmpty() && !stack.peek().isInteger()) {             List<NestedInteger> list = stack.pop().getList();             for (int i = list.size() - 1; i >= 0; i--) {                 stack.push(list.get(i));             }         }         return !stack.isEmpty();     } },1,"341-flatten-nested-list-iterator/Solution.java:4:	LooseCoupling:	Avoid using implementation types like 'Stack'; use the interface instead
341-flatten-nested-list-iterator/Solution.java:4:	ReplaceVectorWithList:	Consider replacing this Vector with the newer java.util.List
341-flatten-nested-list-iterator/Solution.java:7:	ReplaceVectorWithList:	Consider replacing this Vector with the newer java.util.List
",0,0,0
"class Solution {     public int integerBreak(int n) {         if (n == 2) {             return 1;         }         if (n == 3) {             return 2;         }         if (n % 3 == 0) {             return (int) Math.pow(3, n / 3);         }         if (n % 3 == 1) {             return (int) (Math.pow(3, n / 3 - 1) * 4);         }         return (int) (Math.pow(3, n / 3) * 2);     } }  // Test the solution public class Main {     public static void main(String[] args) {         Solution solution = new Solution();         int n = 10;         System.out.println(solution.integerBreak(n)); // Outputs 36     } }",1,"343-integer-break/Main.java:20:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
343-integer-break/Main.java:20:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
343-integer-break/Main.java:20:	UseUtilityClass:	This utility class has a non-private constructor
",0,0,0
"import java.util.*;  class Solution {     public int[] topKFrequent(int[] nums, int k) {         // create a map to track the frequency of each element         Map<Integer, Integer> map = new HashMap<>();         for(int i : nums){             map.put(i, map.getOrDefault(i, 0) + 1);         }                  // create a priority queue to store the elements based on their frequency         PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>((a, b) -> b.getValue() - a.getValue());         pq.addAll(map.entrySet());                  // create an array to store the k most frequent elements         int[] res = new int[k];         int i = 0;         while(i < k){             res[i] = pq.poll().getKey();             i++;         }                  return res;     } }",1,"347-top-k-frequent-elements/Solution.java:6:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
347-top-k-frequent-elements/Solution.java:12:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
",0,0,0
"class Twitter {     private Map<Integer, List<Integer>> tweets;     private Map<Integer, Set<Integer>> followees;     private Deque<Integer> feed;          /** Initialize your data structure here. */     public Twitter() {         tweets = new HashMap<>();         followees = new HashMap<>();         feed = new LinkedList<>();     }          /** Compose a new tweet. */     public void postTweet(int userId, int tweetId) {         List<Integer> userTweets = tweets.getOrDefault(userId, new ArrayList<>());         userTweets.add(tweetId);         tweets.put(userId, userTweets);         feed.addFirst(tweetId);     }          /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */     public List<Integer> getNewsFeed(int userId) {         List<Integer> result = new ArrayList<>();         if(!followees.containsKey(userId))             return result;         Set<Integer> followeeIds = followees.get(userId);         int count = 0;         for(Integer tweetId : feed) {             Integer tweetUserId = getUserId(tweetId);             if(userId.equals(tweetUserId) || followeeIds.contains(tweetUserId)) {                 result.add(tweetId);                 count++;                 if(count == 10)                     break;             }         }         return result;     }          /** Follower follows a followee. If the operation is invalid, it should be a no-op. */     public void follow(int followerId, int followeeId) {         if(followerId == followeeId)             return;         Set<Integer> followedUsers = followees.getOrDefault(followerId, new HashSet<>());         followedUsers.add(followeeId);         followees.put(followerId, followedUsers);     }          /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */     public void unfollow(int followerId, int followeeId) {         if(followerId == followeeId)             return;         Set<Integer> followedUsers = followees.getOrDefault(followerId, new HashSet<>());         followedUsers.remove(followeeId);         followees.put(followerId, followedUsers);     }          private Integer getUserId(Integer tweetId) {         for(Integer userId : tweets.keySet()) {             List<Integer> userTweets = tweets.get(userId);             if(userTweets.contains(tweetId))                 return userId;         }         return -1; // This won't occur as tweetIds are unique     } }",1,"355-design-twitter/Twitter.java:7:5: Redundant 'public' modifier. [RedundantModifier]
355-design-twitter/Twitter.java:7:5: Redundant 'public' modifier. [RedundantModifier]
",0,0,0
"class Solution {     public int countNumbersWithUniqueDigits(int n) {         if(n == 0) return 1;         int ans = 10, uniqueDigits = 9, availableNumber = 9;         while(n-- > 1 && availableNumber > 0) {             uniqueDigits = uniqueDigits * availableNumber;             ans += uniqueDigits;             availableNumber--;         }                  return ans;     } }  class Main {     public static void main(String[] args) {         Solution solution = new Solution();          System.out.println(solution.countNumbersWithUniqueDigits(0)); // 1         System.out.println(solution.countNumbersWithUniqueDigits(1)); // 10         System.out.println(solution.countNumbersWithUniqueDigits(2)); // 91         System.out.println(solution.countNumbersWithUniqueDigits(3)); // 739     } }",1,"357-count-numbers-with-unique-digits/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
357-count-numbers-with-unique-digits/Solution.java:15:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
357-count-numbers-with-unique-digits/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
357-count-numbers-with-unique-digits/Solution.java:15:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
357-count-numbers-with-unique-digits/Solution.java:5:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
357-count-numbers-with-unique-digits/Solution.java:15:	UseUtilityClass:	This utility class has a non-private constructor
",1,1,0
"class Solution {     public boolean canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {         // If the target capacity is greater than the sum of the jug1Capacity and jug2Capacity,         // then it is not possible to measure the target capacity.         if (targetCapacity > jug1Capacity + jug2Capacity) {             return false;         }                  // If the target capacity can be filled completely with one jug,         // then it is possible to measure the target capacity.         if (targetCapacity == jug1Capacity || targetCapacity == jug2Capacity) {             return true;         }                  // If the target capacity is a multiple of the greatest common divisor of the jug capacities,         // then it is possible to measure the target capacity.         int gcd = calculateGcd(jug1Capacity, jug2Capacity);         return targetCapacity % gcd == 0;     }          private int calculateGcd(int a, int b) {         if (b == 0) {             return a;         }         return calculateGcd(b, a % b);     } }",0,,0,0,0
"import java.util.ArrayList; import java.util.Arrays; import java.util.List;  class Solution {     public List<Integer> largestDivisibleSubset(int[] nums) {         int[] dp = new int[nums.length];         Arrays.sort(nums); // sorting the array         Arrays.fill(dp, 1); // filling the dp array with default value 1         int max = 1, index = 0;         for (int i = 1; i < nums.length; i++) {             for (int j = 0; j < i; j++) {                 if (nums[i] % nums[j] == 0) {                     dp[i] = Math.max(dp[i], dp[j] + 1); // dynamic programming approach                 }             }             if (max < dp[i]) { // updating the value of max and index                 max = dp[i];                 index = i;             }         }         List<Integer> result = new ArrayList<>();         int prev = nums[index];         for (int i = index; i >= 0; i--) { // traversing from index to 0 and adding the numbers in result             if (prev % nums[i] == 0 && dp[i] == max) {                 result.add(nums[i]);                 prev = nums[i];                 max--;             }         }         return result; // returning result     } }",1,"368-largest-divisible-subset/Solution.java:10:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
368-largest-divisible-subset/Solution.java:10:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int getSum(int a, int b) {         while(b != 0){             int carry = a & b;             a = a ^ b;             b = carry << 1;         }         return a;     } }",1,"371-sum-of-two-integers/Solution.java:5:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'a'
371-sum-of-two-integers/Solution.java:6:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'b'
",0,1,0
"class Solution {     public int superPow(int a, int[] b) {         int n = b.length;         int res = 1;         for (int i = n - 1; i >= 0; i--) {             int item = (int) Math.pow(a, b[i]) % 1337;             for (int j = 0; j < n - i - 1; j++) {                 item = (item * (int) Math.pow(item, 10)) % 1337;             }             res = (res * item) % 1337;         }         return res;     } }",1,"372-super-pow/Solution.java:8:	UselessParentheses:	Useless parentheses.
372-super-pow/Solution.java:10:	UselessParentheses:	Useless parentheses.
",0,0,0
"import java.util.*;  class Solution {     public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {         List<List<Integer>> res = new ArrayList<>();         if (nums1 == null || nums1.length == 0 || nums2 == null || nums2.length == 0 || k <= 0)             return res;         PriorityQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(o -> (o[0] + o[1])));         for (int i = 0; i < nums1.length && i < k; i++)             queue.offer(new int[]{nums1[i], nums2[0], 0});         while (k-- > 0 && !queue.isEmpty()) {             int[] cur = queue.poll();             List<Integer> tmp = new ArrayList<>();             tmp.add(cur[0]);             tmp.add(cur[1]);             res.add(tmp);             if (cur[2] == nums2.length - 1)                 continue;             queue.offer(new int[]{cur[0], nums2[cur[2] + 1], cur[2] + 1});         }         return res;     } }",1,"373-find-k-pairs-with-smallest-sums/Solution.java:8:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
373-find-k-pairs-with-smallest-sums/Solution.java:8:	UselessParentheses:	Useless parentheses.
373-find-k-pairs-with-smallest-sums/Solution.java:11:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'k'
",0,1,0
"class Solution {     public int getMoneyAmount(int n) {         //creating a 2D array to store the minimum cost to guess a number in a range from i to j         int[][] minCost = new int[n+1][n+1];                  //looping through all the ranges starting from 1 to n         for(int len=1; len<n; len++) {             for(int i=1; i<=n-len; i++) {                 int j=i+len;                 minCost[i][j] = Integer.MAX_VALUE;                 //finding the minimum cost to guess a number k, where k is in the range of i and j                 for(int k=i; k<=j; k++) {                     int costK = k + Math.max(minCost[i][k-1], (k==j) ? 0 : minCost[k+1][j]);                     minCost[i][j] = Math.min(minCost[i][j], costK);                 }             }         }         return minCost[1][n];     } }",0,,0,0,0
"class Solution {     public int wiggleMaxLength(int[] nums) {         int n = nums.length;         if(n<2)             return n;         int[] up = new int[n];         int[] down = new int[n];         up[0] = 1;         down[0] = 1;         for(int i=1;i<n;i++){             if(nums[i]>nums[i-1]){                 up[i] = down[i-1]+1;                 down[i] = down[i-1];             }else if(nums[i]<nums[i-1]){                 down[i] = up[i-1]+1;                 up[i] = up[i-1];             }else{                 down[i] = down[i-1];                 up[i] = up[i-1];             }         }         return Math.max(down[n-1],up[n-1]);     } }",0,,0,0,0
"class Solution {     public int combinationSum4(int[] nums, int target) {         int[] dp = new int[target + 1];         dp[0] = 1;          for (int i = 1; i <= target; i++) {             for (int num : nums) {                 if (i - num >= 0) {                     dp[i] += dp[i - num];                 }             }         }          return dp[target];     } }",0,,0,0,0
"class Solution {     public int kthSmallest(int[][] matrix, int k) {         int rows = matrix.length;         int cols = matrix[0].length;         int l = matrix[0][0], r = matrix[rows - 1][cols - 1];         while (l < r) {             int mid = l + (r - l) / 2;             int count = 0;             int j = cols - 1;             for (int i = 0; i < rows; i++) {                 while (j >= 0 && matrix[i][j] > mid) j--;                 count += j + 1;             }             if (count < k) l = mid + 1;             else r = mid;         }         return l;     } }",1,"378-kth-smallest-element-in-a-sorted-matrix/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
378-kth-smallest-element-in-a-sorted-matrix/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"import java.util.*;  class RandomizedSet {     List<Integer> nums;     Map<Integer, Integer> valToIndex;      /** Initialize your data structure here. */     public RandomizedSet() {         nums = new ArrayList<>();         valToIndex = new HashMap<>();     }      /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */     public boolean insert(int val) {         if (valToIndex.containsKey(val)) {             return false;         }         valToIndex.put(val, nums.size());         nums.add(val);         return true;     }      /** Removes a value from the set. Returns true if the set contained the specified element. */     public boolean remove(int val) {         if (!valToIndex.containsKey(val)) {             return false;         }         int index = valToIndex.get(val);         int lastNum = nums.get(nums.size() - 1);         nums.set(index, lastNum);         valToIndex.put(lastNum, index);         nums.remove(nums.size() - 1);         valToIndex.remove(val);         return true;     }      /** Get a random element from the set. */     public int getRandom() {         int index = (int) (Math.random() * nums.size());         return nums.get(index);     } }  /**  * Your RandomizedSet object will be instantiated and called as such:  * RandomizedSet obj = new RandomizedSet();  * boolean param_1 = obj.insert(val);  * boolean param_2 = obj.remove(val);  * int param_3 = obj.getRandom();  */",1,"380-insert-delete-getrandom-o1/RandomizedSet.java:4:19: Variable 'nums' must be private and have accessor methods. [VisibilityModifier]
380-insert-delete-getrandom-o1/RandomizedSet.java:5:27: Variable 'valToIndex' must be private and have accessor methods. [VisibilityModifier]
380-insert-delete-getrandom-o1/RandomizedSet.java:8:5: Redundant 'public' modifier. [RedundantModifier]
380-insert-delete-getrandom-o1/RandomizedSet.java:4:19: Variable 'nums' must be private and have accessor methods. [VisibilityModifier]
380-insert-delete-getrandom-o1/RandomizedSet.java:5:27: Variable 'valToIndex' must be private and have accessor methods. [VisibilityModifier]
380-insert-delete-getrandom-o1/RandomizedSet.java:8:5: Redundant 'public' modifier. [RedundantModifier]
",0,0,0
"import java.util.Random;  /** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode() {} *     ListNode(int val) { this.val = val; } *     ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution {      private ListNode head;     private Random random;      public Solution(ListNode head) {         this.head = head;         this.random = new Random();     }      public int getRandom() {         int count = 0;         int result = 0;         ListNode current = head;          while (current != null) {             count++;             if (random.nextInt(count) == 0) {                 result = current.val;             }             current = current.next;         }          return result;     } }",1,"382-linked-list-random-node/ListNode.java:18:5: Redundant 'public' modifier. [RedundantModifier]
382-linked-list-random-node/ListNode.java:18:30: 'head' hides a field. [HiddenField]
382-linked-list-random-node/ListNode.java:18:5: Redundant 'public' modifier. [RedundantModifier]
382-linked-list-random-node/ListNode.java:18:30: 'head' hides a field. [HiddenField]
",0,0,0
"class Solution {     private int[] nums;     private int[] original;     private Random rand;      public Solution(int[] nums) {         this.nums = nums;         this.original = nums.clone();         this.rand = new Random();     }          public int[] reset() {         nums = original.clone();         return nums;     }          public int[] shuffle() {         for (int i = 0; i < nums.length; i++) {             int randIndex = rand.nextInt(nums.length-i);             swap(nums, i, randIndex+i);         }         return nums;     }          private void swap(int[] arr, int i, int j) {         int temp = arr[i];         arr[i] = arr[j];         arr[j] = temp;     } } /**  * Your Solution object will be instantiated and called as such:  * Solution obj = new Solution(nums);  * int[] param_1 = obj.reset();  * int[] param_2 = obj.shuffle();  */",1,"384-shuffle-an-array/Solution.java:6:5: Redundant 'public' modifier. [RedundantModifier]
384-shuffle-an-array/Solution.java:6:27: 'nums' hides a field. [HiddenField]
384-shuffle-an-array/Solution.java:6:5: Redundant 'public' modifier. [RedundantModifier]
384-shuffle-an-array/Solution.java:6:27: 'nums' hides a field. [HiddenField]
384-shuffle-an-array/Solution.java:7:	ArrayIsStoredDirectly:	The user-supplied array 'nums' is stored directly.
384-shuffle-an-array/Solution.java:14:	MethodReturnsInternalArray:	Returning 'nums' may expose an internal array.
384-shuffle-an-array/Solution.java:22:	MethodReturnsInternalArray:	Returning 'nums' may expose an internal array.
",0,0,0
"/**  * // This is the interface that allows for creating nested lists.  * // You should not implement it, or speculate about its implementation  * public interface NestedInteger {  *     // Constructor initializes an empty nested list.  *     public NestedInteger();  *  *     // Constructor initializes a single integer.  *     public NestedInteger(int value);  *  *     // @return true if this NestedInteger holds a single integer, rather than a nested list.  *     public boolean isInteger();  *  *     // @return the single integer that this NestedInteger holds, if it holds a single integer  *     // Return null if this NestedInteger holds a nested list  *     public Integer getInteger();  *  *     // Set this NestedInteger to hold a single integer.  *     public void setInteger(int value);  *  *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.  *     public void add(NestedInteger ni);  *  *     // @return the nested list that this NestedInteger holds, if it holds a nested list  *     // Return empty list if this NestedInteger holds a single integer  *     public List<NestedInteger> getList();  * }  */ class Solution {     public NestedInteger deserialize(String s) {         Stack<NestedInteger> stack = new Stack<>();         NestedInteger curr = null;         int num = 0;         int sign = 1;         for (char ch : s.toCharArray()) {             if (Character.isDigit(ch)) {                 num = num * 10 + (int) (ch - '0');             } else if (ch == '-') {                 sign = -1;             } else if (ch == '[') {                 stack.push(curr);                 curr = new NestedInteger();             } else if (ch == ',') {                 if (num != 0 || (num == 0 && curr != null && curr.getList().isEmpty())) {                     curr.add(new NestedInteger(sign * num));                     num = 0;                     sign = 1;                 }             } else if (ch == ']') {                 if (num != 0) {                     curr.add(new NestedInteger(sign * num));                     num = 0;                     sign = 1;                 }                 NestedInteger pop = stack.pop();                 pop.add(curr);                 curr = pop;             }         }         if (num != 0) {             curr.add(new NestedInteger(sign * num));         }         return curr;     } }",1,"385-mini-parser/Solution.java:37:	UnnecessaryCast:	Unnecessary cast (int)
",0,0,0
class Solution {     public List<Integer> lexicalOrder(int n) {         List<Integer> result = new ArrayList<Integer>();         int curr = 1;         for(int i=1; i<=n; i++) {             result.add(curr);             if(curr*10 <= n) {                 curr *= 10;             }             else if(curr%10 != 9 && curr+1 <= n) {                 curr++;             }             else {                 while((curr/10)%10 == 9) {                     curr /= 10;                 }                 curr = curr/10 + 1;             }         }         return result;     } },1,"386-lexicographical-numbers/Solution.java:9:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
386-lexicographical-numbers/Solution.java:12:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
386-lexicographical-numbers/Solution.java:9:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
386-lexicographical-numbers/Solution.java:12:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
386-lexicographical-numbers/Solution.java:14:	UselessParentheses:	Useless parentheses.
",0,0,0
"class Solution {     public int lengthLongestPath(String input) {         Stack<Integer> stack = new Stack<>();         stack.push(0); // dummy length         int maxLen = 0;         for (String s : input.split(""\n"")) {             int level = s.lastIndexOf(""\t"") + 1; // number of preceeding ""\t""             while (level + 1 < stack.size()) stack.pop(); // backtrack             int len = stack.peek() + s.length() - level + 1; // plus one is to count the ""/"" at the end             stack.push(len);             if (s.contains(""."")) maxLen = Math.max(maxLen, len - 1);         }         return maxLen;     } }",1,"388-longest-absolute-file-path/Solution.java:7:	UseIndexOfChar:	String.indexOf(char) is faster than String.indexOf(String).
",0,0,0
 class Solution {     public int lastRemaining(int n) {         boolean leftToRight = true;         int remaining = n;         int step = 1;         int head = 1;         while (remaining > 1) {             if (leftToRight || remaining % 2 == 1) {                 head = head + step;             }             remaining = remaining / 2;             step = step * 2;             leftToRight = !leftToRight;         }         return head;     } } ,0,,0,0,0
class Solution {     public boolean validUtf8(int[] data) {         int i = 0;         while (i < data.length) {             // Counting the number of set bits             int bytes = 0;             if ((data[i] & 128) == 0) {                 bytes = 1;             } else if ((data[i] & 224) == 192) {                 bytes = 2;             } else if ((data[i] & 240) == 224) {                 bytes = 3;             } else if ((data[i] & 248) == 240) {                 bytes = 4;             } else {                 return false;             }             // Check continuation bytes             for (int j = 1; j < bytes; j++) {                 if (i + j >= data.length || (data[i+j] & 192) != 128) {                     return false;                 }             }             // Move to next character             i += bytes;         }         return true;     } },1,"393-utf-8-validation/Solution.java:6:	UnusedAssignment:	The initializer for variable 'bytes' is never used (overwritten on lines 8, 10, 12 and 14)
",0,0,0
"class Solution {     public String decodeString(String s) {         Stack<Integer> numStack = new Stack<>();         Stack<String> strStack = new Stack<>();                  String currStr = """";         int currNum = 0;                  for (char c : s.toCharArray()) {             if (Character.isDigit(c)) {                 currNum = currNum * 10 + (c - '0');             } else if (c == '[') {                 numStack.push(currNum);                 strStack.push(currStr);                 currNum = 0;                 currStr = """";             } else if (c == ']') {                 StringBuilder tmp = new StringBuilder(strStack.pop());                 int k = numStack.pop();                 for (int i = 0; i < k; i++) {                     tmp.append(currStr);                 }                 currStr = tmp.toString();             } else {                 currStr += c;             }         }                  return currStr;     } }",1,"394-decode-string/Solution.java:11:	UselessParentheses:	Useless parentheses.
394-decode-string/Solution.java:25:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
",0,0,0
"class Solution {     public int longestSubstring(String s, int k) {         int uniqueLetters = 0;         int[] count = new int[26];         int result = 0;                  for (int i = 0; i < s.length(); i++) {             if (count[s.charAt(i) - 'a'] == 0) {                 uniqueLetters++;             }             count[s.charAt(i) - 'a']++;         }                  for (int currUnique = 1; currUnique <= uniqueLetters; currUnique++) {             int[] tempCount = new int[26];             int windowStart = 0;             int windowEnd = 0;             int foundUnique = 0;             int validK = 0;                          while (windowEnd < s.length()) {                 if (foundUnique <= currUnique) {                     int index = s.charAt(windowEnd) - 'a';                     if (tempCount[index] == 0) {                         foundUnique++;                     }                     tempCount[index]++;                     if (tempCount[index] == k) {                         validK++;                     }                     windowEnd++;                 } else {                     int index = s.charAt(windowStart) - 'a';                     if (tempCount[index] == k) {                         validK--;                     }                     tempCount[index]--;                     if (tempCount[index] == 0) {                         foundUnique--;                     }                     windowStart++;                 }                                  if (foundUnique == currUnique && validK == foundUnique) {                     result = Math.max(result, windowEnd - windowStart);                 }             }         }                  return result;     } }",0,,0,0,0
"class Solution {     public int maxRotateFunction(int[] nums) {         int n = nums.length;         int sum = 0;         int f0 = 0;         for (int i = 0; i < n; i++) {             sum += nums[i];             f0 += i * nums[i];         }         int max = f0;         int fi = f0;         for (int k = 1; k < n; k++) {             fi += sum - n * nums[n - k];             max = Math.max(max, fi);         }         return max;     } }",0,,0,0,0
"class Solution {     public int integerReplacement(int n) {         if(n == 1) // if n = 1, we need 0 steps to reduce it to 1.             return 0;                  if(n == 3 || (n % 2 == 0 && (n/2)%2 == 1))             // If n=3 or n is even and the next odd number (n/2) ends with 01 in binary,             // then our best option is n-1             return 1 + integerReplacement(n-1);                  // Otherwise, our best option is performing a bit shift         return 1 + integerReplacement(n%2 == 0 ? n/2 : n+1);      } }  // Note: This implementation uses recursion, which can cause a stack overflow for very large values of n.",1,"397-integer-replacement/Solution.java:6:	UselessParentheses:	Useless parentheses.
",0,0,0
import java.util.Random;  class Solution {     int[] nums;     Random rand;      public Solution(int[] nums) {         this.nums = nums;         this.rand = new Random();     }      public int pick(int target) {         int count = 0;         int res = -1;         for (int i = 0; i < nums.length; i++) {             if (nums[i] == target) {                 count++;                 if (rand.nextInt(count) == 0) {                     res = i;                 }             }         }         return res;     } }  /**  * Your Solution object will be instantiated and called as such:  * Solution obj = new Solution(nums);  * int param_1 = obj.pick(target);  */,1,"398-random-pick-index/Solution.java:4:11: Variable 'nums' must be private and have accessor methods. [VisibilityModifier]
398-random-pick-index/Solution.java:5:12: Variable 'rand' must be private and have accessor methods. [VisibilityModifier]
398-random-pick-index/Solution.java:7:5: Redundant 'public' modifier. [RedundantModifier]
398-random-pick-index/Solution.java:7:27: 'nums' hides a field. [HiddenField]
398-random-pick-index/Solution.java:4:11: Variable 'nums' must be private and have accessor methods. [VisibilityModifier]
398-random-pick-index/Solution.java:5:12: Variable 'rand' must be private and have accessor methods. [VisibilityModifier]
398-random-pick-index/Solution.java:7:5: Redundant 'public' modifier. [RedundantModifier]
398-random-pick-index/Solution.java:7:27: 'nums' hides a field. [HiddenField]
398-random-pick-index/Solution.java:8:	ArrayIsStoredDirectly:	The user-supplied array 'nums' is stored directly.
",0,0,0
"import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set;  class Solution {     public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {         Map<String, Map<String, Double>> graph = new HashMap<>();          // build graph         for (int i = 0; i < equations.size(); i++) {             List<String> equation = equations.get(i);             String u = equation.get(0);             String v = equation.get(1);             double weight = values[i];              if (!graph.containsKey(u)) {                 graph.put(u, new HashMap<>());             }             graph.get(u).put(v, weight);              if (!graph.containsKey(v)) {                 graph.put(v, new HashMap<>());             }             graph.get(v).put(u, 1 / weight);         }          // perform query         double[] result = new double[queries.size()];         for (int i = 0; i < queries.size(); i++) {             List<String> query = queries.get(i);             String u = query.get(0);             String v = query.get(1);              if (!graph.containsKey(u) || !graph.containsKey(v)) {                 result[i] = -1.0;             } else if (u.equals(v)) {                 result[i] = 1.0;             } else {                 result[i] = dfs(graph, u, v, new HashSet<>(), 1.0);             }         }         return result;     }      private double dfs(Map<String, Map<String, Double>> graph, String u, String v, Set<String> visited, double currProduct) {         visited.add(u);         Map<String, Double> neighbors = graph.get(u);          if (neighbors.containsKey(v)) {             return currProduct * neighbors.get(v);         }          for (Map.Entry<String, Double> neighborEntry : neighbors.entrySet()) {             String neighbor = neighborEntry.getKey();             double weight = neighborEntry.getValue();              if (!visited.contains(neighbor)) {                 double product = dfs(graph, neighbor, v, visited, currProduct * weight);                 if (product != -1.0) {                     return product;                 }             }         }         return -1.0;     } }",1,"399-evaluate-division/Solution.java:9:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
399-evaluate-division/Solution.java:36:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",0,0,0
class Solution {     public int findNthDigit(int n) {         int digitSize = 1;         long digitCount = 9;         int start = 1;                  while(n > digitSize * digitCount){             n -= digitSize * digitCount;             digitSize++;             digitCount *= 10;             start *= 10;         }                  start += (n-1)/digitSize;         String s = Integer.toString(start);                  return Character.getNumericValue(s.charAt((n-1)%digitSize));     } },1,"400-nth-digit/Solution.java:8:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
",0,1,0
"class Solution {     public String removeKdigits(String num, int k) {         if (num.length() == k) {  // edge case where all digits need to be removed             return ""0"";         }                  Stack<Character> stack = new Stack<>();         int removed = 0;                  for (char c : num.toCharArray()) {             while (!stack.isEmpty() && removed < k && c < stack.peek()) {                 // remove numbers greater than the current number                 stack.pop();                 removed++;             }                          stack.push(c);         }                  // edge case where k is greater than the number of digits removed         while (removed < k) {             stack.pop();             removed++;         }                  // build the resulting string from the stack         StringBuilder sb = new StringBuilder();         while (!stack.isEmpty()) {             char c = stack.pop();             sb.append(c);         }         sb.reverse();         while (sb.length() > 1 && sb.charAt(0) == '0') {             sb.deleteCharAt(0);  // remove leading zeros         }                  return sb.toString();     } }",0,,0,0,0
"class Solution {     public int[][] reconstructQueue(int[][] people) {         Arrays.sort(people, new Comparator<int[]>() {             @Override             public int compare(int[] a, int[] b) {                 if (a[0] == b[0]) {                     return a[1] - b[1];                 } else {                     return b[0] - a[0];                 }             }         });         ArrayList<int[]> list = new ArrayList<>();         for (int[] p : people) {             list.add(p[1], p);         }         int[][] result = new int[people.length][2];         for (int i = 0; i < list.size(); i++) {             result[i] = list.get(i);         }         return result;     } }",0,,0,0,0
class Solution {     public int numberOfArithmeticSlices(int[] nums) {                  int n = nums.length;         int dp = 0; // dynamic programming state         int sum = 0; // the answer                  for (int i = 2; i < n; i++) {             if (nums[i] - nums[i-1] == nums[i-1] - nums[i-2]) { // check if it's an arithmetic subarray                 dp ++;                 sum += dp;             }             else {                 dp = 0; // reset dp             }         }                  return sum;     } },1,"413-arithmetic-slices/Solution.java:12:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
413-arithmetic-slices/Solution.java:12:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
class Solution {     public boolean canPartition(int[] nums) {         int n = nums.length;         int sum = 0;         for (int num : nums)             sum += num;         if (sum % 2 != 0)             return false;         boolean[] dp = new boolean[sum / 2 + 1];         dp[0] = true;         for (int i = 0; i < n; i++) {             for (int j = sum / 2; j >= nums[i]; j--) {                 dp[j] |= dp[j - nums[i]];             }         }         return dp[sum / 2];     } },1,"416-partition-equal-subset-sum/Solution.java:3:	PrematureDeclaration:	Declaration of 'n' can be moved closer to its usages
",0,0,0
"import java.util.ArrayList; import java.util.List;  class Solution {     public List<List<Integer>> pacificAtlantic(int[][] heights) {                  List<List<Integer>> result = new ArrayList<>();                  if(heights == null || heights.length == 0 || heights[0].length == 0) {             return result;         }                  int m = heights.length, n = heights[0].length;                  boolean[][] pVisited = new boolean[m][n];         boolean[][] aVisited = new boolean[m][n];                  // Traverse through the first row and last row and mark as 'true'          for(int i=0; i<n; i++) {             dfs(heights, 0, i, Integer.MIN_VALUE, pVisited);             dfs(heights, m-1, i, Integer.MIN_VALUE, aVisited);         }                  // Traverse through the first column and last column and mark as 'true'          for(int i=0; i<m; i++) {             dfs(heights, i, 0, Integer.MIN_VALUE, pVisited);             dfs(heights, i, n-1, Integer.MIN_VALUE, aVisited);         }                  // Add cell coordinates where pVisited and aVisited is true to the result list         for(int i=0; i<m; i++) {             for(int j=0; j<n; j++) {                 if(pVisited[i][j] && aVisited[i][j]) {                     List<Integer> list = new ArrayList<>();                     list.add(i);                     list.add(j);                     result.add(list);                 }             }         }                  return result;     }          private void dfs(int[][] h, int i, int j, int prev, boolean[][] visited) {                  // If cell coordinates are out of bounds, return.         if(i<0 || j<0 || i>=h.length || j>=h[0].length || visited[i][j] || prev > h[i][j]) {             return;         }                  // Mark current cell coordinates in visited array as 'true'         visited[i][j] = true;                  // Traverse to adjacent cells -> top, down, left and right         dfs(h, i-1, j, h[i][j], visited);         dfs(h, i+1, j, h[i][j], visited);         dfs(h, i, j-1, h[i][j], visited);         dfs(h, i, j+1, h[i][j], visited);     } }",1,"417-pacific-atlantic-water-flow/Solution.java:13:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
417-pacific-atlantic-water-flow/Solution.java:13:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
class Solution {     public int countBattleships(char[][] board) {         int count = 0;         for (int i = 0; i < board.length; i++) {             for (int j = 0; j < board[0].length; j++) {                 if (board[i][j] == 'X') {                     if (i == 0 && j == 0) {                         count++;                     } else if (i == 0 && board[i][j-1] == '.') {                         count++;                     } else if (j == 0 && board[i-1][j] == '.') {                         count++;                     } else if (board[i-1][j] == '.' && board[i][j-1] == '.') {                         count++;                     }                 }             }         }         return count;     } },0,,0,0,0
"class Solution {     public int findMaximumXOR(int[] nums) {         int maxResult = 0, mask = 0;         for (int i = 31; i >= 0; i--) {             //create mask             mask = mask | (1 << i);             //extract prefixes of numbers using the mask             Set<Integer> set = new HashSet<>();             for (int num : nums) {                 set.add(num & mask);             }             int temp = maxResult | (1 << i);             for (int prefix : set) {                 if (set.contains(prefix ^ temp)) {                     maxResult = temp;                     break;                 }             }         }         return maxResult;     } }",1,"421-maximum-xor-of-two-numbers-in-an-array/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
421-maximum-xor-of-two-numbers-in-an-array/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
class Solution {     public String originalDigits(String s) {         int[] count = new int[10];         char[] chars = s.toCharArray();         for (char c : chars) {             if (c == 'z') count[0]++;             if (c == 'w') count[2]++;             if (c == 'u') count[4]++;             if (c == 'x') count[6]++;             if (c == 'g') count[8]++;             if (c == 'o') count[1]++;             if (c == 't') count[3]++;             if (c == 'f') count[5]++;             if (c == 's') count[7]++;             if (c == 'r') count[9]++;         }         count[1] -= count[0] + count[2] + count[4];         count[3] -= count[2] + count[8];         count[5] -= count[4];         count[7] -= count[6];         count[9] -= count[8];          StringBuilder res = new StringBuilder();         for (int i = 0; i < 10; i++) {             for (int j = 0; j < count[i]; j++) {                 res.append(i);             }         }         return res.toString();     } },1,"423-reconstruct-original-digits-from-english/Solution.java:2:	NPathComplexity:	The method 'originalDigits(String)' has an NPath complexity of 3075, current threshold is 200
",0,0,0
"class Solution {     public int characterReplacement(String s, int k) {         int maxCount = 0; //Stores the maximum count of a single character in a substring         int start = 0; //Start index of our window         int[] charCount = new int[26]; //Array to store the count of each character                  for(int end = 0; end < s.length(); end++) {             //Increment the count of the current character in our window             charCount[s.charAt(end) - 'A']++;                          //Reassign maxCount if we have found a new maximum count in our window             maxCount = Math.max(maxCount, charCount[s.charAt(end) - 'A']);                          /* If the number of characters we need to replace (k) is less than the              difference between the total characters in the window and the maximum              count of a single character, we need to shrink the window */             if(end - start + 1 - maxCount > k) {                 //Decrement the count of the character at the start of our window                 charCount[s.charAt(start) - 'A']--;                 //Move the start of our window forward by one character                 start++;             }         }                  /* At this point, our window will always contain the longest substring possible          with k operations, because we've exhausted all possible substrings with k or less          operations. Therefore, our answer is the length of this window. */         return s.length() - start;     } }",0,,0,0,0
"/* // Definition for a QuadTree node. class Node {     public boolean val;     public boolean isLeaf;     public Node topLeft;     public Node topRight;     public Node bottomLeft;     public Node bottomRight;           public Node() {         this.val = false;         this.isLeaf = false;         this.topLeft = null;         this.topRight = null;         this.bottomLeft = null;         this.bottomRight = null;     }          public Node(boolean val, boolean isLeaf) {         this.val = val;         this.isLeaf = isLeaf;         this.topLeft = null;         this.topRight = null;         this.bottomLeft = null;         this.bottomRight = null;     }          public Node(boolean val, boolean isLeaf, Node topLeft, Node topRight, Node bottomLeft, Node bottomRight) {         this.val = val;         this.isLeaf = isLeaf;         this.topLeft = topLeft;         this.topRight = topRight;         this.bottomLeft = bottomLeft;         this.bottomRight = bottomRight;     } }; */  class Solution {     public Node construct(int[][] grid) {         return buildQuadTree(grid, 0, 0, grid.length);     }          private Node buildQuadTree(int[][] grid, int x, int y, int size) {         if (size == 1) {             return new Node(grid[x][y] == 1, true);         }         Node node = new Node();         boolean allOnes = true, allZeroes = true;         int newSize = size / 2;         node.topLeft = buildQuadTree(grid, x, y, newSize);         node.topRight = buildQuadTree(grid, x, y + newSize, newSize);         node.bottomLeft = buildQuadTree(grid, x + newSize, y, newSize);         node.bottomRight = buildQuadTree(grid, x + newSize, y + newSize, newSize);         if (node.topLeft.isLeaf && node.topRight.isLeaf && node.bottomLeft.isLeaf && node.bottomRight.isLeaf) {             if (node.topLeft.val == node.topRight.val && node.topRight.val == node.bottomLeft.val && node.bottomLeft.val == node.bottomRight.val) {                 node.isLeaf = true;                 node.val = node.topLeft.val;             }         }         return node;     } }",1,"427-construct-quad-tree/Node.java:51:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
427-construct-quad-tree/Node.java:51:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
427-construct-quad-tree/Node.java:51:	UnusedLocalVariable:	Avoid unused local variables such as 'allOnes'.
427-construct-quad-tree/Node.java:51:	UnusedLocalVariable:	Avoid unused local variables such as 'allZeroes'.
427-construct-quad-tree/Node.java:58:	CollapsibleIfStatements:	This if statement could be combined with its parent
",1,0,0
"// Definition for a Node. class Node {     public int val;     public List<Node> children;      public Node() {}      public Node(int _val) {         val = _val;     }      public Node(int _val, List<Node> _children) {         val = _val;         children = _children;     } }  class Solution {     public List<List<Integer>> levelOrder(Node root) {         List<List<Integer>> result = new ArrayList<>();         if (root == null) {             return result;         }         Queue<Node> queue = new LinkedList<>();         queue.offer(root);         while (!queue.isEmpty()) {             int levelSize = queue.size();             List<Integer> levelVals = new ArrayList<>();             for (int i = 0; i < levelSize; i++) {                 Node curr = queue.poll();                 levelVals.add(curr.val);                 for (Node child : curr.children) {                     queue.offer(child);                 }             }             result.add(levelVals);         }         return result;     } }",1,"429-n-ary-tree-level-order-traversal/Node.java:3:16: Variable 'val' must be private and have accessor methods. [VisibilityModifier]
429-n-ary-tree-level-order-traversal/Node.java:4:23: Variable 'children' must be private and have accessor methods. [VisibilityModifier]
429-n-ary-tree-level-order-traversal/Node.java:6:5: Redundant 'public' modifier. [RedundantModifier]
429-n-ary-tree-level-order-traversal/Node.java:8:5: Redundant 'public' modifier. [RedundantModifier]
429-n-ary-tree-level-order-traversal/Node.java:12:5: Redundant 'public' modifier. [RedundantModifier]
429-n-ary-tree-level-order-traversal/Node.java:3:16: Variable 'val' must be private and have accessor methods. [VisibilityModifier]
429-n-ary-tree-level-order-traversal/Node.java:4:23: Variable 'children' must be private and have accessor methods. [VisibilityModifier]
429-n-ary-tree-level-order-traversal/Node.java:6:5: Redundant 'public' modifier. [RedundantModifier]
429-n-ary-tree-level-order-traversal/Node.java:8:5: Redundant 'public' modifier. [RedundantModifier]
429-n-ary-tree-level-order-traversal/Node.java:12:5: Redundant 'public' modifier. [RedundantModifier]
429-n-ary-tree-level-order-traversal/Node.java:6:	UncommentedEmptyConstructor:	Document empty constructor
",0,0,0
// Definition for a Node. class Node {     public int val;     public Node prev;     public Node next;     public Node child; };  class Solution {     public Node flatten(Node head) {         if (head == null) {             return null;         }                  Node curr = head;         while (curr != null) {             if (curr.child == null) {                 curr = curr.next;                 continue;             }                          Node child = curr.child;             while (child.next != null) {                 child = child.next;             }                          child.next = curr.next;             if (curr.next != null) {                 curr.next.prev = child;             }                          curr.next = curr.child;             curr.child.prev = curr;             curr.child = null;         }                  return head;     } },1,"430-flatten-a-multilevel-doubly-linked-list/Node.java:3:16: Variable 'val' must be private and have accessor methods. [VisibilityModifier]
430-flatten-a-multilevel-doubly-linked-list/Node.java:4:17: Variable 'prev' must be private and have accessor methods. [VisibilityModifier]
430-flatten-a-multilevel-doubly-linked-list/Node.java:5:17: Variable 'next' must be private and have accessor methods. [VisibilityModifier]
430-flatten-a-multilevel-doubly-linked-list/Node.java:6:17: Variable 'child' must be private and have accessor methods. [VisibilityModifier]
430-flatten-a-multilevel-doubly-linked-list/Node.java:3:16: Variable 'val' must be private and have accessor methods. [VisibilityModifier]
430-flatten-a-multilevel-doubly-linked-list/Node.java:4:17: Variable 'prev' must be private and have accessor methods. [VisibilityModifier]
430-flatten-a-multilevel-doubly-linked-list/Node.java:5:17: Variable 'next' must be private and have accessor methods. [VisibilityModifier]
430-flatten-a-multilevel-doubly-linked-list/Node.java:6:17: Variable 'child' must be private and have accessor methods. [VisibilityModifier]
430-flatten-a-multilevel-doubly-linked-list/Node.java:2:	DataClass:	The class 'Node' is suspected to be a Data Class (WOC=0.000%, NOPA=4, NOAM=0, WMC=0)
430-flatten-a-multilevel-doubly-linked-list/Node.java:7:	UnnecessarySemicolon:	Unnecessary semicolon
430-flatten-a-multilevel-doubly-linked-list/Node.java:34:	NullAssignment:	Assigning an Object to null is a code smell.  Consider refactoring.
",0,0,0
"import java.util.HashSet; import java.util.LinkedList; import java.util.Queue; import java.util.Set;  class Solution {      public int minMutation(String startGene, String endGene, String[] bank) {                  Set<String> bankSet = new HashSet<>();         for (String gene : bank) {             bankSet.add(gene);         }          char[] mutationChoices = new char[] {'A', 'C', 'G', 'T'};                  Queue<String> queue = new LinkedList<>();         queue.offer(startGene);                  int level = 0;                  Set<String> visited = new HashSet<>();         visited.add(startGene);                  while (!queue.isEmpty()) {             int size = queue.size();             while (size-- > 0) {                 String currGene = queue.poll();                 if (currGene.equals(endGene)) {                     return level;                 }                 char[] currGeneArray = currGene.toCharArray();                 for (int i = 0; i < currGene.length(); i++) {                     char originalChar = currGeneArray[i];                     for (char choice : mutationChoices) {                         if (originalChar == choice) {                             continue;                         }                         currGeneArray[i] = choice;                         String newGene = String.valueOf(currGeneArray);                         if (bankSet.contains(newGene) && !visited.contains(newGene)) {                             visited.add(newGene);                             queue.offer(newGene);                         }                     }                     currGeneArray[i] = originalChar;                 }             }             level++;         }                  return -1;     } }",1,"433-minimum-genetic-mutation/Solution.java:12:	UseArraysAsList:	Use asList instead of tight loops
",0,0,0
"class Solution {     public int eraseOverlapIntervals(int[][] intervals) {         if(intervals.length == 0) return 0;                  Arrays.sort(intervals, new Comparator<int[]>(){             public int compare(int[] a, int[] b){                 return a[1] - b[1];             }         });                  int count = 1;         int end = intervals[0][1];                  for(int i=1; i<intervals.length; i++){             if(intervals[i][0] >= end){                 count++;                 end = intervals[i][1];             }         }                  return intervals.length - count;     } }",0,,0,0,0
"class Solution {     public int[] findRightInterval(int[][] intervals) {         int n = intervals.length;         int[] res = new int[n];         Map<Integer, Integer> map = new HashMap<>();          // map stores starti initially         for(int i=0; i<n; i++){             map.put(intervals[i][0], i);         }         Arrays.sort(intervals, (a, b) -> a[0] - b[0]);  // Sort the intervals on the basis of start time               for(int i=0; i<n; i++){                   int l=i+1, r=n-1, ans=-1;             // Initialize lower and upper bounds for binary search              while(l<=r){                 int mid=l+(r-l)/2;                 if(intervals[mid][0]>=intervals[i][1]){     // Check if start of current interval <= end of next interval                     ans=map.get(intervals[mid][0]);        // Get the index of the interval                      r=mid-1;                                // Move search to left side to minimize start                 }else{                     l=mid+1;                 }             }             res[map.get(intervals[i][0])]=ans;              // Store the right interval index for the current interval          }         return res;     } }",1,"436-find-right-interval/Solution.java:13:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
436-find-right-interval/Solution.java:13:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public int pathSum(TreeNode root, int targetSum) {         if(root == null) return 0;         return pathSumHelper(root, targetSum) + pathSum(root.left, targetSum) + pathSum(root.right, targetSum);     }          public int pathSumHelper(TreeNode node, int targetSum){         if(node == null) return 0;         int count = 0;         if(node.val == targetSum) count++;         count += pathSumHelper(node.left, targetSum - node.val) + pathSumHelper(node.right, targetSum - node.val);         return count;     } }",0,,0,0,0
"import java.util.ArrayList; import java.util.Arrays; import java.util.List;  class Solution {     public List<Integer> findAnagrams(String s, String p) {                  List<Integer> resultList = new ArrayList<>();                  int[] charCount = new int[26];          for(char c : p.toCharArray()) {             charCount[c - 'a']++;         }          int start = 0;         int end = 0;         int count = p.length();          while (end < s.length()) {             if (charCount[s.charAt(end++) - 'a']-- >= 1) {                 count--;             }              if (count == 0) {                 resultList.add(start);             }              if (end - start == p.length() && charCount[s.charAt(start++) - 'a']++ >= 0) {                 count++;             }         }          return resultList;     } }",1,"438-find-all-anagrams-in-a-string/Solution.java:2:8: Unused import - java.util.Arrays. [UnusedImports]
438-find-all-anagrams-in-a-string/Solution.java:2:8: Unused import - java.util.Arrays. [UnusedImports]
438-find-all-anagrams-in-a-string/Solution.java:2:	UnnecessaryImport:	Unused import 'java.util.Arrays'
438-find-all-anagrams-in-a-string/Solution.java:21:	AssignmentInOperand:	Avoid assignments in operands
438-find-all-anagrams-in-a-string/Solution.java:21:	AssignmentInOperand:	Avoid assignments in operands
438-find-all-anagrams-in-a-string/Solution.java:29:	AssignmentInOperand:	Avoid assignments in operands
438-find-all-anagrams-in-a-string/Solution.java:29:	AssignmentInOperand:	Avoid assignments in operands
",0,0,0
"class Solution {     public List<Integer> findDuplicates(int[] nums) {         List<Integer> result = new ArrayList<>();                  for (int i = 0; i < nums.length; i++) {             int index = Math.abs(nums[i]) - 1;                          if (nums[index] < 0) {                 result.add(Math.abs(index + 1));             } else {                 nums[index] *= -1;             }         }                  return result;     } }  /* Explanation:    This problem can be easily solved using the concept of negation and indexing. Since the numbers in the given array will be in the range of [1, n], the absolute value of each element can be used as an index into the array (after subtracting 1, since array indexes start from 0). To mark a number as seen, we can negate the value at that index. If we encounter a number that is already negated, it indicates that we have already seen it before and it is a duplicate number. We can add it to the result list. Finally, we return the result list. The algorithm runs in O(n) time and uses only constant extra space. */",1,"442-find-all-duplicates-in-an-array/Solution.java:5:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int compress(char[] chars) {         int i = 0; // pointer to track location in the original array         int j = 0; // pointer to track location in the compressed array         int count = 0; // count variable to keep track of consecutive repeating characters                  // loop through the original array         while(i < chars.length){             chars[j] = chars[i]; // copy the current character to the compressed array                          // get the count of consecutive repeating characters             while(i < chars.length && chars[i] == chars[j]){                 count++;                 i++;             }                          // if there is more than one repeating character, append the count to the compressed array             if(count > 1){                 String countStr = String.valueOf(count); // convert count to string                 for(int k = 0; k < countStr.length(); k++){                     j++;                     chars[j] = countStr.charAt(k); // add each digit of count to the compressed array                 }             }                          // reset count and move to the next character in the original array             count = 0;             j++;         }                  return j; // return the length of the compressed array     } }",1,"443-string-compression/Solution.java:8:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
",0,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public ListNode addTwoNumbers(ListNode l1, ListNode l2) {         Stack<Integer> s1 = new Stack<>();         Stack<Integer> s2 = new Stack<>();         ListNode curr1 = l1;         ListNode curr2 = l2;         while (curr1 != null) {             s1.push(curr1.val);             curr1 = curr1.next;         }         while (curr2 != null) {             s2.push(curr2.val);             curr2 = curr2.next;         }         int carry = 0;         ListNode head = null;         while (!s1.isEmpty() || !s2.isEmpty() || carry > 0) {             int sum = carry;             if (!s1.isEmpty()) {                 sum += s1.pop();             }             if (!s2.isEmpty()) {                 sum += s2.pop();             }             ListNode newNode = new ListNode(sum % 10);             newNode.next = head;             head = newNode;             carry = sum / 10;         }         return head;     } }",0,,0,0,0
"class Solution {     public int numberOfBoomerangs(int[][] points) {         int boomerangs = 0;         // Loop through each point         for (int i = 0; i < points.length; i++) {             // Create a hash map to count the number of points with the same distance from point i             Map<Integer, Integer> distances = new HashMap<>();             for (int j = 0; j < points.length; j++) {                 if (i != j) {                     int distance = (int)(Math.pow(points[i][0]-points[j][0], 2) + Math.pow(points[i][1]-points[j][1], 2));                     distances.put(distance, distances.getOrDefault(distance, 0) + 1);                 }             }             // Count the number of boomerangs that can be formed with point i             for (int count : distances.values()) {                 if (count > 1) {                     boomerangs += count * (count - 1);                 }             }         }         return boomerangs;     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode(int x) { val = x; }  * }  */ public class Codec {      // Encodes a tree to a single string.     public String serialize(TreeNode root) {         if (root == null) {             return """";         }         StringBuilder sb = new StringBuilder();         serializeHelper(root, sb);         return sb.toString();     }          private void serializeHelper(TreeNode node, StringBuilder sb) {         if (node == null) {             return;         }         sb.append(node.val).append("","");         serializeHelper(node.left, sb);         serializeHelper(node.right, sb);     }      // Decodes your encoded data to tree.     public TreeNode deserialize(String data) {         if (data.isBlank()) {             return null;         }         String[] values = data.split("","");         int[] index = {0};         return deserializeHelper(values, index, Integer.MIN_VALUE, Integer.MAX_VALUE);     }          private TreeNode deserializeHelper(String[] values, int[] index, int min, int max) {         if (index[0] >= values.length) {             return null;         }         int value = Integer.parseInt(values[index[0]]);         if (value < min || value > max) {             return null;         }         index[0]++;         TreeNode node = new TreeNode(value);         node.left = deserializeHelper(values, index, min, value);         node.right = deserializeHelper(values, index, value, max);         return node;     } }",1,"449-serialize-and-deserialize-bst/TreeNode.java:26:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public TreeNode deleteNode(TreeNode root, int key) {         if (root == null) return null; // Case when the tree is empty or the key is not found                  if (key < root.val) {             root.left = deleteNode(root.left, key); // Traverse the left subtree recursively         } else if (key > root.val) {             root.right = deleteNode(root.right, key); // Traverse the right subtree recursively         } else { // When the key is found             if (root.left == null) { // Case when the node to delete has only one child or no child                 return root.right;             } else if (root.right == null) { // Case when the node to delete has only one child or no child                 return root.left;             } else { // Case when the node to delete has two children                 TreeNode temp = root.right; // Find the inorder successor (minimum value in the right subtree)                 while (temp.left != null) {                     temp = temp.left;                 }                 root.val = temp.val; // Replace the value of the node to delete with the inorder successor                 root.right = deleteNode(root.right, temp.val); // Delete the inorder successor node recursively             }         }                  return root; // Return the updated root node reference (possibly updated)     } }",0,,0,0,0
"import java.util.*;  class Solution {     public String frequencySort(String s) {         // Create a hashmap to store frequency of characters         Map<Character, Integer> freqMap = new HashMap<>();         for (char c : s.toCharArray()) {             freqMap.put(c, freqMap.getOrDefault(c, 0) + 1);         }                  // Create a list of map entries and sort them by frequency in descending order         List<Map.Entry<Character, Integer>> entryList = new ArrayList<>(freqMap.entrySet());         Collections.sort(entryList, new Comparator<Map.Entry<Character, Integer>>() {             public int compare(Map.Entry<Character, Integer> e1, Map.Entry<Character, Integer> e2) {                 return e2.getValue() - e1.getValue();             }         });                  // Build the sorted string by appending characters based on frequency         StringBuilder sb = new StringBuilder();         for (Map.Entry<Character, Integer> entry : entryList) {             int freq = entry.getValue();             char c = entry.getKey();             for (int i = 0; i < freq; i++) {                 sb.append(c);             }         }                  return sb.toString();     } }",1,"451-sort-characters-by-frequency/Solution.java:6:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
451-sort-characters-by-frequency/Solution.java:13:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new Comparator<>()`
451-sort-characters-by-frequency/Solution.java:14:	MissingOverride:	The method 'compare(Entry<Character, Integer>, Entry<Character, Integer>)' is missing an @Override annotation.
",0,0,0
"class Solution {     public int findMinArrowShots(int[][] points) {         if(points.length==0)             return 0;         Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));         int arrows=1;         int end=points[0][1];                  for(int i=1;i<points.length;i++){             if(points[i][0]<=end)                 continue;             arrows++;             end=points[i][1];         }          return arrows;     } }  /* Logic: - Remove cases where there are no baloons at all. (edge case) - Sort the array of baloons according to the end point of each baloon - First baloon will always need an arrow. - then loop through baloon array and mark a new arrow when the current baloon cannot be popped by      the current arrow.  - Then exit loop and return arrow count. */",0,,0,0,0
class Solution {     public int minMoves(int[] nums) {         int minNum = Integer.MAX_VALUE; // minimum number in the array         int moves = 0; // number of moves required to make all elements equal                  // find the minimum number in the array         for(int i=0; i<nums.length; i++){             if(nums[i]<minNum){                 minNum = nums[i];             }         }                  // calculate the number of moves required         for(int i=0; i<nums.length; i++){             moves += nums[i]-minNum; // increment each element until it becomes equal to the minimum number         }                  return moves;     } },1,"453-minimum-moves-to-equal-array-elements/Solution.java:7:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
453-minimum-moves-to-equal-array-elements/Solution.java:14:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {         int n = nums1.length;         // Assigning frequency of elements of nums4 to a hashmap         HashMap<Integer, Integer> frequencyMap = new HashMap<>();         for (int i = 0; i < n; i++) {             frequencyMap.put(nums4[i], frequencyMap.getOrDefault(nums4[i], 0) + 1);         }         int tupleCount = 0;         for (int i = 0; i < n; i++) {             for (int j = 0; j < n; j++) {                 for (int k = 0; k < n; k++) {                     int complement = -(nums1[i] + nums2[j] + nums3[k]);                     if (frequencyMap.containsKey(complement)) {                         tupleCount += frequencyMap.get(complement);                     }                 }             }         }         return tupleCount;     } }",0,,0,0,0
"class Solution {     public boolean find132pattern(int[] nums) {                  if(nums.length < 3) return false;   // if array is of length less than 3, pattern is not possible                  Stack<Integer> stack = new Stack<>();  // Initializing a new stack to store the 3rd element                  int[] temp = new int[nums.length];     // Temp array to keep track of the smallest element at each index                  temp[0] = nums[0];     // Storing first element into temp                  for(int i = 1; i < nums.length; i++) {  // Looping through the array from 2nd element                          temp[i] = Math.min(temp[i - 1], nums[i]);   // Storing minimum element between the two in the temp array                      }                  for(int j = nums.length - 1; j >= 0; j--) {   // Looping through the array from last index                          if(nums[j] > temp[j]) {     // If current element is larger than smallest element at that index                                  while(!stack.isEmpty() && stack.peek() <= temp[j]) {   // Removing elements from stack which are smaller than smallest element at the index                                          stack.pop();                                      }                                  if(!stack.isEmpty() && stack.peek() < nums[j]) {    // If remaining element in stack is smaller than current element                                          return true;    // Pattern found                                      }                                  stack.push(nums[j]);    // Add current element to stack(if pattern not found)                              }                      }                  return false;   // If no pattern found in the array              } }",0,,0,0,0
"class Solution {     public boolean circularArrayLoop(int[] nums) {         int n = nums.length;          for (int i = 0; i < n; i++) {             // Check for forward direction             boolean isForward = nums[i] > 0;              // Initialize slow and fast pointers             int slow = i, fast = getNext(nums, i, isForward);              // If slow and fast pointers point to same element, no loop exists             while (slow != fast && nums[slow] * nums[fast] > 0) {                 slow = getNext(nums, slow, isForward);                 fast = getNext(nums, fast, isForward);                 fast = getNext(nums, fast, isForward);             }                          // If there is a loop with multiple elements and they are all moving in the same direction, return true             if (slow == fast && nums[slow] * nums[fast] > 0) {                 return true;             }         }         return false;     }      private int getNext(int[] nums, int currentIndex, boolean isForward) {         int nextIndex = (currentIndex + nums[currentIndex]) % nums.length;          // Handle negative index         if (nextIndex < 0) {             nextIndex += nums.length;         }          // If the direction of movement changed, return -1         if (nums[currentIndex] * nums[nextIndex] < 0) {             return -1;         }          return nextIndex;     } }",1,"457-circular-array-loop/Solution.java:10:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
457-circular-array-loop/Solution.java:10:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
457-circular-array-loop/Solution.java:27:	UnusedFormalParameter:	Avoid unused method parameters such as 'isForward'.
",1,0,0
class Solution {     public int minMoves2(int[] nums) {         int n = nums.length;         if(n==0) return 0;                  Arrays.sort(nums);         int median = nums[n/2];                  int moves = 0;         for(int i=0;i<n;i++){             moves += Math.abs(nums[i]-median);         }                  return moves;     } },0,,0,0,0
"import java.util.*;  class Solution {     public boolean canIWin(int maxChoosableInteger, int desiredTotal) {         // If the desired total is 0, then the first player always wins         if (desiredTotal == 0) {             return true;         }         // If the sum of all numbers from 1 to maxChoosableInteger is less than the desiredTotal, then it's impossible to win         if ((maxChoosableInteger * (maxChoosableInteger + 1) / 2) < desiredTotal) {             return false;         }         // Used to keep track of which numbers have been used         boolean[] used = new boolean[maxChoosableInteger + 1];         // Used to keep track of the results of subgames         Map<String, Boolean> memo = new HashMap<>();         // The first player tries all possible moves, and sees if any of them ensure a win         for (int i = 1; i <= maxChoosableInteger; i++) {             used[i] = true;             if (canWin(desiredTotal - i, used, memo, maxChoosableInteger)) {                 return true;             }             used[i] = false;         }         return false;     }          // Helper function to determine if the current player can win from the current state     private boolean canWin(int remainingTotal, boolean[] used, Map<String, Boolean> memo, int maxChoosableInteger) {         // If there are no more numbers to choose from, then the player loses         if (remainingTotal <= 0) {             return false;         }         // Generate a unique key for the current state         String key = Arrays.toString(used);         // If we have already computed the result of this subgame, return that result         if (memo.containsKey(key)) {             return memo.get(key);         }         // Try all possible moves, and see if any of them ensure a win for the current player         for (int i = 1; i <= maxChoosableInteger; i++) {             if (!used[i]) {                 used[i] = true;                 // If the other player can't win from this state, then the current player wins                 if (!canWin(remainingTotal - i, used, memo, maxChoosableInteger)) {                     memo.put(key, true);                     used[i] = false;                     return true;                 }                 used[i] = false;             }         }         // If none of the possible moves ensure a win for the current player, then the current player loses         memo.put(key, false);         return false;     } }",1,"464-can-i-win/Solution.java:16:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
",0,0,0
"class Solution {     public int findSubstringInWraproundString(String s) {         int[] count = new int[26];         int maxLength = 0;         for (int i = 0; i < s.length(); i++) {             if (i > 0 && (s.charAt(i) - s.charAt(i-1) == 1 || s.charAt(i-1) - s.charAt(i) == 25)) {                 maxLength++;             } else {                 maxLength = 1;             }             count[s.charAt(i) - 'a'] = Math.max(count[s.charAt(i) - 'a'], maxLength);         }         int sum = 0;         for (int i = 0; i < 26; i++) {             sum += count[i];         }         return sum;     } }",0,,0,0,0
"class Solution {     public String validIPAddress(String queryIP) {         if (isValidIPv4(queryIP)) {             return ""IPv4"";         } else if (isValidIPv6(queryIP)) {             return ""IPv6"";         } else {             return ""Neither"";         }     }          private boolean isValidIPv4(String ip) {         String[] parts = ip.split(""\\."", -1);         if (parts.length != 4) {             return false;         }         for (String part : parts) {             if (!isValidIPv4Part(part)) {                 return false;             }         }         return true;     }          private boolean isValidIPv4Part(String part) {         if (part.length() == 0 || part.length() > 3) {             return false;         }         if (part.charAt(0) == '0' && part.length() > 1) {             return false;         }         for (char c : part.toCharArray()) {             if (c < '0' || c > '9') {                 return false;             }         }         int num = Integer.parseInt(part);         return num >= 0 && num <= 255;     }          private boolean isValidIPv6(String ip) {         String[] parts = ip.split("":"", -1);         if (parts.length != 8) {             return false;         }         for (String part : parts) {             if (!isValidIPv6Part(part)) {                 return false;             }         }         return true;     }          private boolean isValidIPv6Part(String part) {         if (part.length() == 0 || part.length() > 4) {             return false;         }         for (char c : part.toCharArray()) {             if (!((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'))) {                 return false;             }         }         return true;     } }",0,,0,0,0
/**  * The rand7() API is already defined in the parent class SolBase.  * public int rand7();  * @return a random integer in the range 1 to 7  */ class Solution extends SolBase {     public int rand10() {         int num = (rand7() - 1) * 7 + rand7(); // generate number in range 1-49 with equal probability         while (num > 40) { // reject numbers greater than 40             num = (rand7() - 1) * 7 + rand7();         }         return (num % 10) + 1; // transform number in range 1-10 with equal probability     } },0,,0,0,0
"class Solution {     public boolean makesquare(int[] matchsticks) {         int sum = 0;         for (int stick : matchsticks) {             sum += stick;         }         if (sum % 4 != 0) {             return false;         }         int sideLength = sum / 4;         boolean[] used = new boolean[matchsticks.length];         return dfs(matchsticks, used, 0, 0, sideLength, 4);     }      private boolean dfs(int[] matchsticks, boolean[] used, int startIndex, int currentLength, int sideLength, int sidesLeft) {         if (sidesLeft == 0) {             return true;         }         if (currentLength == sideLength) {             return dfs(matchsticks, used, 0, 0, sideLength, sidesLeft - 1);         }         for (int i = startIndex; i < matchsticks.length; i++) {             if (!used[i] && currentLength + matchsticks[i] <= sideLength) {                 used[i] = true;                 if (dfs(matchsticks, used, i + 1, currentLength + matchsticks[i], sideLength, sidesLeft)) {                     return true;                 }                 used[i] = false;             }         }         return false;     } }",0,,0,0,0
"class Solution {     public int findMaxForm(String[] strs, int m, int n) {         int[][] dp = new int[m+1][n+1];         for (String str : strs) {             int zeros = 0, ones = 0;             for (char c : str.toCharArray()) {                 if (c == '0') zeros++;                 else ones++;             }             for (int i = m; i >= zeros; i--) {                 for (int j = n; j >= ones; j--) {                     dp[i][j] = Math.max(dp[i][j], dp[i-zeros][j-ones] + 1);                 }             }         }         return dp[m][n];     } }",1,"474-ones-and-zeroes/Solution.java:5:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
474-ones-and-zeroes/Solution.java:5:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int findRadius(int[] houses, int[] heaters) {                  int maxRadius = 0;         Arrays.sort(heaters);                  for (int house : houses) {             int radius = Integer.MAX_VALUE;                          int index = Arrays.binarySearch(heaters, house);             if (index < 0) {                 index = -(index + 1);                 if (index > 0) {                     radius = Math.min(radius, house - heaters[index - 1]);                 }                 if (index < heaters.length) {                     radius = Math.min(radius, heaters[index] - house);                 }             }             maxRadius = Math.max(maxRadius, radius);         }         return maxRadius;     } }",0,,0,0,0
class Solution {     public int totalHammingDistance(int[] nums) {         int totalDist = 0;         int n = nums.length;         for(int i=0; i<32; i++) {   // 32-bit integer             int countOnes = 0;             for(int j=0; j<n; j++) {                 if((nums[j] & (1 << i)) != 0) countOnes++;                 // get the ith bit of each number             }             int countZeros = n - countOnes;             totalDist += countOnes * countZeros;              // each pair of 1 and 0 has a hamming distance of 1         }         return totalDist;     } },0,,0,0,0
"import java.util.Random;  class Solution {     double radius, x_center, y_center;     Random rand;      public Solution(double radius, double x_center, double y_center) {         this.radius = radius;         this.x_center = x_center;         this.y_center = y_center;         this.rand = new Random();     }      public double[] randPoint() {         double len = Math.sqrt(rand.nextDouble()) * radius;         double deg = rand.nextDouble() * 2 * Math.PI;         double x = x_center + len * Math.cos(deg);         double y = y_center + len * Math.sin(deg);         return new double[] {x, y};     } }  /**  * Your Solution object will be instantiated and called as such:  * Solution obj = new Solution(radius, x_center, y_center);  * double[] param_1 = obj.randPoint();  */",1,"478-generate-random-point-in-a-circle/Solution.java:4:5: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
478-generate-random-point-in-a-circle/Solution.java:4:12: Variable 'radius' must be private and have accessor methods. [VisibilityModifier]
478-generate-random-point-in-a-circle/Solution.java:4:20: Variable 'x_center' must be private and have accessor methods. [VisibilityModifier]
478-generate-random-point-in-a-circle/Solution.java:4:30: Variable 'y_center' must be private and have accessor methods. [VisibilityModifier]
478-generate-random-point-in-a-circle/Solution.java:5:12: Variable 'rand' must be private and have accessor methods. [VisibilityModifier]
478-generate-random-point-in-a-circle/Solution.java:7:5: Redundant 'public' modifier. [RedundantModifier]
478-generate-random-point-in-a-circle/Solution.java:7:28: 'radius' hides a field. [HiddenField]
478-generate-random-point-in-a-circle/Solution.java:7:43: 'x_center' hides a field. [HiddenField]
478-generate-random-point-in-a-circle/Solution.java:7:60: 'y_center' hides a field. [HiddenField]
478-generate-random-point-in-a-circle/Solution.java:4:5: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
478-generate-random-point-in-a-circle/Solution.java:4:12: Variable 'radius' must be private and have accessor methods. [VisibilityModifier]
478-generate-random-point-in-a-circle/Solution.java:4:20: Variable 'x_center' must be private and have accessor methods. [VisibilityModifier]
478-generate-random-point-in-a-circle/Solution.java:4:30: Variable 'y_center' must be private and have accessor methods. [VisibilityModifier]
478-generate-random-point-in-a-circle/Solution.java:5:12: Variable 'rand' must be private and have accessor methods. [VisibilityModifier]
478-generate-random-point-in-a-circle/Solution.java:7:5: Redundant 'public' modifier. [RedundantModifier]
478-generate-random-point-in-a-circle/Solution.java:7:28: 'radius' hides a field. [HiddenField]
478-generate-random-point-in-a-circle/Solution.java:7:43: 'x_center' hides a field. [HiddenField]
478-generate-random-point-in-a-circle/Solution.java:7:60: 'y_center' hides a field. [HiddenField]
",1,0,0
"class Solution {     public int magicalString(int n) {         if (n <= 0) return 0;         if (n <= 3) return 1;          int[] nums = new int[n + 1];         nums[0] = 1;         nums[1] = 2;         nums[2] = 2;          int head = 2, tail = 3, num = 1, count = 1;          while (tail < n) {             for (int i = 0; i < nums[head]; i++) {                 nums[tail] = num;                 if (num == 1 && tail < n) count++;                 tail++;             }             num = num ^ 3;             head++;         }          return count;     } }",1,"481-magical-string/Solution.java:11:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
481-magical-string/Solution.java:11:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public boolean PredictTheWinner(int[] nums) {         int n = nums.length;         int[][] dp = new int[n][n];                  for(int i=0; i<n; i++){             dp[i][i] = nums[i];         }                  for(int len=1; len<n; len++){             for(int i=0; i<n-len; i++){                 int j = i+len;                 dp[i][j] = Math.max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1]);             }         }                  return dp[0][n-1] >= 0;     } }",1,"486-predict-the-winner/Solution.java:2:	MethodNamingConventions:	The instance method name 'PredictTheWinner' doesn't match '[a-z][a-zA-Z0-9]*'
",0,0,0
"import java.util.*;  class Solution {     public List<List<Integer>> findSubsequences(int[] nums) {                  List<List<Integer>> result = new ArrayList<>();                  // Recursively find all the subsequences starting from each index         for(int i=0; i<nums.length; i++){             dfs(nums, i, new ArrayList<>(), result);         }                  return result;     }          private void dfs(int[] nums, int index, ArrayList<Integer> tmpList, List<List<Integer>> result){                  // If the current subsequence is of length 2 or greater, add it to the result         if(tmpList.size() >= 2){              result.add(new ArrayList<>(tmpList));         }                  // Set to keep track of used numbers         Set<Integer> used = new HashSet<>();                  // Recursively find all subsequences starting from the current index         for(int i = index; i < nums.length; i++){                          if(used.contains(nums[i]) || (!tmpList.isEmpty() && nums[i] < tmpList.get(tmpList.size() - 1))){                 continue; // Skip as the number is already used or is less than the previous number in subsequence             }                          // Add the current number to the subsequence             used.add(nums[i]);             tmpList.add(nums[i]);                          // Recursively find subsequences starting from the next index             dfs(nums, i+1, tmpList, result);                          // Remove the current number from the subsequence to backtrack and try other subsequences             tmpList.remove(tmpList.size() - 1);         }     } }",1,"491-non-decreasing-subsequences/Solution.java:16:	LooseCoupling:	Avoid using implementation types like 'ArrayList'; use the interface instead
",0,0,0
"class Solution {     public int findTargetSumWays(int[] nums, int target) {         int sum = 0;         for (int n : nums) {             sum += n;         }         if (sum < target || (sum + target) % 2 != 0) {             return 0;         }         int subsetSum = (sum + target) / 2;         int[] dp = new int[subsetSum + 1];         dp[0] = 1;         for (int n : nums) {             for (int i = subsetSum; i >= n; i--) {                 dp[i] += dp[i - n];             }         }         return dp[subsetSum];     } }",0,,0,0,0
"import java.util.*;  class Solution {     private int[][] rects;     private int[] ranges; // array to store range of possible coordinates for each rectangle     private Random random;          public Solution(int[][] rects) {         this.rects = rects;         this.ranges = new int[rects.length];         int total = 0;         for(int i=0; i<rects.length; i++) {             int rectSize = getRectSize(rects[i]);             total += rectSize;             ranges[i] = total;         }         random = new Random();     }          private int getRectSize(int[] rect) {         return (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1);     }      public int[] pick() {         int rectIndex = pickRectangle();         int[] rect = rects[rectIndex];         int rectSize = getRectSize(rect);         int x = rect[0] + random.nextInt(rect[2] - rect[0] + 1);         int y = rect[1] + random.nextInt(rect[3] - rect[1] + 1);         return new int[]{x, y};     }          private int pickRectangle() {         int rand = random.nextInt(ranges[ranges.length - 1]);         int left = 0, right = ranges.length-1;         while(left < right) {             int mid = (left + right) / 2;             if(rand >= ranges[mid]) {                 left = mid + 1;             } else {                 right = mid;             }         }         return left;     } }",1,"497-random-point-in-non-overlapping-rectangles/Solution.java:8:5: Redundant 'public' modifier. [RedundantModifier]
497-random-point-in-non-overlapping-rectangles/Solution.java:8:29: 'rects' hides a field. [HiddenField]
497-random-point-in-non-overlapping-rectangles/Solution.java:35:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
497-random-point-in-non-overlapping-rectangles/Solution.java:8:5: Redundant 'public' modifier. [RedundantModifier]
497-random-point-in-non-overlapping-rectangles/Solution.java:8:29: 'rects' hides a field. [HiddenField]
497-random-point-in-non-overlapping-rectangles/Solution.java:35:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
497-random-point-in-non-overlapping-rectangles/Solution.java:9:	ArrayIsStoredDirectly:	The user-supplied array 'rects' is stored directly.
497-random-point-in-non-overlapping-rectangles/Solution.java:27:	UnusedLocalVariable:	Avoid unused local variables such as 'rectSize'.
",1,0,0
"class Solution {     public int[] findDiagonalOrder(int[][] mat) {         int m = mat.length;         int n = mat[0].length;                  int[] result = new int[m * n];         int r = 0, c = 0;                  for (int i = 0; i < result.length; i++) {             result[i] = mat[r][c];             if ((r + c) % 2 == 0) {                 if (c == n - 1) {                     r++;                 } else if (r == 0) {                     c++;                 } else {                     r--;                     c++;                 }             } else {                 if (r == m - 1) {                     c++;                 } else if (c == 0) {                     r++;                 } else {                     r++;                     c--;                 }             }         }                  return result;     } }",1,"498-diagonal-traverse/Solution.java:7:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
498-diagonal-traverse/Solution.java:7:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int[] nextGreaterElements(int[] nums) {         int n = nums.length;         int[] result = new int[n];         Arrays.fill(result, -1);         Stack<Integer> stack = new Stack<>();         for (int i = 0; i < n*2; i++) {             int num = nums[i%n];             while (!stack.isEmpty() && nums[stack.peek()] < num) {                 result[stack.pop()] = num;             }             if (i < n) {                 stack.push(i);             }         }         return result;     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     private Map<Integer, Integer> frequency = new HashMap<>(); // to store frequency of all subtree sums     private int maxFrequency = 0; // to store maximum frequency          public int[] findFrequentTreeSum(TreeNode root) {         if (root == null) return new int[]{};         computeSubtreeSum(root); // recursively calculate subtree sums         List<Integer> results = new ArrayList<>();         for (Map.Entry<Integer, Integer> entry : frequency.entrySet()) {             if (entry.getValue() == maxFrequency) {                 results.add(entry.getKey());             }         }         int[] resultArr = new int[results.size()];         for (int i = 0; i < results.size(); i++) {             resultArr[i] = results.get(i);         }         return resultArr;     }          private int computeSubtreeSum(TreeNode node) {         if (node == null) return 0; // base case         int left = computeSubtreeSum(node.left); // compute sum of left subtree         int right = computeSubtreeSum(node.right); // compute sum of right subtree         int subtreeSum = left + right + node.val; // compute subtree sum         int freq = frequency.getOrDefault(subtreeSum, 0) + 1; // update frequency of subtree sum         frequency.put(subtreeSum, freq);         maxFrequency = Math.max(maxFrequency, freq); // update max frequency         return subtreeSum; // return subtree sum     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public int findBottomLeftValue(TreeNode root) {         Queue<TreeNode> queue = new LinkedList<>();         queue.offer(root);          int leftmostValue = root.val;         while (!queue.isEmpty()) {             int size = queue.size();             for (int i = 0; i < size; i++) {                 TreeNode node = queue.poll();                 if (i == 0) {                     leftmostValue = node.val;                 }                 if (node.left != null) {                     queue.offer(node.left);                 }                 if (node.right != null) {                     queue.offer(node.right);                 }             }         }          return leftmostValue;     } }",0,,0,0,0
"import java.util.*;  class Solution {     public List<Integer> largestValues(TreeNode root) {         List<Integer> result = new ArrayList<>();         if (root == null) {             return result;         }         Queue<TreeNode> queue = new LinkedList<>();         queue.offer(root);         while (!queue.isEmpty()) {             int size = queue.size();             int max = Integer.MIN_VALUE;             for (int i = 0; i < size; i++) {                 TreeNode node = queue.poll();                 max = Math.max(max, node.val);                 if (node.left != null) {                     queue.offer(node.left);                 }                 if (node.right != null) {                     queue.offer(node.right);                 }             }             result.add(max);         }         return result;     } }",0,,0,0,0
"class Solution {     public int longestPalindromeSubseq(String s) {         int n = s.length();         int[][] dp = new int[n][n];                  for (int i = n - 1; i >= 0; i--) {             dp[i][i] = 1;                          for (int j = i + 1; j < n; j++) {                 if (s.charAt(i) == s.charAt(j)) {                     dp[i][j] = 2 + dp[i+1][j-1];                 } else {                     dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);                 }             }         }                  return dp[0][n-1];     } }",0,,0,0,0
"class Solution {     public int change(int amount, int[] coins) {         int n = coins.length;         int[][] dp = new int[n+1][amount+1];                  for (int i = 0; i <= n; i++) {             dp[i][0] = 1;         }                  for (int i = 1; i <= n; i++) {             for (int j = 1; j <= amount; j++) {                 if (j < coins[i-1]) {                     dp[i][j] = dp[i-1][j];                 } else {                     dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]];                 }             }         }                  return dp[n][amount];     } }",0,,0,0,0
"import java.util.Random;  class Solution {     private int row, col, total;     private int[][] matrix;     private Random rand;      public Solution(int m, int n) {         row = m;         col = n;         total = row * col;         matrix = new int[row][col];         rand = new Random();     }      public int[] flip() {         int index = rand.nextInt(total--);         int x = index / col, y = index % col;         int[] res = {x, y};         if (matrix[x][y] == 0) {             matrix[x][y] = 1;             return res;         }         for (int i = index + 1; i < total; i++) {             x = i / col;             y = i % col;             if (matrix[x][y] == 0) {                 matrix[x][y] = 1;                 return new int[]{x, y};             }         }         return null;     }      public void reset() {         total = row * col;         matrix = new int[row][col];     } }",1,"519-random-flip-matrix/Solution.java:4:5: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
519-random-flip-matrix/Solution.java:8:5: Redundant 'public' modifier. [RedundantModifier]
519-random-flip-matrix/Solution.java:18:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
519-random-flip-matrix/Solution.java:4:5: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
519-random-flip-matrix/Solution.java:8:5: Redundant 'public' modifier. [RedundantModifier]
519-random-flip-matrix/Solution.java:18:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
519-random-flip-matrix/Solution.java:32:	ReturnEmptyCollectionRatherThanNull:	Return an empty collection rather than null.
",1,0,0
"class Solution {     public int findLUSlength(String[] strs) {         int n = strs.length;         int maxLength = -1;         for(int i=0; i<n; i++){             boolean isSubsequence = false;             int currentLength = strs[i].length();             for(int j=0; j<n; j++){                 if(i != j && isSubsequence(strs[i], strs[j])){                     isSubsequence = true;                     break;                 }             }             if(!isSubsequence){                 maxLength = Math.max(maxLength, currentLength);             }         }         return maxLength;     }          private boolean isSubsequence(String s1, String s2){         int i=0, j=0;         while(i<s1.length() && j<s2.length()){             if(s1.charAt(i) == s2.charAt(j)){                 i++;             }             j++;         }         return i == s1.length();     } }",1,"522-longest-uncommon-subsequence-ii/Solution.java:22:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
522-longest-uncommon-subsequence-ii/Solution.java:22:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public boolean checkSubarraySum(int[] nums, int k) {         int n = nums.length;         if (n < 2) {             return false;         }                  Map<Integer, Integer> map = new HashMap<>();         map.put(0, -1);         int sum = 0;         for (int i = 0; i < n; i++) {             sum += nums[i];             if (k != 0) {                 sum %= k;             }             if (map.containsKey(sum)) {                 int preIndex = map.get(sum);                 if (i - preIndex > 1) {                     return true;                 }             } else {                 map.put(sum, i);             }         }                  return false;     } }",0,,0,0,0
"import java.util.List; import java.util.ArrayList; import java.util.Collections;  class Solution {     public String findLongestWord(String s, List<String> dictionary) {         List<String> candidates = new ArrayList<>();         for (String word : dictionary) {             int i = 0;             for (char c : s.toCharArray()) {                 if (i < word.length() && c == word.charAt(i)) {                     i++;                 }                 if (i == word.length()) {                     candidates.add(word);                     break;                 }             }         }         if (candidates.size() == 0) {             return """";         } else {             Collections.sort(candidates);             Collections.sort(candidates, (a, b) -> b.length() - a.length());             return candidates.get(0);         }     } }",1,"524-longest-word-in-dictionary-through-deleting/Solution.java:20:	UseCollectionIsEmpty:	Substitute calls to size() == 0 (or size() != 0, size() > 0, size() < 1) with calls to isEmpty()
",0,0,0
"class Solution {     public int findMaxLength(int[] nums) {         int maxLen = 0;         int count = 0;         Map<Integer, Integer> countMap = new HashMap<>();         countMap.put(0, -1);         for(int i = 0; i < nums.length; i++) {             count += nums[i] == 1 ? 1 : -1;             if(countMap.containsKey(count)) {                 maxLen = Math.max(maxLen, i - countMap.get(count));             } else {                 countMap.put(count, i);             }         }         return maxLen;     } }",0,,0,0,0
"class Solution {     public int countArrangement(int n) {         boolean[] visited = new boolean[n+1];         return backtrack(n, 1, visited);     }          private int backtrack(int n, int pos, boolean[] visited) {         if (pos > n) return 1;         int count = 0;         for (int i = 1; i <= n; i++) {             if (!visited[i] && (i % pos == 0 || pos % i == 0)) {                 visited[i] = true;                 count += backtrack(n, pos+1, visited);                 visited[i] = false;             }         }         return count;     } }",0,,0,0,0
class Solution {     int[] prefixSum;     int totalSum;      public Solution(int[] w) {         int n = w.length;         prefixSum = new int[n];         prefixSum[0] = w[0];         for (int i = 1; i < n; i++) {             prefixSum[i] = prefixSum[i-1] + w[i];         }         totalSum = prefixSum[n-1];     }      public int pickIndex() {         double r = Math.random();         int low = 0;         int high = prefixSum.length-1;         while (low < high) {             int mid = (low + high) / 2;             if (r > (double) (prefixSum[mid] / (double) totalSum)) {                 low = mid + 1;             } else {                 high = mid;             }         }         return low;     } },1,"528-random-pick-with-weight/Solution.java:2:11: Variable 'prefixSum' must be private and have accessor methods. [VisibilityModifier]
528-random-pick-with-weight/Solution.java:3:9: Variable 'totalSum' must be private and have accessor methods. [VisibilityModifier]
528-random-pick-with-weight/Solution.java:5:5: Redundant 'public' modifier. [RedundantModifier]
528-random-pick-with-weight/Solution.java:2:11: Variable 'prefixSum' must be private and have accessor methods. [VisibilityModifier]
528-random-pick-with-weight/Solution.java:3:9: Variable 'totalSum' must be private and have accessor methods. [VisibilityModifier]
528-random-pick-with-weight/Solution.java:5:5: Redundant 'public' modifier. [RedundantModifier]
528-random-pick-with-weight/Solution.java:21:	UnnecessaryCast:	Unnecessary cast (double)
",0,0,0
class Solution {     int[] prefixSum;     int totalSum;      public Solution(int[] w) {         int n = w.length;         prefixSum = new int[n];         prefixSum[0] = w[0];         for (int i = 1; i < n; i++) {             prefixSum[i] = prefixSum[i-1] + w[i];         }         totalSum = prefixSum[n-1];     }      public int pickIndex() {         double r = Math.random();         int low = 0;         int high = prefixSum.length-1;         while (low < high) {             int mid = (low + high) / 2;             if (r > (double) (prefixSum[mid] / (double) totalSum)) {                 low = mid + 1;             } else {                 high = mid;             }         }         return low;     } },0,,0,0,0
"class Solution {     public int findPairs(int[] nums, int k) {         if (k < 0) {             return 0;         }         int count = 0;         if (k == 0) {             Map<Integer, Integer> map = new HashMap<>();             for (int num : nums) {                 int frequency = map.getOrDefault(num, 0);                 map.put(num, frequency + 1);             }             for (int frequency : map.values()) {                 if (frequency > 1) {                     count++;                 }             }         } else {             Set<Integer> numsSet = new HashSet<>();             Set<Integer> pairsSet = new HashSet<>();             for (int num : nums) {                 numsSet.add(num);             }             for (int num : numsSet) {                 int pairNum1 = num + k;                 int pairNum2 = num - k;                 if (numsSet.contains(pairNum1)) {                     pairsSet.add(num);                 }                 if (numsSet.contains(pairNum2)) {                     pairsSet.add(num);                 }             }             count = pairsSet.size();         }         return count;     } }",0,,0,0,0
"import java.util.HashMap; import java.util.Random;  public class Codec {      HashMap<String, String> map = new HashMap<>();     Random rand = new Random();     String BASE_URL = ""http://tinyurl.com/"";      // Encodes a URL to a shortened URL.     public String encode(String longUrl) {         StringBuilder sb = new StringBuilder();         for (int i = 0; i < 6; i++) {             char c = longUrl.charAt(rand.nextInt(longUrl.length()));             sb.append(c);         }         String shortUrl = BASE_URL + sb.toString();         map.put(shortUrl, longUrl);         return shortUrl;     }      // Decodes a shortened URL to its original URL.     public String decode(String shortUrl) {         return map.get(shortUrl);     } }",1,"535-encode-and-decode-tinyurl/Codec.java:6:29: Variable 'map' must be private and have accessor methods. [VisibilityModifier]
535-encode-and-decode-tinyurl/Codec.java:7:12: Variable 'rand' must be private and have accessor methods. [VisibilityModifier]
535-encode-and-decode-tinyurl/Codec.java:8:12: Variable 'BASE_URL' must be private and have accessor methods. [VisibilityModifier]
535-encode-and-decode-tinyurl/Codec.java:6:29: Variable 'map' must be private and have accessor methods. [VisibilityModifier]
535-encode-and-decode-tinyurl/Codec.java:7:12: Variable 'rand' must be private and have accessor methods. [VisibilityModifier]
535-encode-and-decode-tinyurl/Codec.java:8:12: Variable 'BASE_URL' must be private and have accessor methods. [VisibilityModifier]
535-encode-and-decode-tinyurl/Codec.java:6:	LooseCoupling:	Avoid using implementation types like 'HashMap'; use the interface instead
",0,0,0
"class Solution {     public String complexNumberMultiply(String num1, String num2) {         int a = Integer.parseInt(num1.substring(0, num1.indexOf('+')));         int b = Integer.parseInt(num1.substring(num1.indexOf('+')+1, num1.indexOf('i')));         int c = Integer.parseInt(num2.substring(0, num2.indexOf('+')));         int d = Integer.parseInt(num2.substring(num2.indexOf('+')+1, num2.indexOf('i')));                  int real = a*c - b*d;         int imag = a*d + b*c;                  return real + ""+"" + imag + ""i"";     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     private int sum = 0;          public TreeNode convertBST(TreeNode root) {         if(root == null) {             return null;         }                  convertBST(root.right);                  sum += root.val;         root.val = sum;                  convertBST(root.left);                  return root;     } }",0,,0,0,0
"import java.util.*;  class Solution {     public int findMinDifference(List<String> timePoints) {         int n = timePoints.size();         int[] minutes = new int[n];          for (int i = 0; i < n; i++) {             int hour = Integer.parseInt(timePoints.get(i).substring(0, 2));             int minute = Integer.parseInt(timePoints.get(i).substring(3));             minutes[i] = hour * 60 + minute;         }          Arrays.sort(minutes);         int minDiff = Integer.MAX_VALUE;          for (int i = 0; i < n - 1; i++) {             int diff = minutes[i + 1] - minutes[i];             if (diff < minDiff)                 minDiff = diff;         }          int cornerDiff = (minutes[0] + 1440) - minutes[n - 1];         if (cornerDiff < minDiff)             minDiff = cornerDiff;          return minDiff;     } }",1,"539-minimum-time-difference/Solution.java:23:	UselessParentheses:	Useless parentheses.
",0,0,0
"class Solution {     public int singleNonDuplicate(int[] nums) {         int left = 0, right = nums.length - 1;         while (left < right) {             int mid = left + (right - left) / 2;             if (mid % 2 == 0) {                 if (nums[mid] == nums[mid + 1]) {                     left = mid + 2;                 } else {                     right = mid;                 }             } else {                 if (nums[mid] == nums[mid - 1]) {                     left = mid + 1;                 } else {                     right = mid - 1;                 }             }         }         return nums[left];     } }",1,"540-single-element-in-a-sorted-array/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
540-single-element-in-a-sorted-array/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int[][] updateMatrix(int[][] mat) {         int rows = mat.length;         int cols = mat[0].length;         int[][] result = new int[rows][cols];         Queue<int[]> queue = new LinkedList<>();                  // Add all the 0's to the queue and mark the others as -1         for (int i = 0; i < rows; i++) {             for (int j = 0; j < cols; j++) {                 if (mat[i][j] == 0) {                     queue.offer(new int[] {i, j});                 } else {                     result[i][j] = -1;                 }             }         }                  // Initialize the distance variable         int distance = 1;                  // Define the four directions         int[][] dirs = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};                  // Traverse the matrix using BFS         while (!queue.isEmpty()) {             int size = queue.size();             for (int i = 0; i < size; i++) {                 int[] curr = queue.poll();                 for (int[] dir : dirs) {                     int r = curr[0] + dir[0];                     int c = curr[1] + dir[1];                     if (r >= 0 && r < rows && c >= 0 && c < cols && result[r][c] == -1) {                         result[r][c] = distance;                         queue.offer(new int[] {r, c});                     }                 }             }             distance++;         }                  return result;     } }",0,,0,0,0
"class Solution {     public int findCircleNum(int[][] isConnected) {         int n = isConnected.length;         boolean[] visited = new boolean[n];         int count = 0;         for (int i = 0; i < n; i++) {             if (!visited[i]) {                 dfs(isConnected, visited, i);                 count++;             }         }         return count;     }      private void dfs(int[][] isConnected, boolean[] visited, int i) {         visited[i] = true;         for (int j = 0; j < isConnected.length; j++) {             if (isConnected[i][j] == 1 && !visited[j]) {                 dfs(isConnected, visited, j);             }         }     } }",0,,0,0,0
"class Solution {     public String optimalDivision(int[] nums) {         int n = nums.length;         StringBuilder sb = new StringBuilder();         sb.append(nums[0]);         if (n == 1) {             return sb.toString();         }         if (n == 2) {             sb.append(""/"");             sb.append(nums[1]);             return sb.toString();         }         sb.append(""/("");         for (int i = 1; i < n; i++) {             sb.append(nums[i]);             sb.append(""/"");         }         sb.setLength(sb.length() - 1);         sb.append("")"");         return sb.toString();     } }",1,"553-optimal-division/Solution.java:10:	ConsecutiveAppendsShouldReuse:	StringBuffer (or StringBuilder).append is called consecutively without reusing the target variable.
553-optimal-division/Solution.java:10:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
553-optimal-division/Solution.java:16:	ConsecutiveAppendsShouldReuse:	StringBuffer (or StringBuilder).append is called consecutively without reusing the target variable.
553-optimal-division/Solution.java:17:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
553-optimal-division/Solution.java:20:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
",0,0,0
"class Solution {     public int leastBricks(List<List<Integer>> wall) {         Map<Integer, Integer> frequencies = new HashMap<>();         int maxFrequency = 0;         for(List<Integer> row:wall){             int sum = 0;             for(int i=0;i<row.size()-1;i++){                 sum+=row.get(i);                 frequencies.put(sum, frequencies.getOrDefault(sum,0)+1);                 maxFrequency = Math.max(maxFrequency, frequencies.get(sum));             }         }         return wall.size()-maxFrequency;     } }",0,,0,0,0
"class Solution {     public int nextGreaterElement(int n) {         char[] digits = (n + """").toCharArray(); // convert number to character array         int firstDigit = digits.length - 2;          // find the first decreasing digit from the right         while (firstDigit >= 0 && digits[firstDigit] >= digits[firstDigit + 1]) {             firstDigit--;         }          if (firstDigit < 0) { // the whole number is in decreasing order             return -1;         }          int secondDigit = digits.length - 1;          // find the smallest digit larger than the first decreasing digit         while (secondDigit >= 0 && digits[firstDigit] >= digits[secondDigit]) {             secondDigit--;         }          // swap the first decreasing digit with the smallest digit larger than it         char temp = digits[firstDigit];         digits[firstDigit] = digits[secondDigit];         digits[secondDigit] = temp;          // reverse the digits after the first decreasing digit         reverse(digits, firstDigit + 1, digits.length - 1);          Long ans = Long.parseLong(new String(digits));          // check if the answer is within the range of a 32-bit integer         if (ans > Integer.MAX_VALUE) {             return -1;         }          return ans.intValue();     }      // helper function to reverse a portion of an array     private void reverse(char[] arr, int start, int end) {         while (start < end) {             char temp = arr[start];             arr[start++] = arr[end];             arr[end--] = temp;         }     } }",1,"556-next-greater-element-iii/Solution.java:3:	AddEmptyString:	Do not add empty strings
556-next-greater-element-iii/Solution.java:30:	StringInstantiation:	Avoid instantiating String objects; this is usually unnecessary.
556-next-greater-element-iii/Solution.java:44:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'start'
556-next-greater-element-iii/Solution.java:45:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'end'
",0,1,0
"// Definition for a QuadTree node. class Node {     public boolean val;     public boolean isLeaf;     public Node topLeft;     public Node topRight;     public Node bottomLeft;     public Node bottomRight;      public Node() {}      public Node(boolean _val,boolean _isLeaf,Node _topLeft,Node _topRight,Node _bottomLeft,Node _bottomRight) {         val = _val;         isLeaf = _isLeaf;         topLeft = _topLeft;         topRight = _topRight;         bottomLeft = _bottomLeft;         bottomRight = _bottomRight;     } };  class Solution {     public Node intersect(Node quadTree1, Node quadTree2) {         if (quadTree1.isLeaf && quadTree2.isLeaf) {             return new Node(quadTree1.val || quadTree2.val, true, null, null, null, null);         } else if (quadTree1.isLeaf) {             if (quadTree1.val) {                 return new Node(true, true, null, null, null, null);             } else {                 return quadTree2;             }         } else if (quadTree2.isLeaf) {             if (quadTree2.val) {                 return new Node(true, true, null, null, null, null);             } else {                 return quadTree1;             }         } else {             Node topLeft = intersect(quadTree1.topLeft, quadTree2.topLeft);             Node topRight = intersect(quadTree1.topRight, quadTree2.topRight);             Node bottomLeft = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);             Node bottomRight = intersect(quadTree1.bottomRight, quadTree2.bottomRight);              boolean val = topLeft.val || topRight.val || bottomLeft.val || bottomRight.val;              if (topLeft.isLeaf && topRight.isLeaf && bottomLeft.isLeaf && bottomRight.isLeaf && topLeft.val == topRight.val && topRight.val == bottomLeft.val && bottomLeft.val == bottomRight.val) {                 return new Node(val, true, null, null, null, null);             } else {                 return new Node(val, false, topLeft, topRight, bottomLeft, bottomRight);             }         }     } }",1,"558-logical-or-of-two-binary-grids-represented-as-quad-trees/Node.java:3:20: Variable 'val' must be private and have accessor methods. [VisibilityModifier]
558-logical-or-of-two-binary-grids-represented-as-quad-trees/Node.java:4:20: Variable 'isLeaf' must be private and have accessor methods. [VisibilityModifier]
558-logical-or-of-two-binary-grids-represented-as-quad-trees/Node.java:5:17: Variable 'topLeft' must be private and have accessor methods. [VisibilityModifier]
558-logical-or-of-two-binary-grids-represented-as-quad-trees/Node.java:6:17: Variable 'topRight' must be private and have accessor methods. [VisibilityModifier]
558-logical-or-of-two-binary-grids-represented-as-quad-trees/Node.java:7:17: Variable 'bottomLeft' must be private and have accessor methods. [VisibilityModifier]
558-logical-or-of-two-binary-grids-represented-as-quad-trees/Node.java:8:17: Variable 'bottomRight' must be private and have accessor methods. [VisibilityModifier]
558-logical-or-of-two-binary-grids-represented-as-quad-trees/Node.java:10:5: Redundant 'public' modifier. [RedundantModifier]
558-logical-or-of-two-binary-grids-represented-as-quad-trees/Node.java:12:5: Redundant 'public' modifier. [RedundantModifier]
558-logical-or-of-two-binary-grids-represented-as-quad-trees/Node.java:3:20: Variable 'val' must be private and have accessor methods. [VisibilityModifier]
558-logical-or-of-two-binary-grids-represented-as-quad-trees/Node.java:4:20: Variable 'isLeaf' must be private and have accessor methods. [VisibilityModifier]
558-logical-or-of-two-binary-grids-represented-as-quad-trees/Node.java:5:17: Variable 'topLeft' must be private and have accessor methods. [VisibilityModifier]
558-logical-or-of-two-binary-grids-represented-as-quad-trees/Node.java:6:17: Variable 'topRight' must be private and have accessor methods. [VisibilityModifier]
558-logical-or-of-two-binary-grids-represented-as-quad-trees/Node.java:7:17: Variable 'bottomLeft' must be private and have accessor methods. [VisibilityModifier]
558-logical-or-of-two-binary-grids-represented-as-quad-trees/Node.java:8:17: Variable 'bottomRight' must be private and have accessor methods. [VisibilityModifier]
558-logical-or-of-two-binary-grids-represented-as-quad-trees/Node.java:10:5: Redundant 'public' modifier. [RedundantModifier]
558-logical-or-of-two-binary-grids-represented-as-quad-trees/Node.java:12:5: Redundant 'public' modifier. [RedundantModifier]
558-logical-or-of-two-binary-grids-represented-as-quad-trees/Node.java:2:	DataClass:	The class 'Node' is suspected to be a Data Class (WOC=0.000%, NOPA=6, NOAM=0, WMC=2)
558-logical-or-of-two-binary-grids-represented-as-quad-trees/Node.java:10:	UncommentedEmptyConstructor:	Document empty constructor
558-logical-or-of-two-binary-grids-represented-as-quad-trees/Node.java:20:	UnnecessarySemicolon:	Unnecessary semicolon
",0,0,0
"class Solution {     public int subarraySum(int[] nums, int k) {         int count = 0;         int sum = 0;         // We'll use a map to store the sum frequency at which it appears while traversing the array         Map<Integer, Integer> sumFreq = new HashMap<>();         sumFreq.put(0, 1); // Put the initial sum as 0 in the map                  for (int i = 0; i < nums.length; i++) {             sum += nums[i];             // Find the complement sum in the hashmap, add its frequency to the count             if (sumFreq.containsKey(sum - k)) {                 count += sumFreq.get(sum - k);             }             // Increment the frequency of sum in the hashmap             sumFreq.put(sum, sumFreq.getOrDefault(sum, 0) + 1);         }                  return count;     } }",1,"560-subarray-sum-equals-k/Solution.java:9:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int arrayNesting(int[] nums) {         int maxLength = 0;         for (int i = 0; i < nums.length; i++) {             int currentNumber = i;             int length = 0;             while(nums[currentNumber] != -1) {                 int temp = currentNumber;                 currentNumber = nums[currentNumber];                 length++;                 nums[temp] = -1;              }             maxLength = Math.max(maxLength, length);         }         return maxLength;     } }",0,,0,0,0
"class Solution {     public boolean checkInclusion(String s1, String s2) {         int[] s1CharCount = new int[26];         int[] s2CharCount = new int[26];                  // put count of all characters of s1 in an array         for (int i = 0; i < s1.length(); i++) {             s1CharCount[s1.charAt(i) - 'a']++;         }                  // loop through s2 and maintain a sliding window of length s1.length()         for (int i = 0; i < s2.length(); i++) {             // if the current character lies outside the sliding window, decrease its count in s2CharCount             if (i >= s1.length()) {                 s2CharCount[s2.charAt(i - s1.length()) - 'a']--;             }             // increase count of current character in s2CharCount             s2CharCount[s2.charAt(i) - 'a']++;                          // if both arrays have same count of all characters, return true             if (Arrays.equals(s1CharCount, s2CharCount)) {                 return true;             }         }                  // permutation not found         return false;     } }",0,,0,0,0
"class Solution {     public int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {         // Initialize the dp array         int[][][] dp = new int[m][n][maxMove + 1];         int MOD = 1000000007;                  // Loop through all possible moves         for (int move = 1; move <= maxMove; move++) {             for (int row = 0; row < m; row++) {                 for (int col = 0; col < n; col++) {                     long left = col == 0 ? 1 : dp[row][col - 1][move - 1];                     long right = col == n - 1 ? 1 : dp[row][col + 1][move - 1];                     long up = row == 0 ? 1 : dp[row - 1][col][move - 1];                     long down = row == m - 1 ? 1 : dp[row + 1][col][move - 1];                     dp[row][col][move] = (int)((left + right + up + down) % MOD);                 }             }         }                  // Return the result         return dp[startRow][startColumn][maxMove];     } }",0,,0,0,0
"class Solution {     public int findUnsortedSubarray(int[] nums) {         int n = nums.length;         int start = -1, end = -2;         int max = nums[0], min = nums[n-1];         for (int i = 0; i < n; i++) {             max = Math.max(max, nums[i]);             min = Math.min(min, nums[n - i - 1]);             if (nums[i] < max) {                 end = i;             }             if (nums[n - i - 1] > min) {                 start = n - i - 1;             }         }         return end - start + 1;     } }",1,"581-shortest-unsorted-continuous-subarray/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
581-shortest-unsorted-continuous-subarray/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
581-shortest-unsorted-continuous-subarray/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
581-shortest-unsorted-continuous-subarray/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int minDistance(String word1, String word2) {         int m = word1.length();         int n = word2.length();                  // dynamic programming array to store the minimum steps required         int[][] dp = new int[m+1][n+1];                  // initializing the first row and column         for(int i=0;i<=m;i++){             dp[i][0] = i;         }         for(int j=0;j<=n;j++){             dp[0][j] = j;         }                  // calculating the minimum steps using dynamic programming approach         for(int i=1;i<=m;i++){             for(int j=1;j<=n;j++){                 if(word1.charAt(i-1) == word2.charAt(j-1)){                     dp[i][j] = dp[i-1][j-1];                 }                 else{                     dp[i][j] = 1 + Math.min(dp[i-1][j],dp[i][j-1]);                 }             }         }                  return dp[m][n];     } }",1,"583-delete-operation-for-two-strings/Solution.java:22:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
583-delete-operation-for-two-strings/Solution.java:22:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
"import java.util.*; class Solution {          private int gcd(int a, int b) {         if(b == 0) {             return a;         }         return gcd(b, a % b);     }          public String fractionAddition(String expression) {         String[] fractions = expression.split(""(?=[-,+])"");         int numerator = 0, denominator = 1;         for(String fraction: fractions) {             int[] f = Arrays.stream(fraction.split(""/"")).mapToInt(Integer::parseInt).toArray();             int num = f[0], den = f[1];             numerator = numerator * den + num * denominator;             denominator *= den;                          int div = gcd(numerator, denominator);             numerator /= div;             denominator /= div;         }                  return numerator + ""/"" + denominator;     } }",1,"592-fraction-addition-and-subtraction/Solution.java:13:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
592-fraction-addition-and-subtraction/Solution.java:16:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
592-fraction-addition-and-subtraction/Solution.java:13:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
592-fraction-addition-and-subtraction/Solution.java:16:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4) {         int[][] points = {p1, p2, p3, p4}; // store coordinates in an array         // check if all four points are unique         Set<String> set = new HashSet<>();         for (int[] p : points) {             set.add(Arrays.toString(p));         }         if (set.size() != 4) {             return false;         }         // calculate distances between all pairs of points         List<Integer> dists = new ArrayList<>();         for (int i = 0; i < points.length - 1; i++) {             for (int j = i + 1; j < points.length; j++) {                 int xDiff = points[i][0] - points[j][0];                 int yDiff = points[i][1] - points[j][1];                 int dist = xDiff * xDiff + yDiff * yDiff;                 if (dist == 0) { // return false if any two points have the same coordinates                     return false;                 }                 dists.add(dist);             }         }         Collections.sort(dists); // sort distances in ascending order         // check if all four sides are equal and all four angles are 90 degrees         return dists.get(0).equals(dists.get(3)) && dists.get(4).equals(dists.get(5));     } }",0,,0,0,0
"import java.util.*;  class Solution {     public List<List<String>> findDuplicate(String[] paths) {         Map<String, List<String>> fileContentMap = new HashMap<>();                  for (String path : paths) {             String[] parts = path.split("" "");             String directory = parts[0];                          for (int i = 1; i < parts.length; i++) {                 String file = parts[i];                 int openIndex = file.indexOf('(');                 int closeIndex = file.indexOf(')');                 String content = file.substring(openIndex + 1, closeIndex);                 String fileName = file.substring(0, openIndex);                 String fullPath = directory + ""/"" + fileName;                                  if (!fileContentMap.containsKey(content)) {                     fileContentMap.put(content, new ArrayList<>());                 }                                  List<String> fileList = fileContentMap.get(content);                 fileList.add(fullPath);                 fileContentMap.put(content, fileList);             }         }                  List<List<String>> result = new ArrayList<>();                  for (List<String> fileList : fileContentMap.values()) {             if (fileList.size() > 1) {                 result.add(new ArrayList<>(fileList));             }         }                  return result;     } }",1,"609-find-duplicate-file-in-system/Solution.java:5:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
",0,0,0
class Solution {     public int triangleNumber(int[] nums) {         Arrays.sort(nums);         int count = 0;         for(int i=0; i<nums.length-2; i++) {             int k = i+2;             for(int j=i+1; j<nums.length-1 && nums[i]!= 0; j++) {                 while(k < nums.length && nums[i] + nums[j] > nums[k]) {                     k++;                 }                 count += k - j - 1;             }         }         return count;     } },0,,0,0,0
"class Solution {     public int leastInterval(char[] tasks, int n) {         int[] taskCounts = new int[26];         // count frequency of each task         for (char task : tasks) {             taskCounts[task - 'A']++;         }         Arrays.sort(taskCounts);         int maxFrequency = taskCounts[25] - 1;         int idleSlots = maxFrequency * n;         for (int i = 24; i >= 0 && taskCounts[i] > 0; i--) {             idleSlots -= Math.min(maxFrequency, taskCounts[i]);         }         idleSlots = Math.max(0, idleSlots);         return tasks.length + idleSlots;     } }",0,,0,0,0
class MyCircularQueue {     private int[] buffer;     private int front;     private int rear;     private int size;          public MyCircularQueue(int k) {         buffer = new int[k];         front = -1;         rear = -1;         size = 0;     }          public boolean enQueue(int value) {         if (isFull()) {             return false;         } else if (isEmpty()) {             front = 0;         }         rear = (rear + 1) % buffer.length;         buffer[rear] = value;         size++;         return true;     }          public boolean deQueue() {         if (isEmpty()) {             return false;         } else if (front == rear) {             front = -1;             rear = -1;         } else {             front = (front + 1) % buffer.length;         }         size--;         return true;     }          public int Front() {         return isEmpty() ? -1 : buffer[front];     }          public int Rear() {         return isEmpty() ? -1 : buffer[rear];     }          public boolean isEmpty() {         return size == 0;     }          public boolean isFull() {         return size == buffer.length;     } } ,1,"622-design-circular-queue/MyCircularQueue.java:7:5: Redundant 'public' modifier. [RedundantModifier]
622-design-circular-queue/MyCircularQueue.java:3:	AvoidFieldNameMatchingMethodName:	Field front has the same name as a method
622-design-circular-queue/MyCircularQueue.java:4:	AvoidFieldNameMatchingMethodName:	Field rear has the same name as a method
622-design-circular-queue/MyCircularQueue.java:39:	MethodNamingConventions:	The instance method name 'Front' doesn't match '[a-z][a-zA-Z0-9]*'
622-design-circular-queue/MyCircularQueue.java:43:	MethodNamingConventions:	The instance method name 'Rear' doesn't match '[a-z][a-zA-Z0-9]*'
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public TreeNode addOneRow(TreeNode root, int val, int depth) {         if (depth == 1) {             return new TreeNode(val, root, null);         }                  Queue<TreeNode> queue = new LinkedList<>();         queue.offer(root);         int level = 1;          while (!queue.isEmpty() && level < depth - 1) {             int size = queue.size();             for (int i = 0; i < size; i++) {                 TreeNode cur = queue.poll();                 if (cur.left != null) {                     queue.offer(cur.left);                 }                 if (cur.right != null) {                     queue.offer(cur.right);                 }             }             level++;         }          while (!queue.isEmpty()) {             TreeNode cur = queue.poll();             TreeNode leftNode = new TreeNode(val, cur.left, null);             TreeNode rightNode = new TreeNode(val, null, cur.right);             cur.left = leftNode;             cur.right = rightNode;         }          return root;             } }",0,,0,0,0
class Solution {     public boolean judgeSquareSum(int c) {                  int left = 0;         int right = (int) Math.sqrt(c);                  while (left <= right) {             int sum = left * left + right * right;             if (sum == c) {                 return true;             } else if (sum > c) {                 right--;             } else {                 left++;             }         }                  return false;              } },0,,0,0,0
"import java.util.*;  class Solution {     public int[] exclusiveTime(int n, List<String> logs) {         Stack<Integer> stack = new Stack<>();         int[] res = new int[n];         int prevTime = 0;         for(String log : logs){             String[] arr = log.split("":"");             int id = Integer.parseInt(arr[0]);             boolean isStart = arr[1].equals(""start"");             int time = Integer.parseInt(arr[2]);              if(!stack.empty())                 res[stack.peek()] += time - prevTime;             prevTime = time;             if(isStart)                 stack.push(id);             else{                 res[stack.pop()]++;                 prevTime++;             }         }         return res;     } }",1,"636-exclusive-time-of-functions/Solution.java:5:	LooseCoupling:	Avoid using implementation types like 'Stack'; use the interface instead
636-exclusive-time-of-functions/Solution.java:5:	ReplaceVectorWithList:	Consider replacing this Vector with the newer java.util.List
636-exclusive-time-of-functions/Solution.java:5:	ReplaceVectorWithList:	Consider replacing this Vector with the newer java.util.List
636-exclusive-time-of-functions/Solution.java:11:	LiteralsFirstInComparisons:	Position literals first in String comparisons
",0,0,0
"class Solution {     public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {         return helper(price, special, needs, 0);     }          private int helper(List<Integer> price, List<List<Integer>> special, List<Integer> needs, int index) {         if (index == special.size()) {             // use the original price when there is no special offer available             int total = 0;             for (int i = 0; i < needs.size(); i++) {                 total += needs.get(i) * price.get(i);             }             return total;         }         // check if the current special can be applied         List<Integer> curSpecial = special.get(index);         boolean isValid = true;         for (int i = 0; i < needs.size(); i++) {             if (needs.get(i) < curSpecial.get(i)) {                 isValid = false;                 break;             }         }         int minPrice = Integer.MAX_VALUE;         if (isValid) {             // apply the current special offer             List<Integer> newNeeds = new ArrayList<>(needs);             for (int i = 0; i < needs.size(); i++) {                 newNeeds.set(i, newNeeds.get(i) - curSpecial.get(i));             }             minPrice = curSpecial.get(needs.size()) + helper(price, special, newNeeds, index);         }         // skip the current special offer         minPrice = Math.min(minPrice, helper(price, special, needs, index + 1));         return minPrice;     } }",0,,0,0,0
"class Solution {     public String solveEquation(String equation) {         String[] sides = equation.split(""="");         int[] left = evaluateExpression(sides[0]);         int[] right = evaluateExpression(sides[1]);         int coef = left[0] - right[0];         int val = right[1] - left[1];         if (coef == 0 && val == 0) {             return ""Infinite solutions"";         } else if (coef == 0) {             return ""No solution"";         } else {             int res = val / coef;             return ""x="" + res;         }     }          private int[] evaluateExpression(String exp) {         String[] tokens = exp.split(""(?=[-+])"");         int[] res = new int[2]; // 0 for x's coefficient, 1 for constant value         for (String token : tokens) {             if (token.equals(""+x"") || token.equals(""x"")) {                 res[0] += 1;             } else if (token.equals(""-x"")) {                 res[0] -= 1;             } else if (token.contains(""x"")) {                 res[0] += Integer.parseInt(token.substring(0, token.indexOf(""x"")));             } else {                 res[1] += Integer.parseInt(token);             }         }         return res;     } }",1,"640-solve-the-equation/Solution.java:22:	LiteralsFirstInComparisons:	Position literals first in String comparisons
640-solve-the-equation/Solution.java:22:	LiteralsFirstInComparisons:	Position literals first in String comparisons
640-solve-the-equation/Solution.java:24:	LiteralsFirstInComparisons:	Position literals first in String comparisons
640-solve-the-equation/Solution.java:27:	UseIndexOfChar:	String.indexOf(char) is faster than String.indexOf(String).
",0,0,0
class MyCircularDeque {     private int[] deque;     private int front;     private int rear;     private int size;     private int capacity;      public MyCircularDeque(int k) {         capacity = k;         size = 0;         front = 0;         rear = -1;         deque = new int[capacity];     }      public boolean insertFront(int value) {         if (isFull()) {             return false;         }         front = (front - 1 + capacity) % capacity;         deque[front] = value;         size++;         if (size == 1) {             rear = front;         }         return true;     }      public boolean insertLast(int value) {         if (isFull()) {             return false;         }         rear = (rear + 1) % capacity;         deque[rear] = value;         size++;         if (size == 1) {             front = rear;         }         return true;     }      public boolean deleteFront() {         if (isEmpty()) {             return false;         }         front = (front + 1) % capacity;         size--;         return true;     }      public boolean deleteLast() {         if (isEmpty()) {             return false;         }         rear = (rear - 1 + capacity) % capacity;         size--;         return true;     }      public int getFront() {         if (isEmpty()) {             return -1;         }         return deque[front];     }      public int getRear() {         if (isEmpty()) {             return -1;         }         return deque[rear];     }      public boolean isEmpty() {         return size == 0;     }      public boolean isFull() {         return size == capacity;     }  }  /**  * Your MyCircularDeque object will be instantiated and called as such:  * MyCircularDeque obj = new MyCircularDeque(k);  * boolean param_1 = obj.insertFront(value);  * boolean param_2 = obj.insertLast(value);  * boolean param_3 = obj.deleteFront();  * boolean param_4 = obj.deleteLast();  * int param_5 = obj.getFront();  * int param_6 = obj.getRear();  * boolean param_7 = obj.isEmpty();  * boolean param_8 = obj.isFull();  */,1,"641-design-circular-deque/MyCircularDeque.java:8:5: Redundant 'public' modifier. [RedundantModifier]
641-design-circular-deque/MyCircularDeque.java:8:5: Redundant 'public' modifier. [RedundantModifier]
",0,0,0
"class Solution {     public int findLongestChain(int[][] pairs) {         int n = pairs.length;         // Sorting the array based on the end value of the pairs         Arrays.sort(pairs, (a, b) -> Integer.compare(a[1], b[1]));         int count = 1, end = pairs[0][1];         for (int i = 1; i < n; i++) {             // If the next pair starts after the current pair ends, we can use this pair             if (pairs[i][0] > end) {                 count++;                 end = pairs[i][1];             }         }         return count;     } }  // The time complexity of this solution is O(n log n) due to sorting.",1,"646-maximum-length-of-pair-chain/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
646-maximum-length-of-pair-chain/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int countSubstrings(String s) {         int count = 0;                  for(int i=0;i<s.length();i++) {             for(int j=i+1;j<=s.length();j++) {                 if(isPalindrome(s.substring(i,j))) {                     count++;                 }             }         }                  return count;     }          private boolean isPalindrome(String s) {         int i=0, j=s.length()-1;         while(i<j) {             if(s.charAt(i) != s.charAt(j)) {                 return false;             }             i++;             j--;         }         return true;     } }",1,"647-palindromic-substrings/Solution.java:17:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
647-palindromic-substrings/Solution.java:17:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public String replaceWords(List<String> dictionary, String sentence) {         // Convert dictionary to a set for faster lookup         Set<String> rootSet = new HashSet<>(dictionary);                  // Split sentence into individual words         String[] words = sentence.split(""\\s+"");                  // Loop through each word in the sentence         for (int i = 0; i < words.length; i++) {             String word = words[i];             String root = """";                          // Check if the word has a root in the dictionary             for (int j = 1; j <= word.length(); j++) {                 String subWord = word.substring(0, j);                 if (rootSet.contains(subWord)) {                     // If the root is shorter than the current root or there is no root                     // for this word yet, replace it                     if (root.equals("""") || subWord.length() < root.length()) {                         root = subWord;                     }                 }             }                          // Replace the word with its root             if (!root.equals("""")) {                 words[i] = root;             }         }                  // Join the words back into a sentence         return String.join("" "", words);     } }",1,"648-replace-words/Solution.java:20:	CollapsibleIfStatements:	This if statement could be combined with its parent
648-replace-words/Solution.java:20:	LiteralsFirstInComparisons:	Position literals first in String comparisons
648-replace-words/Solution.java:27:	LiteralsFirstInComparisons:	Position literals first in String comparisons
",0,0,0
"class Solution {     public String predictPartyVictory(String senate) {         int n = senate.length();         int radiantCount = 0, direCount = 0;         // Count the number of Radiant and Dire Senators         for (int i = 0; i < n; i++) {             if (senate.charAt(i) == 'R') {                 radiantCount++;             } else {                 direCount++;             }         }         // Create arrays to keep track of which Senators have had their rights banned         boolean[] radiantBanned = new boolean[n];         boolean[] direBanned = new boolean[n];         int bans = 0;         // Keep removing Senators until only one party is left         while (radiantCount > 0 && direCount > 0) {             for (int i = 0; i < n; i++) {                 char party = senate.charAt(i);                 if (!radiantBanned[i] && !direBanned[i]) {                     // If the current Senator has not had their rights banned, ban the next Senator of the opposite party                     if (party == 'R') {                         if (direCount == 0) {                             // If no Dire Senators are left, Radiant wins                             return ""Radiant"";                         }                         direBanned[nextOpposite(i, n, direBanned, radiantBanned)] = true;                         direCount--;                         bans++;                     } else {                         if (radiantCount == 0) {                             // If no Radiant Senators are left, Dire wins                             return ""Dire"";                         }                         radiantBanned[nextOpposite(i, n, radiantBanned, direBanned)] = true;                         radiantCount--;                         bans++;                     }                 }             }         }         // If both parties have been eliminated, the game is a tie         return radiantCount > 0 ? ""Radiant"" : ""Dire"";     }          // Helper function to find the index of the next unbanned Senator of the opposite party     private int nextOpposite(int index, int n, boolean[] partyBanned, boolean[] otherPartyBanned) {         int i = (index + 1) % n;         while (true) {             if (!partyBanned[i] && otherPartyBanned[i]) {                 return i;             }             i = (i + 1) % n;         }     } }",1,"649-dota2-senate/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
649-dota2-senate/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
649-dota2-senate/Solution.java:16:	UnusedLocalVariable:	Avoid unused local variables such as 'bans'.
",1,0,0
class Solution {     public int minSteps(int n) {         int result = 0;         int factor = 2;                  while(n > 1){             if(n%factor == 0){                 result += factor;                 n /= factor;             }else{                 factor++;             }         }                  return result;     } },1,"650-2-keys-keyboard/Solution.java:9:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
",0,1,0
"import java.util.*;  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public List<TreeNode> findDuplicateSubtrees(TreeNode root) {         List<TreeNode> result = new ArrayList<>();         Map<String, Integer> map = new HashMap<>();         traverse(root, map, result);         return result;     }          private String traverse(TreeNode node, Map<String, Integer> map, List<TreeNode> result) {         if (node == null) {             return ""#"";         }         String serial = node.val + "","" + traverse(node.left, map, result) + "","" + traverse(node.right, map, result);         if (map.getOrDefault(serial, 0) == 1) {             result.add(node);         }         map.put(serial, map.getOrDefault(serial, 0) + 1);         return serial;     } }",1,"652-find-duplicate-subtrees/TreeNode.java:21:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {          public TreeNode constructMaxBinaryTree(int[] nums) {         return constructMaxBinaryTree(nums, 0, nums.length - 1); // start recursion with whole array     }          private TreeNode constructMaxBinaryTree(int[] nums, int start, int end) {         if (start > end) { // if start is greater than end             return null;         }                  int index = findMaxIndex(nums, start, end); // find the index of the maximum value in the range                  TreeNode root = new TreeNode(nums[index]); // create a new TreeNode with the maximum value as the root                  root.left = constructMaxBinaryTree(nums, start, index - 1); // set the left child of the root                  root.right = constructMaxBinaryTree(nums, index + 1, end); // set the right child of the root                  return root; // return the root node of the Binary Tree     }          private int findMaxIndex(int[] nums, int start, int end) {         int maxIndex = start;         for (int i = start; i <= end; i++) {             if (nums[i] > nums[maxIndex]) { // if current value is greater than max value so far                 maxIndex = i;             }         }         return maxIndex; // return the index of the maximum value in the range     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public List<List<String>> printTree(TreeNode root) {         int height = getHeight(root);         int width = (int) (Math.pow(2, height) - 1);         List<List<String>> res = new ArrayList<>();         for (int i = 0; i < height; i++) {             ArrayList<String> cur = new ArrayList<>();             for (int j = 0; j < width; j++) {                 cur.add("""");             }             res.add(cur);         }         fill(root, res, 0, 0, width - 1);         return res;     }          private void fill(TreeNode node, List<List<String>> res, int height, int left, int right) {         if (node == null) {             return;         }         res.get(height).set((left + right) / 2, String.valueOf(node.val));         fill(node.left, res, height + 1, left, (left + right) / 2 - 1);         fill(node.right, res, height + 1, (left + right) / 2 + 1, right);     }          private int getHeight(TreeNode node) {         if (node == null) {             return 0;         }         return 1 + Math.max(getHeight(node.left), getHeight(node.right));     } }",0,,0,0,0
"import java.util.ArrayList; import java.util.List;  class Solution {     public List<Integer> findClosestElements(int[] arr, int k, int x) {         int left = 0;         int right = arr.length - k;         while (left < right) {             int mid = (left + right) / 2;             if (x - arr[mid] > arr[mid + k] - x) {                 left = mid + 1;             } else {                 right = mid;             }         }         List<Integer> result = new ArrayList<>(k);         for (int i = left; i < left + k; i++) {             result.add(arr[i]);         }         return result;     } }",0,,0,0,0
"class Solution {     public boolean isPossible(int[] nums) {         //initialize a map to store the frequency of each number         Map<Integer, Integer> freq = new HashMap<>();         //initialize a map to store the frequency of each consecutive ending sequence         Map<Integer, Integer> consecutiveEndingFreq = new HashMap<>();                  //count the frequency of each number         for(int num: nums){             freq.put(num, freq.getOrDefault(num, 0) + 1);         }                  for(int num: nums){             //if num has been used (i.e. its frequency is already 0), then continue to the next number             if(freq.get(num) == 0){                 continue;             }             //if there's already a consecutive sequence ending at num-1, then append num to that sequence             else if(consecutiveEndingFreq.getOrDefault(num-1, 0) > 0){                 //decrement the frequency of num and the consecutive sequence ending at num-1                 freq.put(num, freq.get(num) - 1);                 consecutiveEndingFreq.put(num-1, consecutiveEndingFreq.get(num-1) - 1);                 //increment the frequency of the consecutive sequence ending at num                 consecutiveEndingFreq.put(num, consecutiveEndingFreq.getOrDefault(num, 0) + 1);             }             //if num can start a new sequence and the next two numbers are also present, then create a new sequence             else if(freq.getOrDefault(num+1, 0) > 0 && freq.getOrDefault(num+2,0) > 0){                 //decrement the frequency of num, num+1, and num+2                 freq.put(num, freq.get(num) - 1);                 freq.put(num+1, freq.get(num+1) - 1);                 freq.put(num+2, freq.get(num+2) - 1);                 //increment the frequency of the consecutive sequence ending at num+2                 consecutiveEndingFreq.put(num+2, consecutiveEndingFreq.getOrDefault(num+2, 0) + 1);             }             //if none of the above conditions are true, then it is impossible to create the required sequences             else{                 return false;             }         }         //if all numbers have been used to create the required sequences, then return true         return true;     } }",1,"659-split-array-into-consecutive-subsequences/Solution.java:17:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
659-split-array-into-consecutive-subsequences/Solution.java:25:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
659-split-array-into-consecutive-subsequences/Solution.java:34:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
659-split-array-into-consecutive-subsequences/Solution.java:17:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
659-split-array-into-consecutive-subsequences/Solution.java:25:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
659-split-array-into-consecutive-subsequences/Solution.java:34:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public int widthOfBinaryTree(TreeNode root) {         if (root == null) {             return 0;         }         Queue<NodeData> queue = new LinkedList<>();         queue.offer(new NodeData(root, 0, 0));         int curDepth = 0, left = 0, ans = 0;         while (!queue.isEmpty()) {             NodeData data = queue.poll();             if (data.node != null) {                 queue.offer(new NodeData(data.node.left, data.depth + 1, data.pos * 2));                 queue.offer(new NodeData(data.node.right, data.depth + 1, data.pos * 2 + 1));                 if (curDepth != data.depth) {                     curDepth = data.depth;                     left = data.pos;                 }                 ans = Math.max(ans, data.pos - left + 1);             }         }         return ans;     }          private static class NodeData {         TreeNode node;         int depth;         int pos;                  public NodeData(TreeNode node, int depth, int pos) {             this.node = node;             this.depth = depth;             this.pos = pos;         }     } }",1,"662-maximum-width-of-binary-tree/TreeNode.java:23:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
662-maximum-width-of-binary-tree/TreeNode.java:40:18: Variable 'node' must be private and have accessor methods. [VisibilityModifier]
662-maximum-width-of-binary-tree/TreeNode.java:41:13: Variable 'depth' must be private and have accessor methods. [VisibilityModifier]
662-maximum-width-of-binary-tree/TreeNode.java:42:13: Variable 'pos' must be private and have accessor methods. [VisibilityModifier]
662-maximum-width-of-binary-tree/TreeNode.java:44:9: Redundant 'public' modifier. [RedundantModifier]
662-maximum-width-of-binary-tree/TreeNode.java:44:34: 'node' hides a field. [HiddenField]
662-maximum-width-of-binary-tree/TreeNode.java:44:44: 'depth' hides a field. [HiddenField]
662-maximum-width-of-binary-tree/TreeNode.java:44:55: 'pos' hides a field. [HiddenField]
662-maximum-width-of-binary-tree/TreeNode.java:23:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
662-maximum-width-of-binary-tree/TreeNode.java:40:18: Variable 'node' must be private and have accessor methods. [VisibilityModifier]
662-maximum-width-of-binary-tree/TreeNode.java:41:13: Variable 'depth' must be private and have accessor methods. [VisibilityModifier]
662-maximum-width-of-binary-tree/TreeNode.java:42:13: Variable 'pos' must be private and have accessor methods. [VisibilityModifier]
662-maximum-width-of-binary-tree/TreeNode.java:44:9: Redundant 'public' modifier. [RedundantModifier]
662-maximum-width-of-binary-tree/TreeNode.java:44:34: 'node' hides a field. [HiddenField]
662-maximum-width-of-binary-tree/TreeNode.java:44:44: 'depth' hides a field. [HiddenField]
662-maximum-width-of-binary-tree/TreeNode.java:44:55: 'pos' hides a field. [HiddenField]
",1,0,0
"class Solution {     public boolean checkPossibility(int[] nums) {         // Initialize a counter variable to keep track of number of modifications required         int count = 0;                  // Iterate through the array from index 1 to n-1         for(int i=1; i<nums.length; i++){             // Check if the previous element is greater than the current element             if(nums[i-1] > nums[i]){                 // If count is already 1, then we need to modify more than one element to make the array non-decreasing                 if(count == 1){                     return false;                 }                 // If we are at first index, then simply modify this element to be equal to the current one                 if(i==1){                     nums[i-1] = nums[i];                 }                 // If the previous element is greater than the element at index i-2, then modify the current element to be equal to the previous one                 else if(nums[i-2] <= nums[i]){                     nums[i-1] = nums[i];                 }                 // Otherwise, modify the previous element to be equal to the current one                 else{                     nums[i] = nums[i-1];                 }                 // Increment the count variable                 count++;             }         }         // If we reach here without returning false, then we can modify at most one element to make the array non-decreasing         return true;     } }",1,"665-non-decreasing-array/Solution.java:17:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
665-non-decreasing-array/Solution.java:21:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
665-non-decreasing-array/Solution.java:17:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
665-non-decreasing-array/Solution.java:21:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
"class Solution {     public int[] constructArray(int n, int k) {         int[] arr = new int[n];         int i = 0, small = 1, big = n;         while(i < k){             arr[i++] = small++;             if(i < k) arr[i++] = big--;         }         if(k % 2 == 0){             while(i < n) arr[i++] = big--;         }         else{             while(i < n) arr[i++] = small++;         }         return arr;     } }",1,"667-beautiful-arrangement-ii/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
667-beautiful-arrangement-ii/Solution.java:11:9: '}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
667-beautiful-arrangement-ii/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
667-beautiful-arrangement-ii/Solution.java:11:9: '}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",1,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val = val;}  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public TreeNode trimBST(TreeNode root, int low, int high) {         if (root == null) {             return null;         }         if (root.val < low) {             return trimBST(root.right, low, high);         }         if (root.val > high) {             return trimBST(root.left, low, high);         }         root.left = trimBST(root.left, low, high);         root.right = trimBST(root.right, low, high);         return root;     } }",0,,0,0,0
class Solution {     public int maximumSwap(int num) {         char[] numCharArr = Integer.toString(num).toCharArray();         int[] lastOccurence = new int[10];         for (int i = 0; i < numCharArr.length; i++) {             lastOccurence[numCharArr[i] - '0'] = i;         }         for (int i = 0; i < numCharArr.length; i++) {             int numVal = numCharArr[i] - '0';             for (int j = 9; j > numVal; j--) {                 if (lastOccurence[j] > i) {                     char temp = numCharArr[i];                     numCharArr[i] = numCharArr[lastOccurence[j]];                     numCharArr[lastOccurence[j]] = temp;                     return Integer.parseInt(new String(numCharArr));                 }             }         }         return num;     } },1,"670-maximum-swap/Solution.java:15:	StringInstantiation:	Avoid instantiating String objects; this is usually unnecessary.
",0,0,0
"class Solution {     public int flipLights(int n, int presses) {         // We can ignore presses > 3 because pressing any button 4 times is equivalent         // to pressing it 0, 1, 2, or 3 times. Also, pressing any button 2 times is         // equivalent to pressing it twice.         presses = Math.min(presses, 3);                  // We can also ignore n >= 6 because the pattern repeats every 6 bulbs. For         // example, pressing button 1 on bulbs 1-6 is equivalent to pressing button 1         // on bulbs 7-12 and so on.         n = Math.min(n, 6);                  boolean[] state = new boolean[n];         for (int i = 0; i < n; i++) {             state[i] = true;         }                  if (presses >= 1) {             flipAll(state);         }         if (presses >= 2) {             flipEven(state);         }         if (presses >= 3) {             flipOdd(state);         }                  if (n == 1) {             return 2; // There are only two possible states for one bulb         } else if (n == 2) {             return state[0] && state[1] || !state[0] && !state[1] ? 1 : 2;             // There is only one possible state for two bulbs if they are the same,             // otherwise there are two possible states         } else {             return count(state);             // Count the number of different possible states for three or more bulbs         }     }          // Flip the status of all bulbs     private void flipAll(boolean[] state) {         for (int i = 0; i < state.length; i++) {             state[i] = !state[i];         }     }          // Flip the status of all bulbs with even labels     private void flipEven(boolean[] state) {         for (int i = 1; i < state.length; i += 2) {             state[i] = !state[i];         }     }          // Flip the status of all bulbs with odd labels     private void flipOdd(boolean[] state) {         for (int i = 0; i < state.length; i += 2) {             state[i] = !state[i];         }     }          // Flip the status of all bulbs with a label j = 3k + 1     private void flipMod3kPlus1(boolean[] state) {         for (int i = 0; i < state.length; i += 3) {             state[i] = !state[i];         }     }          // Count the number of different possible states     private int count(boolean[] state) {         Set<String> set = new HashSet<>();         for (int i = 0; i < 6; i++) { // The pattern repeats every 6 bulbs             if (i % 2 == 0) {                 flipEven(state);             }             if (i % 3 == 0) {                 flipOdd(state);             }             if (i % 3 == 1) {                 flipMod3kPlus1(state);             }             set.add(Arrays.toString(state));         }         return set.size();     } }",1,"672-bulb-switcher-ii/Solution.java:6:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'presses'
672-bulb-switcher-ii/Solution.java:11:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
",0,1,0
"class Solution {     public int findNumberOfLIS(int[] nums) {         if (nums == null || nums.length == 0) {             return 0;         }         int n = nums.length;         int[] dp = new int[n];         int[] count = new int[n];         Arrays.fill(dp, 1);         Arrays.fill(count, 1);         int max = 1, result = 0;         for (int i = 1; i < n; i++) {             for (int j = 0; j < i; j++) {                 if (nums[i] > nums[j]) {                     if (dp[j] + 1 > dp[i]) {                         dp[i] = dp[j] + 1;                         count[i] = count[j];                     } else if (dp[j] + 1 == dp[i]) {                         count[i] += count[j];                     }                 }             }             max = Math.max(max, dp[i]);         }         for (int i = 0; i < n; i++) {             if (dp[i] == max) {                 result += count[i];             }         }         return result;     } }",1,"673-number-of-longest-increasing-subsequence/Solution.java:11:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
673-number-of-longest-increasing-subsequence/Solution.java:11:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
import java.util.*;  class MagicDictionary {     // HashSet to store the words in the dictionary     private Set<String> dict;      public MagicDictionary() {         dict = new HashSet<>();     }      public void buildDict(String[] dictionary) {         for (String word : dictionary) {             dict.add(word);         }     }      public boolean search(String searchWord) {         // Check if we can change exactly one character to match any word         for (String word : dict) {             if (searchWord.length() == word.length()) {                 int diff = 0;                 for (int i = 0; i < searchWord.length(); i++) {                     if (searchWord.charAt(i) != word.charAt(i)) {                         diff++;                     }                     if (diff > 1) {                         break;                     }                 }                 if (diff == 1) {                     return true;                 }             }         }         return false;     } }  /**  * Your MagicDictionary object will be instantiated and called as such:  * MagicDictionary obj = new MagicDictionary();  * obj.buildDict(dictionary);  * boolean param_2 = obj.search(searchWord);  */,1,"676-implement-magic-dictionary/MagicDictionary.java:7:5: Redundant 'public' modifier. [RedundantModifier]
676-implement-magic-dictionary/MagicDictionary.java:7:5: Redundant 'public' modifier. [RedundantModifier]
676-implement-magic-dictionary/MagicDictionary.java:13:	UseArraysAsList:	Use asList instead of tight loops
",0,0,0
"import java.util.HashMap; import java.util.Map;  class MapSum {      private Map<String, Integer> map;      public MapSum() {         map = new HashMap<>();     }          public void insert(String key, int val) {         map.put(key, val);     }          public int sum(String prefix) {         int sum = 0;         for (String key : map.keySet()) {             if (key.startsWith(prefix)) {                 sum += map.get(key);             }         }         return sum;     }      public static void main(String[] args) {         MapSum mapSum = new MapSum();         mapSum.insert(""apple"", 3);         System.out.println(mapSum.sum(""ap"")); // Expected output: 3         mapSum.insert(""app"", 2);         System.out.println(mapSum.sum(""ap"")); // Expected output: 5     }  }",1,"677-map-sum-pairs/MapSum.java:8:5: Redundant 'public' modifier. [RedundantModifier]
677-map-sum-pairs/MapSum.java:8:5: Redundant 'public' modifier. [RedundantModifier]
",0,0,0
"class Solution {     public boolean checkValidString(String s) {         int lo = 0, hi = 0;         for(char c: s.toCharArray()){             lo += c == '(' ? 1 : -1;             hi += c != ')' ? 1 : -1;             if(hi < 0) break;             lo = Math.max(lo, 0);         }         return lo == 0;     } }",1,"678-valid-parenthesis-string/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
678-valid-parenthesis-string/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
678-valid-parenthesis-string/Solution.java:6:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",1,0,0
"class Solution {     public int[] findRedundantConnection(int[][] edges) {         int[] parent = new int[edges.length+1];         for(int i=0; i<parent.length; i++){             parent[i] = i;         }         for(int[] edge: edges){             int from = edge[0], to = edge[1];             if(find(parent, from) == find(parent, to)){                 return edge;             }             parent[find(parent, from)] = find(parent, to);         }         return new int[2];     }          private int find(int[] parent, int node){         while(node != parent[node]){             parent[node] = parent[parent[node]];             node = parent[node];         }         return node;     } }",1,"684-redundant-connection/Solution.java:8:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
684-redundant-connection/Solution.java:8:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
684-redundant-connection/Solution.java:20:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'node'
",1,1,0
"class Solution {     public int repeatedStringMatch(String a, String b) {         int count = 1;         StringBuilder sb = new StringBuilder(a);                  while (sb.length() < b.length()) {             sb.append(a);             count++;         }                  if (sb.indexOf(b) != -1) {             return count;         }                  sb.append(a);         count++;                  if (sb.indexOf(b) != -1) {             return count;         }                  return -1;     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     int ans;     public int longestUnivaluePath(TreeNode root) {         ans = 0;         arrowLength(root);         return ans;     }     public int arrowLength(TreeNode node) {         if (node == null) return 0;         int left = arrowLength(node.left);         int right = arrowLength(node.right);         int arrowLeft = 0, arrowRight = 0;         if (node.left != null && node.left.val == node.val) {             arrowLeft += left + 1;         }         if (node.right != null && node.right.val == node.val) {             arrowRight += right + 1;         }         ans = Math.max(ans, arrowLeft + arrowRight);         return Math.max(arrowLeft, arrowRight);     } }",1,"687-longest-univalue-path/TreeNode.java:17:9: Variable 'ans' must be private and have accessor methods. [VisibilityModifier]
687-longest-univalue-path/TreeNode.java:27:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
687-longest-univalue-path/TreeNode.java:17:9: Variable 'ans' must be private and have accessor methods. [VisibilityModifier]
687-longest-univalue-path/TreeNode.java:27:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     private static final int[][] moves = {{-2, -1}, {-1, -2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}};          public double knightProbability(int n, int k, int row, int column) {         double[][] dp = new double[n][n];         dp[row][column] = 1.0;         for (int s = 1; s <= k; s++) {             double[][] dp2 = new double[n][n];             for (int i = 0; i < n; i++) {                 for (int j = 0; j < n; j++) {                     for (int[] move : moves) {                         int row2 = i + move[0];                         int col2 = j + move[1];                         if (row2 >= 0 && row2 < n && col2 >= 0 && col2 < n) {                             dp2[row2][col2] += dp[i][j] / 8.0;                         }                     }                 }             }             dp = dp2;         }         double res = 0.0;         for (double[] rowDp : dp) {             for (double p : rowDp) {                 res += p;             }         }         return res;     } }",0,,0,0,0
"// Definition for Employee. class Employee {     public int id;     public int importance;     public List<Integer> subordinates; }  class Solution {     public int getImportance(List<Employee> employees, int id) {         // create a hash map to store all employees with their IDs         Map<Integer, Employee> employeeMap = new HashMap<>();         for (Employee e : employees) {             employeeMap.put(e.id, e);         }                  // recursively get the importance of the employee and all their subordinates         return getImportanceHelper(employeeMap, id);     }          private int getImportanceHelper(Map<Integer, Employee> employeeMap, int id) {         Employee e = employeeMap.get(id);         int importance = e.importance;         for (int sub : e.subordinates) {             importance += getImportanceHelper(employeeMap, sub);         }         return importance;     } }",1,"690-employee-importance/Employee.java:3:16: Variable 'id' must be private and have accessor methods. [VisibilityModifier]
690-employee-importance/Employee.java:4:16: Variable 'importance' must be private and have accessor methods. [VisibilityModifier]
690-employee-importance/Employee.java:5:26: Variable 'subordinates' must be private and have accessor methods. [VisibilityModifier]
690-employee-importance/Employee.java:3:16: Variable 'id' must be private and have accessor methods. [VisibilityModifier]
690-employee-importance/Employee.java:4:16: Variable 'importance' must be private and have accessor methods. [VisibilityModifier]
690-employee-importance/Employee.java:5:26: Variable 'subordinates' must be private and have accessor methods. [VisibilityModifier]
",0,0,0
"import java.util.*;  class Solution {     public List<String> topKFrequent(String[] words, int k) {         // Create a HashMap to store the frequency of each word         Map<String, Integer> map = new HashMap<>();         for (String word : words) {             map.put(word, map.getOrDefault(word, 0) + 1);         }                  // Create a PriorityQueue of size k to store the k most frequent words         PriorityQueue<String> pq = new PriorityQueue<>(new Comparator<String>() {             public int compare(String s1, String s2) {                 if (map.get(s1) == map.get(s2)) {                     return s2.compareTo(s1); // If the frequencies are equal, sort by lexicographical order                 } else {                     return map.get(s1) - map.get(s2); // Sort by frequency                 }             }         });                  for (String word : map.keySet()) {             pq.offer(word);             if (pq.size() > k) { // If the size of pq is greater than k, remove the least frequent word                 pq.poll();             }         }                  // Create a List to store the k most frequent words         List<String> result = new ArrayList<>();         while (!pq.isEmpty()) {             result.add(0, pq.poll()); // Add each word to the beginning of the List, since we are removing from the end of the PriorityQueue         }                  return result;     } }",1,"692-top-k-frequent-words/Solution.java:6:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
692-top-k-frequent-words/Solution.java:12:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
692-top-k-frequent-words/Solution.java:12:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new Comparator<>()`
692-top-k-frequent-words/Solution.java:13:	MissingOverride:	The method 'compare(String, String)' is missing an @Override annotation.
692-top-k-frequent-words/Solution.java:14:	CompareObjectsWithEquals:	Use equals() to compare object references.
",0,0,0
"class Solution {     public int maxAreaOfIsland(int[][] grid) {         int maxArea = 0;         for (int i = 0; i < grid.length; i++) {             for (int j = 0; j < grid[i].length; j++) {                 if (grid[i][j] == 1) {                     int area = findIslandArea(grid, i, j);                     maxArea = Math.max(maxArea, area);                 }             }         }         return maxArea;     }      private int findIslandArea(int[][] grid, int i, int j) {         if (i < 0 || i >= grid.length || j < 0 || j >= grid[i].length || grid[i][j] == 0) {             return 0;         }         grid[i][j] = 0;         int area = 1;         area += findIslandArea(grid, i + 1, j);         area += findIslandArea(grid, i - 1, j);         area += findIslandArea(grid, i, j + 1);         area += findIslandArea(grid, i, j - 1);         return area;     } }",0,,0,0,0
"class Solution {     public boolean canPartitionKSubsets(int[] nums, int k) {         int sum = 0;         for(int num : nums) {             sum += num;         }                  if(k <= 0 || sum % k != 0) { // it is not possible to divide the numbers equally             return false;         }                  boolean[] visited = new boolean[nums.length]; // visited array to keep track of used elements         return canPartition(nums, visited, 0, k, 0, sum/k);      }          public boolean canPartition(int[] nums, boolean[] visited, int startIndex, int k, int currentSum, int targetSum) {         if(k == 1) { // for k=1, we'll always have only one group, so no need to check further             return true;         }                  if(currentSum == targetSum) { // found one subset, now move to next subset             return canPartition(nums, visited, 0, k-1, 0, targetSum);         }                  for(int i=startIndex; i<nums.length; i++) {             if(!visited[i]) {                 visited[i] = true; // mark the element as used                 if(canPartition(nums, visited, i+1, k, currentSum+nums[i], targetSum)) {                     return true;                 }                 visited[i] = false; // unmark the element to try other combinations             }         }         return false; // unable to partition the array     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public TreeNode insertIntoBST(TreeNode root, int val) {         if (root == null) { // if root is null             root = new TreeNode(val); // create a new Node with the given val             return root;         }         if (val < root.val) { // if val is less than the root val             root.left = insertIntoBST(root.left, val); // insert it in the left subtree         } else { // if val is greater than or equal to the root value             root.right = insertIntoBST(root.right, val); // insert it in the right subtree         }         return root; // return the root     } }",1,"701-insert-into-a-binary-search-tree/TreeNode.java:19:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'root'
",0,1,0
"class MyLinkedList {      private static class ListNode {         int val;         ListNode next;          public ListNode(int val) {             this.val = val;         }     }      private ListNode head;     private int size;      public MyLinkedList() {         head = null;         size = 0;     }      public int get(int index) {         if (index >= size) {             return -1;         }         ListNode curr = head;         for (int i = 0; i < index; i++) {             curr = curr.next;         }         return curr.val;     }      public void addAtHead(int val) {         ListNode newNode = new ListNode(val);         newNode.next = head;         head = newNode;         size++;     }          public void addAtTail(int val) {         if (head == null) {             addAtHead(val);             return;         }         ListNode newNode = new ListNode(val);         ListNode curr = head;         while (curr.next != null) {             curr = curr.next;         }         curr.next = newNode;         size++;     }      public void addAtIndex(int index, int val) {         if (index > size) {             return;         }         if (index == 0) {             addAtHead(val);             return;         }         if (index == size) {             addAtTail(val);             return;         }         ListNode newNode = new ListNode(val);         ListNode curr = head;         for (int i = 0; i < index - 1; i++) {             curr = curr.next;         }         newNode.next = curr.next;         curr.next = newNode;         size++;     }      public void deleteAtIndex(int index) {         if (index >= size) {             return;         }         if (index == 0) {             head = head.next;             size--;             return;         }         ListNode curr = head;         for (int i = 0; i < index - 1; i++) {             curr = curr.next;         }         curr.next = curr.next.next;         size--;     } } ",1,"707-design-linked-list/MyLinkedList.java:4:13: Variable 'val' must be private and have accessor methods. [VisibilityModifier]
707-design-linked-list/MyLinkedList.java:5:18: Variable 'next' must be private and have accessor methods. [VisibilityModifier]
707-design-linked-list/MyLinkedList.java:7:9: Redundant 'public' modifier. [RedundantModifier]
707-design-linked-list/MyLinkedList.java:7:29: 'val' hides a field. [HiddenField]
707-design-linked-list/MyLinkedList.java:15:5: Redundant 'public' modifier. [RedundantModifier]
707-design-linked-list/MyLinkedList.java:12:	FieldDeclarationsShouldBeAtStartOfClass:	Fields should be declared at the top of the class, before any method declarations, constructors, initializers or inner classes.
707-design-linked-list/MyLinkedList.java:13:	FieldDeclarationsShouldBeAtStartOfClass:	Fields should be declared at the top of the class, before any method declarations, constructors, initializers or inner classes.
707-design-linked-list/MyLinkedList.java:16:	NullAssignment:	Assigning an Object to null is a code smell.  Consider refactoring.
",0,0,0
"class Solution {     public int minimumDeleteSum(String s1, String s2) {         int m = s1.length(), n = s2.length();         int[][] dp = new int[m + 1][n + 1];                  for (int i = 1; i <= m; i++) {             dp[i][0] = dp[i-1][0] + s1.charAt(i-1);         }         for (int j = 1; j <= n; j++) {             dp[0][j] = dp[0][j-1] + s2.charAt(j-1);         }                  for (int i = 1; i <= m; i++) {             for (int j = 1; j <= n; j++) {                 if (s1.charAt(i-1) == s2.charAt(j-1)) {                     dp[i][j] = dp[i-1][j-1];                 } else {                     dp[i][j] = Math.min(dp[i-1][j] + s1.charAt(i-1), dp[i][j-1] + s2.charAt(j-1));                 }             }         }         return dp[m][n];     } }",1,"712-minimum-ascii-delete-sum-for-two-strings/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
712-minimum-ascii-delete-sum-for-two-strings/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int numSubarrayProductLessThanK(int[] nums, int k) {         if (k <= 1) return 0; // If k is less than or equal to 1, no subarray will have a product less than it.                  int count = 0, prod = 1, left = 0;         for (int right = 0; right < nums.length; right++) {             prod *= nums[right]; // Update the product of the subarray by multiplying it with the new number             while (prod >= k) { // As soon as the product exceeds k, we need to remove the left most element in the subarray to make the product less than k                 prod /= nums[left];                 left++;             }             count += (right - left + 1); // Counting all the subarrays that have the current right element as the last element         }                  return count;     } }",1,"713-subarray-product-less-than-k/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
713-subarray-product-less-than-k/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int maxProfit(int[] prices, int fee) {         int n = prices.length;         int cash = 0; // store the maximum profit when there is no stock in hand         int hold = -prices[0]; // store the maximum profit when there is stock in hand         for (int i = 1; i < n; i++) {             // if we sell the stock on the current day, we will get the current stock price minus the fees              cash = Math.max(cash, hold + prices[i] - fee);             // if we continue to hold the stock, the profit will remain the same             hold = Math.max(hold, cash - prices[i]);         }         return cash;     } }",0,,0,0,0
"class Solution {     public int findLength(int[] nums1, int[] nums2) {         int n1 = nums1.length;         int n2 = nums2.length;                  int[][] dp = new int[n1 + 1][n2 + 1];         int max = 0;                  for (int i = 1; i <= n1; i++) {             for (int j = 1; j <= n2; j++) {                 if (nums1[i - 1] == nums2[j - 1]) {                     dp[i][j] = dp[i - 1][j - 1] + 1;                     max = Math.max(max, dp[i][j]);                 }             }         }                  return max;     } }",0,,0,0,0
"class Solution {     public String longestWord(String[] words) {         // Sort the array lexicographically         Arrays.sort(words);                  // A hashset to keep track of valid prefixes         HashSet<String> prefixes = new HashSet<>();                  // Initialize the result with an empty string         String result = """";                  // Iterate through the words         for (String word : words) {             // If the word is only one character or its prefix is already in the set, we can add it to the set             if (word.length() == 1 || prefixes.contains(word.substring(0, word.length() - 1))) {                 prefixes.add(word); // Add the word to the set                 if (word.length() > result.length()) {                     result = word; // Update the result if the current word is longer                 }             }         }                  return result;     } }",0,,0,0,0
"import java.util.*;  class Solution {     public List<List<String>> accountsMerge(List<List<String>> accounts) {         Map<String, String> emailToName = new HashMap<>();         Map<String, ArrayList<String>> graph = new HashMap<>();          for (List<String> account : accounts) {             String name = account.get(0);             String firstEmail = account.get(1);             for (int i = 1; i < account.size(); i++) {                 String email = account.get(i);                 emailToName.put(email, name);                 if (!graph.containsKey(email)) {                     graph.put(email, new ArrayList<String>());                 }                 if (i == 1) {                     continue;                 }                 String prevEmail = account.get(i - 1);                 graph.get(prevEmail).add(email);                 graph.get(email).add(prevEmail);             }         }          Set<String> visited = new HashSet<>();         List<List<String>> ans = new ArrayList<>();         for (String email : emailToName.keySet()) {             if (visited.add(email)) {                 List<String> component = new ArrayList<>();                 component.add(emailToName.get(email));                 Stack<String> stack = new Stack<>();                 stack.push(email);                 while (!stack.empty()) {                     String node = stack.pop();                     component.add(node);                     for (String nei : graph.get(node)) {                         if (visited.add(nei)) {                             stack.push(nei);                         }                     }                 }                 Collections.sort(component);                 ans.add(component);             }         }          return ans;         } }",1,"721-accounts-merge/Solution.java:5:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
721-accounts-merge/Solution.java:6:	LooseCoupling:	Avoid using implementation types like 'ArrayList'; use the interface instead
721-accounts-merge/Solution.java:6:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
721-accounts-merge/Solution.java:10:	UnusedLocalVariable:	Avoid unused local variables such as 'firstEmail'.
721-accounts-merge/Solution.java:15:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new ArrayList<>()`
721-accounts-merge/Solution.java:32:	LooseCoupling:	Avoid using implementation types like 'Stack'; use the interface instead
721-accounts-merge/Solution.java:32:	ReplaceVectorWithList:	Consider replacing this Vector with the newer java.util.List
721-accounts-merge/Solution.java:32:	ReplaceVectorWithList:	Consider replacing this Vector with the newer java.util.List
",0,0,0
class Solution {     public List<String> removeComments(String[] source) {         List<String> result = new ArrayList<String>();         StringBuilder stringBuilder = new StringBuilder();         boolean inBlockComment = false;         for (String line : source) {             int i = 0;             char[] charArray = line.toCharArray();             if (!inBlockComment) {                 stringBuilder = new StringBuilder();             }             while (i < line.length()) {                 if (!inBlockComment && i+1 < line.length() && line.charAt(i) == '/' && line.charAt(i+1) == '/') {                     // Line comment found                     break;                 } else if (!inBlockComment && i+1 < line.length() && line.charAt(i) == '/' && line.charAt(i+1) == '*') {                     // Block comment found                     inBlockComment = true;                     i++;                 } else if (inBlockComment && i+1 < line.length() && line.charAt(i) == '*' && line.charAt(i+1) == '/') {                     // End of block comment found                     inBlockComment = false;                     i++;                 } else if (!inBlockComment) {                     // Regular character                     stringBuilder.append(line.charAt(i));                 }                 i++;             }             if (!inBlockComment && stringBuilder.length() > 0) {                 result.add(stringBuilder.toString());             }         }         return result;     } },1,"722-remove-comments/Solution.java:8:	UnusedLocalVariable:	Avoid unused local variables such as 'charArray'.
",0,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public ListNode[] splitListToParts(ListNode head, int k) {         ListNode[] result = new ListNode[k];         int size = 0;         ListNode curr = head;         while(curr != null){             size++;             curr = curr.next;         }         int remainder = size % k;         int partSize = size / k;         curr = head;         for(int i = 0; i < k; i++){             ListNode newHead = curr;             for(int j = 0; j < partSize + (remainder > 0 ? 1 : 0) - 1; j++){                 if(curr != null){                     curr = curr.next;                 }             }             if(curr != null){                 ListNode prev = curr;                 curr = curr.next;                 prev.next = null;             }             remainder--;             result[i] = newHead;         }         return result;     } }",1,"725-split-linked-list-in-parts/ListNode.java:33:	NullAssignment:	Assigning an Object to null is a code smell.  Consider refactoring.
",0,0,0
"class MyCalendar {     List<int[]> bookings;      public MyCalendar() {         bookings = new ArrayList<>();     }          public boolean book(int start, int end) {         for (int[] booking : bookings) {             if (booking[0] < end && start < booking[1]) {                 return false;             }         }         bookings.add(new int[] {start, end});         return true;     } }  /**  * Your MyCalendar object will be instantiated and called as such:  * MyCalendar obj = new MyCalendar();  * boolean param_1 = obj.book(start,end);  */",1,"729-my-calendar-i/MyCalendar.java:2:17: Variable 'bookings' must be private and have accessor methods. [VisibilityModifier]
729-my-calendar-i/MyCalendar.java:4:5: Redundant 'public' modifier. [RedundantModifier]
729-my-calendar-i/MyCalendar.java:2:17: Variable 'bookings' must be private and have accessor methods. [VisibilityModifier]
729-my-calendar-i/MyCalendar.java:4:5: Redundant 'public' modifier. [RedundantModifier]
",0,0,0
"class MyCalendarTwo {     List<int[]> calendar;     List<int[]> overlaps;          public MyCalendarTwo() {         calendar = new ArrayList<>();         overlaps = new ArrayList<>();     }          public boolean book(int start, int end) {         for (int[] overlap: overlaps) {             if (start < overlap[1] && end > overlap[0]) {                 return false;             }         }         for (int[] event: calendar) {             if (start < event[1] && end > event[0]) {                 overlaps.add(new int[]{ Math.max(start, event[0]), Math.min(end, event[1]) });             }         }         calendar.add(new int[]{ start, end });         return true;     } }",1,"731-my-calendar-ii/MyCalendarTwo.java:2:17: Variable 'calendar' must be private and have accessor methods. [VisibilityModifier]
731-my-calendar-ii/MyCalendarTwo.java:3:17: Variable 'overlaps' must be private and have accessor methods. [VisibilityModifier]
731-my-calendar-ii/MyCalendarTwo.java:5:5: Redundant 'public' modifier. [RedundantModifier]
731-my-calendar-ii/MyCalendarTwo.java:2:17: Variable 'calendar' must be private and have accessor methods. [VisibilityModifier]
731-my-calendar-ii/MyCalendarTwo.java:3:17: Variable 'overlaps' must be private and have accessor methods. [VisibilityModifier]
731-my-calendar-ii/MyCalendarTwo.java:5:5: Redundant 'public' modifier. [RedundantModifier]
",0,0,0
class Solution {     public int[] asteroidCollision(int[] asteroids) {         Stack<Integer> stack = new Stack<>();         for (int asteroid : asteroids) {             if (asteroid > 0) {                 stack.push(asteroid);             } else {                 while (!stack.isEmpty() && stack.peek() > 0 && stack.peek() < Math.abs(asteroid)) {                     stack.pop();                 }                 if (stack.isEmpty() || stack.peek() < 0) {                     stack.push(asteroid);                 } else if (stack.peek() == Math.abs(asteroid)) {                     stack.pop();                 }             }         }         int[] result = new int[stack.size()];         for (int i = result.length - 1; i >= 0; i--) {             result[i] = stack.pop();         }         return result;     } },0,,0,0,0
"class Solution {     public int monotoneIncreasingDigits(int n) {         String strNum = Integer.toString(n); // convert integer to string         int len = strNum.length();         char[] arr = new char[len];         Arrays.fill(arr, '0'); // instantiate array with 0's         for (int i = 0; i < len; i++) {             arr[i] = strNum.charAt(i); // add each digit to array             for (char j = '0'; j < arr[i]; j++) {                 if (isValid(arr, j, i)) {                     // if current digit is valid, replace all following with 9s                     Arrays.fill(arr, i+1, len, '9');                     arr[i] = j; // change current digit to valid                     break;                 }             }         }         return Integer.parseInt(new String(arr));     }          private boolean isValid(char[] arr, char c, int idx) {         // check if adding c while maintaining monotone increasing digits is possible         for (int i = idx-1; i >= 0 && arr[i] >= c; i--) {             if (arr[i] == c) {                 return true;             }         }         return false;     } }",1,"738-monotone-increasing-digits/Solution.java:18:	StringInstantiation:	Avoid instantiating String objects; this is usually unnecessary.
",0,0,0
class Solution {     public int[] dailyTemperatures(int[] temperatures) {         int[] answer = new int[temperatures.length];         Stack<Integer> stack = new Stack<>();         for (int i = 0; i < temperatures.length; i++) {             while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {                 int index = stack.pop();                 answer[index] = i - index;             }             stack.push(i);         }         return answer;     } },0,,0,0,0
"class Solution {     public int deleteAndEarn(int[] nums) {         // Finding the maximum element of the array         int max = Integer.MIN_VALUE;         for (int num : nums) {             max = Math.max(max, num);         }                  int[] dp = new int[max + 1];         for (int num : nums) {             dp[num] += num;  // Adding the value of num to the dp array         }                  // Calculate the maximum points we can earn using dynamic programming         int prevMax = 0, currMax = dp[0];         for (int i = 1; i < dp.length; i++) {             int temp = currMax;             currMax = Math.max(currMax, prevMax + dp[i]);             prevMax = temp;         }                  return currMax;     } }",1,"740-delete-and-earn/Solution.java:15:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
740-delete-and-earn/Solution.java:15:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"import java.util.*;  class Solution {     public int networkDelayTime(int[][] times, int n, int k) {         Map<Integer, List<Node>> graph = new HashMap<>();         PriorityQueue<Node> minHeap = new PriorityQueue<>((a, b) -> a.cost - b.cost);          // build the graph with all edges and its costs         for (int[] time : times) {             int source = time[0];             int destination = time[1];             int cost = time[2];              graph.putIfAbsent(source, new ArrayList<>());             graph.get(source).add(new Node(destination, cost));         }          // keep track of the visited nodes and its costs         Map<Integer, Integer> visited = new HashMap<>();          // add the source node to the queue         minHeap.add(new Node(k, 0));          while (!minHeap.isEmpty()) {             Node current = minHeap.poll();              if (visited.containsKey(current.destination)) {                 continue;             }              visited.put(current.destination, current.cost);              // search through all the neighbors of the current node             if (graph.containsKey(current.destination)) {                 for (Node neighbor : graph.get(current.destination)) {                     minHeap.add(new Node(neighbor.destination, neighbor.cost + current.cost));                 }             }         }          // check if all nodes were visited or not         if (visited.size() != n) {             return -1;         }          int maxCost = 0;         for (int cost : visited.values()) {             maxCost = Math.max(maxCost, cost);         }          return maxCost;     }      static class Node {         int destination;         int cost;          Node(int destination, int cost) {             this.destination = destination;             this.cost = cost;         }     } }",1,"743-network-delay-time/Solution.java:55:13: Variable 'destination' must be private and have accessor methods. [VisibilityModifier]
743-network-delay-time/Solution.java:56:13: Variable 'cost' must be private and have accessor methods. [VisibilityModifier]
743-network-delay-time/Solution.java:58:18: 'destination' hides a field. [HiddenField]
743-network-delay-time/Solution.java:58:35: 'cost' hides a field. [HiddenField]
743-network-delay-time/Solution.java:55:13: Variable 'destination' must be private and have accessor methods. [VisibilityModifier]
743-network-delay-time/Solution.java:56:13: Variable 'cost' must be private and have accessor methods. [VisibilityModifier]
743-network-delay-time/Solution.java:58:18: 'destination' hides a field. [HiddenField]
743-network-delay-time/Solution.java:58:35: 'cost' hides a field. [HiddenField]
743-network-delay-time/Solution.java:5:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
743-network-delay-time/Solution.java:6:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
743-network-delay-time/Solution.java:19:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
",0,0,0
"import java.util.HashSet; import java.util.LinkedList; import java.util.Queue; import java.util.Set;  class Solution {     public int openLock(String[] deadends, String target) {         Set<String> deads = new HashSet<>();         for (String s : deadends) deads.add(s);          Queue<String> queue = new LinkedList<>();         Set<String> visited = new HashSet<>();         queue.offer(""0000"");         visited.add(""0000"");          int step = 0;         while (!queue.isEmpty()) {             int size = queue.size();             for (int i = 0; i < size; i++) {                 String curr = queue.poll();                  if (deads.contains(curr)) continue;                 if (curr.equals(target)) return step;                  for (int j = 0; j < 4; j++) {                     String up = plusOne(curr, j);                     if (!visited.contains(up)) {                         queue.offer(up);                         visited.add(up);                     }                     String down = minusOne(curr, j);                     if (!visited.contains(down)) {                         queue.offer(down);                         visited.add(down);                     }                 }             }             step++;         }         return -1;     }      private String plusOne(String s, int index) {         char[] chars = s.toCharArray();         if (chars[index] == '9') {             chars[index] = '0';         } else {             chars[index] += 1;         }         return new String(chars);     }      private String minusOne(String s, int index) {         char[] chars = s.toCharArray();         if (chars[index] == '0') {             chars[index] = '9';         } else {             chars[index] -= 1;         }         return new String(chars);     } }",1,"752-open-the-lock/Solution.java:50:	StringInstantiation:	Avoid instantiating String objects; this is usually unnecessary.
752-open-the-lock/Solution.java:60:	StringInstantiation:	Avoid instantiating String objects; this is usually unnecessary.
",0,0,0
"class Solution {     public int reachNumber(int target) {         // Let's convert target to be always positive         target = Math.abs(target);         // Let's start assuming we need to move n steps, then we will adjust accordingly         int n = (int) Math.ceil((-1.0 + Math.sqrt(1 + 8.0 * target)) / 2);         // Let's calculate the sum of the first n integers to check if we need to move back a step         int sum = n * (n + 1) / 2;         if (sum == target) {             // We reached the target, return n             return n;         } else if ((sum - target) % 2 == 0) {             // We can move back to reach the target             return n;         } else {             // We need to move an additional step forward to be able to move back and reach the target             return n + ((n + 1) % 2);         }     } }",1,"754-reach-a-number/Solution.java:4:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'target'
",0,1,0
"import java.util.*;  class Solution {     public boolean pyramidTransition(String bottom, List<String> allowed) {         Map<String, Set<Character>> map = new HashMap<>();         for (String s : allowed) {             String key = s.substring(0, 2);             if (!map.containsKey(key)) {                 map.put(key, new HashSet<>());             }             map.get(key).add(s.charAt(2));         }         return dfs(bottom, map, 1);     }      private boolean dfs(String row, Map<String, Set<Character>> map, int index) {         if (row.length() == 1) {             return true;         }         if (index == row.length()) {             return dfs(row.substring(1), map, 1);         }         String key = row.substring(index - 1, index + 1);         if (!map.containsKey(key)) {             return false;         }         Set<Character> set = map.get(key);         for (char c : set) {             if (dfs(row, map, index + 1, """", c)) {                 return true;             }         }         return false;     }      private boolean dfs(String row, Map<String, Set<Character>> map, int index, String newRow, char block) {         if (index == row.length()) {             return dfs(newRow, map, 1);         }         String key = row.substring(index - 1, index + 1);         if (!map.containsKey(key)) {             return false;         }         Set<Character> set = map.get(key);         if (!set.contains(block)) {             return false;         }         for (char c : set) {             if (dfs(row, map, index + 1, newRow + c, block)) {                 return true;             }         }         return false;     } }",1,"756-pyramid-transition-matrix/Solution.java:5:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
",0,0,0
"import java.util.ArrayList; import java.util.List;  class Solution {     public List<Integer> partitionLabels(String s) {         List<Integer> result = new ArrayList<>();          // Create an array to store the last index of each character in the given string         int[] lastIndex = new int[26];         for (int i = 0; i < s.length(); i++) {             lastIndex[s.charAt(i) - 'a'] = i;         }          int startIndex = 0;         int endIndex = 0;          // Traverse through the given string and try to merge characters if possible         for (int i = 0; i < s.length(); i++) {             endIndex = Math.max(endIndex, lastIndex[s.charAt(i) - 'a']);              // If the current index is same as the endIndex, then we have found a partition             if (i == endIndex) {                 result.add(endIndex - startIndex + 1);                 startIndex = i + 1;             }         }          return result;     } }",0,,0,0,0
"class Solution {     public int orderOfLargestPlusSign(int n, int[][] mines) {         int[][] grid = new int[n][n];         for (int i = 0; i < n; i++) {             Arrays.fill(grid[i], 1);         }         for (int[] mine : mines) {             grid[mine[0]][mine[1]] = 0;         }         int[][] left = new int[n][n];         int[][] right = new int[n][n];         int[][] up = new int[n][n];         int[][] down = new int[n][n];         for (int i = 0; i < n; i++) {             for (int j = 0; j < n; j++) {                 if (grid[i][j] == 1) {                     if (j == 0) {                         left[i][j] = 1;                     } else {                         left[i][j] = left[i][j - 1] + 1;                     }                 }             }         }         for (int i = 0; i < n; i++) {             for (int j = n - 1; j >= 0; j--) {                 if (grid[i][j] == 1) {                     if (j == n - 1) {                         right[i][j] = 1;                     } else {                         right[i][j] = right[i][j + 1] + 1;                     }                 }             }         }         for (int j = 0; j < n; j++) {             for (int i = 0; i < n; i++) {                 if (grid[i][j] == 1) {                     if (i == 0) {                         up[i][j] = 1;                     } else {                         up[i][j] = up[i - 1][j] + 1;                     }                 }             }         }         for (int j = 0; j < n; j++) {             for (int i = n - 1; i >= 0; i--) {                 if (grid[i][j] == 1) {                     if (i == n - 1) {                         down[i][j] = 1;                     } else {                         down[i][j] = down[i + 1][j] + 1;                     }                 }             }         }         int result = 0;         for (int i = 0; i < n; i++) {             for (int j = 0; j < n; j++) {                 if (grid[i][j] == 1) {                     int order = Math.min(Math.min(left[i][j], right[i][j]), Math.min(up[i][j], down[i][j]));                     result = Math.max(result, order);                 }             }         }         return result;     } }",1,"764-largest-plus-sign/Solution.java:2:	NPathComplexity:	The method 'orderOfLargestPlusSign(int, int[][])' has an NPath complexity of 10000, current threshold is 200
",0,0,0
"class Solution {     public String reorganizeString(String s) {         int n = s.length();         int[] freq = new int[26];         for(char ch: s.toCharArray())             freq[ch-'a']++;                  PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> b[1]-a[1]);         for(int i=0; i<26; i++)             if(freq[i] > 0)                 pq.offer(new int[]{i, freq[i]});                  StringBuilder sb = new StringBuilder();         while(pq.size() > 1) {             int[] cnt1 = pq.poll();             int[] cnt2 = pq.poll();             sb.append((char)('a' + cnt1[0]));             sb.append((char)('a' + cnt2[0]));             if(--cnt1[1] > 0)                 pq.offer(cnt1);             if(--cnt2[1] > 0)                 pq.offer(cnt2);         }                  if(pq.size() > 0) {             int[] last = pq.poll();             if(last[1] > 1)                 return """";             else                 sb.append((char)('a' + last[0]));         }         return sb.toString();     } }  public class Main {     public static void main(String[] args) {         Solution solution = new Solution();         String s1 = ""aab"";         System.out.println(solution.reorganizeString(s1)); // Expected Output: ""aba""          String s2 = ""aaab"";         System.out.println(solution.reorganizeString(s2)); // Expected Output: """"     } }",1,"767-reorganize-string/Main.java:36:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
767-reorganize-string/Main.java:36:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
767-reorganize-string/Main.java:3:	UnusedLocalVariable:	Avoid unused local variables such as 'n'.
767-reorganize-string/Main.java:17:	ConsecutiveAppendsShouldReuse:	StringBuffer (or StringBuilder).append is called consecutively without reusing the target variable.
767-reorganize-string/Main.java:19:	AssignmentInOperand:	Avoid assignments in operands
767-reorganize-string/Main.java:21:	AssignmentInOperand:	Avoid assignments in operands
767-reorganize-string/Main.java:36:	UseUtilityClass:	This utility class has a non-private constructor
",0,0,0
"class Solution {     public int maxChunksToSorted(int[] arr) {         int maxChunks = 0;         int sortedUntilIndex = 0;         for (int i = 0; i < arr.length; i++) {             sortedUntilIndex = Math.max(sortedUntilIndex, arr[i]);             if (sortedUntilIndex == i) {                 maxChunks++;             }         }         return maxChunks;     } }",0,,0,0,0
"class Solution {     public boolean isIdealPermutation(int[] nums) {         int n = nums.length;         int maxLocal = 0;         for (int i = 0; i < n - 1; i++) {             maxLocal = Math.max(maxLocal, nums[i]);             if (maxLocal > nums[i + 1]) {                 return false;             }         }         int[] bit = new int[n + 1];         int global = 0;         for (int i = n - 1; i >= 0; i--) {             global += query(bit, nums[i] - 1);             update(bit, nums[i]);         }         return global == countInversions(nums);     }          private int countInversions(int[] nums) {         return countInversions(nums, 0, nums.length - 1);     }          private int countInversions(int[] nums, int left, int right) {         if (left >= right) {             return 0;         }         int mid = (left + right) / 2;         int count = countInversions(nums, left, mid) +                     countInversions(nums, mid + 1, right) +                     merge(nums, left, mid, right);         return count;     }          private int merge(int[] nums, int left, int mid, int right) {         int[] temp = new int[right - left + 1];         int i = left;         int j = mid + 1;         int k = 0;         int count = 0;         while (i <= mid && j <= right) {             if (nums[i] <= nums[j]) {                 temp[k++] = nums[i++];             } else {                 count += mid - i + 1;                 temp[k++] = nums[j++];             }         }         while (i <= mid) {             temp[k++] = nums[i++];         }         while (j <= right) {             temp[k++] = nums[j++];         }         System.arraycopy(temp, 0, nums, left, temp.length);         return count;     }          private void update(int[] bit, int i) {         i++;         while (i < bit.length) {             bit[i]++;             i += i & -i;         }     }          private int query(int[] bit, int i) {         i++;         int sum = 0;         while (i > 0) {             sum += bit[i];             i -= i & -i;         }         return sum;     } }",1,"775-global-and-local-inversions/Solution.java:29:	UnnecessaryLocalBeforeReturn:	Consider simply returning the value vs storing it in local variable 'count'
775-global-and-local-inversions/Solution.java:49:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
775-global-and-local-inversions/Solution.java:52:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
775-global-and-local-inversions/Solution.java:60:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'i'
775-global-and-local-inversions/Solution.java:68:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'i'
",0,1,0
"class Solution {     public boolean canTransform(String start, String end) {         if (start.length() != end.length()) {             return false;         }         int i = 0, j = 0;         while (i < start.length() && j < end.length()) {             // skip all 'X' characters             while (i < start.length() && start.charAt(i) == 'X') {                 i++;             }             while (j < end.length() && end.charAt(j) == 'X') {                 j++;             }             // check if the characters at the current indices are different             if (i < start.length() && j < end.length() && start.charAt(i) != end.charAt(j)) {                 return false;             }              // check if 'L' moves left only             if (i < start.length() && start.charAt(i) == 'L' && i < j) {                 return false;             }             // check if 'R' moves right only             if (j < end.length() && end.charAt(j) == 'R' && j < i) {                 return false;             }             i++;             j++;         }         // make sure there are no remaining characters, except 'X', in either start or end         while (i < start.length() && start.charAt(i) == 'X') {             i++;         }         while (j < end.length() && end.charAt(j) == 'X') {             j++;         }         return i == start.length() && j == end.length();     } }",1,"777-swap-adjacent-in-lr-string/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
777-swap-adjacent-in-lr-string/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
777-swap-adjacent-in-lr-string/Solution.java:2:	NPathComplexity:	The method 'canTransform(String, String)' has an NPath complexity of 20808, current threshold is 200
",1,0,0
"class Solution {     int kthGrammar(int n, int k) {         // base condition         if (n == 1) return 0;         //recursive call to previous row         int val = kthGrammar(n - 1, (k + 1) / 2);         //if the k is even, replace 0 with 01 and 1 with 10         if (k % 2 == 0) {             return (val == 0) ? 1 : 0;         } else {             //if the k is odd, replace 0 with 0 and 1 with 1             return (val == 0) ? 0 : 1;         }     } }  class Solution {     public int kthGrammar(int n, int k) {         return Integer.bitCount(k - 1) % 2;     } }",0,,0,0,0
"class Solution {     public int numRabbits(int[] answers) {         HashMap<Integer, Integer> count = new HashMap<Integer, Integer>();         for (int ans : answers)             count.put(ans, count.getOrDefault(ans, 0) + 1);          int result = 0;         for (int ans : count.keySet()) {             int group = count.get(ans) / (ans + 1);             if (count.get(ans) % (ans + 1) != 0)                 group += 1;             result += group * (ans + 1);         }         return result;     } }",0,,0,0,0
"import java.util.ArrayList; import java.util.List;  class Solution {     public List<String> letterCasePermutation(String s) {         // Create an empty list to store permutations         List<String> result = new ArrayList<>();                  // Call recursive function to generate permutations         generatePermutations(s.toCharArray(), 0, result);                  return result;     }          // Recursive function to generate permutations     private void generatePermutations(char[] s, int index, List<String> result) {         // Base case: if we have processed all characters in the string         if (index == s.length) {             // Add the current permutation to the list             result.add(new String(s));             return;         }                  // If the current character is not a letter, move to the next character         if (!Character.isLetter(s[index])) {             generatePermutations(s, index + 1, result);             return;         }                  // Generate permutations by converting the current character to lowercase         s[index] = Character.toLowerCase(s[index]);         generatePermutations(s, index + 1, result);                  // Generate permutations by converting the current character to uppercase         s[index] = Character.toUpperCase(s[index]);         generatePermutations(s, index + 1, result);                  // Restore the original character at the current index         s[index] = Character.isLowerCase(s[index]) ? Character.toUpperCase(s[index]) : Character.toLowerCase(s[index]);     } }",1,"784-letter-case-permutation/Solution.java:20:	StringInstantiation:	Avoid instantiating String objects; this is usually unnecessary.
",0,0,0
"class Solution {     public boolean isBipartite(int[][] graph) {         int n = graph.length;         int[] color = new int[n];         for (int i = 0; i < n; i++) {             if (color[i] == 0 && !dfs(i, 1, color, graph))                 return false;         }         return true;     }          public boolean dfs(int u, int c, int[] color, int[][] graph) {         color[u] = c;         for (int v : graph[u]) {             if (color[v] == c)                 return false;             if (color[v] == 0 && !dfs(v, -c, color, graph))                 return false;         }         return true;     } }",0,,0,0,0
"import java.util.PriorityQueue;  class Solution {     public int[] kthSmallestPrimeFraction(int[] arr, int k) {         PriorityQueue<int[]> minHeap = new PriorityQueue<int[]>((a, b) -> arr[a[0]] * arr[b[1]] - arr[b[0]] * arr[a[1]]);         int n = arr.length;         for (int i = 0; i < n - 1; i++) {             minHeap.offer(new int[] {i, n - 1});         }         while (--k > 0) {             int[] curr = minHeap.poll();             if (curr[1] - 1 > curr[0]) {                 curr[1]--;                 minHeap.offer(curr);             }         }         int[] result = new int[] {arr[minHeap.peek()[0]], arr[minHeap.peek()[1]]};         return result;     } }",1,"786-k-th-smallest-prime-fraction/Solution.java:5:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
786-k-th-smallest-prime-fraction/Solution.java:5:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new PriorityQueue<>(...)`
786-k-th-smallest-prime-fraction/Solution.java:10:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'k'
786-k-th-smallest-prime-fraction/Solution.java:17:	UnnecessaryLocalBeforeReturn:	Consider simply returning the value vs storing it in local variable 'result'
",0,1,0
"import java.util.Arrays;  class Solution {     public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {         // Create a 2-D array to store the shortest distance from source to         // each city up to a certain number of stops         int[][] dp = new int[k + 2][n];         // Initialize the dp array to a large value to denote an invalid path         for (int[] row : dp) {             Arrays.fill(row, Integer.MAX_VALUE);         }         // Distance from source to itself is zero         for (int i = 0; i <= k + 1; i++) {             dp[i][src] = 0;         }         // For each level of stops, find the minimum cost to reach each city         for (int i = 1; i <= k + 1; i++) {             for (int[] flight : flights) {                 int from = flight[0];                 int to = flight[1];                 int cost = flight[2];                 if (dp[i - 1][from] != Integer.MAX_VALUE) {                     dp[i][to] = Math.min(dp[i][to], dp[i - 1][from] + cost);                 }             }         }         // Return the minimum cost to reach the destination with at most k stops         int minCost = Integer.MAX_VALUE;         for (int i = 1; i <= k + 1; i++) {             minCost = Math.min(minCost, dp[i][dst]);         }         return minCost == Integer.MAX_VALUE ? -1 : minCost;     } }",0,,0,0,0
class Solution {     public int rotatedDigits(int n) {         int count = 0;         for(int i=1; i<=n; i++){             if(isGood(i)){                 count++;             }         }         return count;     }          public boolean isGood(int num){         boolean valid = false;         while(num > 0){             int digit = num % 10;             if(digit == 3 || digit == 4 || digit == 7){                 return false;             }else if(digit == 2 || digit == 5 || digit == 6 || digit == 9){                 valid = true;             }             num = num / 10;         }                  return valid;     } },1,"788-rotated-digits/Solution.java:21:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'num'
",0,1,0
"class Solution {     public boolean escapeGhosts(int[][] ghosts, int[] target) {         int distanceToTarget = Math.abs(target[0]) + Math.abs(target[1]);         for (int[] ghost : ghosts) {             int distanceToGhost = Math.abs(ghost[0] - target[0]) + Math.abs(ghost[1] - target[1]);             if (distanceToGhost <= distanceToTarget) {                 return false;             }         }         return true;     } }",0,,0,0,0
class Solution {     public int numTilings(int n) {         long[] dp = new long[n+2];         long mod = 1000000007;         dp[0] = 1;         dp[1] = 1;         dp[2] = 2;         for(int i=3; i<=n; i++){             dp[i] = (2*dp[i-1]+dp[i-3])%mod;         }         return (int)dp[n];     } },0,,0,0,0
"class Solution {     public String customSortString(String order, String s) {         int[] count = new int[26];                  //Get frequency of characters in s         for(char c: s.toCharArray()) {             count[c - 'a']++;         }                  StringBuilder result = new StringBuilder();                  //Append characters of order in the order they appear         for(char c: order.toCharArray()) {             while(count[c - 'a'] > 0) {                 result.append(c);                 count[c - 'a']--;             }         }                  //Append remaining characters         for(char c='a'; c<='z'; c++) {             while(count[c - 'a'] > 0) {                 result.append(c);                 count[c - 'a']--;             }         }                  return result.toString();     } }",0,,0,0,0
"class Solution {     public int numMatchingSubseq(String s, String[] words) {         int count = 0;         for (String w : words) {             if (isSubsequence(w, s)) {                 count++;             }         }         return count;     }          private boolean isSubsequence(String w, String s) {         if (w.length() > s.length()) {             return false;         }         int i = 0, j = 0;         while (i < w.length() && j < s.length()) {             if (w.charAt(i) == s.charAt(j)) {                 i++;             }             j++;         }         return i == w.length();     } }",1,"792-number-of-matching-subsequences/Solution.java:16:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
792-number-of-matching-subsequences/Solution.java:16:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public boolean validTicTacToe(String[] board) {         // Count the number of ""X"" and ""O"" occurrences         int countX = 0, countO = 0;         for (int i = 0; i < 3; i++) {             for (int j = 0; j < 3; j++) {                 if (board[i].charAt(j) == 'X') {                     countX++;                 } else if (board[i].charAt(j) == 'O') {                     countO++;                 }             }         }                  // Check if the number of ""O"" is greater than ""X""         if (countO > countX) {             return false;         }                  // Check if there's more than 1 difference in the number of ""X"" and ""O""         if (countX - countO > 1) {             return false;         }                  // Check if ""O"" has won         if (hasWon(board, 'O') && countO != countX) {             return false;         }                  // Check if ""X"" has won         if (hasWon(board, 'X') && countO == countX) {             return false;         }                  return true;     }          // Helper function to check if a player has won     private boolean hasWon(String[] board, char player) {         for (int i = 0; i < 3; i++) {             if (board[i].charAt(0) == player && board[i].charAt(1) == player && board[i].charAt(2) == player) {                 return true;             }             if (board[0].charAt(i) == player && board[1].charAt(i) == player && board[2].charAt(i) == player) {                 return true;             }         }         if (board[0].charAt(0) == player && board[1].charAt(1) == player && board[2].charAt(2) == player) {             return true;         }         if (board[0].charAt(2) == player && board[1].charAt(1) == player && board[2].charAt(0) == player) {             return true;         }         return false;     } }",1,"794-valid-tic-tac-toe-state/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
794-valid-tic-tac-toe-state/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
794-valid-tic-tac-toe-state/Solution.java:31:	SimplifyBooleanReturns:	This if statement can be replaced by `return !{condition};`
794-valid-tic-tac-toe-state/Solution.java:39:	NPathComplexity:	The method 'hasWon(String[], char)' has an NPath complexity of 272, current threshold is 200
794-valid-tic-tac-toe-state/Solution.java:51:	SimplifyBooleanReturns:	This if statement can be replaced by `return {condition};`
",1,0,0
"class Solution {     public int numSubarrayBoundedMax(int[] nums, int left, int right) {         int count = 0;         int leftIndex = -1;         int rightIndex = -1;         for (int i = 0; i < nums.length; i++) {             if (nums[i] > right) {                 leftIndex = i;                 rightIndex = i;                 continue;             }             if (nums[i] < left) {                 if (rightIndex != -1) {                     count += rightIndex - leftIndex + 1;                 }                 continue;             }             if (nums[i] >= left && nums[i] <= right) {                 rightIndex = i;                 if (leftIndex == -1) {                     leftIndex = i;                 }                 count += rightIndex - leftIndex + 1;             }         }         return count;     } }",0,,0,0,0
"import java.util.*;  class Solution {     public List<List<Integer>> allPathsSourceTarget(int[][] graph) {         List<List<Integer>> paths = new ArrayList<>();         dfs(0, graph, new ArrayList<Integer>(Arrays.asList(0)), paths);         return paths;     }          private void dfs(int node, int[][] graph, List<Integer> path, List<List<Integer>> paths) {         if (node == graph.length - 1) { // we have reached the destination node             paths.add(new ArrayList<Integer>(path));         } else {             for (int neighbor : graph[node]) { // explore all neighbors of the current node                 path.add(neighbor);                 dfs(neighbor, graph, path, paths);                 path.remove(path.size() - 1); // backtrack to explore other paths             }         }     } }",1,"797-all-paths-from-source-to-target/Solution.java:6:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new ArrayList<>(Arrays.asList(0))`
797-all-paths-from-source-to-target/Solution.java:12:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new ArrayList<>(path)`
",0,0,0
"class Solution {     public double champagneTower(int poured, int query_row, int query_glass) {         double[] glasses = new double[100]; // array to store the amount of champagne in each glass         glasses[0] = poured; // the initial amount of champagne poured into the first glass                  // loop through each row of glasses         for (int i = 1; i <= query_row; i++) {             // loop through each glass in the current row             for (int j = i; j >= 0; j--) {                 // calculate the amount of champagne that overflows to each adjacent glass                 double overflow = (glasses[j] - 1) / 2.0;                 if (overflow > 0) {                     glasses[j+1] += overflow;                     glasses[j] = overflow;                 } else {                     glasses[j] = 0; // if there is no overflow, the glass is empty                 }             }         }                  // return the amount of champagne in the requested glass         return Math.min(1.0, glasses[query_glass]); // ensure the value is not greater than 1.0     } }",0,,0,0,0
import java.util.*;  class Solution {     public List<Integer> eventualSafeNodes(int[][] graph) {         int n = graph.length;          // out degree         int[] outdegree = new int[n];          // edges         List<List<Integer>> que = new ArrayList<>(n);         for(int i=0; i<n; i++) {             que.add(new ArrayList<>());         }          for(int i=0; i<n; i++) {             for(int v : graph[i]) {                 outdegree[i]++;                 que.get(v).add(i);             }         }          Queue<Integer> queue = new LinkedList<>();         for(int i=0; i<n; i++) {             if(outdegree[i] == 0) queue.add(i);         }          while(!queue.isEmpty()) {             int b = queue.poll();             for(int i : que.get(b)) {                 outdegree[i]--;                 if(outdegree[i] == 0) queue.add(i);             }         }          List<Integer> res = new ArrayList<>();         for(int i=0; i<n; i++) {             if(outdegree[i] == 0) res.add(i);         }          Collections.sort(res);         return res;     } },1,"802-find-eventual-safe-states/Solution.java:4:	NPathComplexity:	The method 'eventualSafeNodes(int[][])' has an NPath complexity of 216, current threshold is 200
",0,0,0
"public class Solution {     public int maxIncreaseKeepingSkyline(int[][] grid) {                  int n = grid.length;         int[] rowMax = new int[n];         int[] colMax = new int[n];                  // Find the maximum building heights for each row and column         for (int i = 0; i < n; i++) {             for (int j = 0; j < n; j++) {                 rowMax[i] = Math.max(rowMax[i], grid[i][j]);                 colMax[j] = Math.max(colMax[j], grid[i][j]);             }         }                  int sum = 0;                  // Calculate the maximum possible increase in building heights         // without changing the skyline from any direction         for (int i = 0; i < n; i++) {             for (int j = 0; j < n; j++) {                 sum += Math.min(rowMax[i], colMax[j]) - grid[i][j];             }         }                  return sum;     } }",0,,0,0,0
"class Solution {     public double soupServings(int n) {         if (n >= 5000) {             // If n is very large, the result will be very close to 1             return 1.0;         }         // One serving of type A takes 4 operations (serve 100ml of A, 75ml of A and 25ml of B, 50ml of both, and 25ml of A and 75ml of B)         // One serving of type B takes 4 operations (serve 100ml of B, 75ml of B and 25ml of A, 50ml of both, and 25ml of B and 75ml of A)         // If we note ""dp[i][j]"" as the probability of the amount of A left is ""i"" ml and the amount of B left is ""j"" ml.         // The formula for the probability is simply the sum of the probability after each of the four operations.          // If we use Math.min to compute the fraction served which has to be a multiple of 25, we'll have some rounding errors.         // To correct that, let's round down to the nearest multiple of 25         n = (n + 24) / 25;         double[][] dp = new double[n + 1][n + 1];         dp[0][0] = 0.5;         for (int i = 1; i <= n; i++) {             dp[i][0] = 0;             dp[0][i] = 1;         }         for (int i = 1; i <= n; i++) {             for (int j = 1; j <= n; j++) {                 // Remember that we're computing the probability that ""A"" will be empty first,                 // plus half the probability that both ""A"" and ""B"" will be empty at the same time.                 dp[i][j] = 0.25 * (dp[Math.max(i - 4, 0)][j] +                                      dp[Math.max(i - 3, 0)][Math.max(j - 1, 0)] +                                     dp[Math.max(i - 2, 0)][Math.max(j - 2, 0)] +                                      dp[Math.max(i - 1, 0)][Math.max(j - 3, 0)]);             }         }         return dp[n][n];     } }",1,"808-soup-servings/Solution.java:13:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
",0,1,0
"class Solution {     public int expressiveWords(String s, String[] words) {         int count = 0;         for (String word : words) {             if (isStretchy(s, word)) {                 count++;             }         }         return count;     }          private boolean isStretchy(String s, String word) {         int i = 0;         int j = 0;         while (i < s.length() && j < word.length()) {             if (s.charAt(i) == word.charAt(j)) {                 int sameCharCountS = getSameCharCount(s, i);                 int sameCharCountW = getSameCharCount(word, j);                 if (sameCharCountS < 3 && sameCharCountS != sameCharCountW) {                     return false;                 }                 if (sameCharCountS >= 3 && sameCharCountS < sameCharCountW) {                     return false;                 }                 i += sameCharCountS;                 j += sameCharCountW;             } else {                 return false;             }         }         return i == s.length() && j == word.length();     }          private int getSameCharCount(String str, int start) {         int end = start;         while (end < str.length() && str.charAt(end) == str.charAt(start)) {             end++;         }         return end - start;     } }",0,,0,0,0
"import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map;  class Solution {     public List<String> subdomainVisits(String[] cpdomains) {         List<String> result = new ArrayList<String>();         Map<String, Integer> map = new HashMap<String, Integer>();          for (String domain : cpdomains) {             String[] array = domain.split("" "");             int count = Integer.parseInt(array[0]);             String[] subDomains = array[1].split(""\\."");              String current = """";             for (int i = subDomains.length - 1; i >= 0; i--) {                 current = subDomains[i] + (i < subDomains.length - 1 ? ""."" : """") + current;                 map.put(current, map.getOrDefault(current, 0) + count);             }         }          for (Map.Entry<String, Integer> entry : map.entrySet()) {             result.add(entry.getValue() + "" "" + entry.getKey());         }          return result;     } }",1,"811-subdomain-visit-count/Solution.java:8:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new ArrayList<>()`
811-subdomain-visit-count/Solution.java:9:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
811-subdomain-visit-count/Solution.java:9:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new HashMap<>()`
811-subdomain-visit-count/Solution.java:18:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
",0,0,0
"import java.util.Arrays;  class Solution {     public double largestSumOfAverages(int[] nums, int k) {         int n = nums.length;         double[][] dp = new double[k+1][n+1];         double[] prefix = new double[n+1];                  for(int i=1;i<=n;i++){             prefix[i] = prefix[i-1] + nums[i-1];             dp[1][i] = prefix[i] / (double)i;         }                  for(int i=2;i<=k;i++){             for(int j=i;j<=n;j++){                 for(int l=i-1;l<j;l++){                     dp[i][j] = Math.max(dp[i][j], dp[i-1][l] + ((prefix[j]-prefix[l])/(double)(j-l)));                 }             }         }         return dp[k][n];     } }",1,"813-largest-sum-of-averages/Solution.java:1:8: Unused import - java.util.Arrays. [UnusedImports]
813-largest-sum-of-averages/Solution.java:1:8: Unused import - java.util.Arrays. [UnusedImports]
813-largest-sum-of-averages/Solution.java:1:	UnnecessaryImport:	Unused import 'java.util.Arrays'
813-largest-sum-of-averages/Solution.java:11:	UnnecessaryCast:	Unnecessary cast (double)
813-largest-sum-of-averages/Solution.java:17:	UnnecessaryCast:	Unnecessary cast (double)
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public TreeNode pruneTree(TreeNode root) {         if(root == null)             return null;         if(root.left == null && root.right == null){             if(root.val == 0)                 return null;             else                   return root;         }else{             root.left = pruneTree(root.left);             root.right = pruneTree(root.right);             if(root.left == null && root.right == null){                 if(root.val == 0)                     return null;                 else                       return root;             }else{                 return root;             }         }     } }",0,,0,0,0
"import java.util.*;  class Solution {     public List<String> ambiguousCoordinates(String s) {         List<String> results = new ArrayList<>();         s = s.substring(1, s.length() - 1); // Remove parentheses         for (int i = 1; i < s.length(); i++) {             List<String> left = findNumbers(s.substring(0, i));             List<String> right = findNumbers(s.substring(i));             for (String l : left) {                 for (String r : right) {                     results.add(""("" + l + "", "" + r + "")"");                 }             }         }         return results;     }          private List<String> findNumbers(String s) {         int n = s.length();         List<String> numbers = new ArrayList<>();         if (n == 1) {             numbers.add(s);         } else {             if (s.charAt(0) != '0') { // Add integer part                 numbers.add(s);             }             for (int i = 1; i < n; i++) { // Add fraction part                 String integerPart = s.substring(0, i);                 String fractionPart = s.substring(i);                 if (fractionPart.charAt(fractionPart.length() - 1) != '0') { // Ignore trailing zeros                     numbers.add(integerPart + ""."" + fractionPart);                 }             }         }         return numbers;     } }",1,"816-ambiguous-coordinates/Solution.java:6:	AvoidReassigningParameters:	Avoid reassigning parameters such as 's'
",0,1,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public int numComponents(ListNode head, int[] nums) {         Set<Integer> numsSet = new HashSet<>();         for (int num : nums) {             numsSet.add(num);         }         int numComponents = 0;         boolean connected = false;         while (head != null) {             if (numsSet.contains(head.val)) {                 // current node is in nums array                 if (!connected) {                     // start of new connected component                     connected = true;                     numComponents++;                 }             } else {                 // current node is not in nums array                 connected = false;             }             head = head.next;         }         return numComponents;     } }",1,"817-linked-list-components/ListNode.java:31:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'head'
",0,1,0
"class Solution {     public int minimumLengthEncoding(String[] words) {         // Initialize a set to store all words         Set<String> wordSet = new HashSet<>(Arrays.asList(words));         // Initialize a set to remove all suffixes of each word         Set<String> suffixes = new HashSet<>();         for (String word : wordSet) {             for (int i = 1; i < word.length(); i++) {                 suffixes.add(word.substring(i));             }         }         // Remove all words that are suffixes of other words         wordSet.removeAll(suffixes);         // Initialize count         int count = 0;         // Add length of each word plus 1 for ""#""         for (String word : wordSet) {             count += word.length() + 1;         }         // Return count         return count;     } }",0,,0,0,0
"class Solution {     public int flipgame(int[] fronts, int[] backs) {         Set<Integer> same = new HashSet<>();         int n = fronts.length;                  for (int i = 0; i < n; i++) {             if (fronts[i] == backs[i]) {                 same.add(fronts[i]);             }         }                  int min = Integer.MAX_VALUE;         for (int num : fronts) {             if (!same.contains(num)) {                 min = Math.min(min, num);             }         }                  for (int num : backs) {             if (!same.contains(num)) {                 min = Math.min(min, num);             }         }                  return min == Integer.MAX_VALUE ? 0 : min;     } }",0,,0,0,0
"class Solution {     public int numFactoredBinaryTrees(int[] arr) {         int MOD = 1000000007;         int n = arr.length;         Arrays.sort(arr);         long[] dp = new long[n];         Arrays.fill(dp, 1);         Map<Integer, Integer> indexMap = new HashMap<>();         for (int i = 0; i < n; i++) {             indexMap.put(arr[i], i);         }         for (int i = 0; i < n; i++) {             for (int j = 0; j < i; j++) {                 if (arr[i] % arr[j] == 0 && indexMap.containsKey(arr[i] / arr[j])) {                     dp[i] = (dp[i] + dp[j] * dp[indexMap.get(arr[i] / arr[j])]) % MOD;                 }             }         }         long ans = 0;         for (long count : dp) {             ans = (ans + count) % MOD;         }         return (int) ans;     } }",0,,0,0,0
class Solution {     public int numFriendRequests(int[] ages) {         int[] count = new int[121];         for (int i : ages) {             count[i]++;         }         int sum = 0;         for (int i = 15; i < 121; i++) {             for (int j = (int) (i * 0.5 + 7) + 1; j <= i; j++) {                 sum += count[i] * (count[j] - (i == j ? 1 : 0));             }         }         return sum;     } },0,,0,0,0
"class Solution {     public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {         int n = difficulty.length;         List<Job> jobs = new ArrayList<>(n);         for (int i = 0; i < n; i++) {             jobs.add(new Job(difficulty[i], profit[i]));         }         Collections.sort(jobs, Comparator.comparingInt(j -> j.difficulty));         Arrays.sort(worker);         int totalProfit = 0, bestProfit = 0, bestDifficulty = 0, j = 0;         for (int ability : worker) {             while (j < n && ability >= jobs.get(j).difficulty) {                 Job job = jobs.get(j);                 if (job.profit > bestProfit) {                     bestProfit = job.profit;                     bestDifficulty = job.difficulty;                 }                 j++;             }             if (bestProfit > 0) {                 totalProfit += bestProfit;             }         }         return totalProfit;     } }  class Job {     int difficulty;     int profit;      Job(int difficulty, int profit) {         this.difficulty = difficulty;         this.profit = profit;     } }",1,"826-most-profit-assigning-work/Solution.java:10:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
826-most-profit-assigning-work/Solution.java:29:9: Variable 'difficulty' must be private and have accessor methods. [VisibilityModifier]
826-most-profit-assigning-work/Solution.java:30:9: Variable 'profit' must be private and have accessor methods. [VisibilityModifier]
826-most-profit-assigning-work/Solution.java:32:13: 'difficulty' hides a field. [HiddenField]
826-most-profit-assigning-work/Solution.java:32:29: 'profit' hides a field. [HiddenField]
826-most-profit-assigning-work/Solution.java:10:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
826-most-profit-assigning-work/Solution.java:29:9: Variable 'difficulty' must be private and have accessor methods. [VisibilityModifier]
826-most-profit-assigning-work/Solution.java:30:9: Variable 'profit' must be private and have accessor methods. [VisibilityModifier]
826-most-profit-assigning-work/Solution.java:32:13: 'difficulty' hides a field. [HiddenField]
826-most-profit-assigning-work/Solution.java:32:29: 'profit' hides a field. [HiddenField]
826-most-profit-assigning-work/Solution.java:10:	UnusedLocalVariable:	Avoid unused local variables such as 'bestDifficulty'.
826-most-profit-assigning-work/Solution.java:10:	UnusedAssignment:	The initializer for variable 'bestDifficulty' is never used (overwritten on line 16)
826-most-profit-assigning-work/Solution.java:16:	UnusedAssignment:	The value assigned to variable 'bestDifficulty' is never used (reassigned every iteration)
",1,0,0
"class Solution {     public String maskPII(String s) {         String masked = """";         if(s.contains(""@"")){ //check if it is an email             String[] email = s.split(""@""); //split name and domain             String domain = email[1].toLowerCase(); //convert domain to lowercase             String name = email[0].toLowerCase(); //convert name to lowercase             //mask name             masked += name.charAt(0);             masked += ""*****"";             masked += name.charAt(name.length()-1);             masked += ""@""+domain; //combine masked name and domain         } else { //it is a phone number             int digits = 0;             for(int i=0; i<s.length(); i++){                 if(Character.isDigit(s.charAt(i))){                     digits++; //count number of digits                 }             }             //mask the phone number based on number of digits             if(digits == 10){ //local number only                 String local = s.replaceAll(""\\D"", """"); //remove separation characters                 masked = ""***-***-""+local.substring(local.length()-4);             } else { //country code and local number                 String local = s.replaceAll(""\\D"", """").substring(s.length()-10); //extract last 10 digits                 masked = """";                 int countryCode = digits-10; //calculate the number of digits in country code                 //add masking for country code if there is any                 if(countryCode == 1){                     masked += ""+*-"";                 } else if(countryCode == 2){                     masked += ""+**-"";                 } else if(countryCode == 3){                     masked += ""+***-"";                 }                 //add masking for local number                 masked += ""***-***-""+local.substring(local.length()-4);             }         }         return masked;     } }",1,"831-masking-personal-information/Solution.java:6:	UseLocaleWithCaseConversions:	When doing a String.toLowerCase()/toUpperCase() call, use a Locale
831-masking-personal-information/Solution.java:7:	UseLocaleWithCaseConversions:	When doing a String.toLowerCase()/toUpperCase() call, use a Locale
831-masking-personal-information/Solution.java:9:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
831-masking-personal-information/Solution.java:10:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
831-masking-personal-information/Solution.java:11:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
831-masking-personal-information/Solution.java:12:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
831-masking-personal-information/Solution.java:30:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
831-masking-personal-information/Solution.java:32:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
831-masking-personal-information/Solution.java:34:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
831-masking-personal-information/Solution.java:37:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
",0,0,0
"class Solution {     public String findReplaceString(String s, int[] indices, String[] sources, String[] targets) {         // Convert the original string to a character array to make replacements easier         char[] chars = s.toCharArray();         // Loop through the replacement operations in reverse order to avoid affecting the         // indices of earlier replacements         for (int i = indices.length - 1; i >= 0; i--) {             int index = indices[i];             String source = sources[i];             String target = targets[i];             // Check if the substring to be replaced is present at the given index             if (s.substring(index, index + source.length()).equals(source)) {                 // Replace the substring with the target string                 chars = replaceSubstring(chars, index, source.length(), target);             }         }         // Convert the character array back to a string and return it         return new String(chars);     }          private char[] replaceSubstring(char[] chars, int index, int length, String target) {         // Calculate the new length of the character array         int newLength = chars.length - length + target.length();         // Create a new character array with the new length         char[] result = new char[newLength];         // Copy the characters from the original array to the new array up to the start of the         // substring to be replaced         System.arraycopy(chars, 0, result, 0, index);         // Copy the target string into the new array at the position of the substring to be replaced         target.getChars(0, target.length(), result, index);         // Copy the characters from the original array to the new array after the end of the         // substring to be replaced         System.arraycopy(chars, index + length, result, index + target.length(), chars.length - index - length);         return result;     } }",1,"833-find-and-replace-in-string/Solution.java:18:	StringInstantiation:	Avoid instantiating String objects; this is usually unnecessary.
",0,0,0
"class Solution {     public int largestOverlap(int[][] img1, int[][] img2) {         int n = img1.length;                  int maxOverlap = 0;         for (int yShift = 1-n; yShift < n; yShift++) {             for (int xShift = 1-n; xShift < n; xShift++) {                 int overlap = 0;                 // check for overlapping cells in both images                 for (int i = 0; i < n; i++) {                     for (int j = 0; j < n; j++) {                         if (i+yShift < 0 || i+yShift >= n || j+xShift < 0 || j+xShift >= n) {                             // ignore cells outside the image borders                             continue;                         }                         overlap += img1[i][j] & img2[i+yShift][j+xShift];                     }                 }                 // update maxOverlap if current overlap is greater                 maxOverlap = Math.max(maxOverlap, overlap);             }         }         return maxOverlap;     } }",0,,0,0,0
"class Solution {     public double new21Game(int n, int k, int maxPts) {         if (k == 0 || n >= k + maxPts) return 1.0;         double[] dp = new double[n+1];         double W = 1.0, ans = 0.0;         dp[0] = 1.0;         for (int i = 1; i <= n; ++i) {             dp[i] = W / maxPts;             if (i < k) W += dp[i];             else ans += dp[i];             if (i >= maxPts) W -= dp[i - maxPts];         }         return ans;     } }",1,"837-new-21-game/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
837-new-21-game/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public String pushDominoes(String dominoes) {         char[] dominoArray = dominoes.toCharArray();         int[] forceArray = new int[dominoArray.length];  // records the accumulated force at each position          // store initial forces         int force = 0;         for (int i = 0; i < dominoArray.length; i++) {             if (dominoArray[i] == 'R') {                 force = dominoArray.length;  // max force             } else if (dominoArray[i] == 'L') {                 force = 0;             } else {                 force = Math.max(force - 1, 0);  // decay force, cannot go below zero             }             forceArray[i] += force;         }          // push dominos to the right         force = 0;         for (int i = dominoArray.length - 1; i >= 0; i--) {             if (dominoArray[i] == 'L') {                 force = dominoArray.length;  // max force             } else if (dominoArray[i] == 'R') {                 force = 0;             } else {                 force = Math.max(force - 1, 0);  // decay force, cannot go below zero             }             forceArray[i] -= force;  // subtract force to account for both left and right forces         }          // construct final string based on forceArray         StringBuilder sb = new StringBuilder();         for (int i = 0; i < forceArray.length; i++) {             if (forceArray[i] > 0) {                 sb.append('R');             } else if (forceArray[i] < 0) {                 sb.append('L');             } else {                 sb.append('.');             }         }         return sb.toString();     } }",1,"838-push-dominoes/Solution.java:34:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int numMagicSquaresInside(int[][] grid) {                  int count = 0; // counter for magic squares                  // looping through the grid         for(int i=0;i<grid.length-2;i++){             for(int j=0;j<grid[i].length-2;j++){                 if(isMagic(grid,i,j)) // checking if the subgrid is magic square                     count++;             }         }                  return count;     }          // helper function to check if a subgrid is magic square or not     public boolean isMagic(int[][] grid, int row, int col){         // checking if each element of subgrid is between 1 to 9         for(int i=row;i<=row+2;i++){             for(int j=col;j<=col+2;j++){                 if(grid[i][j]<1 || grid[i][j]>9)                     return false;             }         }                  int firstRow = grid[row][col] + grid[row][col+1] + grid[row][col+2];         int secondRow = grid[row+1][col] + grid[row+1][col+1] + grid[row+1][col+2];         int thirdRow = grid[row+2][col] + grid[row+2][col+1] + grid[row+2][col+2];                  int firstCol = grid[row][col] + grid[row+1][col] + grid[row+2][col];         int secondCol = grid[row][col+1] + grid[row+1][col+1] + grid[row+2][col+1];         int thirdCol = grid[row][col+2] + grid[row+1][col+2] + grid[row+2][col+2];                  int diag1 = grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2];         int diag2 = grid[row][col+2] + grid[row+1][col+1] + grid[row+2][col];                  // Checking if all sums are equal to 15 as this is the sum of digits from         // 1 to 9 and each row, column and diagonals should have the sum of 15         if(firstRow == 15 && secondRow == 15 && thirdRow == 15 && firstCol == 15           && secondCol == 15 && thirdCol == 15 && diag1 == 15 && diag2 == 15)             return true;                  return false;     } }",1,"840-magic-squares-in-grid/Solution.java:40:	SimplifyBooleanReturns:	This if statement can be replaced by `return {condition};`
",0,0,0
"import java.util.*;  class Solution {     public boolean canVisitAllRooms(List<List<Integer>> rooms) {                  // total number of rooms         int n = rooms.size();         // Set to keep track of the visited rooms         Set<Integer> visited = new HashSet<>();                  // Stack to hold the keys          Stack<Integer> keys = new Stack<>();         // Initialize with key to the first room         keys.add(0);                  // DFS traversal         while(!keys.isEmpty()) {             int curr = keys.pop();             // Add the current key to the visited set             visited.add(curr);             // Get the keys in the current room             List<Integer> currKeys = rooms.get(curr);             for(int key: currKeys) {                 // If the key belongs to an unvisited room, add it to the stack                 if(!visited.contains(key)) {                     keys.add(key);                 }             }         }                  // Check if all rooms are visited         return visited.size() == n;     } }",1,"841-keys-and-rooms/Solution.java:12:	LooseCoupling:	Avoid using implementation types like 'Stack'; use the interface instead
841-keys-and-rooms/Solution.java:12:	ReplaceVectorWithList:	Consider replacing this Vector with the newer java.util.List
841-keys-and-rooms/Solution.java:12:	ReplaceVectorWithList:	Consider replacing this Vector with the newer java.util.List
",0,0,0
"import java.util.*;  class Solution {     public List<Integer> splitIntoFibonacci(String num) {         List<Integer> res = new ArrayList<>();         dfs(num, 0, res);         return res;     }          private boolean dfs(String num, int index, List<Integer> res) {         int n = num.length();         if (index == n && res.size() >= 3) {             return true;         }                  for (int i = index; i < n; i++) {             String str = num.substring(index, i + 1);             if (str.charAt(0) == '0' && str.length() > 1) {                 // leading zeros are not allowed                 return false;             }             long val = Long.parseLong(str);             if (val > Integer.MAX_VALUE) {                 // the number is too large                 return false;             }             int size = res.size();             if (size >= 2 && val > (long)res.get(size - 1) + (long)res.get(size - 2)) {                 // the value is too large, stop further recursion                 return false;             }             if (size <= 1 || val == (long)res.get(size - 1) + (long)res.get(size - 2)) {                 res.add((int)val);                 if (dfs(num, i + 1, res)) {                     return true;                 }                 res.remove(res.size() - 1);             }         }         return false;     } }",1,"842-split-array-into-fibonacci-sequence/Solution.java:10:	NPathComplexity:	The method 'dfs(String, int, List<Integer>)' has an NPath complexity of 219, current threshold is 200
842-split-array-into-fibonacci-sequence/Solution.java:28:	UnnecessaryCast:	Unnecessary cast (long)
842-split-array-into-fibonacci-sequence/Solution.java:28:	UnnecessaryCast:	Unnecessary cast (long)
842-split-array-into-fibonacci-sequence/Solution.java:32:	UnnecessaryCast:	Unnecessary cast (long)
842-split-array-into-fibonacci-sequence/Solution.java:32:	UnnecessaryCast:	Unnecessary cast (long)
",0,0,0
"class Solution {     public int longestMountain(int[] arr) {         int n = arr.length;         int ans = 0;         for(int i = 1; i < n - 1; ){             if(arr[i] > arr[i - 1] && arr[i] > arr[i + 1]){                 int j = i, cnt = 1;                 while(j > 0 && arr[j] > arr[j - 1]){                     j--;                     cnt++;                 }                 while(i < n - 1 && arr[i] > arr[i + 1]){                     i++;                     cnt++;                 }                 ans = Math.max(ans, cnt);             }             else{                 i++;             }         }         return ans;     } }",1,"845-longest-mountain-in-array/Solution.java:5:35: ';' is followed by whitespace. [EmptyForIteratorPad]
845-longest-mountain-in-array/Solution.java:7:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
845-longest-mountain-in-array/Solution.java:17:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
845-longest-mountain-in-array/Solution.java:5:35: ';' is followed by whitespace. [EmptyForIteratorPad]
845-longest-mountain-in-array/Solution.java:7:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
845-longest-mountain-in-array/Solution.java:17:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",1,0,0
"public class Solution {     public boolean isNStraightHand(int[] hand, int groupSize) {         if(hand.length%groupSize!=0)return false; // If not sufficient cards are there         Map<Integer, Integer> map = new TreeMap<>();          for(int i=0;i<hand.length;i++){ // Building frequency map             map.put(hand[i], map.getOrDefault(hand[i],0)+1);         }         for(int num: map.keySet()){             int freq = map.get(num);             if(freq>0){                 for(int j=1;j<groupSize;j++){ // Check if next groupSize-1 consecutive numbers exist                     int next = num+j;                     if(map.getOrDefault(next, 0)<freq) return false; // If not exist then return false                     map.put(next, map.get(next)-freq); //decrease frequency of current number                 }             }         }         return true;     } }",1,"846-hand-of-straights/Solution.java:5:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public String shiftingLetters(String s, int[] shifts) {         // Convert the string s to a character array for easy manipulation         char[] letters = s.toCharArray();         int n = shifts.length;         int shiftSum = 0;                  // Starting from the end of shifts array         for (int i = n-1; i >= 0; i--) {             // Calculate the sum of all the shifts so far             shiftSum = (shiftSum + shifts[i]) % 26;             // Shift the letter i times and update the letters array             letters[i] = shift(letters[i], shiftSum);         }                  // Convert the char array back to a string and return         return new String(letters);     }          // Utility function to shift a letter by a given number of times     public char shift(char c, int times) {         int x = c - 'a';    // Convert the character to an index (0-25)         x = (x + times) % 26;    // Apply the shift         return (char) ('a' + x);    // Convert the shifted index back to a character     } }",1,"848-shifting-letters/Solution.java:17:	StringInstantiation:	Avoid instantiating String objects; this is usually unnecessary.
",0,0,0
"class Solution {     public int maxDistToClosest(int[] seats) {                  int maxDistance = Integer.MIN_VALUE;         int lastOccupiedIndex = -1;         int n = seats.length;                  for(int i=0;i<n;i++){                          if(seats[i]==1){                                  if(lastOccupiedIndex==-1){                     //-- if the first seat itself is taken                     maxDistance = i;                 }                 else{                     //-- to check the maximum distance between two occupied seats                 maxDistance = Math.max(maxDistance, (i-lastOccupiedIndex)/2);                 }                                  lastOccupiedIndex = i; //-- update the index of last occupied seat             }         }                  //-- to check the distance from last occupied seat to the end of row         maxDistance = Math.max(maxDistance, (n-1-lastOccupiedIndex));                  return maxDistance;     } }",1,"849-maximize-distance-to-closest-person/Solution.java:15:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
849-maximize-distance-to-closest-person/Solution.java:15:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
849-maximize-distance-to-closest-person/Solution.java:26:	UselessParentheses:	Useless parentheses.
",0,0,0
"class Solution {     public int[] loudAndRich(int[][] richer, int[] quiet) {         int n = quiet.length;         List<List<Integer>> graph = new ArrayList<>();         for (int i = 0; i < n; i++) {             graph.add(new ArrayList<>());         }         for (int[] edge : richer) {             int u = edge[0];             int v = edge[1];             graph.get(v).add(u);         }         int[] answer = new int[n];         Arrays.fill(answer, -1);         for (int i = 0; i < n; i++) {             dfs(i, graph, quiet, answer);         }         return answer;     }          private int dfs(int u, List<List<Integer>> graph, int[] quiet, int[] answer) {         if (answer[u] != -1) {             return answer[u];         }         answer[u] = u;         for (int v : graph.get(u)) {             int candidate = dfs(v, graph, quiet, answer);             if (quiet[candidate] < quiet[answer[u]]) {                 answer[u] = candidate;             }         }         return answer[u];     } }",0,,0,0,0
"class Solution {     public int peakIndexInMountainArray(int[] arr) {         int start = 0, end = arr.length-1;         while(start < end){             int mid = start + (end - start)/2;             if(arr[mid] < arr[mid+1])                 start = mid+1;             else                 end = mid;         }         return start; // or end, since start=end at this point     } }  // Time Complexity: O(log(arr.length)) // Space Complexity: O(1)",1,"852-peak-index-in-a-mountain-array/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
852-peak-index-in-a-mountain-array/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int carFleet(int target, int[] position, int[] speed) {                  int n = position.length;                  // Create a list of pairs (position, speed) to represent each car         List<Pair<Integer, Integer>> cars = new ArrayList<>();         for (int i = 0; i < n; i++) {             cars.add(new Pair<Integer, Integer>(position[i], speed[i]));         }                  // Sort the list in decreasing order of positions         Collections.sort(cars, (a, b) -> b.getKey() - a.getKey());                  // Initialize the number of fleets and the current time to reach the target         int fleets = 0;         double currentTime = -1.0;                  for (Pair<Integer, Integer> car : cars) {             int pos = car.getKey();             int spd = car.getValue();                          // Calculate the time to reach the target for this car             double time = (double)(target - pos) / spd;                          // If this car will arrive later than the current fleet, create a new one             if (time > currentTime) {                 fleets++;                 currentTime = time;             }         }                  return fleets;     } }",0,,0,0,0
"import java.util.TreeSet;  class ExamRoom {     private int n;     private TreeSet<Integer> set;      public ExamRoom(int n) {         this.n = n;         set = new TreeSet<>();     }          public int seat() {         int pos = 0;         if (!set.isEmpty()) {             int prev = -1, maxDist = -1;             for (int x : set) {                 if (prev == -1) {                     int dist = x - prev - 1;                     if (maxDist < dist) {                         maxDist = dist;                         pos = 0;                     }                 } else {                     int dist = (x - prev) / 2;                     if (maxDist < dist) {                         maxDist = dist;                         pos = prev + dist;                     }                 }                 prev = x;             }              if (n - 1 - prev > maxDist) {                 pos = n - 1;             }         }          set.add(pos);         return pos;     }          public void leave(int p) {         set.remove(p);     } }  /**  * Your ExamRoom object will be instantiated and called as such:  * ExamRoom obj = new ExamRoom(n);  * int param_1 = obj.seat();  * obj.leave(p);  */",1,"855-exam-room/ExamRoom.java:7:5: Redundant 'public' modifier. [RedundantModifier]
855-exam-room/ExamRoom.java:7:25: 'n' hides a field. [HiddenField]
855-exam-room/ExamRoom.java:15:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
855-exam-room/ExamRoom.java:7:5: Redundant 'public' modifier. [RedundantModifier]
855-exam-room/ExamRoom.java:7:25: 'n' hides a field. [HiddenField]
855-exam-room/ExamRoom.java:15:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
855-exam-room/ExamRoom.java:5:	LooseCoupling:	Avoid using implementation types like 'TreeSet'; use the interface instead
",1,0,0
"class Solution {     public int scoreOfParentheses(String s) {         Stack<Integer> stack = new Stack<Integer>();         int res = 0;         for (char c : s.toCharArray()) {             if (c == '(') {                 stack.push(res);                 res = 0;             } else {                 res = stack.pop() + Math.max(res * 2, 1);             }         }         return res;     } }",0,,0,0,0
"class Solution {     public int mirrorReflection(int p, int q) {         int gcd = gcd(p, q);         int m = p / gcd;         int n = q / gcd;         if (m % 2 == 0) {             return 2;         } else {             if (n % 2 == 0) {                 return 0;             } else {                 return 1;             }         }     }      private int gcd(int a, int b) {         return b == 0 ? a : gcd(b, a % b);     } }",0,,0,0,0
class Solution {     public int matrixScore(int[][] grid) {         int m = grid.length;         int n = grid[0].length;                  // Ensure the leftmost column contains all 1s         for (int i = 0; i < m; i++) {             if (grid[i][0] == 0) {                 for (int j = 0; j < n; j++) {                     grid[i][j] ^= 1;                 }             }         }                  // Ensure each column has more 1s than 0s         for (int j = 1; j < n; j++) {             int numOnes = 0;             for (int i = 0; i < m; i++) {                 numOnes += grid[i][j];             }             if (numOnes * 2 < m) {                 for (int i = 0; i < m; i++) {                     grid[i][j] ^= 1;                 }             }         }                  // Calculate the score         int score = 0;         for (int i = 0; i < m; i++) {             int rowSum = 0;             for (int j = 0; j < n; j++) {                 rowSum += (grid[i][j] << (n - j - 1));             }             score += rowSum;         }                  return score;     } },0,,0,0,0
"import java.util.*;  class TreeNode {     int val;     TreeNode left;     TreeNode right;     TreeNode(int x) {          val = x;      } }  class Solution {          List<Integer> result = new ArrayList<>();          public List<Integer> distanceK(TreeNode root, TreeNode target, int k) {         // create a map to store parent node for each node in the tree         Map<TreeNode, TreeNode> map = new HashMap<>();         // perform DFS to fill the map         DFS(null, root, map);         // create a set to keep track of visited nodes         Set<TreeNode> visited = new HashSet<>();         // perform BFS to find all nodes at distance k from the target         BFS(target, k, map, visited);         return result;     }          // DFS to fill the parent map     private void DFS(TreeNode parent, TreeNode node, Map<TreeNode, TreeNode> map) {         if (node == null) {             return;         }         map.put(node, parent);         DFS(node, node.left, map);         DFS(node, node.right, map);     }          // BFS to find all nodes at distance k from the target     private void BFS(TreeNode target, int k, Map<TreeNode, TreeNode> map, Set<TreeNode> visited) {         Queue<TreeNode> queue = new LinkedList<>();         queue.add(target);         visited.add(target);         int distance = 0;         while (!queue.isEmpty()) {             int size = queue.size();             for (int i = 0; i < size; i++) {                 TreeNode node = queue.poll();                 if (distance == k) {                     result.add(node.val);                 }                 if (node.left != null && !visited.contains(node.left)) {                     visited.add(node.left);                     queue.add(node.left);                 }                 if (node.right != null && !visited.contains(node.right)) {                     visited.add(node.right);                     queue.add(node.right);                 }                 TreeNode parent = map.get(node);                 if (parent != null && !visited.contains(parent)) {                     visited.add(parent);                     queue.add(parent);                 }             }             distance++;         }     } }",1,"863-all-nodes-distance-k-in-binary-tree/TreeNode.java:4:9: Variable 'val' must be private and have accessor methods. [VisibilityModifier]
863-all-nodes-distance-k-in-binary-tree/TreeNode.java:5:14: Variable 'left' must be private and have accessor methods. [VisibilityModifier]
863-all-nodes-distance-k-in-binary-tree/TreeNode.java:6:14: Variable 'right' must be private and have accessor methods. [VisibilityModifier]
863-all-nodes-distance-k-in-binary-tree/TreeNode.java:14:19: Variable 'result' must be private and have accessor methods. [VisibilityModifier]
863-all-nodes-distance-k-in-binary-tree/TreeNode.java:4:9: Variable 'val' must be private and have accessor methods. [VisibilityModifier]
863-all-nodes-distance-k-in-binary-tree/TreeNode.java:5:14: Variable 'left' must be private and have accessor methods. [VisibilityModifier]
863-all-nodes-distance-k-in-binary-tree/TreeNode.java:6:14: Variable 'right' must be private and have accessor methods. [VisibilityModifier]
863-all-nodes-distance-k-in-binary-tree/TreeNode.java:14:19: Variable 'result' must be private and have accessor methods. [VisibilityModifier]
863-all-nodes-distance-k-in-binary-tree/TreeNode.java:18:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
863-all-nodes-distance-k-in-binary-tree/TreeNode.java:29:	MethodNamingConventions:	The instance method name 'DFS' doesn't match '[a-z][a-zA-Z0-9]*'
863-all-nodes-distance-k-in-binary-tree/TreeNode.java:39:	MethodNamingConventions:	The instance method name 'BFS' doesn't match '[a-z][a-zA-Z0-9]*'
",0,0,0
" /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public TreeNode subtreeWithAllDeepest(TreeNode root) {         if(root == null) {             return null;         }         int left_depth = max_depth(root.left);         int right_depth = max_depth(root.right);         if(left_depth == right_depth) {             return root;         }         else if(left_depth > right_depth) {             return subtreeWithAllDeepest(root.left);         }         else {             return subtreeWithAllDeepest(root.right);         }     }          private int max_depth(TreeNode node) {         if(node == null) {             return 0;         }         else {             return Math.max(max_depth(node.left), max_depth(node.right)) + 1;         }     } }",1,"865-smallest-subtree-with-all-the-deepest-nodes/TreeNode.java:26:9: '}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
865-smallest-subtree-with-all-the-deepest-nodes/TreeNode.java:29:9: '}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
865-smallest-subtree-with-all-the-deepest-nodes/TreeNode.java:38:9: '}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
865-smallest-subtree-with-all-the-deepest-nodes/TreeNode.java:35:	MethodNamingConventions:	The instance method name 'max_depth' doesn't match '[a-z][a-zA-Z0-9]*'
",0,0,0
"class Solution {     public int primePalindrome(int n) {         if (n <= 2) {             return 2;         }         int nextPalindrome = getNextPalindrome(n);         while (!isPrime(nextPalindrome)) {             nextPalindrome = getNextPalindrome(nextPalindrome);         }         return nextPalindrome;     }          // Returns the next palindrome greater than or equal to n     private int getNextPalindrome(int n) {         while (!isPalindrome(n)) {             n++;         }         return n;     }          private boolean isPalindrome(int n) {         String numStr = Integer.toString(n);         int i = 0, j = numStr.length() - 1;         while (i < j) {             if (numStr.charAt(i) != numStr.charAt(j)) {                 return false;             }             i++;             j--;         }         return true;     }          private boolean isPrime(int n) {         if (n <= 1) {             return false;         }         if (n == 2 || n == 3) {             return true;         }         if (n % 2 == 0) {             return false;         }         for (int i = 3; i * i <= n; i += 2) {             if (n % i == 0) {                 return false;             }         }         return true;     } }",1,"866-prime-palindrome/Solution.java:23:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
866-prime-palindrome/Solution.java:23:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
866-prime-palindrome/Solution.java:16:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
",1,1,0
"class Solution {     public boolean reorderedPowerOf2(int n) {         int[] digits = countDigits(n); // count the frequency of digits in the input number         for (int i = 0; i <= 30; i++) { // we need to check up to 2^30 because the max input is 10^9 which is less than 2^30             int[] powerDigits = countDigits(1 << i); // count the frequency of digits in the ith power of 2             if (Arrays.equals(digits, powerDigits)) { // if the frequencies are the same, we found a power of 2 that can be formed from the input number                 return true;             }         }         return false;     }          // helper method to count the frequency of digits in a number     private int[] countDigits(int num) {         int[] digits = new int[10];         while (num > 0) {             digits[num % 10]++;             num /= 10;         }         return digits;     } }",1,"869-reordered-power-of-2/Solution.java:18:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'num'
",0,1,0
"import java.util.Arrays; import java.util.PriorityQueue;  class Solution {     public int[] advantageCount(int[] nums1, int[] nums2) {         Arrays.sort(nums1);         int[] res = new int[nums1.length];         PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (b[1] - a[1]));         for (int i = 0; i < nums2.length; i++) pq.offer(new int[] { i, nums2[i] });         int left = 0, right = nums1.length - 1;         while (!pq.isEmpty()) {             int[] cur = pq.poll();             int index = cur[0], val = cur[1];             if (nums1[right] > val) res[index] = nums1[right--];             else res[index] = nums1[left++];         }         return res;     } }",1,"870-advantage-shuffle/Solution.java:10:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
870-advantage-shuffle/Solution.java:13:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
870-advantage-shuffle/Solution.java:10:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
870-advantage-shuffle/Solution.java:13:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
870-advantage-shuffle/Solution.java:8:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
870-advantage-shuffle/Solution.java:8:	UselessParentheses:	Useless parentheses.
",1,0,0
"class Solution {     public int lenLongestFibSubseq(int[] arr) {         int n = arr.length;         int[][] dp = new int[n][n];                  //filling the diagonal and one place below diagonal values with 2         for(int i=0; i<n-1; i++) {             dp[i][i+1] = 2;         }                  //calculating the required value for each dp[i][j]         int max = 0;         for(int i=n-3; i>=0; i--) {             int m = i+2;             int j=n-1;             while(m < j) {                 int temp = arr[i] + arr[m];                 if(temp == arr[j]) {                     dp[i][m] = dp[m][j] + 1;                     max = Math.max(max, dp[i][m]);                     m++;                     j--;                 }                 else if(temp > arr[j]) {                     j--;                 }                 else {                     m++;                 }             }         }                  //returning the maximum length of Fibonacci-like subsequence         return max == 0 ? 0 : max+2;     } }",1,"873-length-of-longest-fibonacci-subsequence/Solution.java:23:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
873-length-of-longest-fibonacci-subsequence/Solution.java:26:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
873-length-of-longest-fibonacci-subsequence/Solution.java:23:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
873-length-of-longest-fibonacci-subsequence/Solution.java:26:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
"class Solution {     public int robotSim(int[] commands, int[][] obstacles) {         // Initialize a set to keep track of obstacles         Set<String> obstacleSet = new HashSet<>();         for(int[] obs: obstacles) {             obstacleSet.add(obs[0] + "","" + obs[1]);         }                  // Initialize the directions         int[][] directions = {{0,1}, {1,0}, {0,-1}, {-1,0}};                  int directionIndex = 0; // Initialize the direction index         int x = 0, y = 0; // Initialize the starting position         int maxDistance = 0; // Initialize the maximum distance                  for(int command: commands) {             if(command == -2) {                 // Turn left 90 degrees                 directionIndex = (directionIndex + 3) % 4;             } else if(command == -1) {                 // Turn right 90 degrees                 directionIndex = (directionIndex + 1) % 4;             } else {                 // Move forward k units                 for(int i = 0; i < command; i++) {                     int nextX = x + directions[directionIndex][0];                     int nextY = y + directions[directionIndex][1];                     // Check if the next position is an obstacle                     if(obstacleSet.contains(nextX + "","" + nextY)) {                         break; // Stay in the current position and move on to the next command                     }                     x = nextX;                     y = nextY;                     maxDistance = Math.max(maxDistance, x * x + y * y); // Record the maximum distance                 }             }         }                  return maxDistance; // Return the maximum distance squared     } }",1,"874-walking-robot-simulation/Solution.java:13:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
874-walking-robot-simulation/Solution.java:13:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int minEatingSpeed(int[] piles, int h) {         int low = 1;         int high = getMax(piles);         while (low <= high) {             int mid = low + (high - low) / 2;             if (canEatAll(piles, h, mid)) {                 high = mid - 1;             } else {                 low = mid + 1;             }         }         return low;     }          private boolean canEatAll(int[] piles, int h, int k) {         int time = 0;         for (int pile : piles) {             time += pile / k;             if (pile % k != 0) {                 time++;             }         }         return time <= h;     }          private int getMax(int[] arr) {         int max = Integer.MIN_VALUE;         for (int num : arr) {             max = Math.max(max, num);         }         return max;     } }",0,,0,0,0
"class Solution {     public boolean stoneGame(int[] piles) {         int n = piles.length;         int[][] dp = new int[n][n];                  for(int i=0;i<n;i++){             for(int j=i;j<n;j++){                 if(i==j) dp[i][j] = piles[i];             }         }                  for(int len=2;len<=n;len++){             for(int i=0;i<n-len+1;i++){                 int j = i+len-1;                                  if(len%2!=0)                     dp[i][j] = Math.max(piles[i] + dp[i+1][j], piles[j] + dp[i][j-1]);                 else                     dp[i][j] = Math.min(dp[i+1][j], dp[i][j-1]);             }         }                  return dp[0][n-1] > (int)Math.floor(pilesSum(piles)/2);     }          private double pilesSum(int[] piles){         double sum = 0;         for(int i=0;i<piles.length;i++){             sum += piles[i];         }         return sum;     } }",1,"877-stone-game/Solution.java:16:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
877-stone-game/Solution.java:28:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public String decodeAtIndex(String s, int k) {         long size = 0; // current size of decoded string         int n = s.length();                  // calculate the size of the decoded string         for (int i = 0; i < n; i++) {             char c = s.charAt(i);             if (Character.isLetter(c)) {                 size++;             } else {                 size *= c - '0'; // repeat the previous string c-1 times             }         }                  // iterate through the string backwards         for (int i = n-1; i >= 0; i--) {             char c = s.charAt(i);             k %= size;             if (k == 0 && Character.isLetter(c)) {                 // the kth character is a letter and we have reached the end                 return Character.toString(c);             }             if (Character.isDigit(c)) {                 size /= c - '0'; // backtrack to the previous size             } else {                 size--;             }         }                  // return the first letter of the decoded string         return Character.toString(s.charAt(0));     } }",1,"880-decoded-string-at-index/Solution.java:19:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'k'
",0,1,0
"class Solution {     public int numRescueBoats(int[] people, int limit) {         Arrays.sort(people); //Sorting the array          int low = 0;         int high = people.length - 1;         int boats = 0;          while(low <= high){              if(people[low] + people[high] <= limit){ //Checking if two people can be boarded on the same boat                 low++;                 high--;             }              else{                 high--; //If not, reduce the weight of the high index (bigger number) so that it can be boarded alone on a boat             }              boats++; //Incrementing counter of boats used          }          return boats; //Returning the minimum number of boats needed     } }",1,"881-boats-to-save-people/Solution.java:14:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
881-boats-to-save-people/Solution.java:14:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
"class Solution {     public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {         int[][] ans = new int[rows * cols][2];         ans[0] = new int[]{rStart, cStart};         int x = 0, y = 1, tmp, i = 0, j = 1, k = 0;         while (j < rows * cols) {             int step = k / 2 + 1;             for (int s = 0; s < step; s++) {                 rStart += x;                 cStart += y;                 if (rStart >= 0 && rStart < rows && cStart >= 0 && cStart < cols) {                     ans[j++] = new int[]{rStart, cStart};                 }             }             tmp = x;             x = y;             y = -tmp;             k++;         }         return ans;     } }",1,"885-spiral-matrix-iii/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
885-spiral-matrix-iii/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
885-spiral-matrix-iii/Solution.java:5:	UnusedLocalVariable:	Avoid unused local variables such as 'i'.
885-spiral-matrix-iii/Solution.java:9:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'rStart'
885-spiral-matrix-iii/Solution.java:10:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'cStart'
",1,1,0
"import java.util.*;  class Solution {     public boolean possibleBipartition(int n, int[][] dislikes) {         // create the graph         List<Integer>[] graph = new ArrayList[n+1];         for (int i = 1; i <= n; i++) {             graph[i] = new ArrayList<>();         }         for (int[] edge : dislikes) {             graph[edge[0]].add(edge[1]);             graph[edge[1]].add(edge[0]);         }                  // initialize the colors array         int[] colors = new int[n+1];         Arrays.fill(colors, -1);                  // color the graph         for (int i = 1; i <= n; i++) {             if (colors[i] == -1 && !dfs(graph, colors, i, 0)) {                 return false;             }         }                  return true;     }          private boolean dfs(List<Integer>[] graph, int[] colors, int node, int color) {         colors[node] = color;         for (int neighbor : graph[node]) {             if (colors[neighbor] == color) {                 return false;             }             if (colors[neighbor] == -1 && !dfs(graph, colors, neighbor, 1-color)) {                 return false;             }         }         return true;     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {         // Create a HashMap to store the values and their indexes of postorder array         Map<Integer, Integer> postMap = new HashMap<>();         for(int i=0; i<postorder.length; i++) {             postMap.put(postorder[i], i);         }         // Call the helper function to construct the binary tree         return helper(preorder, postorder, 0, preorder.length-1, 0, postorder.length-1, postMap);     }          // Recursive helper function to construct the binary tree using pre and post order traversal     private TreeNode helper(int[] preorder, int[] postorder, int preStart, int preEnd, int postStart, int postEnd, Map<Integer, Integer> postMap) {         // Base case         if(preEnd < preStart) {             return null;         }         // Create a new TreeNode with the value of the first element in preorder array         TreeNode root = new TreeNode(preorder[preStart]);         // Base case         if(preEnd == preStart) {             return root;         }         // Find the index of the root value in postorder array using the HashMap         int postRoot = postMap.get(preorder[preStart]);         // Calculate the length of the left subtree         int leftLength = postRoot - postStart + 1;         // Recursively construct the left and right subtrees         root.left = helper(preorder, postorder, preStart+1, preStart+leftLength, postStart, postRoot, postMap);         root.right = helper(preorder, postorder, preStart+leftLength+1, preEnd, postRoot+1, postEnd-1, postMap);         // Return the root of the constructed binary tree         return root;     } }",0,,0,0,0
"import java.util.*; class Solution {     public List<String> findAndReplacePattern(String[] words, String pattern) {         List<String> ans = new ArrayList<>();         for(String word : words)         {             if(matches(word, pattern))                 ans.add(word);         }         return ans;     }     public boolean matches(String word, String pattern)     {         if(word.length() != pattern.length())             return false;         HashMap<Character, Character> map1 = new HashMap<>();         HashMap<Character, Character> map2 = new HashMap<>();         for(int i=0; i<word.length(); i++)         {             char w = word.charAt(i);             char p = pattern.charAt(i);             if(map1.containsKey(w))             {                 if(map1.get(w) != p)                     return false;             }             else             {                 if(map2.containsKey(p))                     return false;                 map1.put(w,p);                 map2.put(p,w);             }         }         return true;     } }",1,"890-find-and-replace-pattern/Solution.java:6:9: '{' at column 9 should be on the previous line. [LeftCurly]
890-find-and-replace-pattern/Solution.java:13:5: '{' at column 5 should be on the previous line. [LeftCurly]
890-find-and-replace-pattern/Solution.java:19:9: '{' at column 9 should be on the previous line. [LeftCurly]
890-find-and-replace-pattern/Solution.java:23:13: '{' at column 13 should be on the previous line. [LeftCurly]
890-find-and-replace-pattern/Solution.java:26:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
890-find-and-replace-pattern/Solution.java:28:13: '{' at column 13 should be on the previous line. [LeftCurly]
890-find-and-replace-pattern/Solution.java:6:9: '{' at column 9 should be on the previous line. [LeftCurly]
890-find-and-replace-pattern/Solution.java:13:5: '{' at column 5 should be on the previous line. [LeftCurly]
890-find-and-replace-pattern/Solution.java:19:9: '{' at column 9 should be on the previous line. [LeftCurly]
890-find-and-replace-pattern/Solution.java:23:13: '{' at column 13 should be on the previous line. [LeftCurly]
890-find-and-replace-pattern/Solution.java:26:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
890-find-and-replace-pattern/Solution.java:28:13: '{' at column 13 should be on the previous line. [LeftCurly]
890-find-and-replace-pattern/Solution.java:16:	LooseCoupling:	Avoid using implementation types like 'HashMap'; use the interface instead
890-find-and-replace-pattern/Solution.java:17:	LooseCoupling:	Avoid using implementation types like 'HashMap'; use the interface instead
",0,0,0
class Solution {     public int numSpecialEquivGroups(String[] words) {         Set<String> set = new HashSet<>(); // to store special equivalent strings         for (String word : words) {             // Create two stringbuilders to hold the odd and even indexed characters             StringBuilder odd = new StringBuilder();             StringBuilder even = new StringBuilder();             for (int i = 0; i < word.length(); i++) {                 if (i % 2 == 0) {                     even.append(word.charAt(i));                 } else {                     odd.append(word.charAt(i));                 }             }             char[] chars1 = even.toString().toCharArray(); // convert to character array             char[] chars2 = odd.toString().toCharArray();  // convert to character array             Arrays.sort(chars1); // sort even indexed characters             Arrays.sort(chars2); // sort odd indexed characters             set.add(new String(chars1) + new String(chars2)); // add special equivalent string to set         }         return set.size(); // return number of groups     } },1,"893-groups-of-special-equivalent-strings/Solution.java:19:	StringInstantiation:	Avoid instantiating String objects; this is usually unnecessary.
893-groups-of-special-equivalent-strings/Solution.java:19:	StringInstantiation:	Avoid instantiating String objects; this is usually unnecessary.
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public List<TreeNode> allPossibleFBT(int n) {         List<TreeNode> result = new ArrayList<>();          if (n % 2 == 0) {             return result;         }          if (n == 1) {             result.add(new TreeNode(0));             return result;         }          for (int i = 1; i < n; i += 2) {             List<TreeNode> leftSubtrees = allPossibleFBT(i);             List<TreeNode> rightSubtrees = allPossibleFBT(n - i - 1);              for (TreeNode left : leftSubtrees) {                 for (TreeNode right : rightSubtrees) {                     TreeNode root = new TreeNode(0);                     root.left = left;                     root.right = right;                     result.add(root);                 }             }         }          return result;     } }",0,,0,0,0
class Solution {     public int subarrayBitwiseORs(int[] arr) {         Set<Integer> res = new HashSet<>();         Set<Integer> cur = new HashSet<>();         for (int num : arr) {             Set<Integer> next = new HashSet<>();             next.add(num);             for (int val : cur) {                 next.add(num | val);             }             res.addAll(cur = next);         }         return res.size();     } }   // Time Complexity: O(N log W) where N is the length of the input array and W is the maximum value of an element in the array.  // Space Complexity: O(N log W) to store intermediate results.,1,"898-bitwise-ors-of-subarrays/Solution.java:11:28: Inner assignments should be avoided. [InnerAssignment]
898-bitwise-ors-of-subarrays/Solution.java:11:28: Inner assignments should be avoided. [InnerAssignment]
",0,0,0
class RLEIterator {     int[] encoding;     int curIndex;     int curCount;      public RLEIterator(int[] encoding) {         this.encoding = encoding;         curIndex = 0;         curCount = encoding[0];     }      public int next(int n) {         while (curIndex < encoding.length && n > 0) {             if (curCount >= n) {                 curCount -= n;                 return encoding[curIndex + 1];             } else {                 n -= curCount;                 curIndex += 2;                 if (curIndex < encoding.length) {                     curCount = encoding[curIndex];                 }             }         }         return -1;     } },1,"900-rle-iterator/RLEIterator.java:2:11: Variable 'encoding' must be private and have accessor methods. [VisibilityModifier]
900-rle-iterator/RLEIterator.java:3:9: Variable 'curIndex' must be private and have accessor methods. [VisibilityModifier]
900-rle-iterator/RLEIterator.java:4:9: Variable 'curCount' must be private and have accessor methods. [VisibilityModifier]
900-rle-iterator/RLEIterator.java:6:5: Redundant 'public' modifier. [RedundantModifier]
900-rle-iterator/RLEIterator.java:6:30: 'encoding' hides a field. [HiddenField]
900-rle-iterator/RLEIterator.java:2:11: Variable 'encoding' must be private and have accessor methods. [VisibilityModifier]
900-rle-iterator/RLEIterator.java:3:9: Variable 'curIndex' must be private and have accessor methods. [VisibilityModifier]
900-rle-iterator/RLEIterator.java:4:9: Variable 'curCount' must be private and have accessor methods. [VisibilityModifier]
900-rle-iterator/RLEIterator.java:6:5: Redundant 'public' modifier. [RedundantModifier]
900-rle-iterator/RLEIterator.java:6:30: 'encoding' hides a field. [HiddenField]
900-rle-iterator/RLEIterator.java:7:	ArrayIsStoredDirectly:	The user-supplied array 'encoding' is stored directly.
900-rle-iterator/RLEIterator.java:18:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
",0,1,0
class StockSpanner {        // member variables     Stack<Integer> prices;     Stack<Integer> spans;          public StockSpanner() {         prices = new Stack<Integer>(); // stack to store prices         spans = new Stack<Integer>(); // stack to store spans     }          public int next(int price) {         int span = 1;         while (!prices.isEmpty() && prices.peek() <= price) {             prices.pop();             span += spans.pop();         }         prices.push(price);         spans.push(span);         return span;     } },1,"901-online-stock-span/StockSpanner.java:4:20: Variable 'prices' must be private and have accessor methods. [VisibilityModifier]
901-online-stock-span/StockSpanner.java:5:20: Variable 'spans' must be private and have accessor methods. [VisibilityModifier]
901-online-stock-span/StockSpanner.java:7:5: Redundant 'public' modifier. [RedundantModifier]
901-online-stock-span/StockSpanner.java:4:20: Variable 'prices' must be private and have accessor methods. [VisibilityModifier]
901-online-stock-span/StockSpanner.java:5:20: Variable 'spans' must be private and have accessor methods. [VisibilityModifier]
901-online-stock-span/StockSpanner.java:7:5: Redundant 'public' modifier. [RedundantModifier]
",0,0,0
class Solution {     public int totalFruit(int[] fruits) {         int maxFruits = 0;         int currentFruits = 0;         int lastFruit = -1;         int secondLastFruit = -1;         int lastFruitCount = 0;         int currentFruitCount = 0;                  for(int fruit : fruits) {             if(fruit == lastFruit || fruit == secondLastFruit) {                 currentFruits++;                 if(fruit == lastFruit) {                     lastFruitCount++;                 } else {                     currentFruitCount++;                     secondLastFruit = lastFruit;                     lastFruitCount = 1;                 }             } else {                 currentFruits = lastFruitCount + 1;                 lastFruitCount = 1;                 currentFruitCount = 0;                 secondLastFruit = lastFruit;             }                          if(currentFruits > maxFruits) {                 maxFruits = currentFruits;             }                          lastFruit = fruit;         }                  return maxFruits;     } },1,"904-fruit-into-baskets/Solution.java:8:	UnusedLocalVariable:	Avoid unused local variables such as 'currentFruitCount'.
",0,0,0
class Solution {     public int sumSubarrayMins(int[] arr) {         int n = arr.length;         int MOD = (int) 1e9 + 7;          Stack<Integer> stack = new Stack<>();         int[] left = new int[n];         for (int i = 0; i < n; i++) {             while (!stack.isEmpty() && arr[stack.peek()] >= arr[i]) {                 stack.pop();             }             left[i] = stack.isEmpty() ? -1 : stack.peek();             stack.push(i);         }          stack.clear();         int[] right = new int[n];         for (int i = n-1; i >= 0; i--) {             while (!stack.isEmpty() && arr[stack.peek()] > arr[i]) {                 stack.pop();             }             right[i] = stack.isEmpty() ? n : stack.peek();             stack.push(i);         }          long ans = 0L;         for (int i = 0; i < n; i++) {             long contribution = (long) arr[i] * (i - left[i]) * (right[i] - i);             ans = (ans + contribution) % MOD;         }         return (int) ans;     } },0,,0,0,0
"class Solution {     public int snakesAndLadders(int[][] board) {         int n = board.length;         int target = n * n;          Queue<Integer> queue = new LinkedList<>();         boolean[] visited = new boolean[target + 1];                  queue.offer(1);         visited[1] = true;         int moves = 0;                  while (!queue.isEmpty()) {             int size = queue.size();                          for (int i = 0; i < size; i++) {                 int curr = queue.poll();                                  if (curr == target) {                     return moves;                 }                                  for (int next = curr + 1; next <= Math.min(curr + 6, target); next++) {                     int[] coordinates = getCoordinates(next, n);                     int row = coordinates[0];                     int col = coordinates[1];                                          int dest = board[row][col] == -1 ? next : board[row][col];                                          if (!visited[dest]) {                         queue.offer(dest);                         visited[dest] = true;                     }                 }             }                          moves++;         }                  return -1;     }          private int[] getCoordinates(int curr, int n) {         int row = n - 1 - (curr - 1) / n;         int col = (curr - 1) % n;         if (row % 2 == n % 2) {             return new int[] {row, n - 1 - col};         } else {             return new int[] {row, col};         }     } }",0,,0,0,0
"class Solution {     public int smallestRangeII(int[] nums, int k) {         int n = nums.length;         Arrays.sort(nums);                  int ans = nums[n-1] - nums[0]; //initial difference                  for(int i=0; i<n-1; i++){             int max = Math.max(nums[i] + k, nums[n-1] - k); //add k to smaller element or subtract k from larger element             int min = Math.min(nums[0] + k, nums[i+1] - k); //add k to smaller element or subtract k from larger element             ans = Math.min(ans, max - min); //update the minimum difference         }                  return ans;     } }",0,,0,0,0
"import java.util.*;  class TopVotedCandidate {     int[] leadingCandidates; //to store the current leading candidate at each point of time     int[] time; //the times corresponding to the votes in persons array     int[] personVotes; //count of votes for each person     public TopVotedCandidate(int[] persons, int[] times) {         int maxVote = 0; //to keep count of maximum votes received by a person         leadingCandidates = new int[persons.length]; //initializing leadingCandidates array         time = new int[persons.length]; //initializing time array         personVotes = new int[persons.length]; //initializing personVotes array         Map<Integer, Integer> personVotesMap = new HashMap<>(); //to keep count of votes for each person                  for(int i = 0; i < persons.length; i++){             //incrementing the vote count for the corresponding person and updating the maximum vote count             int votes = personVotesMap.getOrDefault(persons[i], 0) + 1;             personVotesMap.put(persons[i], votes);             if(votes >= maxVote){                 maxVote = votes;                 leadingCandidates[i] = persons[i];             }else{                 leadingCandidates[i] = leadingCandidates[i-1];             }             time[i] = times[i];             personVotes[i] = persons[i];         }     }          public int q(int t) {         int index = Arrays.binarySearch(time, t); //finding the index of the time in the time array         if(index < 0) index = -index - 2; //if time is not present, finding the index of the largest element smaller than the time                  return leadingCandidates[index]; //returning the leading candidate at that time     } }  public class Main {     public static void main(String[] args) {         TopVotedCandidate topVotedCandidate = new TopVotedCandidate(new int[]{0, 1, 1, 0, 0, 1, 0}, new int[]{0, 5, 10, 15, 20, 25, 30});         System.out.println(topVotedCandidate.q(3)); // return 0         System.out.println(topVotedCandidate.q(12)); // return 1         System.out.println(topVotedCandidate.q(25)); // return 1         System.out.println(topVotedCandidate.q(15)); // return 0         System.out.println(topVotedCandidate.q(24)); // return 0         System.out.println(topVotedCandidate.q(8)); // return 1     } }",1,"911-online-election/Main.java:4:11: Variable 'leadingCandidates' must be private and have accessor methods. [VisibilityModifier]
911-online-election/Main.java:5:11: Variable 'time' must be private and have accessor methods. [VisibilityModifier]
911-online-election/Main.java:6:11: Variable 'personVotes' must be private and have accessor methods. [VisibilityModifier]
911-online-election/Main.java:7:5: Redundant 'public' modifier. [RedundantModifier]
911-online-election/Main.java:37:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
911-online-election/Main.java:4:11: Variable 'leadingCandidates' must be private and have accessor methods. [VisibilityModifier]
911-online-election/Main.java:5:11: Variable 'time' must be private and have accessor methods. [VisibilityModifier]
911-online-election/Main.java:6:11: Variable 'personVotes' must be private and have accessor methods. [VisibilityModifier]
911-online-election/Main.java:7:5: Redundant 'public' modifier. [RedundantModifier]
911-online-election/Main.java:37:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
911-online-election/Main.java:12:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
911-online-election/Main.java:29:	ShortMethodName:	Avoid using short method names
911-online-election/Main.java:37:	UseUtilityClass:	This utility class has a non-private constructor
",0,0,0
"class Solution {     public int[] sortArray(int[] nums) {         mergeSort(nums, 0, nums.length -1);         return nums;     }          // Implement Merge sort recursively     private void mergeSort(int[] nums, int left, int right) {         if(left < right) {             // Find the middle point to divide the array into two halves             int mid = (left + right) / 2;                          // recurcively sort two array halves             mergeSort(nums, left, mid);             mergeSort(nums, mid+1, right);                          //Merge the sorted halves             merge(nums, left, mid, right);         }     }          // Merge two subarrays of nums[] : left array [left...mid], right array [mid+1...right]     void merge(int[] nums, int left, int mid, int right) {         //Find sizes of two sub-arrays to be merged         int n1 = mid - left + 1;         int n2 = right - mid;                  //Create temp arrays          int L[] = new int[n1];         int R[] = new int[n2];                  //Copy data to temp arrays         for(int i = 0; i < n1; i++) {             L[i] = nums[left + i];         }         for(int j = 0; j < n2; j++) {             R[j] = nums[mid + 1 + j];         }                  // merge two temp arrays                   //Initial indexes of left and right subarrays         int i = 0, j = 0;                  //Initial index of merged subarray array         int k = left;                  while(i < n1 && j < n2) {             if(L[i] <= R[j]) {                 nums[k] = L[i];                 i++;             } else {                 nums[k] = R[j];                 j++;             }             k++;         }                  // Copy remaining elements of L[] if there are any         while(i < n1) {             nums[k] = L[i];             i++;             k++;         }                  // Copy remaining elements of R[] if there are any         while(j < n2) {             nums[k] = R[j];             j++;             k++;         }     } }",1,"912-sort-an-array/Solution.java:29:14: Array brackets at illegal position. [ArrayTypeStyle]
912-sort-an-array/Solution.java:30:14: Array brackets at illegal position. [ArrayTypeStyle]
912-sort-an-array/Solution.java:43:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
912-sort-an-array/Solution.java:29:14: Array brackets at illegal position. [ArrayTypeStyle]
912-sort-an-array/Solution.java:30:14: Array brackets at illegal position. [ArrayTypeStyle]
912-sort-an-array/Solution.java:43:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int partitionDisjoint(int[] nums) {         int n = nums.length;         int[] preMax = new int[n];         preMax[0] = nums[0];         for(int i=1;i<n;i++){             preMax[i] = Math.max(preMax[i-1],nums[i]);         }                  int[] sufMin = new int [n];         sufMin[n-1] = nums[n-1];         for(int i=n-2;i>=0;i--){             sufMin[i] = Math.min(sufMin[i+1],nums[i]);         }                  int i=0;         while(preMax[i]>sufMin[i+1]){             i++;         }         return i+1;     } }",0,,0,0,0
"class Solution {     public List<String> wordSubsets(String[] words1, String[] words2) {                  List<String> answer = new ArrayList<>(); //result list                  int[] maxFreq = new int[26]; //count frequency of each letter in all words in words2          for (String word : words2) {             int[] freq = new int[26];              for (char c : word.toCharArray()) {                 freq[c - 'a']++;                 maxFreq[c - 'a'] = Math.max(maxFreq[c - 'a'], freq[c - 'a']);             }         }          for (String word : words1) {             int[] freq = new int[26];              for (char c : word.toCharArray()) {                 freq[c - 'a']++;             }                          boolean isUniversal = true;                          for (int i = 0; i < 26; i++) {                 if (maxFreq[i] > freq[i]) {                     isUniversal = false;                     break;                 }             }                          if (isUniversal) {                 answer.add(word);             }         }                  return answer;     } }",0,,0,0,0
"class Solution {     public int maxSubarraySumCircular(int[] nums) {         int n = nums.length;         int maxSum = nums[0];         int minSum = nums[0];         int currentMax = nums[0];         int currentMin = nums[0];         int totalSum = nums[0];          // max sum in a standard subarray         for (int i = 1; i < n; i++) {             currentMax = Math.max(nums[i], currentMax + nums[i]);             maxSum = Math.max(maxSum, currentMax);             totalSum += nums[i];         }          // min sum in a standard subarray         for (int i = 1; i < n; i++) {             currentMin = Math.min(nums[i], currentMin + nums[i]);             minSum = Math.min(minSum, currentMin);         }          // max sum in a circular subarray         if (totalSum == minSum) {             return maxSum;         } else {             return Math.max(maxSum, totalSum - minSum);         }     } }",0,,0,0,0
import java.util.*;  class CBTInserter {      TreeNode root;     List<TreeNode> treeList;      public CBTInserter(TreeNode root) {         this.root = root;         this.treeList = new ArrayList<>();         if(root!=null) {             Queue<TreeNode> queue = new LinkedList<>();             queue.add(root);             while(!queue.isEmpty()) {                 TreeNode node = queue.poll();                 treeList.add(node);                 if(node.left!=null) {                     queue.add(node.left);                 }                 if(node.right!=null) {                     queue.add(node.right);                 }             }         }     }          public int insert(int val) {         int n = treeList.size();         TreeNode newNode = new TreeNode(val);         TreeNode parentNode = treeList.get((n-1)/2);         treeList.add(newNode);         if(n%2==1) {             parentNode.left = newNode;         } else {             parentNode.right = newNode;         }         return parentNode.val;     }          public TreeNode get_root() {         return root;     } }  /**  * Your CBTInserter object will be instantiated and called as such:  * CBTInserter obj = new CBTInserter(root);  * int param_1 = obj.insert(val);  * TreeNode param_2 = obj.get_root();  */,1,"919-complete-binary-tree-inserter/CBTInserter.java:5:14: Variable 'root' must be private and have accessor methods. [VisibilityModifier]
919-complete-binary-tree-inserter/CBTInserter.java:6:20: Variable 'treeList' must be private and have accessor methods. [VisibilityModifier]
919-complete-binary-tree-inserter/CBTInserter.java:8:5: Redundant 'public' modifier. [RedundantModifier]
919-complete-binary-tree-inserter/CBTInserter.java:8:33: 'root' hides a field. [HiddenField]
919-complete-binary-tree-inserter/CBTInserter.java:5:14: Variable 'root' must be private and have accessor methods. [VisibilityModifier]
919-complete-binary-tree-inserter/CBTInserter.java:6:20: Variable 'treeList' must be private and have accessor methods. [VisibilityModifier]
919-complete-binary-tree-inserter/CBTInserter.java:8:5: Redundant 'public' modifier. [RedundantModifier]
919-complete-binary-tree-inserter/CBTInserter.java:8:33: 'root' hides a field. [HiddenField]
919-complete-binary-tree-inserter/CBTInserter.java:40:	MethodNamingConventions:	The instance method name 'get_root' doesn't match '[a-z][a-zA-Z0-9]*'
",0,0,0
"class Solution {     public int minAddToMakeValid(String s) {         int openBrackets = 0, closedBrackets = 0;         for(int i=0; i<s.length(); i++){             char c = s.charAt(i);             if(c=='('){                 openBrackets++;             }             else{                 if(openBrackets>0){                     openBrackets--;                 }                 else{                     closedBrackets++;                 }             }         }         return openBrackets+closedBrackets;     } }  // The code above works as follows: // We keep a count of how many opening brackets have been seen so far // If we see a closing bracket and there are opening brackets left, // we match it with an opening bracket, subtracting one from the count of open brackets // If we see a closing bracket and there are no opening brackets left, // then we know that we have to add one to the count of closing brackets.  // Finally we return the sum of the count of the brackets that are missing  // (the opening brackets minus the ones that got matched plus the closing brackets) // as our answer.",1,"921-minimum-add-to-make-parentheses-valid/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
921-minimum-add-to-make-parentheses-valid/Solution.java:8:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
921-minimum-add-to-make-parentheses-valid/Solution.java:12:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
921-minimum-add-to-make-parentheses-valid/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
921-minimum-add-to-make-parentheses-valid/Solution.java:8:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
921-minimum-add-to-make-parentheses-valid/Solution.java:12:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",1,0,0
"class Solution {     public int threeSumMulti(int[] arr, int target) {         int MOD = 1000000007; // modulo          int result = 0;         int[] count = new int[101]; // count the frequency to ease the calculation         for (int num : arr) count[num]++;         for (int i = 0; i <= 100; i++) {             for (int j = i; j <= 100; j++) {                 int k = target - i - j;                 if (k < 0 || k > 100) continue; // ensure k is between 0 to 100                 if (i == j && j == k) {                     result += count[i] * (count[i] - 1) * (count[i] - 2) / 6; // the combinations of choosing 3 from 3 numbers are 1                 } else if (i == j && j != k) {                     result += count[i] * (count[i] - 1) / 2 * count[k]; // the combinations of choosing 2 from 3 numbers are 3                 } else if (i < j && j < k) {                      result += count[i] * count[j] * count[k]; // the combination of choosing 1 from 3 numbers are 6                 }                 result %= MOD;             }         }         return result;     } }",0,,0,0,0
"class Solution {     public int minFlipsMonoIncr(String s) {         int ones = 0; // count of 1's         int flips = 0; // count of flips required                  for (int i = 0; i < s.length(); i++) {             if (s.charAt(i) == '0') {                 // If we flip this 0 to 1, we need to count the total number of 1's so far                  // and apply these many flips to convert 1's to 0's                 flips = Math.min(ones, flips + 1);             } else {                 ones++; // Increment count of 1's             }         }                  return flips; // Return the minimum number of flips required     } }",0,,0,0,0
"class Solution {     public int numSubarraysWithSum(int[] nums, int goal) {         int count = 0;         int sum = 0;         int[] map = new int[nums.length + 1];         map[0] = 1;                  for (int i = 0; i < nums.length; i++) {             sum += nums[i];             if (sum >= goal) {                 count += map[sum - goal];             }             map[sum]++;         }                  return count;     } }",1,"930-binary-subarrays-with-sum/Solution.java:8:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int minFallingPathSum(int[][] matrix) {         int n = matrix.length;         int[][] dp = new int[n][n];                  // Initialize the first row of dp         for(int i=0; i<n; i++) {             dp[0][i] = matrix[0][i];         }                  // Calculate the minimum falling path sum for each row         for(int i=1; i<n; i++) {             for(int j=0; j<n; j++) {                 dp[i][j] = dp[i-1][j];                 if(j>0) {                     dp[i][j] = Math.min(dp[i][j], dp[i-1][j-1]);                 }                 if(j<n-1) {                     dp[i][j] = Math.min(dp[i][j], dp[i-1][j+1]);                 }                 dp[i][j] += matrix[i][j];             }         }                  // Find the minimum falling path sum in the last row of dp         int minSum = Integer.MAX_VALUE;         for(int j=0; j<n; j++) {             minSum = Math.min(minSum, dp[n-1][j]);         }                  return minSum;     } }",0,,0,0,0
"class Solution {     //Helper function to generate beautiful array recursively     public int[] generateBeautifulArray(int n) {         int[] res = new int[n];         if(n == 1) {             res[0] = 1;             return res;         }         int i = 0;         for(int x: generateBeautifulArray((n+1)/2)) {             res[i++] = 2*x - 1;         }         for(int x: generateBeautifulArray(n/2)) {             res[i++] = 2*x;         }         return res;     }          public int[] beautifulArray(int n) {         //Generate beautiful array and return         return generateBeautifulArray(n);     } }    // Sample Test cases public class Main{   public static void main(String[] args) {             Solution s=new Solution();             int[] result=s.beautifulArray(4);             System.out.print(""["");             for(int i=0;i<result.length;i++)                 System.out.print(result[i]+"","");             System.out.println(""]"");              result=s.beautifulArray(5);             System.out.print(""["");             for(int i=0;i<result.length;i++)                 System.out.print(result[i]+"","");             System.out.println(""]"");     } }",1,"932-beautiful-array/Main.java:27:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
932-beautiful-array/Main.java:27:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
932-beautiful-array/Main.java:27:	UseUtilityClass:	This utility class has a non-private constructor
932-beautiful-array/Main.java:32:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
932-beautiful-array/Main.java:38:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int shortestBridge(int[][] grid) {         int n = grid.length;         boolean[][] visited = new boolean[n][n];         Queue<int[]> queue = new LinkedList<>();         boolean found = false;                  // Finding the first island and marking all its cells as visited         for (int i = 0; i < n && !found; i++) {             for (int j = 0; j < n && !found; j++) {                 if (grid[i][j] == 1) {                     markIsland(i, j, grid, visited, queue);                     found = true;                 }             }         }                  int steps = 0;         int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};                  // Performing BFS to find the shortest path to connect the islands         while (!queue.isEmpty()) {             int size = queue.size();             while (size-- > 0) {                 int[] curr = queue.poll();                 for (int[] dir : dirs) {                     int x = curr[0] + dir[0];                     int y = curr[1] + dir[1];                     if (x < 0 || x >= n || y < 0 || y >= n || visited[x][y])                         continue;                     if (grid[x][y] == 1)                         return steps;                     visited[x][y] = true;                     queue.offer(new int[]{x, y});                 }             }             steps++;         }         return -1;     }          // DFS function to mark all cells of an island as visited     private void markIsland(int i, int j, int[][] grid, boolean[][] visited, Queue<int[]> queue) {         int n = grid.length;         if (i < 0 || i >= n || j < 0 || j >= n || visited[i][j] || grid[i][j] == 0)             return;         visited[i][j] = true;         queue.offer(new int[]{i, j});         markIsland(i - 1, j, grid, visited, queue);         markIsland(i + 1, j, grid, visited, queue);         markIsland(i, j - 1, grid, visited, queue);         markIsland(i, j + 1, grid, visited, queue);       } }",0,,0,0,0
"class Solution {     private final int MOD = 1000000007;          public int knightDialer(int n) {         int[][] moves = {             {4, 6},              {6, 8},              {7, 9},              {4, 8},              {0, 3, 9},              {},              {0, 1, 7},              {2, 6},              {1, 3},              {2, 4}         };                  int[][] dp = new int[n + 1][10];         Arrays.fill(dp[1], 1);         for (int i = 2; i <= n; i++) {             for (int j = 0; j < 10; j++) {                 for (int move : moves[j]) {                     dp[i][j] = (dp[i][j] + dp[i - 1][move]) % MOD;                 }             }         }                  int ans = 0;         for (int i = 0; i < 10; i++) {             ans = (ans + dp[n][i]) % MOD;         }         return ans;     } }",1,"935-knight-dialer/Solution.java:2:	FinalFieldCouldBeStatic:	This final field could be made static
",0,0,0
"import java.util.Arrays; import java.util.Comparator;  class Solution {     public String[] reorderLogFiles(String[] logs) {         Comparator<String> myComp = new Comparator<String>() {             @Override             public int compare(String s1, String s2) {                 int s1SpaceIndex = s1.indexOf("" "");                 int s2SpaceIndex = s2.indexOf("" "");                 char s1FirstChar = s1.charAt(s1SpaceIndex + 1);                 char s2FirstChar = s2.charAt(s2SpaceIndex + 1);                  if (s1FirstChar <= '9') {                     if (s2FirstChar <= '9')                         return 0;                     else                         return 1;                 }                 if (s2FirstChar <= '9') {                     return -1;                 }                  int comp = s1.substring(s1SpaceIndex + 1).compareTo(s2.substring(s2SpaceIndex + 1));                 if (comp == 0)                     return s1.substring(0, s1SpaceIndex).compareTo(s2.substring(0, s2SpaceIndex));                 return comp;             }         };          Arrays.sort(logs, myComp);         return logs;     } }",1,"937-reorder-data-in-log-files/Solution.java:6:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new Comparator<>()`
937-reorder-data-in-log-files/Solution.java:9:	UseIndexOfChar:	String.indexOf(char) is faster than String.indexOf(String).
937-reorder-data-in-log-files/Solution.java:10:	UseIndexOfChar:	String.indexOf(char) is faster than String.indexOf(String).
",0,0,0
"class Solution {     public int minAreaRect(int[][] points) {         int ans = Integer.MAX_VALUE;         Map<Integer, Set<Integer>> map = new HashMap<>();         for (int[] point : points) {             int x = point[0], y = point[1];             map.putIfAbsent(x, new HashSet<>());             map.get(x).add(y);         }         for (int i = 0; i < points.length; i++) {             int x1 = points[i][0], y1 = points[i][1];             for (int j = i + 1; j < points.length; j++) {                 int x2 = points[j][0], y2 = points[j][1];                 if (x1 == x2 || y1 == y2) continue; // cannot form a rectangle if two points are on the same line                 if (map.get(x1).contains(y2) && map.get(x2).contains(y1)) {                     ans = Math.min(ans, Math.abs(x1 - x2) * Math.abs(y1 - y2)); // update the minimum area                 }             }         }         return ans == Integer.MAX_VALUE ? 0 : ans;     } }",1,"939-minimum-area-rectangle/Solution.java:6:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
939-minimum-area-rectangle/Solution.java:11:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
939-minimum-area-rectangle/Solution.java:13:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
939-minimum-area-rectangle/Solution.java:6:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
939-minimum-area-rectangle/Solution.java:11:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
939-minimum-area-rectangle/Solution.java:13:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int minIncrementForUnique(int[] nums) {         if(nums == null || nums.length < 2) {             return 0;         }         int[] count = new int[100001]; // As 0<= nums[i] <= 100001         int moves = 0;         for(int num : nums) {             count[num]++;         }         for(int i=0; i<count.length; i++) {             if(count[i] > 1) { // If count of number is greater than one, increment moves, remove current instance and add incremented version of same.                 moves += count[i] - 1;                 count[i+1] += count[i] - 1;             }         }         return moves;     } }",0,,0,0,0
"class Solution {     public boolean validateStackSequences(int[] pushed, int[] popped) {         Stack<Integer> stack = new Stack<>();         int i = 0;         for (int x : pushed) {             stack.push(x);             while (!stack.empty() && stack.peek() == popped[i]) {                 stack.pop();                 i++;             }         }         return i == popped.length;     } }",0,,0,0,0
"class Solution {     public int removeStones(int[][] stones) {         int n = stones.length;         int[] parent = new int[n];         for(int i = 0; i < n; i++) {             parent[i] = i;         }                  // Union the stones which have same x and y coordinate         for(int i = 0; i < n; i++) {             for(int j = i + 1; j < n; j++) {                 if(stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {                     union(i, j, parent);                 }             }         }                  int count = 0;         for(int i = 0; i < n; i++) {             if(parent[i] == i) {                 count++;             }         }         return n - count;     }          private void union(int x, int y, int[] parent) {         int rootX = find(x, parent);         int rootY = find(y, parent);         if(rootX != rootY) {             parent[rootX] = rootY;         }     }          private int find(int x, int[] parent) {         if(parent[x] != x) {             parent[x] = find(parent[x], parent);         }         return parent[x];     } }",0,,0,0,0
"class Solution {     public int bagOfTokensScore(int[] tokens, int power) {         Arrays.sort(tokens);    //sort the tokens array to play them in increasing values of tokens.         int left = 0, right = tokens.length - 1;         int score = 0, maxScore = 0;         while(left <= right){             if(power >= tokens[left]){    //if we have enough power to play the leftmost token, play it.                 power -= tokens[left++];                 score++;                 maxScore = Math.max(score, maxScore);    //update the maximum score achieved so far.             }             else if(score > 0){    //if we don't have enough power, try to play a token face down (if we have already played some face up).                 power += tokens[right--];                 score--;             }             else{    //if we can't play any more tokens, break out of the loop.                 break;             }         }         return maxScore;     } }",1,"948-bag-of-tokens/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
948-bag-of-tokens/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
948-bag-of-tokens/Solution.java:11:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
948-bag-of-tokens/Solution.java:15:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
948-bag-of-tokens/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
948-bag-of-tokens/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
948-bag-of-tokens/Solution.java:11:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
948-bag-of-tokens/Solution.java:15:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
948-bag-of-tokens/Solution.java:8:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'power'
",1,1,0
"class Solution {     public String largestTimeFromDigits(int[] arr) {         // Initialize variables for storing max time and max digit value         String maxTime = """";         int maxDigits = -1;         // Generate all possible permutations of the array         for (int i = 0; i < arr.length; i++) {             for (int j = 0; j < arr.length; j++) {                 if (j == i) continue;                 for (int k = 0; k < arr.length; k++) {                     if (k == i || k == j) continue;                     for (int l = 0; l < arr.length; l++) {                         if (l == i || l == j || l == k) continue;                         // Create potential time strings                         String hours = """" + arr[i] + arr[j];                         String minutes = """" + arr[k] + arr[l];                         String time = hours + "":"" + minutes;                         // Check if time is valid and later than current max                         if (isValidTime(hours, minutes) && time.compareTo(maxTime) > 0) {                             maxTime = time;                         }                     }                 }             }         }         return maxTime;     }          // Helper function to check if a potential time is valid     private boolean isValidTime(String hours, String minutes) {         int h = Integer.parseInt(hours);         int m = Integer.parseInt(minutes);         return h < 24 && m < 60;     } }",1,"949-largest-time-for-given-digits/Solution.java:5:	UnusedLocalVariable:	Avoid unused local variables such as 'maxDigits'.
949-largest-time-for-given-digits/Solution.java:15:	AddEmptyString:	Do not add empty strings
949-largest-time-for-given-digits/Solution.java:16:	AddEmptyString:	Do not add empty strings
",0,0,0
class Solution {     public int[] deckRevealedIncreasing(int[] deck) {         int n=deck.length;         Arrays.sort(deck);         int[] ans=new int[n];         Queue<Integer> q=new LinkedList<>();         for(int i=0;i<n;i++){             q.add(i);         }         for(int i=0;i<n;i++){             ans[q.poll()]=deck[i];             q.add(q.poll());         }         return ans;     } },0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public boolean flipEquiv(TreeNode root1, TreeNode root2) {          // If both roots are null then the trees are flip equivalent         if (root1 == null && root2 == null) {             return true;         }                  // If only one of the root is null then the trees cannot be equivalent         if (root1 == null || root2 == null) {             return false;         }                  // If the values of the roots are not equal then the trees cannot be equivalent         if (root1.val != root2.val) {             return false;         }                  // Recursively check if the flip-equivalence property holds true for both possible cases         // where the left and right subtrees are flipped or not         return (flipEquiv(root1.left, root2.left) && flipEquiv(root1.right, root2.right)                 || flipEquiv(root1.left, root2.right) && flipEquiv(root1.right, root2.left));     } }",1,"951-flip-equivalent-binary-trees/TreeNode.java:30:	SimplifyBooleanReturns:	This if statement can be replaced by `return !{condition} || {elseBranch};`
951-flip-equivalent-binary-trees/TreeNode.java:36:	UselessParentheses:	Useless parentheses.
",0,0,0
"class Solution {     public boolean canReorderDoubled(int[] arr) {         HashMap<Integer, Integer> map = new HashMap<>();         for(int i: arr) {             map.put(i, map.getOrDefault(i, 0) + 1); //Count the frequency of each element         }         Arrays.sort(arr); //Sort the array to access the elements from absolute smallest to largest         for(int i: arr) {             if(map.containsKey(i) && map.containsKey(2 * i) && map.get(i) > 0 && map.get(2 * i) > 0) {                 //If both the current and its double are present and have not been used yet                 map.put(i, map.get(i) - 1); //Mark both as used                 map.put(2 * i, map.get(2 * i) - 1);             }         }         for(int i: map.values()) {             if(i != 0) return false; //If any element has not been used, it cannot be reordered         }         return true;     } }",0,,0,0,0
class Solution {     public int minDeletionSize(String[] strs) {         int numCols = strs[0].length();         int count = 0;         for (int c = 0; c < numCols; c++) {             for (int r = 1; r < strs.length; r++) {                 if (strs[r].charAt(c) < strs[r-1].charAt(c)) {                     count++;                     break;                 }             }         }         return count;     } },0,,0,0,0
"class Solution {     public int[] prisonAfterNDays(int[] cells, int n) {                  int cycle = 1;         int[] nextState = getNextState(cells);         while (!Arrays.equals(cells, nextState) && n > 1) {             cells = nextState;             nextState = getNextState(cells);             cycle++;             n--;         }                  if (n > 1) {             n %= cycle;         }                  for (int i = 0; i < n; i++) {             cells = getNextState(cells);         }                  return cells;     }          private int[] getNextState(int[] cells) {         int[] nextState = new int[cells.length];         for (int i = 1; i < cells.length - 1; i++) {             if (cells[i - 1] == cells[i + 1]) {                 nextState[i] = 1;             } else {                 nextState[i] = 0;             }         }         return nextState;     } }",1,"957-prison-cells-after-n-days/Solution.java:7:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'cells'
957-prison-cells-after-n-days/Solution.java:10:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
",0,1,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public boolean isCompleteTree(TreeNode root) {         if (root == null)             return true;                  Queue<TreeNode> queue = new LinkedList<>();         queue.offer(root);         boolean end = false;                  while (!queue.isEmpty()) {             TreeNode curr = queue.poll();             if (curr == null)                 end = true;             else {                 if (end)                     return false;                 queue.offer(curr.left);                 queue.offer(curr.right);             }         }                  return true;     } }",0,,0,0,0
"class Solution {     public int regionsBySlashes(String[] grid) {         int n = grid.length;         //Creating a 2n x 2n grid to simulate the slashes          int[][] matrix = new int[n * 3][n * 3];         int regions = 0;                  //Iterating through the rows and columns of 2n x 2n grid         for(int i=0; i<n*3; i++){             for(int j=0; j<n*3; j++){                 if(i%3 == 0 || j%3 == 0){                     //If the element has a coordinate on 2n x 2n grid, then marking it as visited by putting 1                     matrix[i][j] = 1;                 }             }         }                  //Iterating through the input grid         for(int i=0; i<n; i++){             for(int j=0; j<n; j++){                 if(grid[i].charAt(j) == '/'){                     //If the element is '/', then simulating the slash                     if(matrix[i*3][j*3+2] == 0) matrix[i*3][j*3+2] = 1;                     if(matrix[i*3+1][j*3+1] == 0) matrix[i*3+1][j*3+1] = 1;                     if(matrix[i*3+2][j*3] == 0) matrix[i*3+2][j*3] = 1;                 }else if(grid[i].charAt(j) == '\\'){                     //If the element is '\', then simulating the slash                     if(matrix[i*3][j*3] == 0) matrix[i*3][j*3] = 1;                     if(matrix[i*3+1][j*3+1] == 0) matrix[i*3+1][j*3+1] = 1;                     if(matrix[i*3+2][j*3+2] == 0) matrix[i*3+2][j*3+2] = 1;                 }             }         }                  //Counting the number of unvisited 1 x 1 squares in the 2n x 2n grid         for(int i=0; i<n*3; i++){             for(int j=0; j<n*3; j++){                 if(matrix[i][j] == 0){                     dfs(matrix, i, j);                     regions++;                 }             }         }                  return regions;     }          private void dfs(int[][] matrix, int i, int j){         if(i<0 || i>=matrix.length || j<0 || j>=matrix.length || matrix[i][j] != 0) return;         matrix[i][j] = 1;         dfs(matrix, i+1, j);         dfs(matrix, i-1, j);         dfs(matrix, i, j+1);         dfs(matrix, i, j-1);     } }",1,"959-regions-cut-by-slashes/Solution.java:2:	NPathComplexity:	The method 'regionsBySlashes(String[])' has an NPath complexity of 380, current threshold is 200
",0,0,0
"class Solution {     public int maxWidthRamp(int[] nums) {         int n = nums.length;         int[] leftMin = new int[n];         leftMin[0] = nums[0];         for (int i = 1; i < n; i++) {             leftMin[i] = Math.min(leftMin[i-1], nums[i]);         }                  int maxRampWidth = 0;         for (int j = n-1; j > maxRampWidth; j--) {             if (nums[j] >= leftMin[j]) {                 int i = findLeftIndex(leftMin, nums, 0, j, nums[j]);                 maxRampWidth = Math.max(maxRampWidth, j-i);             }         }         return maxRampWidth;     }          private int findLeftIndex(int[] leftMin, int[] nums, int lo, int hi, int target) {         while (lo < hi) {             int mid = lo + (hi - lo) / 2;             if (leftMin[mid] > target) {                 lo = mid + 1;             } else {                 hi = mid;             }         }         return lo;     } }",1,"962-maximum-width-ramp/Solution.java:20:	UnusedFormalParameter:	Avoid unused method parameters such as 'nums'.
962-maximum-width-ramp/Solution.java:24:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'lo'
962-maximum-width-ramp/Solution.java:26:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'hi'
",0,1,0
"import java.util.*;  class Solution {     public double minAreaFreeRect(int[][] points) {         int n = points.length;         if(n < 4){             return 0;         }                  Map<String, List<int[]>> map = new HashMap<>();         double minArea = Double.MAX_VALUE;                  for(int i=0;i<n;i++){             for(int j=i+1;j<n;j++){                 int[] p1 = points[i];                 int[] p2 = points[j];                                  int dist = (p2[0] - p1[0]) * (p2[0] - p1[0]) + (p2[1] - p1[1]) * (p2[1] - p1[1]);                 double center_x = (p1[0]+p2[0])/2.0;                 double center_y = (p1[1]+p2[1])/2.0;                                  String key = dist+""_""+center_x+""_""+center_y;                 map.putIfAbsent(key, new ArrayList<>());                                  List<int[]> sameDist = map.get(key);                 for(int[] p3 : sameDist){                     int[] p4 = new int[]{p2[0]+p3[0]-p1[0], p2[1]+p3[1]-p1[1]};                                          double area = calculateArea(p1, p2, p3);                     if(area > 0){                         minArea = Math.min(minArea, area);                     }                 }                                  sameDist.add(p1);             }         }         return minArea==Double.MAX_VALUE ? 0 : minArea;           }          public double calculateArea(int[] p1, int[] p2, int[] p3){         double area = 0;         area = 0.5 * (p1[0]*p2[1]+p2[0]*p3[1]+p3[0]*p1[1]-p1[1]*p2[0]-p2[1]*p3[0]-p3[1]*p1[0]);         return Math.abs(area);     } }",1,"963-minimum-area-rectangle-ii/Solution.java:10:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
963-minimum-area-rectangle-ii/Solution.java:27:	UnusedLocalVariable:	Avoid unused local variables such as 'p4'.
963-minimum-area-rectangle-ii/Solution.java:42:	UnusedAssignment:	The initializer for variable 'area' is never used (overwritten on line 43)
",0,0,0
"class Solution {     public String[] spellchecker(String[] wordlist, String[] queries) {         // Creating a hashset to store the given wordlist         HashSet<String> set = new HashSet<>();         for (String word : wordlist) {             set.add(word);         }                  // Creating two hashmaps: one to store cases and the other to store vowel errors         HashMap<String, String> caseMap = new HashMap<>();         HashMap<String, String> vowelMap = new HashMap<>();                  for (String word : wordlist) {             String lowerCase = word.toLowerCase();             String withoutVowel = lowerCase.replaceAll(""[aeiou]"", ""_"");                          if (!caseMap.containsKey(lowerCase)) {                 caseMap.put(lowerCase, word);             }             if (!vowelMap.containsKey(withoutVowel)) {                 vowelMap.put(withoutVowel, word);             }         }                  // Creating an array to store the correct answers         String[] ans = new String[queries.length];                  for (int i = 0; i < queries.length; i++) {             String word = queries[i];             String lowerCase = word.toLowerCase();             String withoutVowel = lowerCase.replaceAll(""[aeiou]"", ""_"");                          if (set.contains(word)) {                 ans[i] = word;             } else if (caseMap.containsKey(lowerCase)) {                 ans[i] = caseMap.get(lowerCase);             } else if (vowelMap.containsKey(withoutVowel)) {                 ans[i] = vowelMap.get(withoutVowel);             } else {                 ans[i] = """";             }         }                  return ans;     } }",1,"966-vowel-spellchecker/Solution.java:14:	UseLocaleWithCaseConversions:	When doing a String.toLowerCase()/toUpperCase() call, use a Locale
966-vowel-spellchecker/Solution.java:30:	UseLocaleWithCaseConversions:	When doing a String.toLowerCase()/toUpperCase() call, use a Locale
",0,0,0
"class Solution {     public int[] numsSameConsecDiff(int n, int k) {         List<Integer> result = new ArrayList<>();         if (n == 1) {             result.add(0);         }         for (int i = 1; i <= 9; i++) {             dfs(i, n - 1, k, result);         }         return result.stream().mapToInt(Integer::intValue).toArray();     }      private void dfs(int num, int n, int k, List<Integer> result) {         if (n == 0) {             result.add(num);             return;         }         List<Integer> nums = new ArrayList<>();         int lastDigit = num % 10;         nums.add(lastDigit + k);         if (k != 0) {             nums.add(lastDigit - k);         }         for (int nextNum : nums) {             if (nextNum >= 0 && nextNum <= 9) {                 int newNum = num * 10 + nextNum;                 dfs(newNum, n - 1, k, result);             }         }     } }",0,,0,0,0
"import java.util.ArrayList; import java.util.List;  class Solution {     public List<Integer> pancakeSort(int[] arr) {         List<Integer> res = new ArrayList<>();         for (int i = arr.length; i > 0 ; i--) {             int index = find(arr, i);             if (index == i-1) continue; // if the number is already in the correct position, no need to flip             if (index > 0) { // if not the first element of the array, flip to make it first                 res.add(index+1);                 flip(arr, index+1);             }             res.add(i); // flip to make it the ith element in the array             flip(arr, i);         }         return res;     }      private int find(int[] arr, int target) {         for (int i = 0; i < arr.length; i++) {             if (arr[i] == target) return i;         }         return -1;     }      private void flip(int[] arr, int k) {         int i = 0, j = k-1;         while (i < j) {             int temp = arr[i];             arr[i] = arr[j];             arr[j] = temp;             i++;             j--;         }     } }",1,"969-pancake-sorting/Solution.java:28:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
969-pancake-sorting/Solution.java:28:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set;  class Solution {     public List<Integer> powerfulIntegers(int x, int y, int bound) {         Set<Integer> set = new HashSet<>();         for (int i = 1; i <= bound; i *= x) {             for (int j = 1; i + j <= bound; j *= y) {                 set.add(i + j);                 if (y == 1) {                     break;                 }             }             if (x == 1) {                 break;             }         }         return new ArrayList<>(set);     } }",0,,0,0,0
"import java.util.ArrayList; import java.util.List;  class Solution {     List<Integer> flipped = new ArrayList<>();     int i = 0;      public List<Integer> flipMatchVoyage(TreeNode root, int[] voyage) {         return dfs(root, voyage) ? flipped : List.of(-1);     }      private boolean dfs(TreeNode node, int[] voyage) {         if (node == null) return true;         if (node.val != voyage[i++]) return false;         if (node.left != null && node.left.val != voyage[i]) {             flipped.add(node.val);             return dfs(node.right, voyage) && dfs(node.left, voyage);                         }         return dfs(node.left, voyage) && dfs(node.right, voyage);     } }",1,"971-flip-binary-tree-to-match-preorder-traversal/Solution.java:5:19: Variable 'flipped' must be private and have accessor methods. [VisibilityModifier]
971-flip-binary-tree-to-match-preorder-traversal/Solution.java:6:9: Variable 'i' must be private and have accessor methods. [VisibilityModifier]
971-flip-binary-tree-to-match-preorder-traversal/Solution.java:5:19: Variable 'flipped' must be private and have accessor methods. [VisibilityModifier]
971-flip-binary-tree-to-match-preorder-traversal/Solution.java:6:9: Variable 'i' must be private and have accessor methods. [VisibilityModifier]
971-flip-binary-tree-to-match-preorder-traversal/Solution.java:14:	AssignmentInOperand:	Avoid assignments in operands
",0,0,0
"import java.util.Arrays;  class Solution {     public int[][] kClosest(int[][] points, int k) {         Arrays.sort(points, (a, b) -> distance(a) - distance(b));         return Arrays.copyOfRange(points, 0, k);     }          private int distance(int[] point) {         return point[0] * point[0] + point[1] * point[1];     } }",0,,0,0,0
"class Solution {     public int subarraysDivByK(int[] nums, int k) {         Map<Integer, Integer> map = new HashMap<>();         int prefixSum = 0;         map.put(0,1);         int count = 0;         for(int i=0; i<nums.length; i++) {             prefixSum += nums[i];             int mod = prefixSum % k;             if(mod < 0) {                 mod += k;             }             int freq = map.getOrDefault(mod, 0);             count += freq;             map.put(mod, freq+1);         }         return count;     } }",1,"974-subarray-sums-divisible-by-k/Solution.java:7:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int maxTurbulenceSize(int[] arr) {         int maxLength = 1, curLength = 1;         // comparisons is initially set to 0, which means the array has only one element         // and it's already a turbulent subarray of length 1         for (int i = 1, comparisons = 0; i < arr.length; i++) {             int cmp = Integer.compare(arr[i - 1], arr[i]);             if (cmp == 0) {                 // same elements don't contribute to the length of a turbulent subarray                 curLength = 1;                 comparisons = 0;             } else if (comparisons == 0 || cmp * comparisons < 0) {                 // a new turbulent sequence starts here                 curLength++;                 comparisons = cmp;             } else {                 // non-turbulent sequence breaks the current subarray                 curLength = 2;                 comparisons = cmp;             }             maxLength = Math.max(maxLength, curLength);         }         return maxLength;     } }",1,"978-longest-turbulent-subarray/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
978-longest-turbulent-subarray/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
978-longest-turbulent-subarray/Solution.java:6:	ForLoopVariableCount:	Too many control variables in the for statement
",1,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {          private int moves = 0;          public int distributeCoins(TreeNode root) {         dfs(root);         return moves;     }          private int dfs(TreeNode node) {         if (node == null) {             return 0;         }         int left = dfs(node.left);         int right = dfs(node.right);         moves += Math.abs(left) + Math.abs(right);         return node.val + left + right - 1;     } }",0,,0,0,0
"import java.util.*;  class ValueNode {     String value;     int timestamp;      public ValueNode(String value, int timestamp) {         this.value = value;         this.timestamp = timestamp;     } }  class TimeMap {     Map<String, List<ValueNode>> map; // Mapping String to a list of value nodes.      public TimeMap() {         map = new HashMap<>();     }      public void set(String key, String value, int timestamp) {         List<ValueNode> valueList = map.getOrDefault(key, new ArrayList<>());         valueList.add(new ValueNode(value, timestamp));         map.put(key, valueList);     }      public String get(String key, int timestamp) {         List<ValueNode> valueList = map.get(key);          if (valueList == null) { // Check if there exists a list.             return """";         }          int left = 0;         int right = valueList.size() - 1;          if (timestamp < valueList.get(0).timestamp) { // Check if the query is before the earliest timestamp entry.             return """";         }          while (left <= right) {             int mid = left + (right - left) / 2; // Binary search for the greatest timestamp less than or equal to the given timestamp.             if (valueList.get(mid).timestamp <= timestamp) {                 return valueList.get(mid).value;             } else {                 right = mid - 1;             }         }          if (right >= 0) { // As per the above condition, check if ""right"" has a valid value otherwise return empty string.             return valueList.get(right).value; // Return the value at the greatest timestamp <= given timestamp.         } else {             return """";         }     } }  /**  * Your TimeMap object will be instantiated and called as such:  * TimeMap obj = new TimeMap();  * obj.set(key,value,timestamp);  * String param_2 = obj.get(key,timestamp);  */",1,"981-time-based-key-value-store/ValueNode.java:4:12: Variable 'value' must be private and have accessor methods. [VisibilityModifier]
981-time-based-key-value-store/ValueNode.java:5:9: Variable 'timestamp' must be private and have accessor methods. [VisibilityModifier]
981-time-based-key-value-store/ValueNode.java:7:5: Redundant 'public' modifier. [RedundantModifier]
981-time-based-key-value-store/ValueNode.java:7:29: 'value' hides a field. [HiddenField]
981-time-based-key-value-store/ValueNode.java:7:40: 'timestamp' hides a field. [HiddenField]
981-time-based-key-value-store/ValueNode.java:14:34: Variable 'map' must be private and have accessor methods. [VisibilityModifier]
981-time-based-key-value-store/ValueNode.java:16:5: Redundant 'public' modifier. [RedundantModifier]
981-time-based-key-value-store/ValueNode.java:4:12: Variable 'value' must be private and have accessor methods. [VisibilityModifier]
981-time-based-key-value-store/ValueNode.java:5:9: Variable 'timestamp' must be private and have accessor methods. [VisibilityModifier]
981-time-based-key-value-store/ValueNode.java:7:5: Redundant 'public' modifier. [RedundantModifier]
981-time-based-key-value-store/ValueNode.java:7:29: 'value' hides a field. [HiddenField]
981-time-based-key-value-store/ValueNode.java:7:40: 'timestamp' hides a field. [HiddenField]
981-time-based-key-value-store/ValueNode.java:14:34: Variable 'map' must be private and have accessor methods. [VisibilityModifier]
981-time-based-key-value-store/ValueNode.java:16:5: Redundant 'public' modifier. [RedundantModifier]
981-time-based-key-value-store/ValueNode.java:33:	PrematureDeclaration:	Declaration of 'left' can be moved closer to its usages
981-time-based-key-value-store/ValueNode.java:34:	PrematureDeclaration:	Declaration of 'right' can be moved closer to its usages
",0,0,0
"class Solution {     public int mincostTickets(int[] days, int[] costs) {         int n = days.length;         int[] dp = new int[n];         dp[0] = Math.min(Math.min(costs[0], costs[1]), costs[2]);         int mincost = dp[0];          for (int i = 1; i < n; i++) {             dp[i] = dp[i - 1] + costs[0]; // 1-day pass             for (int j = i - 1; j >= 0; j--) {                 if (days[i] - days[j] < 7) {                     dp[i] = Math.min(dp[i], (j - 1 >= 0 ? dp[j - 1] : 0) + costs[1]); // 7-day pass                 } else if (days[i] - days[j] < 30) {                     dp[i] = Math.min(dp[i], (j - 1 >= 0 ? dp[j - 1] : 0) + costs[2]); // 30-day pass                 } else {                     break;                 }             }             mincost = Math.min(mincost, dp[i]);         }          return mincost;     } }",0,,0,0,0
"class Solution {     public String strWithout3a3b(int a, int b) {         StringBuilder sb = new StringBuilder();         char aChar = 'a', bChar = 'b';         if (b > a) {             int temp = a;             a = b;             b = temp;             aChar = 'b';             bChar = 'a';         }         while (a > 0 || b > 0) {             if (a > 0) {                 sb.append(aChar);                 a--;             }             if (a > b) {                 sb.append(aChar);                 a--;             }             if (b > 0) {                 sb.append(bChar);                 b--;             }         }         return sb.toString();     } }",1,"984-string-without-aaa-or-bbb/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
984-string-without-aaa-or-bbb/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
984-string-without-aaa-or-bbb/Solution.java:7:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'a'
984-string-without-aaa-or-bbb/Solution.java:8:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'b'
",1,1,0
"class Solution {     public int[] sumEvenAfterQueries(int[] nums, int[][] queries) {         int n = nums.length;         int[] answer = new int[n];         int evenSum = 0;  // Used to store the sum of even numbers in the array                  // Initializing the evenSum by summing all even elements in the nums array         for (int num : nums) {             if (num % 2 == 0) evenSum += num;         }                  // Processing each query         for (int i = 0; i < n; i++) {             int val = queries[i][0];             int index = queries[i][1];             int prevNum = nums[index];                          // Updating the nums array             nums[index] += val;                          int newNum = nums[index];                          // If both the prevNum and newNum are even, add or subtract the val from the evenSum accordingly             if (prevNum % 2 == 0 && newNum % 2 == 0) {                 evenSum += (newNum - prevNum);             }             // If only newNum is even, add it to the evenSum             else if (newNum % 2 == 0) {                 evenSum += newNum;             }             // If only prevNum is even, subtract it from the evenSum             else if (prevNum % 2 == 0) {                 evenSum -= prevNum;             }                          answer[i] = evenSum;  // Storing the current evenSum in the answer array         }                  return answer;  // Returning the final answer array     } }",1,"985-sum-of-even-numbers-after-queries/Solution.java:26:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
985-sum-of-even-numbers-after-queries/Solution.java:30:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
985-sum-of-even-numbers-after-queries/Solution.java:26:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
985-sum-of-even-numbers-after-queries/Solution.java:30:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
"class Solution {     public int[][] intervalIntersection(int[][] firstList, int[][] secondList) {         List<int[]> res = new ArrayList<>();         int i = 0, j = 0;         while (i < firstList.length && j < secondList.length) {             int[] a = firstList[i];             int[] b = secondList[j];             if (a[1] < b[0]) {                 i++;             } else if (b[1] < a[0]) {                 j++;             } else {                 res.add(new int[]{Math.max(a[0], b[0]), Math.min(a[1], b[1])});                 if (a[1] < b[1]) {                     i++;                 } else {                     j++;                 }             }         }         return res.toArray(new int[res.size()][]);     } }",1,"986-interval-list-intersections/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
986-interval-list-intersections/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public String smallestFromLeaf(TreeNode root) {         return getSmallestString(root, """");     }          private String getSmallestString(TreeNode node, String suffix) {         if (node == null) {             return suffix;         }         String left = getSmallestString(node.left, (char)('a' + node.val) + suffix);         String right = getSmallestString(node.right, (char)('a' + node.val) + suffix);         if (node.left == null && node.right == null) {             return (char)('a' + node.val) + """";         } else if (node.left == null) {             return right;         } else if (node.right == null) {             return left;         } else {             return left.compareTo(right) < 0 ? left : right;         }     } }",1,"988-smallest-string-starting-from-leaf/TreeNode.java:25:	UnnecessaryCast:	Unnecessary cast (char)
988-smallest-string-starting-from-leaf/TreeNode.java:26:	UnnecessaryCast:	Unnecessary cast (char)
988-smallest-string-starting-from-leaf/TreeNode.java:28:	AddEmptyString:	Do not add empty strings
988-smallest-string-starting-from-leaf/TreeNode.java:28:	UnnecessaryCast:	Unnecessary cast (char)
",0,0,0
"class Solution {     public boolean equationsPossible(String[] equations) {         int[] parent = new int[26];         for(int i = 0; i < parent.length; i++) {             parent[i] = i;         }         for(String equation: equations) {             if(equation.charAt(1) == '=') {                 int x = equation.charAt(0) - 'a';                 int y = equation.charAt(3) - 'a';                 union(parent, x, y);             }         }         for(String equation: equations) {             if(equation.charAt(1) == '!') {                 int x = equation.charAt(0) - 'a';                 int y = equation.charAt(3) - 'a';                 if(find(parent, x) == find(parent, y)) {                     return false;                 }             }         }         return true;     }          private void union(int[] parent, int x, int y) {         parent[find(parent, x)] = find(parent, y);     }          private int find(int[] parent, int x) {         if(parent[x] != x) {             parent[x] = find(parent, parent[x]);         }         return parent[x];     } }",0,,0,0,0
"class Solution {     public int brokenCalc(int startValue, int target) {         if (startValue >= target) {             return startValue - target;         }         if (target % 2 == 0) {             return brokenCalc(startValue, target / 2) + 1;         } else {             return brokenCalc(startValue, target + 1) + 1;         }     } }",0,,0,0,0
"class Solution {     public int orangesRotting(int[][] grid) {         int[][] directions = new int[][] {{-1,0},{0,-1},{1,0},{0,1}}; // 4-directions                  int rows = grid.length;         int cols = grid[0].length;                  Queue<int[]> queue = new LinkedList<>();                  // find all rotten oranges         for(int i=0;i<rows;i++) {             for(int j=0;j<cols;j++) {                 if(grid[i][j]==2) {                     queue.add(new int[] {i,j});                 }             }         }                  int minutesElapsed = 0;         while(!queue.isEmpty()) {             int size = queue.size();             boolean didRotten = false;                          for(int i=0;i<size;i++) {                 int[] cell = queue.poll();                 int row = cell[0];                 int col = cell[1];                                  // check for fresh oranges in 4 directions                 for(int[] direction : directions) {                     int newRow = row + direction[0];                     int newCol = col + direction[1];                                          if(newRow>=0 && newRow<rows && newCol>=0 && newCol<cols && grid[newRow][newCol]==1) {                         grid[newRow][newCol] = 2; // mark as rotten                         queue.add(new int[] {newRow, newCol}); // add newly rotten orange to queue                         didRotten = true;                     }                 }             }             if(didRotten) {                 minutesElapsed++;             }         }                  // check if any fresh orange is left         for(int i=0;i<rows;i++) {             for(int j=0;j<cols;j++) {                 if(grid[i][j]==1) {                     return -1; // unreachable fresh orange                 }             }         }                  return minutesElapsed;     } }",1,"994-rotting-oranges/Solution.java:2:	NPathComplexity:	The method 'orangesRotting(int[][])' has an NPath complexity of 272, current threshold is 200
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public TreeNode insertIntoMaxTree(TreeNode root, int val) {         if(root == null || val > root.val){  //create a new node since root value is less than passed value              TreeNode newNode = new TreeNode(val);             newNode.left = root; //assign root node as left child of newly created node             return newNode;         }         else{             root.right = insertIntoMaxTree(root.right,val); //recursively traverse right subtree             return root;         }     } }",1,"998-maximum-binary-tree-ii/TreeNode.java:22:9: '}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
998-maximum-binary-tree-ii/TreeNode.java:22:9: '}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
"class Solution {     public double findMedianSortedArrays(int[] nums1, int[] nums2) {         int m = nums1.length;         int n = nums2.length;         if (m > n) {             int[] temp = nums1;             nums1 = nums2;             nums2 = temp;             int tmp = m;             m = n;             n = tmp;         }         int min = 0, max = m, half = (m + n + 1) / 2;         while (min <= max) {             int i = (min + max) / 2;             int j = half - i;             if (i < max && nums2[j - 1] > nums1[i]) {                 min = i + 1;             } else if (i > min && nums1[i - 1] > nums2[j]) {                 max = i - 1;             } else {                 int leftMax = 0;                 if (i == 0) {                     leftMax = nums2[j - 1];                 } else if (j == 0) {                     leftMax = nums1[i - 1];                 } else {                     leftMax = Math.max(nums1[i - 1], nums2[j - 1]);                 }                 if ((m + n) % 2 == 1) {                     return leftMax;                 }                 int rightMin = 0;                 if (i == m) {                     rightMin = nums2[j];                 } else if (j == n) {                     rightMin = nums1[i];                 } else {                     rightMin = Math.min(nums1[i], nums2[j]);                 }                 return (leftMax + rightMin) / 2.0;             }         }         return 0.0;     } }",1,"004-median-of-two-sorted-arrays/Solution.java:13:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
004-median-of-two-sorted-arrays/Solution.java:7:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'nums1'
004-median-of-two-sorted-arrays/Solution.java:8:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'nums2'
004-median-of-two-sorted-arrays/Solution.java:22:	UnusedAssignment:	The initializer for variable 'leftMax' is never used (overwritten on lines 24, 26 and 28)
004-median-of-two-sorted-arrays/Solution.java:33:	UnusedAssignment:	The initializer for variable 'rightMin' is never used (overwritten on lines 35, 37 and 39)
",1,1,0
"class Solution {     public boolean isMatch(String s, String p) {         int m = s.length();         int n = p.length();                  boolean[][] dp = new boolean[m+1][n+1];                  dp[0][0] = true;                  for(int j=1; j<=n; j++){             if(p.charAt(j-1) == '*'){                 dp[0][j] = dp[0][j-2];             }         }                  for(int i=1; i<=m; i++){             for(int j=1; j<=n; j++){                 if(p.charAt(j-1) == '.' || s.charAt(i-1) == p.charAt(j-1)){                     dp[i][j] = dp[i-1][j-1];                 }                 else if(p.charAt(j-1) == '*'){                     dp[i][j] = dp[i][j-2];                     if(p.charAt(j-2) == '.' || s.charAt(i-1) == p.charAt(j-2)){                         dp[i][j] = dp[i][j] || dp[i-1][j];                     }                 }                 else{                     dp[i][j] = false;                 }             }         }         return dp[m][n];     } }",1,"010-regular-expression-matching/Solution.java:20:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
010-regular-expression-matching/Solution.java:26:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
"import java.util.PriorityQueue;  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public ListNode mergeKLists(ListNode[] lists) {         // Create a priority queue of size k         PriorityQueue<ListNode> pq = new PriorityQueue<>(lists.length, (a, b) -> a.val - b.val);                  // Add the head node of each linked list to the priority queue         for (ListNode list : lists) {             if (list != null) {                 pq.offer(list);             }         }                  // Create a dummy node to build the merged linked list         ListNode dummy = new ListNode(0);         ListNode tail = dummy;                  // Merge k linked lists by comparing the head node of each list in the priority queue         while (!pq.isEmpty()) {             ListNode node = pq.poll();             tail.next = node;             tail = tail.next;             if (node.next != null) {                 pq.offer(node.next);             }         }                  return dummy.next;     } }",1,"023-merge-k-sorted-lists/ListNode.java:16:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
",0,0,0
"/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public ListNode reverseKGroup(ListNode head, int k) {         if (head == null || k == 1) {             return head;         }         ListNode dummyHead = new ListNode(0);         dummyHead.next = head;         ListNode pre = dummyHead;         ListNode cur = head;         int i = 0;         while (cur != null) {             i++;             if (i % k == 0) {                 pre = reverse(pre, cur.next);                 cur = pre.next;             } else {                 cur = cur.next;             }         }         return dummyHead.next;     }          private ListNode reverse(ListNode pre, ListNode next) {         ListNode last = pre.next;         ListNode cur = last.next;         while (cur != next) {             last.next = cur.next;             cur.next = pre.next;             pre.next = cur;             cur = last.next;         }         return last;     } }",0,,0,0,0
"import java.util.*;  class Solution {     public List<Integer> findSubstring(String s, String[] words) {         List<Integer> result = new ArrayList<>();         if (s == null || words == null || words.length == 0) {             return result;         }         int wordLength = words[0].length();         int windowLength = wordLength * words.length;         if (s.length() < windowLength) {             return result;         }         Map<String, Integer> map = new HashMap<>();         for (String word : words) {             map.put(word, map.getOrDefault(word, 0) + 1);         }         for (int i = 0; i <= s.length() - windowLength; i++) {             String window = s.substring(i, i + windowLength);             if (isConcatenatedSubstring(window, map, wordLength)) {                 result.add(i);             }         }         return result;     }          private boolean isConcatenatedSubstring(String window, Map<String, Integer> map, int wordLength) {         Map<String, Integer> seen = new HashMap<>();         for (int i = 0; i < window.length(); i += wordLength) {             String word = window.substring(i, i + wordLength);             seen.put(word, seen.getOrDefault(word, 0) + 1);         }         return seen.equals(map);     } }",1,"030-substring-with-concatenation-of-all-words/Solution.java:14:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
030-substring-with-concatenation-of-all-words/Solution.java:28:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
",0,0,0
"class Solution {     public int longestValidParentheses(String s) {         Stack<Integer> stack = new Stack<>();         int max = 0;         stack.push(-1);         for (int i = 0; i < s.length(); i++) {             if (s.charAt(i) == '(') {                 stack.push(i);             } else {                 stack.pop();                 if (stack.isEmpty()) {                     stack.push(i);                 } else {                     max = Math.max(max, i - stack.peek());                 }             }         }         return max;     } }",0,,0,0,0
"class Solution {     public void solveSudoku(char[][] board) {         solveSudokuHelper(board, 0, 0);     }          private boolean solveSudokuHelper(char[][] board, int row, int col) {         if (row == 9) {             // Solved entire board             return true;         }                  if (col == 9) {             // End of row, go to next row             return solveSudokuHelper(board, row + 1, 0);         }                  if (board[row][col] != '.') {             // Cell is already filled, go to next cell             return solveSudokuHelper(board, row, col + 1);         }                  // Try all possible digits in the empty cell         for (char c = '1'; c <= '9'; c++) {             if (isValid(board, row, col, c)) {                 board[row][col] = c;                 if (solveSudokuHelper(board, row, col + 1)) {                     // Found a valid solution                     return true;                 }                 // Backtrack if no valid solution found                 board[row][col] = '.';             }         }                  // Exhausted all possibilities, no solution found         return false;     }          private boolean isValid(char[][] board, int row, int col, char c) {         // Check if c is already present in row or col         for (int i = 0; i < 9; i++) {             if (board[i][col] == c || board[row][i] == c) {                 return false;             }         }                  // Check if c is already present in the sub-box         int startRow = 3 * (row / 3);         int startCol = 3 * (col / 3);         for (int i = startRow; i < startRow + 3; i++) {             for (int j = startCol; j < startCol + 3; j++) {                 if (board[i][j] == c) {                     return false;                 }             }         }                  // c is not present in row, col or sub-box         return true;     }  }",0,,0,0,0
"class Solution {     public int firstMissingPositive(int[] nums) {         //Step 1: Remove negative and zero elements from the array         for(int i=0; i<nums.length; i++){             if(nums[i]<=0){                 nums[i] = nums.length+1;             }         }         //Step 2: Mark previously seen elements by taking the absolute value of the element as an index in the array and making it negative         for(int i=0; i<nums.length; i++){             int num = Math.abs(nums[i]);             if(num<=nums.length){                 nums[num-1] = -Math.abs(nums[num-1]);             }         }         //Step 3: The first positive index gives the smallest missing positive integer         for(int i=0; i<nums.length; i++){             if(nums[i]>0){                 return i+1;             }         }         //Step 4: If no positive element is found, then all positive integer elements are in the array and the next integer is the smallest missing integer         return nums.length+1;     } }   //Test the function  public class Main {     public static void main(String[] args) {         Solution s = new Solution();         int[] nums = {1,2,0};         System.out.println(s.firstMissingPositive(nums)); //Output: 3         int[] nums1 = {3,4,-1,1};         System.out.println(s.firstMissingPositive(nums1)); //Output: 2         int[] nums2 = {7,8,9,11,12};         System.out.println(s.firstMissingPositive(nums2)); //Output: 1     } }",1,"041-first-missing-positive/Main.java:28:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
041-first-missing-positive/Main.java:10:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
041-first-missing-positive/Main.java:28:	UseUtilityClass:	This utility class has a non-private constructor
",0,0,1
"class Solution {     public int trap(int[] height) {         int n = height.length;         int[] leftMax = new int[n], rightMax = new int[n];         int max = 0, water = 0;                  // For each bar, compute the maximum height to its left         for (int i = 0; i < n; i++) {             leftMax[i] = max;             max = Math.max(max, height[i]);         }                  // Reset the maximum height and compute the maximum to the right of each bar         max = 0;         for (int i = n-1; i >= 0; i--) {             rightMax[i] = max;             max = Math.max(max, height[i]);         }                  // Iterate over all bars and accumulate the trapped water         for (int i = 0; i < n; i++) {             int level = Math.min(leftMax[i], rightMax[i]);  // the water level if there are walls on both sides             if (level > height[i]) {  // if the bar is lower than the water level                 water += level - height[i];  // accumulate the trapped water             }         }                  return water;     } }",1,"042-trapping-rain-water/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
042-trapping-rain-water/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public boolean isMatch(String s, String p) {         int sLen = s.length();         int pLen = p.length();                  // 2D table for storing the subproblem results         boolean[][] dp = new boolean[pLen+1][sLen+1];                  // empty pattern can match with empty string         dp[0][0] = true;                  // Only '*' can match with empty string         for(int i=1; i<=pLen; i++){             if(p.charAt(i-1)=='*'){                 dp[i][0] = dp[i-1][0];             }         }                  /*          fill the table in bottom-up fashion          - At each (i,j), dp[i][j] is true if pattern[i-1] matches text[j-1] and dp[i-1][j-1] is also true           OR         - If pattern[i-1] is '?' then dp[i][j] = dp[i-1][j-1]           OR         - If pattern[i-1] is '*'           then dp[i][j] = dp[i-1][j] OR dp[i][j-1]           i.e,           - dp[i-1][j] represents multiple occurrences           - dp[i][j-1] represents single occurrence         */         for(int i=1; i<=pLen; i++){             for(int j=1; j<=sLen; j++){                 if(p.charAt(i-1) == s.charAt(j-1)){                     dp[i][j] = dp[i-1][j-1];                 }                 else if(p.charAt(i-1) == '?'){                     dp[i][j] = dp[i-1][j-1];                 }                 else if(p.charAt(i-1) == '*'){                     dp[i][j] = dp[i-1][j] || dp[i][j-1];                 }             }         }                  //print the table         //for(boolean[] row: dp){         //    System.out.println(Arrays.toString(row));         //}                  return dp[pLen][sLen];     } }",1,"044-wildcard-matching/Solution.java:35:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
044-wildcard-matching/Solution.java:38:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",0,0,0
"import java.util.ArrayList; import java.util.List;  class Solution {      // Main method that calls the recursive backtrack function.     public List<List<String>> solveNQueens(int n) {         List<List<String>> solutions = new ArrayList<>(); // List to store all solutions.         int[] queens = new int[n]; // Array to store the position of the queens.         backtrack(solutions, queens, 0); // Call recursive backtrack function.         return solutions;     }      // Recursive backtrack function to explore all possible configurations.     private void backtrack(List<List<String>> solutions, int[] queens, int row) {         if (row == queens.length) {             solutions.add(createBoard(queens)); // Found a valid solution, add it to the list.             return;         }         for (int col = 0; col < queens.length; col++) {             if (isValid(queens, row, col)) { // Check if the queen can be placed in this column.                 queens[row] = col; // Place the queen in this column.                 backtrack(solutions, queens, row+1); // Move to next row and explore recursively.             }         }     }      // Helper method to check if a queen can be placed in the current cell.     private boolean isValid(int[] queens, int row, int col) {         for (int i = 0; i < row; i++) {             int j = queens[i];             if (j == col) // Same column.                 return false;             if (i+j == row+col) // Same diagonal (top-left to bottom-right).                 return false;             if (i-j == row-col) // Same diagonal (top-right to bottom-left).                 return false;         }         return true;     }      // Helper method to create a board configuration from the queen positions.     private List<String> createBoard(int[] queens) {         List<String> board = new ArrayList<>();         for (int i = 0; i < queens.length; i++) {             StringBuilder row = new StringBuilder();             for (int j = 0; j < queens.length; j++) {                 if (j == queens[i])                     row.append('Q');                 else                     row.append('.');             }             board.add(row.toString());         }         return board;     } } ",1,"051-n-queens/Solution.java:45:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
051-n-queens/Solution.java:49:	ConsecutiveAppendsShouldReuse:	StringBuffer (or StringBuilder).append is called consecutively without reusing the target variable.
",0,0,1
"class Solution {     public int totalNQueens(int n) {         int[] nums = new int[n];         List<List<String>> res = new ArrayList<>();         solveNQueens(res, nums, 0, n);         return res.size();     }          private void solveNQueens(List<List<String>> res, int[] nums, int index, int n){         if(index == n){             List<String> temp = new ArrayList<>();             for(int i = 0; i < n; ++i){                 StringBuilder sb = new StringBuilder();                 for(int j = 0; j < n; ++j){                     if(j == nums[i]){                         sb.append(""Q"");                     } else {                         sb.append(""."");                     }                 }                 temp.add(sb.toString());             }             res.add(temp);             return;         }                  for(int i = 0; i < n; ++i){             nums[index] = i;             if(isValid(nums, index)){                 solveNQueens(res, nums, index + 1, n);             }         }     }          private boolean isValid(int[] nums, int index){         for(int i = 0; i < index; ++i){             if(nums[i] == nums[index] || Math.abs(nums[i] - nums[index]) == index - i){                 return false;             }         }         return true;        } }",1,"052-n-queens-ii/Solution.java:16:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
052-n-queens-ii/Solution.java:18:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
",0,0,0
"class Solution {     public String getPermutation(int n, int k) {         int[] factorial = new int[n];         List<Integer> nums = new ArrayList<>();         StringBuilder sb = new StringBuilder();          //factorial of each index from 0 to n-1         factorial[0] = 1;         for (int i = 1; i < n; i++) {             factorial[i] = factorial[i - 1] * i;         }          //create a list of numbers to choose from         for (int i = 1; i <= n; i++) {             nums.add(i);         }          k--; //to avoid edge cases with modulo operator         for (int i = n - 1; i >= 0; i--) {             int index = k / factorial[i];             int num = nums.remove(index);             sb.append(num);             k = k % factorial[i];         }          return sb.toString();     } }",1,"060-permutation-sequence/Solution.java:18:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'k'
",0,1,0
"class Solution {     public boolean isNumber(String s) {         // Remove leading/trailing whitespaces         s = s.trim();                  boolean seenNumber = false;         boolean seenE = false;         boolean seenDot = false;                  for(int i=0; i<s.length(); i++) {             char c = s.charAt(i);                          // Check for digits             if(Character.isDigit(c)) {                 seenNumber = true;             }             // Check for signs (+/-) but they can only appear at index 0 or after the exponent (e/E)             else if(c == '+' || c == '-') {                 if(i > 0 && s.charAt(i-1) != 'e' && s.charAt(i-1) != 'E') {                     return false;                 }             }             // Check for exponent (e/E)             else if(c == 'e' || c == 'E') {                 if(seenE || !seenNumber) {                     return false;                 }                 seenE = true;                 seenNumber = false;             }             // Check for decimal point (.)             else if(c == '.') {                 if(seenDot || seenE) {                     return false;                 }                 seenDot = true;             }             // If any other character is encountered, it is not a valid number             else {                 return false;             }         }                  // Number is valid if we have seen at least one digit         return seenNumber;     } }",1,"065-valid-number/Solution.java:16:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
065-valid-number/Solution.java:22:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
065-valid-number/Solution.java:30:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
065-valid-number/Solution.java:37:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
065-valid-number/Solution.java:4:	AvoidReassigningParameters:	Avoid reassigning parameters such as 's'
",0,1,0
"class Solution {     public List<String> fullJustify(String[] words, int maxWidth) {         List<String> result = new ArrayList<>();                  int i = 0;         while (i < words.length) {             int j = i;             int lineLength = 0;             while (j < words.length && lineLength + words[j].length() + j - i <= maxWidth) {                 lineLength += words[j].length();                 j++;             }                          StringBuilder sb = new StringBuilder();             int spaces = maxWidth - lineLength;             int evenSpaces = j - i - 1 > 0 ? spaces / (j - i - 1) : spaces;             int extraSpaces = j - i - 1 > 0 ? spaces % (j - i - 1) : 0;                          for (int k = i; k < j; k++) {                 sb.append(words[k]);                 if (k < j - 1) {                     int spacesToAdd = evenSpaces + (extraSpaces-- > 0 ? 1 : 0);                     for (int l = 0; l < spacesToAdd; l++) {                         sb.append("" "");                     }                 }             }                          for (int k = sb.length(); k < maxWidth; k++) {                 sb.append("" "");             }                          result.add(sb.toString());             i = j;         }                  return result;     } }",1,"068-text-justification/Solution.java:24:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
068-text-justification/Solution.java:30:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
",0,0,0
"class Solution {     public int minDistance(String word1, String word2) {         int m = word1.length();         int n = word2.length();                  int[][] dp = new int[m+1][n+1];                  for(int i = 0; i <= m; i++){             for(int j = 0; j <= n;j++){                 if(i == 0){                     dp[i][j] = j;                 } else if(j == 0){                     dp[i][j] = i;                 } else if(word1.charAt(i-1) == word2.charAt(j-1)){                     dp[i][j] = dp[i-1][j-1];                 } else {                     dp[i][j] = 1 + Math.min(Math.min(dp[i-1][j-1], dp[i][j-1]), dp[i-1][j]);                 }             }         }         return dp[m][n];     } }",0,,0,0,0
"class Solution {     public String minWindow(String s, String t) {         if (s == null || t == null || s.length() < t.length()) {             return """";         }         Map<Character, Integer> targetMap = new HashMap<>();         // fill targetMap with character frequency in target string t         for (int i = 0; i < t.length(); i++) {             targetMap.put(t.charAt(i), targetMap.getOrDefault(t.charAt(i), 0) + 1);         }         int count = targetMap.size();         int left = 0, right = 0;         int minLen = Integer.MAX_VALUE;         String result = """";         while (right < s.length()) {             char c = s.charAt(right);             if (targetMap.containsKey(c)) {                 targetMap.put(c, targetMap.get(c) - 1);                 if (targetMap.get(c) == 0) {                     count--;                 }             }             right++;             while (count == 0) {                 if (right - left < minLen) {                     minLen = right - left;                     result = s.substring(left, right);                 }                 char lc = s.charAt(left);                 if (targetMap.containsKey(lc)) {                     targetMap.put(lc, targetMap.get(lc) + 1);                     if (targetMap.get(lc) > 0) {                         count++;                     }                 }                 left++;             }         }         return result;     } }",1,"076-minimum-window-substring/Solution.java:12:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int largestRectangleArea(int[] heights) {         int n = heights.length;         int[] left = new int[n];         int[] right = new int[n];                  // Traverse from left to right and find the index of the first bar to the left of the current bar which         // is smaller than the current bar         Stack<Integer> stack = new Stack<>();         for (int i = 0; i < n; i++) {             while (!stack.isEmpty() && heights[stack.peek()] >= heights[i]) {                 stack.pop();             }             if (stack.isEmpty()) {                 left[i] = -1;             } else {                 left[i] = stack.peek();             }             stack.push(i);         }                  // Empty the stack         stack.clear();                  // Traverse from right to left and find the index of the first bar to the right of the current bar which         // is smaller than the current bar         for (int i = n - 1; i >= 0; i--) {             while (!stack.isEmpty() && heights[stack.peek()] >= heights[i]) {                 stack.pop();             }             if (stack.isEmpty()) {                 right[i] = n;             } else {                 right[i] = stack.peek();             }             stack.push(i);         }                  int maxArea = 0;         for (int i = 0; i < n; i++) {             int area = heights[i] * (right[i] - left[i] - 1);             maxArea = Math.max(maxArea, area);         }                  return maxArea;     } }",0,,0,0,0
"class Solution {     public int maximalRectangle(char[][] matrix) {         if (matrix == null || matrix.length == 0) {             return 0;         }                  int rows = matrix.length, cols = matrix[0].length;         int[] heights = new int[cols];         int maxArea = 0;                  for (int i = 0; i < rows; i++) {             for (int j = 0; j < cols; j++) {                 if (matrix[i][j] == '1') {                     heights[j]++;                 } else {                     heights[j] = 0;                 }             }             maxArea = Math.max(maxArea, getLargestRectangleArea(heights));         }                  return maxArea;     }          private int getLargestRectangleArea(int[] heights) {         Stack<Integer> stack = new Stack<>();         int maxArea = 0, i = 0;                  while (i < heights.length) {             if (stack.isEmpty() || heights[i] >= heights[stack.peek()]) {                 stack.push(i++);             } else {                 int top = stack.pop();                 maxArea = Math.max(maxArea, heights[top] * (stack.isEmpty() ? i : i - stack.peek() - 1));             }         }                  while (!stack.isEmpty()) {             int top = stack.pop();             maxArea = Math.max(maxArea, heights[top] * (stack.isEmpty() ? i : i - stack.peek() - 1));         }                  return maxArea;     } }",1,"085-maximal-rectangle/Solution.java:7:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
085-maximal-rectangle/Solution.java:27:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public boolean isScramble(String s1, String s2) {         if(s1.length() != s2.length()) {             return false;         }         if(s1.equals(s2)) {             return true;         }         int[] alphabets = new int[26];         for(int i = 0; i < s1.length(); i++) {             alphabets[s1.charAt(i) - 'a']++;             alphabets[s2.charAt(i) - 'a']--;         }         for(int i = 0; i < 26; i++) {             if(alphabets[i] != 0){                 return false;             }         }         for(int i = 1; i < s1.length(); i++) {             boolean case1 = isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i), s2.substring(i));             boolean case2 = isScramble(s1.substring(0, i), s2.substring(s2.length()-i)) && isScramble(s1.substring(i), s2.substring(0,s2.length()-i));             if(case1 || case2){                 return true;             }         }         return false;     } }",0,,0,0,0
"class Solution {     public int mergeStones(int[] stones, int k) {         int len = stones.length;         if ((len-1)%(k-1) != 0) return -1; //not possible         int[][][] dp=new int[len][len][k+1];                  return helper(stones,dp,0,len-1,1,k);     }           private int helper(int[] stones,int[][][] dp,int i,int j,int p,int k){                    if(i==j){              if(p==1) return 0;              return Integer.MAX_VALUE;          }                    if(p==1){              if(dp[i][j][p]!=0) return dp[i][j][p];              int res=helper(stones,dp,i,j,k,k)+sum(stones,i,j);              dp[i][j][p]=res;              return res;          }                     if(dp[i][j][p]!=0) return dp[i][j][p];                   int res=Integer.MAX_VALUE;          for(int x=i;x<j;x+=k-1){              int left=helper(stones,dp,i,x,p-1,k);              if(left==Integer.MAX_VALUE) continue;              int right=helper(stones,dp,x+1,j,p-1,k);              if(right==Integer.MAX_VALUE) continue;              res=Math.min(res,left+right);          }          dp[i][j][p]=res;          return res;      }               private int sum(int[] arr,int i,int j){         int sum=0;         for(int x=i;x<=j;x++){             sum+=arr[x];         }         return sum;     } }",0,,0,0,0
"class Solution {     public int[] gridIllumination(int n, int[][] lamps, int[][] queries) {         // Create maps for each row, col, diagonal and off-diagonal.         Map<Integer, Integer> rowMap = new HashMap<>();         Map<Integer, Integer> colMap = new HashMap<>();         Map<Integer, Integer> diagMap = new HashMap<>();         Map<Integer, Integer> offDiagMap = new HashMap<>();                  // Create a set to hold the lamps' positions.         Set<String> lampPositions = new HashSet<>();                  // Loop through all the lamps and update the corresponding maps and set.         for (int[] lamp : lamps) {             int row = lamp[0];             int col = lamp[1];             rowMap.put(row, rowMap.getOrDefault(row, 0) + 1);             colMap.put(col, colMap.getOrDefault(col, 0) + 1);             diagMap.put(row - col, diagMap.getOrDefault(row - col, 0) + 1);             offDiagMap.put(row + col, offDiagMap.getOrDefault(row + col, 0) + 1);             lampPositions.add(row + "","" + col);         }                  // Create a result array to hold the answers to the queries.         int[] result = new int[queries.length];         int index = 0;                  // Loop through all the queries and check if the corresponding cell is illuminated or not.         for (int[] query : queries) {             int row = query[0];             int col = query[1];                          // Check if the query cell is illuminated or not.             if (rowMap.getOrDefault(row, 0) > 0 ||                 colMap.getOrDefault(col, 0) > 0 ||                 diagMap.getOrDefault(row - col, 0) > 0 ||                 offDiagMap.getOrDefault(row + col, 0) > 0) {                 result[index++] = 1;             } else {                 result[index++] = 0;             }                          // Turn off the lamp at the query cell and its adjacent lamps.             for (int i = row - 1; i <= row + 1; i++) {                 for (int j = col - 1; j <= col + 1; j++) {                     if (i < 0 || i >= n || j < 0 || j >= n) {                         continue;                     }                     String position = i + "","" + j;                     if (lampPositions.contains(position)) {                         lampPositions.remove(position);                         rowMap.put(i, rowMap.getOrDefault(i, 0) - 1);                         colMap.put(j, colMap.getOrDefault(j, 0) - 1);                         diagMap.put(i - j, diagMap.getOrDefault(i - j, 0) - 1);                         offDiagMap.put(i + j, offDiagMap.getOrDefault(i + j, 0) - 1);                     }                 }             }         }                  return result;     } }",0,,0,0,0
class Solution {     public int numDupDigitsAtMostN(int n) {         int res = 0;         for (int i = 1; i <= n; i++) {             if (isDupDigit(i)) {                 res++;             }         }         return res;     }          private boolean isDupDigit(int num) {         int[] digits = new int[10];         while (num != 0) {             int digit = num % 10;             if (digits[digit] != 0) {                 return true;             }             digits[digit]++;             num /= 10;         }         return false;     } },1,"1012-numbers-with-repeated-digits/Solution.java:20:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'num'
",0,1,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public TreeNode recoverFromPreorder(String traversal) {         Stack<TreeNode> stack = new Stack<>();         int i = 0;                  while (i < traversal.length()) {             int level = 0;             while (i < traversal.length() && traversal.charAt(i) == '-') {                 level++;                 i++;             }                          int value = 0;             while (i < traversal.length() && traversal.charAt(i) >= '0' && traversal.charAt(i) <= '9') {                 value = value * 10 + (traversal.charAt(i) - '0');                 i++;             }                          TreeNode node = new TreeNode(value);             if (level == stack.size()) {                 if (!stack.empty()) {                     stack.peek().left = node;                 }             } else {                 while (level != stack.size()) {                     stack.pop();                 }                 stack.peek().right = node;             }             stack.push(node);         }                  while (stack.size() > 1) {             stack.pop();         }         return stack.peek();     } }",1,"1028-recover-a-tree-from-preorder-traversal/TreeNode.java:30:	UselessParentheses:	Useless parentheses.
",0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public TreeNode recoverFromPreorder(String traversal) {         Stack<TreeNode> stack = new Stack<>();         int i = 0;                  while (i < traversal.length()) {             int level = 0;             while (i < traversal.length() && traversal.charAt(i) == '-') {                 level++;                 i++;             }                          int value = 0;             while (i < traversal.length() && traversal.charAt(i) >= '0' && traversal.charAt(i) <= '9') {                 value = value * 10 + (traversal.charAt(i) - '0');                 i++;             }                          TreeNode node = new TreeNode(value);             if (level == stack.size()) {                 if (!stack.empty()) {                     stack.peek().left = node;                 }             } else {                 while (level != stack.size()) {                     stack.pop();                 }                 stack.peek().right = node;             }             stack.push(node);         }                  while (stack.size() > 1) {             stack.pop();         }         return stack.peek();     } }",0,,0,0,0
"class Solution {     private static final int MAX_COORDINATE = 1000000;      public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {         Set<String> blockedSet = new HashSet<>();         for (int[] block : blocked) {             blockedSet.add(block[0] + "","" + block[1]);         }                  return canEscape(blockedSet, source, target) && canEscape(blockedSet, target, source);     }          private boolean canEscape(Set<String> blocked, int[] source, int[] target) {         boolean[][] visited = new boolean[MAX_COORDINATE+1][MAX_COORDINATE+1];         Queue<int[]> queue = new LinkedList<>();         queue.offer(source);         visited[source[0]][source[1]] = true;                  while (!queue.isEmpty()) {             int[] curr = queue.poll();             if (curr[0] == target[0] && curr[1] == target[1]) {                 return true;             }             int[][] neighbors = {{curr[0]+1, curr[1]}, {curr[0]-1, curr[1]}, {curr[0], curr[1]+1}, {curr[0], curr[1]-1}};             for (int[] neighbor : neighbors) {                 int x = neighbor[0];                 int y = neighbor[1];                 if (x >= 0 && x <= MAX_COORDINATE && y >= 0 && y <= MAX_COORDINATE && !visited[x][y] && !blocked.contains(x + "","" + y)) {                     visited[x][y] = true;                     queue.offer(neighbor);                 }             }             if (queue.size() > blocked.size() + 1000000) {                 // Avoid infinite loop, assume can escape                 return true;             }         }         return false;     } }",0,,0,0,0
"class Solution {     public String longestDupSubstring(String s) {         int n = s.length();         int[] nums = new int[n];         for (int i = 0; i < n; i++) {             nums[i] = s.charAt(i) - 'a';         }          int a = 0, b = n;         int start = 0;         while (a < b) {             int mid = a + (b - a) / 2;             int dupIdx = duplicateSubstring(nums, mid);             if (dupIdx >= 0) {                 a = mid + 1;                 start = dupIdx;             } else {                 b = mid;             }         }          return s.substring(start, start + a - 1);     }      private int duplicateSubstring(int[] nums, int len) {         long p = (long) Math.pow(26, len);         long hash = 0;          for (int i = 0; i < len; i++) {             hash = hash * 26 + nums[i];         }          Set<Long> set = new HashSet<>();         set.add(hash);         for (int i = 1; i <= nums.length - len; i++) {             hash = hash * 26 - nums[i - 1] * p + nums[i + len - 1];             if (set.contains(hash)) {                 return i;             }             set.add(hash);         }          return -1;     } }",1,"1044-longest-duplicate-substring/Solution.java:9:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int numSubmatrixSumTarget(int[][] matrix, int target) {         int m = matrix.length;         int n = matrix[0].length;         int[][] prefixSum = new int[m + 1][n + 1];         for (int i = 1; i <= m; i++) {             for (int j = 1; j <= n; j++) {                 prefixSum[i][j] = prefixSum[i - 1][j] + prefixSum[i][j - 1] - prefixSum[i - 1][j - 1] + matrix[i - 1][j - 1];             }         }         int count = 0;         for (int top = 0; top < m; top++) {             for (int bot = top; bot < m; bot++) {                 Map<Integer, Integer> map = new HashMap<>();                 map.put(0, 1);                 int cur = 0;                 for (int r = 0; r < n; r++) {                     cur += prefixSum[bot + 1][r + 1] - prefixSum[top][r + 1];                     count += map.getOrDefault(cur - target, 0);                     map.put(cur, map.getOrDefault(cur, 0) + 1);                 }             }         }         return count;     } }",0,,0,0,0
"class Solution {     public String shortestCommonSupersequence(String str1, String str2) {         int m = str1.length();         int n = str2.length();         int[][] dp = new int[m+1][n+1];         for (int i = 1; i <= m; i++) {             for (int j = 1; j <= n; j++) {                 if (str1.charAt(i-1) == str2.charAt(j-1)) {                     dp[i][j] = dp[i-1][j-1] + 1;                 } else {                     dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);                 }             }         }         StringBuilder sb = new StringBuilder();         int i = m, j = n;         while (i > 0 && j > 0) {             if (str1.charAt(i-1) == str2.charAt(j-1)) {                 sb.append(str1.charAt(i-1));                 i--;                 j--;             } else if (dp[i-1][j] > dp[i][j-1]) {                 sb.append(str1.charAt(i-1));                 i--;             } else {                 sb.append(str2.charAt(j-1));                 j--;             }         }         while (i > 0) {             sb.append(str1.charAt(i-1));             i--;         }         while (j > 0) {             sb.append(str2.charAt(j-1));             j--;         }         return sb.reverse().toString();     } }",1,"1092-shortest-common-supersequence/Solution.java:16:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"/**  * // This is MountainArray's API interface.  * // You should not implement it, or speculate about its implementation  * interface MountainArray {  *     public int get(int index) {}  *     public int length() {}  * }  */   class Solution {     public int findInMountainArray(int target, MountainArray mountainArr) {         int peakIndex = findPeakIndex(mountainArr);         int leftIndex = searchInLeft(target, mountainArr, peakIndex);         if (leftIndex != -1) {             return leftIndex;         }         int rightIndex = searchInRight(target, mountainArr, peakIndex);         return rightIndex;     }          private int findPeakIndex(MountainArray mountainArr) {         int n = mountainArr.length();         int left = 0;         int right = n - 1;         while (left < right) {             int mid = left + (right - left) / 2;             int midVal = mountainArr.get(mid);             int midValPlusOne = mountainArr.get(mid + 1);             if (midVal < midValPlusOne) {                 left = mid + 1;             } else {                 right = mid;             }         }         return left;     }          private int searchInLeft(int target, MountainArray mountainArr, int peakIndex) {         int left = 0;         int right = peakIndex;         while (left <= right) {             int mid = left + (right - left) / 2;             int midVal = mountainArr.get(mid);             if (midVal == target) {                 return mid;             } else if (midVal < target) {                 left = mid + 1;             } else {                 right = mid - 1;             }         }         return -1;     }          private int searchInRight(int target, MountainArray mountainArr, int peakIndex) {         int left = peakIndex + 1;         int right = mountainArr.length() - 1;         while (left <= right) {             int mid = left + (right - left) / 2;             int midVal = mountainArr.get(mid);             if (midVal == target) {                 return mid;             } else if (midVal > target) {                 left = mid + 1;             } else {                 right = mid - 1;             }         }         return -1;     } }",1,"1095-find-in-mountain-array/Solution.java:17:	UnnecessaryLocalBeforeReturn:	Consider simply returning the value vs storing it in local variable 'rightIndex'
",0,0,0
"import java.util.ArrayList; import java.util.Arrays; import java.util.HashSet; import java.util.List; import java.util.Set;  class Solution {     public List<String> braceExpansionII(String expression) {         List<List<String>> groups = parseGroups(expression);         Set<String> result = new HashSet<>();         for (List<String> group : groups) {             Set<String> current = new HashSet<>();             current.add("""");             for (String option : group) {                 Set<String> tmp = new HashSet<>();                 for (String prefix : current)                      for (String suffix : R(option))                          tmp.add(prefix + suffix);                 current = tmp;             }             result.addAll(current);         }         List<String> res = new ArrayList<>(result);         res.sort(null);         return res;     }          private List<List<String>> parseGroups(String expression) {         List<List<String>> groups = new ArrayList<>();         List<String> current = new ArrayList<>();         int balance = 0;         for (int i = 0; i < expression.length(); i++) {             char c = expression.charAt(i);             if (c == '{') balance++;             else if (c == '}') balance--;             if (balance == 0 && c == ',') {                 groups.add(current);                 current = new ArrayList<>();             } else current.add("""" + c);         }         if (!current.isEmpty()) groups.add(current);         return groups;     }          private List<String> R(String expr) {         if (expr.charAt(0) == '{') {             List<List<String>> groups = parseGroups(expr.substring(1, expr.length() - 1));             List<String> result = new ArrayList<>();             for (List<String> group : groups)                  for (String g : group)                     result.add(g);             return result;         } else {             return Arrays.asList("""" + expr.charAt(0));         }     } }",1,"1096-brace-expansion-ii/Solution.java:39:	AddEmptyString:	Do not add empty strings
1096-brace-expansion-ii/Solution.java:45:	ShortMethodName:	Avoid using short method names
1096-brace-expansion-ii/Solution.java:45:	MethodNamingConventions:	The instance method name 'R' doesn't match '[a-z][a-zA-Z0-9]*'
1096-brace-expansion-ii/Solution.java:54:	AddEmptyString:	Do not add empty strings
",0,0,0
"class Solution {     public boolean parseBoolExpr(String expression) {         if (expression.equals(""t"")) {             return true;         }         if (expression.equals(""f"")) {             return false;         }         char op = expression.charAt(0);         boolean result = op == '&'; // For AND, default to true         int i = 2; // Start index for sub-expressions         int exprStart = i; // Start index of a sub-expression         int exprCount = 0; // Number of nested expressions         while (i < expression.length() - 1) {             char c = expression.charAt(i);             if (c == '(') {                 exprCount++;             } else if (c == ')') {                 exprCount--;             } else if (c == ',' && exprCount == 0) {                 String subExpr = expression.substring(exprStart, i);                 boolean subResult = parseBoolExpr(subExpr);                 if (op == '&') {                     result &= subResult;                 } else if (op == '|') {                     result |= subResult;                 }                 exprStart = i + 1;             }             i++;         }         String lastSubExpr = expression.substring(exprStart, i);         boolean lastSubResult = parseBoolExpr(lastSubExpr);         if (op == '&') {             result &= lastSubResult;         } else if (op == '|') {             result |= lastSubResult;         } else if (op == '!') {             result = !parseBoolExpr(expression.substring(2, expression.length() - 1));         }         return result;     } }",1,"1106-parsing-a-boolean-expression/Solution.java:3:	LiteralsFirstInComparisons:	Position literals first in String comparisons
1106-parsing-a-boolean-expression/Solution.java:6:	LiteralsFirstInComparisons:	Position literals first in String comparisons
",0,0,0
"import java.util.*;  class Solution {     public int[] smallestSufficientTeam(String[] req_skills, List<List<String>> people) {         Map<String, Integer> skillIndex = new HashMap<>();         int n = req_skills.length;         for (int i = 0; i < n; i++) {             skillIndex.put(req_skills[i], i);         }                  int p = people.size();         int[] skills = new int[p];         for (int i = 0; i < p; i++) {             for (String skill : people.get(i)) {                 skills[i] |= 1 << skillIndex.get(skill);             }         }                  int[] dp = new int[1 << n];         Arrays.fill(dp, Integer.MAX_VALUE);         int[] parent = new int[1 << n];         Arrays.fill(parent, -1);         dp[0] = 0;                  for (int i = 0; i < p; i++) {             int skillset = skills[i];             for (int j = (1 << n) - 1; j >= 0; j--) {                 if (dp[j] == Integer.MAX_VALUE) continue;                 int next = j | skillset;                 if (dp[next] > dp[j] + 1) {                     dp[next] = dp[j] + 1;                     parent[next] = i;                 }             }         }                  int[] result = new int[dp[(1 << n) - 1]];         int teamIndex = result.length - 1;         int mask = (1 << n) - 1;         while (teamIndex >= 0) {             result[teamIndex--] = parent[mask];             mask ^= skills[parent[mask]];         }                  return result;     } }",1,"1125-smallest-sufficient-team/Solution.java:5:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
",0,0,0
"class Solution {     public int longestDecomposition(String text) {         int n = text.length();         // For an empty string or a string with only one character, return 1         if (n == 0 || n == 1) return 1;         // Initialize left and right substrings         String left = """", right = """";         // Initialize count for number of valid substrings         int count = 0;         // Iterate over the string         for (int i = 0; i < n; i++) {             // Append the ith character to the left substring             left = left + text.charAt(i);             // Prepend the (n-i)th character to the right substring             right = text.charAt(n-i-1) + right;             // If the left and right substrings are equal, we have found a valid substring             if (left.equals(right)) {                 // Increment the count of valid substrings                 count++;                 // Reset the left and right substrings                 left = """";                 right = """";             }         }         // If the left substring is not empty, we have an extra valid substring         if (!left.equals("""")) count++;         // Return the count of valid substrings         return count;     } }",1,"1147-longest-chunked-palindrome-decomposition/Solution.java:7:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1147-longest-chunked-palindrome-decomposition/Solution.java:13:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
1147-longest-chunked-palindrome-decomposition/Solution.java:15:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
1147-longest-chunked-palindrome-decomposition/Solution.java:26:	LiteralsFirstInComparisons:	Position literals first in String comparisons
",1,0,0
"class Solution {     public int numDistinct(String s, String t) {         int m = s.length();         int n = t.length();         int[][] dp = new int[m+1][n+1];                  // Initialize dp table         for(int i=0; i<=m; i++) {             dp[i][0] = 1;         }                  // Fill the dp table         for(int i=1; i<=m; i++) {             for(int j=1; j<=n; j++) {                 if(s.charAt(i-1) == t.charAt(j-1)) {                     dp[i][j] = dp[i-1][j-1] + dp[i-1][j];                 } else {                     dp[i][j] = dp[i-1][j];                 }             }         }         return dp[m][n];     } }",0,,0,0,0
"class MajorityChecker {     private int[] arr;     private Map<String, Integer> memo;      public MajorityChecker(int[] arr) {         this.arr = arr;         this.memo = new HashMap<>();     }          public int query(int left, int right, int threshold) {         String queryStr = left + "","" + right + "","" + threshold;         if (memo.containsKey(queryStr)) {             return memo.get(queryStr);         }         int count = 0, candidate = -1;         for (int i = left; i <= right; i++) {             if (count == 0) {                 candidate = arr[i];             }             if (arr[i] == candidate) {                 count++;             } else {                 count--;             }         }         count = 0;         for (int i = left; i <= right; i++) {             if (arr[i] == candidate) {                 count++;             }         }         int result = count >= threshold ? candidate : -1;         memo.put(queryStr, result);         return result;     } }",1,"1157-online-majority-element-in-subarray/MajorityChecker.java:5:5: Redundant 'public' modifier. [RedundantModifier]
1157-online-majority-element-in-subarray/MajorityChecker.java:5:34: 'arr' hides a field. [HiddenField]
1157-online-majority-element-in-subarray/MajorityChecker.java:15:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1157-online-majority-element-in-subarray/MajorityChecker.java:6:	ArrayIsStoredDirectly:	The user-supplied array 'arr' is stored directly.
",1,0,0
"class Solution {     public String lastSubstring(String s) {         int n = s.length();         int i = 0, j = i + 1, k = 0;                  while (j + k < n) {              if (s.charAt(i+k) == s.charAt(j+k)) {                  k++;                  continue;              }              if (s.charAt(i+k) < s.charAt(j+k)) {                  i = j++;              } else {                  j = j + k + 1;              }              k = 0;          }           return s.substring(i);      } }",1,"1163-last-substring-in-lexicographical-order/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
import java.util.*;  class DinnerPlates {     private int capacity;     private List<Stack<Integer>> stacks;     private Set<Integer> nonFullStacks;     private int leftmostNonFullStack;      public DinnerPlates(int capacity) {         this.capacity = capacity;         this.stacks = new ArrayList<>();         this.nonFullStacks = new HashSet<>();         this.leftmostNonFullStack = 0;     }          public void push(int val) {         if (nonFullStacks.isEmpty()) {             stacks.add(new Stack<>());             nonFullStacks.add(stacks.size() - 1);         }         int stackIndex = leftmostNonFullStack;         stacks.get(stackIndex).push(val);         if (stacks.get(stackIndex).size() == capacity) {             nonFullStacks.remove(stackIndex);             findLeftmostNonFullStack();         }     }          private void findLeftmostNonFullStack() {         while (leftmostNonFullStack < stacks.size() && stacks.get(leftmostNonFullStack).size() == capacity) {             leftmostNonFullStack++;         }     }          public int pop() {         if (stacks.isEmpty()) {             return -1;         }         return popAtStack(stacks.size() - 1);     }          public int popAtStack(int index) {         if (index < 0 || index >= stacks.size() || stacks.get(index).isEmpty()) {             return -1;         }         int val = stacks.get(index).pop();         nonFullStacks.add(index);         if (index < leftmostNonFullStack) {             leftmostNonFullStack = index;         }         return val;     } },1,"1172-dinner-plate-stacks/DinnerPlates.java:9:5: Redundant 'public' modifier. [RedundantModifier]
1172-dinner-plate-stacks/DinnerPlates.java:9:29: 'capacity' hides a field. [HiddenField]
1172-dinner-plate-stacks/DinnerPlates.java:5:	LooseCoupling:	Avoid using implementation types like 'Stack'; use the interface instead
1172-dinner-plate-stacks/DinnerPlates.java:5:	ReplaceVectorWithList:	Consider replacing this Vector with the newer java.util.List
1172-dinner-plate-stacks/DinnerPlates.java:18:	ReplaceVectorWithList:	Consider replacing this Vector with the newer java.util.List
",0,0,0
"import java.util.*;  class Solution {     public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {         Map<Integer, Integer> frequencyMap = new HashMap<>();          // Count the frequency of words with specific combination of characters in puzzles[i]         for (String word : words) {             int mask = 0;             for (int i = 0; i < word.length(); i++) {                 mask |= (1 << (word.charAt(i) - 'a'));             }              if (Integer.bitCount(mask) <= 7) {                 frequencyMap.put(mask, frequencyMap.getOrDefault(mask, 0) + 1);             }         }          List<Integer> result = new ArrayList<>();         for (String puzzle : puzzles) {             int count = 0;             int puzzleMask = 0;             for (int i = 0; i < puzzle.length(); i++) {                 puzzleMask |= (1 << (puzzle.charAt(i) - 'a'));             }             int firstLetterMask = 1 << (puzzle.charAt(0) - 'a');              int subset = puzzleMask;             while (subset > 0) {                 if ((subset & firstLetterMask) > 0 && frequencyMap.containsKey(subset)) {                     count += frequencyMap.get(subset);                 }                  subset = (subset - 1) & puzzleMask;             }              result.add(count);         }          return result;     } }",1,"1178-number-of-valid-words-for-each-puzzle/Solution.java:5:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
",0,0,0
"class Solution {     public int makeArrayIncreasing(int[] arr1, int[] arr2) {         // Sort arr2 for binary search         Arrays.sort(arr2);                  // Initialize memoization array with -1         int[][] memo = new int[arr1.length][arr2.length];         for (int i = 0; i < arr1.length; i++) {             Arrays.fill(memo[i], -1);         }                  // Sort arr1 and start recursion         Arrays.sort(arr1);         return helper(arr1, arr2, 0, -1, memo);     }          private int helper(int[] arr1, int[] arr2, int i, int prev, int[][] memo) {         // Base case: reached end of arr1         if (i == arr1.length) {             return 0;         }                  // Check memoization array to avoid redundant calculation         if (prev >= 0 && memo[i][prev] != -1) {             return memo[i][prev];         }                  int res = Integer.MAX_VALUE;         // Case 1: Don't do any operation on arr1[i]         if (arr1[i] > prev) {             res = helper(arr1, arr2, i+1, arr1[i], memo);         }         // Case 2: Do operation on arr1[i]         int j = Arrays.binarySearch(arr2, prev);         if (j < 0) {             j = -j-1;         }         if (j < arr2.length) {             res = Math.min(res, 1 + helper(arr1, arr2, i+1, arr2[j], memo));         }         // Update memoization array         if (prev >= 0) {             memo[i][prev] = res;         }         return res;     } }",0,,0,0,0
"import java.util.*;  class Solution {     private int[] low;     private int[] disc;     private int time;     private boolean[] visited;     private List<List<Integer>> graph;     private List<List<Integer>> bridges;          public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {         // initialize variables         low = new int[n];         disc = new int[n];         visited = new boolean[n];         graph = new ArrayList<>();         bridges = new ArrayList<>();         time = 0;                  // create graph         for(int i = 0; i < n; i++) {             graph.add(new ArrayList<>());         }                  for(List<Integer> conn: connections) {             int u = conn.get(0);             int v = conn.get(1);             graph.get(u).add(v);             graph.get(v).add(u);         }                  // perform DFS         for(int i = 0; i < n; i++) {             if(!visited[i]) {                 dfs(i, -1);             }         }                  return bridges;     }          private void dfs(int u, int parent) {         visited[u] = true;         disc[u] = low[u] = time++;                  for(int v: graph.get(u)) {             if(v == parent) {                 continue;             }             if(!visited[v]) {                 dfs(v, u);                 low[u] = Math.min(low[u], low[v]);                 if(low[v] > disc[u]) {                     bridges.add(Arrays.asList(u, v));                 }             } else {                 low[u] = Math.min(low[u], disc[v]);             }         }     } }",1,"1192-critical-connections-in-a-network/Solution.java:44:26: Inner assignments should be avoided. [InnerAssignment]
1192-critical-connections-in-a-network/Solution.java:50:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",0,0,0
"class Solution {     public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {         // First, we'll create a graph to represent the items and their dependencies.         List<List<Integer>> itemGraph = new ArrayList<>();         for (int i = 0; i < n; i++) {             itemGraph.add(new ArrayList<>());         }          for (int i = 0; i < n; i++) {             List<Integer> beforeList = beforeItems.get(i);             for (int before : beforeList) {                 itemGraph.get(before).add(i);             }         }          // Next, we'll create a group graph to represent the groups and their dependencies.         List<List<Integer>> groupGraph = new ArrayList<>();         for (int i = 0; i < m; i++) {             groupGraph.add(new ArrayList<>());         }          List<Integer> noGroupItems = new ArrayList<>();         for (int i = 0; i < n; i++) {             int g = group[i];             if (g == -1) {                 noGroupItems.add(i);             } else {                 groupGraph.get(g).add(i);             }         }          // We'll now use a topological sort to get a valid ordering for the groups.         List<Integer> sortedGroups = topologicalSort(groupGraph, m);          if (sortedGroups == null) {             return new int[0];         }          // We'll now use another topological sort to get a valid ordering for the items within each group.         List<Integer> sortedItems = new ArrayList<>();         for (int g : sortedGroups) {             List<Integer> groupItems = groupGraph.get(g);             List<Integer> sortedGroupItems = topologicalSort(itemGraph, groupItems.size(), groupItems);              if (sortedGroupItems == null) {                 return new int[0];             }              sortedItems.addAll(sortedGroupItems);         }          // Finally, we'll add any items not belonging to a group to the end of the sorted list.         sortedItems.addAll(noGroupItems);          return sortedItems.stream().mapToInt(i -> i).toArray();     }      private List<Integer> topologicalSort(List<List<Integer>> graph, int numVertices, List<Integer> initialVertices) {         List<Integer> sortedList = new ArrayList<>();          // Track the number of incoming edges (dependencies) for each vertex.         int[] inDegrees = new int[numVertices];          // Initialize the incoming edge counts and create the queue of initial vertices.         Deque<Integer> queue = new LinkedList<>();         for (int vertex : initialVertices) {             for (int neighbor : graph.get(vertex)) {                 inDegrees[neighbor]++;             }             queue.offer(vertex);         }          // Process each vertex in the queue, adding it to the sorted list and reducing the incoming edge counts for its neighbors.         while (!queue.isEmpty()) {             int vertex = queue.poll();             sortedList.add(vertex);             for (int neighbor : graph.get(vertex)) {                 inDegrees[neighbor]--;                 if (inDegrees[neighbor] == 0) {                     queue.offer(neighbor);                 }             }         }          // If not all vertices were processed, we have a cycle and cannot do a topological sort.         if (sortedList.size() != numVertices) {             return null;         }          return sortedList;     }      private List<Integer> topologicalSort(List<List<Integer>> graph, int numVertices) {         List<Integer> sortedList = new ArrayList<>();          // Track the number of incoming edges (dependencies) for each vertex.         int[] inDegrees = new int[numVertices];          // Initialize the incoming edge counts.         for (int i = 0; i < numVertices; i++) {             for (int neighbor : graph.get(i)) {                 inDegrees[neighbor]++;             }         }          // Create the queue of vertices with no incoming edges.         Deque<Integer> queue = new LinkedList<>();         for (int i = 0; i < numVertices; i++) {             if (inDegrees[i] == 0) {                 queue.offer(i);             }         }          // Process each vertex in the queue, adding it to the sorted list and reducing the incoming edge counts for its neighbors.         while (!queue.isEmpty()) {             int vertex = queue.poll();             sortedList.add(vertex);             for (int neighbor : graph.get(vertex)) {                 inDegrees[neighbor]--;                 if (inDegrees[neighbor] == 0) {                     queue.offer(neighbor);                 }             }         }          // If not all vertices were processed, we have a cycle and cannot do a topological sort.         if (sortedList.size() != numVertices) {             return null;         }          return sortedList;     } }",1,"1203-sort-items-by-groups-respecting-dependencies/Solution.java:2:	NPathComplexity:	The method 'sortItems(int, int, int[], List<List<Integer>>)' has an NPath complexity of 216, current threshold is 200
",0,0,0
"import java.util.Random;  class Skiplist {     class Node {         int val;         Node[] forward;         public Node(int level, int val) {             forward = new Node[level];             this.val = val;         }     }      Node head;     int maxLevel;     Random rand;      public Skiplist() {         head = new Node(1, -1);         maxLevel = 1;         rand = new Random();     }      public boolean search(int target) {         Node node = head;         for (int i = maxLevel-1; i >= 0; i--) {             while (node.forward[i] != null && node.forward[i].val < target) {                 node = node.forward[i];             }         }         node = node.forward[0];         return node != null && node.val == target;     }      public void add(int num) {         int level = randomLevel();         Node newNode = new Node(level, num);         Node[] update = new Node[level];         Node node = head;         for (int i = level-1; i >= 0; i--) {             while (node.forward[i] != null && node.forward[i].val < num) {                 node = node.forward[i];             }             update[i] = node;         }         for (int i = 0; i < level; i++) {             newNode.forward[i] = update[i].forward[i];             update[i].forward[i] = newNode;         }         if (level > maxLevel) {             maxLevel = level;         }     }      public boolean erase(int num) {         Node[] update = new Node[maxLevel];         Node node = head;         for (int i = maxLevel-1; i >= 0; i--) {             while (node.forward[i] != null && node.forward[i].val < num) {                 node = node.forward[i];             }             update[i] = node;         }         node = node.forward[0];         if (node == null || node.val != num) {             return false;         }         for (int i = 0; i < maxLevel; i++) {             if (update[i].forward[i] != node) {                 break;             }             update[i].forward[i] = node.forward[i];         }         while (maxLevel > 1 && head.forward[maxLevel-1] == null) {             maxLevel--;         }         return true;     }      private int randomLevel() {         int level = 1;         while (rand.nextDouble() < 0.5 && level < 16) {             level++;         }         return level;     } }",1,"1206-design-skiplist/Skiplist.java:5:13: Variable 'val' must be private and have accessor methods. [VisibilityModifier]
1206-design-skiplist/Skiplist.java:6:16: Variable 'forward' must be private and have accessor methods. [VisibilityModifier]
1206-design-skiplist/Skiplist.java:7:9: Redundant 'public' modifier. [RedundantModifier]
1206-design-skiplist/Skiplist.java:7:36: 'val' hides a field. [HiddenField]
1206-design-skiplist/Skiplist.java:13:10: Variable 'head' must be private and have accessor methods. [VisibilityModifier]
1206-design-skiplist/Skiplist.java:14:9: Variable 'maxLevel' must be private and have accessor methods. [VisibilityModifier]
1206-design-skiplist/Skiplist.java:15:12: Variable 'rand' must be private and have accessor methods. [VisibilityModifier]
1206-design-skiplist/Skiplist.java:17:5: Redundant 'public' modifier. [RedundantModifier]
1206-design-skiplist/Skiplist.java:13:	FieldDeclarationsShouldBeAtStartOfClass:	Fields should be declared at the top of the class, before any method declarations, constructors, initializers or inner classes.
1206-design-skiplist/Skiplist.java:14:	FieldDeclarationsShouldBeAtStartOfClass:	Fields should be declared at the top of the class, before any method declarations, constructors, initializers or inner classes.
1206-design-skiplist/Skiplist.java:15:	FieldDeclarationsShouldBeAtStartOfClass:	Fields should be declared at the top of the class, before any method declarations, constructors, initializers or inner classes.
1206-design-skiplist/Skiplist.java:68:	CompareObjectsWithEquals:	Use equals() to compare object references.
",0,0,0
"class Solution {     public int minimumMoves(int[][] grid) {         int n = grid.length;         Queue<int[]> q = new LinkedList<>();  //Using Queue to store the current position of the snake and its direction         int[][][] visited = new int[n][n][2]; //visited array to keep track if the current position is already visited or not.         int[] start = {0, 0, 0, 1};  //initial position of the snake, 4 parameters are row, column, direction (0 for horizontal and 1 for vertical) and distance travelled         q.offer(start);         visited[0][0][0] = 1;         visited[0][1][0] = 1;         while (!q.isEmpty()) {             int[] curr = q.poll();             int row = curr[0], col = curr[1], dir = curr[2], dist = curr[3];             if (row == n - 1 && col == n - 2 && dir == 0)                 return dist;  //if we have reached the destination             if (dir == 0) {                 //horizontal direction                 //check right, down and clock-wise rotation                 if (col + 2 < n && grid[row][col + 2] == 0 && visited[row][col + 1][0] == 0) {                     visited[row][col + 1][0] = 1;                     q.offer(new int[]{row, col + 1, 0, dist + 1});                 }                 if (row + 1 < n && grid[row + 1][col] == 0 && grid[row + 1][col + 1] == 0 && visited[row + 1][col][0] == 0) {                     visited[row + 1][col][0] = 1;                     q.offer(new int[]{row + 1, col, 0, dist + 1});                 }                 if (row + 1 < n && grid[row + 1][col] == 0 && grid[row + 1][col + 1] == 0 && grid[row][col + 1] == 0 && visited[row][col][1] == 0) {                     visited[row][col][1] = 1;                     q.offer(new int[]{row, col, 1, dist + 1});                 }             } else {                 //vertical direction                 //check down, right and counter-clockwise rotation                 if (row + 2 < n && grid[row + 2][col] == 0 && visited[row + 1][col][1] == 0) {                     visited[row + 1][col][1] = 1;                     q.offer(new int[]{row + 1, col, 1, dist + 1});                 }                 if (col + 1 < n && grid[row][col + 1] == 0 && grid[row + 1][col + 1] == 0 && visited[row][col + 1][1] == 0) {                     visited[row][col + 1][1] = 1;                     q.offer(new int[]{row, col + 1, 1, dist + 1});                 }                 if (col + 1 < n && grid[row][col + 1] == 0 && grid[row + 1][col + 1] == 0 && grid[row + 1][col] == 0 && visited[row][col][0] == 0) {                     visited[row][col][0] = 1;                     q.offer(new int[]{row, col, 0, dist + 1});                 }             }         }         return -1;         //if there is no way to reach the destination     } }",1,"1210-minimum-moves-to-reach-target-with-rotations/Solution.java:12:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1210-minimum-moves-to-reach-target-with-rotations/Solution.java:2:	NPathComplexity:	The method 'minimumMoves(int[][])' has an NPath complexity of 961, current threshold is 200
",1,0,0
"class Solution {     public int countVowelPermutation(int n) {         final int MOD = 1000000007;         // Initialize dp array         long[][] dp = new long[n+1][5];         for (int i = 0; i < 5; i++) {             dp[1][i] = 1;         }          // Fill dp array using the given rules         for (int i = 2; i <= n; i++) {             // For vowel 'a', previous vowel can be either 'e' or 'i' or 'u'             dp[i][0] = (dp[i-1][1] + dp[i-1][2] + dp[i-1][4]) % MOD;              // For vowel 'e', previous vowel can be either 'a' or 'i'             dp[i][1] = (dp[i-1][0] + dp[i-1][2]) % MOD;              // For vowel 'i', previous vowel can be either 'e' or 'o'             dp[i][2] = (dp[i-1][1] + dp[i-1][3]) % MOD;              // For vowel 'o', previous vowel can only be 'i'             dp[i][3] = dp[i-1][2];              // For vowel 'u', previous vowel can only be 'a'             dp[i][4] = dp[i-1][0];         }          long count = 0;         for (int i = 0; i < 5; i++) {             count = (count + dp[n][i]) % MOD;         }          return (int) count;     } }",0,,0,0,0
"class Solution {     public int dieSimulator(int n, int[] rollMax) {         int MOD = 1_000_000_007;         int[][] dp = new int[n+1][7];         for (int i = 1; i <= n; i++) {             for (int j = 1; j <= 6; j++) {                 if (i == 1) {                     dp[i][j] = 1;                     continue;                 }                 for (int k = 1; k <= rollMax[j-1]; k++) {                     if (i - k < 1) {                         break;                     }                     int cnt = 0;                     for (int l = 1; l <= 6; l++) {                         if (j == l) {                             continue;                         }                         cnt = (cnt + dp[i-k][l])%MOD;                     }                     dp[i][j] = (dp[i][j] + cnt)%MOD;                 }             }         }         return dp[n][1] + dp[n][2] + dp[n][3] + dp[n][4] + dp[n][5] + dp[n][6];     } }",0,,0,0,0
"class Solution {     public int maxEqualFreq(int[] nums) {         Map<Integer, Integer> countFreq = new HashMap<>();         Map<Integer, Integer> freqCount = new HashMap<>();              int maxLength = 1; // minimum length         for (int i = 0; i < nums.length; i++) {             int num = nums[i];             int count = countFreq.getOrDefault(num, 0) + 1;             countFreq.put(num, count);                      freqCount.put(count, freqCount.getOrDefault(count, 0) + 1);                          // Minimum interval ending with element `i` with valid frequency.             int intervalLength = i + 1;             if(freqCount.size()==1) {                 maxLength = intervalLength;             } else if (freqCount.size() == 2) {                 int x = -1, y = -1;                  for (int freq : freqCount.keySet()) {                     if (x == -1) {                         x = freq;                     } else if (y == -1) {                         y = freq;                     }                 }                  if ((x == 1 && freqCount.get(x) == 1) || (y == 1 && freqCount.get(y) == 1)) {                      maxLength = intervalLength; // only one number with frequency 1                 } else if (Math.abs(x - y) == 1 && freqCount.get(Math.max(x, y)) == 1) {                     maxLength = intervalLength; // removing one element that occurs once in the beginning or end after removing will make `x` and `y` occurrence equal                 }             }             else {                 maxLength = Math.max(maxLength, 1); // only one element can be removed             }         }          return maxLength;     } }",1,"1224-maximum-equal-frequency/Solution.java:19:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1224-maximum-equal-frequency/Solution.java:34:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",1,0,0
"class Solution {     public int maxProfit(int[] prices) {         int n = prices.length;         int[] buy = new int[2];         buy[0] = buy[1] = Integer.MIN_VALUE;         int[] sell = new int[2];                  for(int i=0; i<n; i++){             int price = prices[i];             sell[1] = Math.max(sell[1], buy[1]+price);             buy[1] = Math.max(buy[1], sell[0]-price);             sell[0] = Math.max(sell[0], buy[0]+price);             buy[0] = Math.max(buy[0], -price);         }         return sell[1];     } }",1,"123-best-time-to-buy-and-sell-stock-iii/Solution.java:5:25: Inner assignments should be avoided. [InnerAssignment]
",0,0,0
"class Solution {     public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {         int n = startTime.length;                  //creating jobs list         List<Job> jobs = new ArrayList<>();         for(int i = 0; i < n; i++){             jobs.add(new Job(startTime[i], endTime[i], profit[i]));         }                  //sorting jobs based on end time         Collections.sort(jobs, (a, b) -> Integer.compare(a.endTime, b.endTime));                  int[] dp = new int[n];         dp[0] = jobs.get(0).profit;                  for(int i = 1; i < n; i++){             int currProfit = jobs.get(i).profit;             int lastNonConflictingJobIndex = getLastNonConflictingJobIndex(jobs, i, dp);             if(lastNonConflictingJobIndex != -1){                 currProfit += dp[lastNonConflictingJobIndex];             }             dp[i] = Math.max(currProfit, dp[i-1]);         }                  return dp[n-1];     }          //helper method to get the last non-conflicting job index     private int getLastNonConflictingJobIndex(List<Job> jobs, int index, int[] dp){         int lo = 0, hi = index-1;         while(lo <= hi){             int mid = lo + (hi - lo)/2;             if(jobs.get(mid).endTime <= jobs.get(index).startTime){                 if(jobs.get(mid+1).endTime <= jobs.get(index).startTime){                     lo = mid + 1;                 } else {                     return mid;                 }             } else {                 hi = mid - 1;             }         }         return -1;     } }  //Job class representing each job class Job {     int startTime;     int endTime;     int profit;          public Job(int startTime, int endTime, int profit){         this.startTime = startTime;         this.endTime = endTime;         this.profit = profit;     } }",1,"1235-maximum-profit-in-job-scheduling/Solution.java:31:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1235-maximum-profit-in-job-scheduling/Solution.java:50:9: Variable 'startTime' must be private and have accessor methods. [VisibilityModifier]
1235-maximum-profit-in-job-scheduling/Solution.java:51:9: Variable 'endTime' must be private and have accessor methods. [VisibilityModifier]
1235-maximum-profit-in-job-scheduling/Solution.java:52:9: Variable 'profit' must be private and have accessor methods. [VisibilityModifier]
1235-maximum-profit-in-job-scheduling/Solution.java:54:5: Redundant 'public' modifier. [RedundantModifier]
1235-maximum-profit-in-job-scheduling/Solution.java:54:20: 'startTime' hides a field. [HiddenField]
1235-maximum-profit-in-job-scheduling/Solution.java:54:35: 'endTime' hides a field. [HiddenField]
1235-maximum-profit-in-job-scheduling/Solution.java:54:48: 'profit' hides a field. [HiddenField]
1235-maximum-profit-in-job-scheduling/Solution.java:30:	UnusedFormalParameter:	Avoid unused method parameters such as 'dp'.
",1,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {          int maxValue = Integer.MIN_VALUE; //initialize max value to minimum          public int maxPathSum(TreeNode root) {         helper(root);         return maxValue;     }          public int helper(TreeNode node){         if(node == null) {             return 0;         }                  int leftSum = Math.max(0, helper(node.left)); //calculate left sum recursively         int rightSum = Math.max(0, helper(node.right)); //calculate right sum recursively                  maxValue = Math.max(maxValue, node.val + leftSum + rightSum); // update max value                  return node.val + Math.max(leftSum, rightSum); // return path sum that includes only one child     } }",1,"124-binary-tree-maximum-path-sum/TreeNode.java:18:9: Variable 'maxValue' must be private and have accessor methods. [VisibilityModifier]
",0,0,0
"class Solution {     public int tilingRectangle(int n, int m) {         // Create a 2D array to keep track of the minimum number of squares needed to cover the rectangle         int[][] dp = new int[n+1][m+1];                  // Initialize the array with a value that is greater than any possible number of squares needed (n*m)         for(int i=0; i<=n; i++) {             for(int j=0; j<=m; j++) {                 dp[i][j] = n*m;             }         }                  // Loop through every possible square size         for(int i=1; i<=n; i++) {             for(int j=1; j<=m; j++) {                 // Check if the current square fits in the rectangle                 if(i <= n && j <= m) {                     // If it fits, then the rectangle can be covered by 1 square of this size                     dp[i][j] = 1;                                          // Loop through every possible sub-rectangle using this square and update the minimum number of squares needed                     for(int k=i+1; k<=n; k++) {                         dp[k][j] = Math.min(dp[k][j], dp[k-i][j] + dp[i][j]);                     }                     for(int k=j+1; k<=m; k++) {                         dp[i][k] = Math.min(dp[i][k], dp[i][k-j] + dp[i][j]);                     }                 }             }         }                  // Return the minimum number of squares needed to cover the entire rectangle         return dp[n][m];     } }",0,,0,0,0
"class Solution {     public boolean isGoodArray(int[] nums) {         int gcd = nums[0];                  // Finding gcd of all the array elements         for(int i=1;i<nums.length;i++){             gcd = gcd(gcd, nums[i]);         }                  return gcd == 1;     }          // Function to find gcd of two numbers     private int gcd(int a, int b){         if(b == 0){             return a;         }         return gcd(b, a%b);     } }",0,,0,0,0
"class Solution {     public int maxScoreWords(String[] words, char[] letters, int[] score) {         int[] freq = new int[26];         for (char c : letters) {             freq[c-'a']++;         }         return dfs(words, freq, score, 0);     }          private int dfs(String[] words, int[] freq, int[] score, int pos) {         if (pos == words.length) {             return 0;         }         // skip current word         int res = dfs(words, freq, score, pos+1);         // use current word         boolean isValid = true;         int curScore = 0;         for (char c : words[pos].toCharArray()) {             freq[c-'a']--;             curScore += score[c-'a'];             if (freq[c-'a'] < 0) {                 isValid = false;             }         }         if (isValid) {             res = Math.max(res, curScore + dfs(words, freq, score, pos+1));         }         // backtrack         for (char c : words[pos].toCharArray()) {             freq[c-'a']++;         }         return res;     } }",0,,0,0,0
"import java.util.*;  class Solution {     public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {         List<List<String>> result = new ArrayList<>();         Set<String> wordSet = new HashSet<>(wordList);          if (!wordSet.contains(endWord)) {             return result;         }          Map<String, List<String>> graph = new HashMap<>();         Map<String, Integer> distances = new HashMap<>();         bfs(beginWord, endWord, wordSet, graph, distances);          List<String> path = new ArrayList<>();         path.add(beginWord);         dfs(beginWord, endWord, graph, distances, path, result);          return result;     }      private void bfs(String beginWord, String endWord, Set<String> wordSet, Map<String, List<String>> graph, Map<String, Integer> distances) {         Queue<String> queue = new LinkedList<>();         queue.offer(beginWord);         distances.put(beginWord, 0);          while (!queue.isEmpty()) {             int size = queue.size();             boolean foundEndWord = false;             Set<String> visitedLevel = new HashSet<>();             for (int i = 0; i < size; i++) {                 String curr = queue.poll();                 int distanceToCurr = distances.get(curr);                 List<String> neighbors = getNeighbors(curr, wordSet);                 for (String neighbor : neighbors) {                     if (!distances.containsKey(neighbor)) {                         graph.put(neighbor, new ArrayList<>());                         distances.put(neighbor, distanceToCurr + 1);                         visitedLevel.add(neighbor);                         if (neighbor.equals(endWord)) {                             foundEndWord = true;                         } else {                             queue.offer(neighbor);                         }                     }                     graph.get(neighbor).add(curr);                 }             }             if (foundEndWord) {                 break;             }             wordSet.removeAll(visitedLevel);         }     }      private void dfs(String curr, String endWord, Map<String, List<String>> graph, Map<String, Integer> distances, List<String> path, List<List<String>> result) {         if (curr.equals(endWord)) {             result.add(new ArrayList<>(path));             return;         }         List<String> neighbors = graph.get(curr);         for (String neighbor : neighbors) {             if (distances.get(neighbor) == distances.get(curr) + 1) {                 path.add(neighbor);                 dfs(neighbor, endWord, graph, distances, path, result);                 path.remove(path.size() - 1);             }         }     }      private List<String> getNeighbors(String word, Set<String> wordSet) {         List<String> neighbors = new ArrayList<>();         char[] arr = word.toCharArray();         for (int i = 0; i < arr.length; i++) {             for (char c = 'a'; c <= 'z'; c++) {                 char original = arr[i];                 if (original != c) {                     arr[i] = c;                     String newWord = new String(arr);                     if (wordSet.contains(newWord)) {                         neighbors.add(newWord);                     }                 }                 arr[i] = original;             }         }         return neighbors;     } }",1,"126-word-ladder-ii/Solution.java:12:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
126-word-ladder-ii/Solution.java:13:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
126-word-ladder-ii/Solution.java:80:	StringInstantiation:	Avoid instantiating String objects; this is usually unnecessary.
",0,0,0
"class Solution {          // class for storing the state of the game     class State {         int bx, by, px, py;         State(int bx, int by, int px, int py) {             this.bx = bx;             this.by = by;             this.px = px;             this.py = py;         }     }          public int minPushBox(char[][] grid) {         int m = grid.length;         int n = grid[0].length;                  // find positions of B, T, and S in the grid         int bx = -1, by = -1, tx = -1, ty = -1, px = -1, py = -1;         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 if (grid[i][j] == 'B') {                     bx = i;                     by = j;                 } else if (grid[i][j] == 'T') {                     tx = i;                     ty = j;                 } else if (grid[i][j] == 'S') {                     px = i;                     py = j;                 }             }         }                  // initialize visited array with false         boolean[][][][] visited = new boolean[m][n][m][n];                  // initialize queue for BFS         Queue<State> q = new LinkedList<>();         q.offer(new State(bx, by, px, py));         visited[bx][by][px][py] = true;                  // BFS loop         int pushes = 0;         int[] dx = {0, 0, 1, -1};         int[] dy = {1, -1, 0, 0};         while (!q.isEmpty()) {             int size = q.size();             for (int i = 0; i < size; i++) {                 State curr = q.poll();                 if (curr.bx == tx && curr.by == ty) {                     return pushes;                 }                 for (int j = 0; j < 4; j++) {                     int nx = curr.px + dx[j];                     int ny = curr.py + dy[j];                     if (nx < 0 || nx >= m || ny < 0 || ny >= n || grid[nx][ny] == '#' || visited[curr.bx][curr.by][nx][ny]) {                         continue;                     }                     if (nx == curr.bx && ny == curr.by) {                         int nnx = curr.bx + dx[j];                         int nny = curr.by + dy[j];                         if (nnx < 0 || nnx >= m || nny < 0 || nny >= n || grid[nnx][nny] == '#') {                             continue;                         }                         q.offer(new State(nnx, nny, curr.px, curr.py));                         visited[curr.bx][curr.by][nnx][nny] = true;                     } else {                         q.offer(new State(curr.bx, curr.by, nx, ny));                         visited[curr.bx][curr.by][nx][ny] = true;                     }                 }             }             pushes++;         }         return -1;     } }",1,"1263-minimum-moves-to-move-a-box-to-their-target-location/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1263-minimum-moves-to-move-a-box-to-their-target-location/Solution.java:5:13: Variable 'bx' must be private and have accessor methods. [VisibilityModifier]
1263-minimum-moves-to-move-a-box-to-their-target-location/Solution.java:5:17: Variable 'by' must be private and have accessor methods. [VisibilityModifier]
1263-minimum-moves-to-move-a-box-to-their-target-location/Solution.java:5:21: Variable 'px' must be private and have accessor methods. [VisibilityModifier]
1263-minimum-moves-to-move-a-box-to-their-target-location/Solution.java:5:25: Variable 'py' must be private and have accessor methods. [VisibilityModifier]
1263-minimum-moves-to-move-a-box-to-their-target-location/Solution.java:6:19: 'bx' hides a field. [HiddenField]
1263-minimum-moves-to-move-a-box-to-their-target-location/Solution.java:6:27: 'by' hides a field. [HiddenField]
1263-minimum-moves-to-move-a-box-to-their-target-location/Solution.java:6:35: 'px' hides a field. [HiddenField]
1263-minimum-moves-to-move-a-box-to-their-target-location/Solution.java:6:43: 'py' hides a field. [HiddenField]
1263-minimum-moves-to-move-a-box-to-their-target-location/Solution.java:19:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1263-minimum-moves-to-move-a-box-to-their-target-location/Solution.java:14:	NPathComplexity:	The method 'minPushBox(char[][])' has an NPath complexity of 1038, current threshold is 200
",1,0,0
"class Solution {     public int numWays(int steps, int arrLen) {         int MOD = 1000000007;         int maxColumn = Math.min(arrLen - 1, steps);         int[] dp = new int[maxColumn + 1];         dp[0] = 1;         for (int i = 1; i <= steps; i++) {             int[] dpNext = new int[maxColumn + 1];             for (int j = 0; j <= maxColumn; j++) {                 dpNext[j] = dp[j];                 if (j - 1 >= 0)                     dpNext[j] = (dpNext[j] + dp[j - 1]) % MOD;                 if (j + 1 <= maxColumn)                     dpNext[j] = (dpNext[j] + dp[j + 1]) % MOD;             }             dp = dpNext;         }         return dp[0];     } }",1,"1269-number-of-ways-to-stay-in-the-same-place-after-some-steps/Solution.java:7:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
1269-number-of-ways-to-stay-in-the-same-place-after-some-steps/Solution.java:9:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
",0,0,0
"import java.util.*;  class Solution {     public int ladderLength(String beginWord, String endWord, List<String> wordList) {         Set<String> dict = new HashSet<>(wordList);         if (!dict.contains(endWord)) {             return 0;         }         Set<String> visited = new HashSet<>();         Queue<String> queue = new LinkedList<>();         queue.offer(beginWord);         visited.add(beginWord);         int level = 1;         while (!queue.isEmpty()) {             int size = queue.size();             for (int i = 0; i < size; i++) {                 String currentWord = queue.poll();                 char[] chars = currentWord.toCharArray();                 for (int j = 0; j < chars.length; j++) {                     char originalChar = chars[j];                     for (char c = 'a'; c <= 'z'; c++) {                         if (c == originalChar) {                             continue;                         }                         chars[j] = c;                         String newWord = new String(chars);                         if (newWord.equals(endWord)) {                             return level + 1;                         }                         if (dict.contains(newWord) && !visited.contains(newWord)) {                             queue.offer(newWord);                             visited.add(newWord);                         }                     }                     chars[j] = originalChar;                 }             }             level++;         }         return 0;     } }",1,"127-word-ladder/Solution.java:26:	StringInstantiation:	Avoid instantiating String objects; this is usually unnecessary.
",0,0,0
"class Solution {     public int palindromePartition(String s, int k) {         int n = s.length();         int[][] cost = new int[n][n];         for (int i = 0; i < n; i++) {             for (int j = i + 1; j < n; j++) {                 cost[i][j] = cost[i][j - 1] + (s.charAt(j) != s.charAt(j - 1) ? 1 : 0);             }         }          int[][] dp = new int[k][n];         for (int i = 0; i < n; i++) {             dp[0][i] = cost[0][i];         }          for (int i = 1; i < k; i++) {             for (int j = i; j < n; j++) {                 int min = Integer.MAX_VALUE;                 for (int l = i - 1; l < j; l++) {                     min = Math.min(min, dp[i - 1][l] + cost[l + 1][j]);                 }                 dp[i][j] = min;             }         }          return dp[k - 1][n - 1];     } }",1,"1278-palindrome-partitioning-iii/Solution.java:7:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",0,0,0
"class Solution {     public int minFlips(int[][] mat) {         int m = mat.length;         int n = mat[0].length;         int[][] target = new int[m][n];         int[] dx = new int[] {0, 1, -1, 0, 0};         int[] dy = new int[] {0, 0, 0, 1, -1};         Queue<int[][]> queue = new LinkedList<>();         Set<String> visited = new HashSet<>();          queue.offer(mat);         visited.add(Arrays.deepToString(mat));         int steps = 0;          while (!queue.isEmpty()) {             int size = queue.size();             for (int i = 0; i < size; i++) {                 int[][] curr = queue.poll();                 if (Arrays.deepEquals(curr, target)) {                     return steps;                 }                  for (int x = 0; x < m; x++) {                     for (int y = 0; y < n; y++) {                         int[][] next = new int[m][n];                         for (int k = 0; k < m; k++) {                             next[k] = Arrays.copyOf(curr[k], n);                         }                          next[x][y] = 1 - next[x][y];                         for (int k = 0; k < 5; k++) {                             int nx = x + dx[k];                             int ny = y + dy[k];                             if (nx >= 0 && nx < m && ny >= 0 && ny < n) {                                 next[nx][ny] = 1 - next[nx][ny];                             }                         }                          String s = Arrays.deepToString(next);                         if (!visited.contains(s)) {                             visited.add(s);                             queue.offer(next);                         }                     }                 }             }              steps++;         }          return -1;     } }",0,,0,0,0
"class Solution {     public int minFallingPathSum(int[][] grid) {                  int n = grid.length;                  // Initialize dp array with the values of first row         int[] dp = grid[0];                  // Traverse through the rest of the rows         for(int i=1; i<n; i++){             // Initialize the temporary array to store the values of the new row             int[] temp = new int[n];                          // Traverse through the columns of the new row             for(int j=0; j<n; j++){                 // Initialize minimum value to Integer.MAX_VALUE                 int min = Integer.MAX_VALUE;                                  // Traverse through the columns of the previous row                 for(int k=0; k<n; k++){                     // Check if the column of the previous row is not same as the current column                     if(k != j){                         // Take the minimum value of the previous row's column                         min = Math.min(min, dp[k]);                     }                 }                 // Add the current cell and minimum value of the previous row column                 temp[j] = grid[i][j] + min;             }             // Update the dp array with the values of the new row             dp = temp;         }                  // Find the minimum value of the last row         int min = Integer.MAX_VALUE;         for(int i=0; i<n; i++){             min = Math.min(min, dp[i]);         }                  // Return the minimum value of the last row         return min;     } }",0,,0,0,0
"import java.util.*;  class Solution {     public int shortestPath(int[][] grid, int k) {         int m = grid.length;         int n = grid[0].length;         int[][] directions = { {1,0}, {-1,0}, {0,1}, {0,-1} };         int[][][] visited = new int[m][n][k+1]; // Keep track of the visited cells with 0 to k obstacles already removed         Queue<int[]> queue = new LinkedList<>();         queue.add(new int[]{0,0,0}); // Starting point with x=0, y=0 and 0 obstacles removed         visited[0][0][0] = 1; // Marking the starting point visited with 0 obstacles removed          // BFS         int steps = 0;         while(!queue.isEmpty()) {             int size = queue.size(); // Current level of BFS             for(int i=0; i<size; i++) {                 int[] curr = queue.poll();                 int x = curr[0];                 int y = curr[1];                 int obstacles = curr[2];                 if(x == m-1 && y == n-1) {                     return steps;                 }                 for(int[] dir : directions) {                     int dx = x + dir[0];                     int dy = y + dir[1];                     if(dx >= 0 && dx < m && dy >= 0 && dy < n) { // If the neighbor cell is within the grid                         if(grid[dx][dy] == 0 && visited[dx][dy][obstacles] == 0) { // If the neighbor cell is empty and not visited before                             visited[dx][dy][obstacles] = 1; // Mark it visited                             queue.add(new int[]{dx, dy, obstacles}); // Add it to the queue                         } else if(grid[dx][dy] == 1 && obstacles < k && visited[dx][dy][obstacles+1] == 0) { // If the neighbor cell is an obstacle and we can still remove obstacles and not visited before                             visited[dx][dy][obstacles+1] = 1; // Mark it visited                             queue.add(new int[]{dx, dy, obstacles+1}); // Add it to the queue with one more obstacle removed                         }                     }                 }             }             steps++; // Increment the steps once we finish traversing the current level         }         return -1; // If we couldn't reach to the end point, return -1     } }",1,"1293-shortest-path-in-a-grid-with-obstacles-elimination/Solution.java:21:	PrematureDeclaration:	Declaration of 'obstacles' can be moved closer to its usages
",0,0,0
"class Solution {     public int maxCandies(int[] status, int[] candies, int[][] keys, int[][] containedBoxes, int[] initialBoxes) {         int n = status.length;         boolean[] visited = new boolean[n];         List<Integer> availableBoxes = new ArrayList<>(); // boxes that can be opened without using a key         Queue<Integer> queue = new LinkedList<>(); // keep track of boxes that can be opened with a key                  for (int box : initialBoxes) {             visited[box] = true;             if (status[box] == 1) {                 availableBoxes.add(box);             } else {                 queue.offer(box);             }         }                  int maxCandies = 0;         while (!availableBoxes.isEmpty() || !queue.isEmpty()) {             while (!queue.isEmpty()) { // open boxes with keys                 int box = queue.poll();                 visited[box] = true;                 if (status[box] == 1) {                     availableBoxes.add(box);                 }                 for (int key : keys[box]) {                     if (!visited[key]) {                         queue.offer(key);                     }                 }             }             if (availableBoxes.isEmpty()) {                 break;             }             int box = availableBoxes.remove(0); // open boxes without keys             visited[box] = true;             maxCandies += candies[box];             for (int containedBox : containedBoxes[box]) {                 if (!visited[containedBox]) {                     if (status[containedBox] == 1) {                         availableBoxes.add(containedBox);                     } else {                         queue.offer(containedBox);                     }                 }             }         }                  return maxCandies;     } }",0,,0,0,0
"import java.util.*;  class Solution {          private static final int MOD = 1000000007;          public int[] pathsWithMaxScore(List<String> board) {         int n = board.size();         int[][] dp = new int[n][n];         int[][] count = new int[n][n];         count[n - 1][n - 1] = 1;                  for (int i = n - 1; i >= 0; i--) {             char[] row = board.get(i).toCharArray();             for (int j = n - 1; j >= 0; j--) {                 if (row[j] == 'X') {                     continue;                 }                 int maxPrev = 0;                 int pathCount = 0;                                  for (int[] dir: new int[][]{{1, 0}, {0, 1}, {1, 1}}) {                     int x = i + dir[0];                     int y = j + dir[1];                     if (x < n && y < n && dp[x][y] > maxPrev) {                         maxPrev = dp[x][y];                         pathCount = count[x][y];                     } else if (x < n && y < n && dp[x][y] == maxPrev) {                         pathCount = (pathCount + count[x][y]) % MOD;                     }                 }                                  if (i == 0 && j == 0) {                     dp[i][j] = 0;                     count[i][j] = 1;                 } else {                     dp[i][j] = maxPrev + (row[j] == 'E' ? 0 : row[j] - '0');                     count[i][j] = pathCount;                 }             }         }                  return new int[]{dp[0][0], count[0][0]};     } }",0,,0,0,0
"import java.util.HashSet;  class Solution {     public boolean isSolvable(String[] words, String result) {         HashSet<Character> uniqueChars = new HashSet<>();         for (String word : words) {             for (int i = 0; i < word.length(); i++) {                 uniqueChars.add(word.charAt(i));             }         }         for (int i = 0; i < result.length(); i++) {             uniqueChars.add(result.charAt(i));         }         int[] charMapping = new int[26];         for (int i = 0; i < charMapping.length; i++) {             charMapping[i] = -1;         }         Character[] possibleValues = new Character[10];         for (int i = 0; i < 10; i++) {             possibleValues[i] = (char)('0' + i);         }         return backtrack(0, uniqueChars, charMapping, possibleValues, words, result);     }          private boolean backtrack(int index, HashSet<Character> uniqueChars, int[] charMapping, Character[] possibleValues, String[] words, String result) {         if (index == possibleValues.length) {             return decodeAndCheckWords(words, result, charMapping);         }         char currentChar = (char)('A' + index);         if (!uniqueChars.contains(currentChar)) {             return backtrack(index+1, uniqueChars, charMapping, possibleValues, words, result);         }         for (int i = 0; i < possibleValues.length; i++) {             if (possibleValues[i] != null && !usedValue(charMapping, possibleValues[i])) {                 charMapping[currentChar - 'A'] = i;                 possibleValues[i] = null;                 if (backtrack(index+1, uniqueChars, charMapping, possibleValues, words, result)) {                     return true;                 }                 charMapping[currentChar - 'A'] = -1;                 possibleValues[i] = (char)('0' + i);             }         }         return false;     }          private boolean usedValue(int[] charMapping, char c) {         for (int i = 0; i < charMapping.length; i++) {             if (charMapping[i] == (c - '0')) {                 return true;             }         }         return false;     }          private boolean decodeAndCheckWords(String[] words, String result, int[] charMapping) {         int sum = 0;         for (String word : words) {             int currentNum = 0;             for (int i = 0; i < word.length(); i++) {                 currentNum = currentNum * 10 + charMapping[word.charAt(i) - 'A'];             }             sum += currentNum;         }         int resultNum = 0;         for (int i = 0; i < result.length(); i++) {             resultNum = resultNum * 10 + charMapping[result.charAt(i) - 'A'];         }         return sum == resultNum;     } }",1,"1307-verbal-arithmetic-puzzle/Solution.java:5:	LooseCoupling:	Avoid using implementation types like 'HashSet'; use the interface instead
1307-verbal-arithmetic-puzzle/Solution.java:25:	LooseCoupling:	Avoid using implementation types like 'HashSet'; use the interface instead
1307-verbal-arithmetic-puzzle/Solution.java:36:	NullAssignment:	Assigning an Object to null is a code smell.  Consider refactoring.
1307-verbal-arithmetic-puzzle/Solution.java:48:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int minInsertions(String s) {         int n = s.length();         int[][] dp = new int[n][n];          for (int i = n - 1; i >= 0; i--) {             for (int j = i + 1; j < n; j++) {                 if (s.charAt(i) == s.charAt(j)) {                     dp[i][j] = dp[i+1][j-1];                 } else {                     dp[i][j] = Math.min(dp[i+1][j], dp[i][j-1]) + 1;                  }             }         }         return dp[0][n-1];     } }   // Test the implementation public class Main {     public static void main(String[] args) {         Solution solution = new Solution();                  String s1 = ""zzazz"";         String s2 = ""mbadm"";         String s3 = ""leetcode"";                  System.out.println(solution.minInsertions(s1)); //Output: 0         System.out.println(solution.minInsertions(s2)); //Output: 2         System.out.println(solution.minInsertions(s3)); //Output: 5              } }",1,"1312-minimum-insertion-steps-to-make-a-string-palindrome/Main.java:20:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
1312-minimum-insertion-steps-to-make-a-string-palindrome/Main.java:20:	UseUtilityClass:	This utility class has a non-private constructor
",0,0,0
"class Solution {     public int distinctEchoSubstrings(String text) {         int count = 0;         Set<String> set = new HashSet<>(); // to store distinct substrings          for (int i = 0; i < text.length(); i++) {             for (int j = i + 1; j < text.length(); j++) {                 int len = j - i; // length of current substring                 if (j + len <= text.length() && text.substring(i, i + len).equals(text.substring(j, j + len))) {                     // check if the next substring of same length is equal to current substring                     String substr = text.substring(i, i + len);                     if (!set.contains(substr)) {                         set.add(substr);                         count++;                     }                 }             }         }         return count;     } }",0,,0,0,0
"class Solution {     public int minCut(String s) {         int n = s.length();         int[] cuts = new int[n];         boolean[][] isPalindrome = new boolean[n][n];                  for (int i = 0; i < n; i++) {             int minCut = i;             for (int j = 0; j <= i; j++) {                 if (s.charAt(i) == s.charAt(j) && (j + 1 > i - 1 || isPalindrome[j + 1][i - 1])) {                     isPalindrome[j][i] = true;                     minCut = j == 0 ? 0 : Math.min(minCut, cuts[j - 1] + 1);                 }             }             cuts[i] = minCut;         }         return cuts[n - 1];     } }",1,"132-palindrome-partitioning-ii/Solution.java:5:	LinguisticNaming:	Linguistics Antipattern - The variable 'isPalindrome' indicates linguistically it is a boolean, but it is 'boolean[][]'
",0,0,0
"class Solution {     public int minimumDistance(String word) {         int n = word.length();         int[][][] dp = new int[27][n+1][n+1]; // maximum number of letters possible = 26         return findMinDist(dp, 0, 26, 0, word);     }          public int findMinDist(int[][][] dp, int pos, int l1, int l2, String s) {         if(pos == s.length())             return 0;         if(dp[l1][l2][pos] != 0)             return dp[l1][l2][pos];                  int currentLetter = s.charAt(pos) - 'A';         int moveLeft = findMinDist(dp, pos+1, currentLetter, l2, s) + distance(l1, currentLetter);         int moveRight = findMinDist(dp, pos+1, l1, currentLetter, s) + distance(l2, currentLetter);                  dp[l1][l2][pos] = Math.min(moveLeft, moveRight);         return dp[l1][l2][pos];     }          public int distance(int l1, int l2) {         if(l1 == 26)             return 0;         int x1 = l1 / 6, y1 = l1 % 6;         int x2 = l2 / 6, y2 = l2 % 6;         return Math.abs(x1-x2) + Math.abs(y1-y2);     } }",1,"1320-minimum-distance-to-type-a-word-using-two-fingers/Solution.java:25:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1320-minimum-distance-to-type-a-word-using-two-fingers/Solution.java:26:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int minTaps(int n, int[] ranges) {         // create an array of tapes         int[] taps = new int[n + 1];         for (int i = 0; i <= n; i++) {             int left = Math.max(i - ranges[i], 0);             int right = Math.min(i + ranges[i], n);             taps[left] = Math.max(taps[left], right - left);         }                  int currentEnd = 0; // current end covered by last tap         int nextEnd = 0; // the next end point that can be covered         int count = 0; // number of taps required                  for (int i = 0; i <= n; i++) {             nextEnd = Math.max(nextEnd, i + taps[i]);             if (i == currentEnd) { // need to add another tap for next end                 count++;                 currentEnd = nextEnd;                 if (currentEnd >= n) { // the whole garden is covered                     return count;                 }             }         }                  return -1; // not all parts of the garden are covered     } }",0,,0,0,0
"class Solution {     public int maxValueAfterReverse(int[] nums) {         int n = nums.length;         int res = 0, rev = 0;         for (int i = 1; i < n; i++) {             res += Math.abs(nums[i] - nums[i - 1]);         }         for (int i = 1; i < n; i++) {             rev = Math.max(rev, Math.abs(nums[i] - nums[0]) - Math.abs(nums[i - 1] - nums[i]));             rev = Math.max(rev, Math.abs(nums[n - 1] - nums[i]) - Math.abs(nums[i - 1] - nums[i]));         }         Arrays.sort(nums);         return res + Math.max(rev, 2 * (nums[n - 1] - nums[0]));     } }",1,"1330-reverse-subarray-to-maximize-array-value/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int minDifficulty(int[] jobDifficulty, int d) {         int n = jobDifficulty.length;         if (d > n) {             // It's impossible to schedule the jobs             return -1;         }         int[][] dp = new int[d][n];         // Fill the first row of the DP table         int maxDifficulty = jobDifficulty[0];         for (int j = 0; j < n; j++) {             maxDifficulty = Math.max(maxDifficulty, jobDifficulty[j]);             dp[0][j] = maxDifficulty;         }         // Fill the rest of the DP table         for (int i = 1; i < d; i++) {             for (int j = i; j < n; j++) {                 int minDifficulty = Integer.MAX_VALUE;                 maxDifficulty = jobDifficulty[j];                 for (int k = j; k >= i; k--) {                     maxDifficulty = Math.max(maxDifficulty, jobDifficulty[k]);                     minDifficulty = Math.min(minDifficulty, dp[i-1][k-1] + maxDifficulty);                 }                 dp[i][j] = minDifficulty;             }         }         return dp[d-1][n-1];     } }",0,,0,0,0
"class Solution {     public int maxJumps(int[] arr, int d) {         int n = arr.length;         int[] dp = new int[n]; // array to store max jumps from each index                  // traverse the array from left to right and compute max jumps         for (int i = 0; i < n; i++) {             dp[i] = 1; // minimum number of jumps is 1 (jumping to self)             // check for all possible jumps to the left             for (int j = i - 1; j >= Math.max(0, i - d) && arr[j] < arr[i]; j--) {                 dp[i] = Math.max(dp[i], dp[j] + 1);             }         }                  // traverse the array from right to left and recompute max jumps         for (int i = n - 1; i >= 0; i--) {             // check for all possible jumps to the right             for (int j = i + 1; j <= Math.min(n - 1, i + d) && arr[j] < arr[i]; j++) {                 dp[i] = Math.max(dp[i], dp[j] + 1);             }         }                  // return the maximum value in dp array         int ans = Integer.MIN_VALUE;         for (int i = 0; i < n; i++) {             ans = Math.max(ans, dp[i]);         }         return ans;     } }",0,,0,0,0
"class Solution {     public int minJumps(int[] arr) {         int n = arr.length;         // Base case         if (n == 1) {             return 0;         }          // Create a map to store indices for each element in array         Map<Integer, List<Integer>> indices = new HashMap<>();         for (int i = 0; i < n; i++) {             indices.putIfAbsent(arr[i], new ArrayList<>());             indices.get(arr[i]).add(i);         }          // Create a boolean array to track visited indices         boolean[] visited = new boolean[n];         visited[0] = true;          // Create a queue to store indices to be visited         Queue<Integer> queue = new LinkedList<>();         queue.offer(0);          int jumps = 0;         while (!queue.isEmpty()) {             int size = queue.size();             for (int i = 0; i < size; i++) {                 int index = queue.poll();                 // If last index is reached, return minimum jumps                 if (index == n - 1) {                     return jumps;                 }                 // Check adjacent indices                 if (index - 1 >= 0 && !visited[index - 1]) {                     visited[index - 1] = true;                     queue.offer(index - 1);                 }                 if (index + 1 < n && !visited[index + 1]) {                     visited[index + 1] = true;                     queue.offer(index + 1);                 }                 // Check indices with same value                 for (int sameValueIndex : indices.get(arr[index])) {                     if (!visited[sameValueIndex]) {                         visited[sameValueIndex] = true;                         queue.offer(sameValueIndex);                     }                 }                 // Clear indices with same value after they are visited                 indices.get(arr[index]).clear();             }             jumps++;         }          return -1; // If last index is unreachable     } }",1,"1345-jump-game-iv/Solution.java:2:	NPathComplexity:	The method 'minJumps(int[])' has an NPath complexity of 224, current threshold is 200
",0,0,0
"class Solution {     public int maxStudents(char[][] seats) {         int m = seats.length, n = seats[0].length;         int[][] dp = new int[m+1][1<<n]; // dp to store maximum number of students that can be placed         for(int i=1; i<=m; i++) {             for(int j=0; j<(1<<n); j++) {                 int cnt = 0; // stores count of valid seats                 boolean isValid = true;                 for(int k=0; k<n; k++) {                     if(((j>>k)&1)==1) { // if seat can't be taken or adjacent seats                         if(seats[i-1][k]=='#') isValid=false;                         if(k>0 && ((j>>k-1)&1)==1) isValid=false;                         if(k<n-1 && ((j>>k+1)&1)==1) isValid=false;                     }                 }                 if(isValid==false) continue;                 for(int k=0; k<n; k++) {                     if(((j>>k)&1)==1) cnt++; // incrementing count for valid seat                 }                 for(int k=0; k<(1<<n); k++) {                     boolean flag = true;                     for(int l=0; l<n; l++) {                         if((j>>l&1) == 1 && (k>>l&1) == 1) {                             flag = false;                             break;                         }                     }                     if(flag==true) {                         dp[i][j] = Math.max(dp[i][j], dp[i-1][k]+cnt);                     }                 }             }         }         int res = 0;         for(int i=0; i<(1<<n); i++) {             res = Math.max(res, dp[m][i]);         }         return res;     } }",1,"1349-maximum-students-taking-exam/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1349-maximum-students-taking-exam/Solution.java:16:27: Expression can be simplified. [SimplifyBooleanExpression]
1349-maximum-students-taking-exam/Solution.java:28:28: Expression can be simplified. [SimplifyBooleanExpression]
1349-maximum-students-taking-exam/Solution.java:2:	NPathComplexity:	The method 'maxStudents(char[][])' has an NPath complexity of 2164, current threshold is 200
1349-maximum-students-taking-exam/Solution.java:16:	SimplifyBooleanExpressions:	Avoid unnecessary comparisons in boolean expressions
1349-maximum-students-taking-exam/Solution.java:28:	SimplifyBooleanExpressions:	Avoid unnecessary comparisons in boolean expressions
",1,0,0
"class Solution {     public int candy(int[] ratings) {         int n = ratings.length;         int[] candy = new int[n];                  // each child gets one candy         Arrays.fill(candy, 1);                  // check left neighbor         for (int i = 1; i < n; i++) {             if (ratings[i] > ratings[i-1]) {                 candy[i] = candy[i-1] + 1;             }         }                  // check right neighbor and update max candies for each child         for (int i = n-2; i >= 0; i--) {             if (ratings[i] > ratings[i+1]) {                 candy[i] = Math.max(candy[i], candy[i+1] + 1);             }         }                  // calculate total candies required         int totalCandies = 0;         for (int i = 0; i < n; i++) {             totalCandies += candy[i];         }                  return totalCandies;     } }",0,,0,0,0
"class Solution {     public boolean isPossible(int[] target) {         int n = target.length;         long sum = 0;         for(int i=0;i<n;i++) sum += target[i];         PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->b-a);         for(int i=0;i<n;i++) pq.offer(target[i]);         while(true) {             int num = pq.poll();             sum -= num;             if(num==1 || sum==1) return true;             if(num<sum || sum==0 || num%sum==0) return false;             num %= sum;             sum += num;             pq.offer(num);         }     } }",0,,0,0,0
class Solution {     public int countOrders(int n) {         int mod = 1000000007;         long dp[] = new long[n+1];         //base case initialization         dp[1] = 1;                  for(int i=2;i<=n;i++){             long factor = ((i-1)*2)+1;             dp[i] = (factor*dp[i-1])%mod;         }                  return (int)dp[n];     } },1,"1359-count-all-valid-pickup-and-delivery-options/Solution.java:4:16: Array brackets at illegal position. [ArrayTypeStyle]
1359-count-all-valid-pickup-and-delivery-options/Solution.java:10:	UselessParentheses:	Useless parentheses.
",0,0,0
"class Solution {     public String largestMultipleOfThree(int[] digits) {         String res = """";         int n = digits.length;          // creating an array to store the count of occurrences of each digit         int[] cnt = new int[10];         for(int d : digits){             cnt[d]++;         }          // sum of digits         int sum = 0;         for(int i = 0; i < 10; i++){             sum += i * cnt[i];         }          // removing digits with remainder (sum % 3) in order to get the largest multiple of three         if(sum % 3 == 1){             if(removeOne(cnt, 1)){                 removeOne(cnt, 1);             }else{                 removeOne(cnt, 2);                 removeOne(cnt, 2);             }         }else if(sum % 3 == 2){             if(removeOne(cnt, 2)){                 removeOne(cnt, 2);             }else{                 removeOne(cnt, 1);                 removeOne(cnt, 1);             }         }          // adding remaining digits to the result string         for(int i = 9; i >= 0; i--){             for(int j = 0; j < cnt[i]; j++){                 res += i;             }         }          // trimming leading zeroes         while(res.length() > 1 && res.charAt(0) == '0'){             res = res.substring(1);         }          return res;     }      // helper function to remove one digit from the count array     private boolean removeOne(int[] cnt, int rem){         for(int i = rem; i < 10; i += 3){             if(cnt[i] > 0){                 cnt[i]--;                 return true;             }         }         return false;     } }",1,"1363-largest-multiple-of-three/Solution.java:4:	UnusedLocalVariable:	Avoid unused local variables such as 'n'.
1363-largest-multiple-of-three/Solution.java:38:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
",0,0,0
"class Solution {     public int minCost(int[][] grid) {         int row = grid.length;         int col = grid[0].length;         int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // right, left, down, up         PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]); // min heap based on cost         boolean[][] visited = new boolean[row][col];         pq.add(new int[]{0, 0, 0}); // starting cell (0,0) with cost=0         while (!pq.isEmpty()) {             int[] cur = pq.poll();             int x = cur[0];             int y = cur[1];             int cost = cur[2];             if (visited[x][y]) continue;             visited[x][y] = true;             if (x == row - 1 && y == col - 1) return cost; // reached the bottom right cell             for (int i = 0; i < 4; i++) { // try each direction                 int nx = x + directions[i][0];                 int ny = y + directions[i][1];                 if (nx < 0 || nx >= row || ny < 0 || ny >= col || visited[nx][ny]) continue; // out of bounds or already visited                 int newCost = cost;                 if (i != grid[x][y] - 1) newCost++; // need to modify the sign                 pq.add(new int[]{nx, ny, newCost});             }         }         return -1; // no valid path to the bottom right cell     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     private int maxSum = 0;          public int maxSumBST(TreeNode root) {         traverse(root);         return maxSum;     }          private Result traverse(TreeNode node) {         if (node == null) {             return new Result(Integer.MAX_VALUE, Integer.MIN_VALUE, 0, true);         }                  Result left = traverse(node.left);         Result right = traverse(node.right);                  Result res = new Result();                  if (!left.isBST || !right.isBST || left.max >= node.val || right.min <= node.val) {             res.isBST = false;             res.totalSum = Math.max(left.totalSum, right.totalSum);             maxSum = Math.max(maxSum, res.totalSum);             return res;         }                  res.isBST = true;         res.min = Math.min(left.min, node.val);         res.max = Math.max(right.max, node.val);         res.totalSum = left.totalSum + right.totalSum + node.val;                  maxSum = Math.max(maxSum, res.totalSum);                  return res;     }          private class Result {         int min;         int max;         int totalSum;         boolean isBST;                  public Result() {}                  public Result(int min, int max, int totalSum, boolean isBST) {             this.min = min;             this.max = max;             this.totalSum = totalSum;             this.isBST = isBST;         }     } }",1,"1373-maximum-sum-bst-in-binary-tree/TreeNode.java:52:13: Variable 'min' must be private and have accessor methods. [VisibilityModifier]
1373-maximum-sum-bst-in-binary-tree/TreeNode.java:53:13: Variable 'max' must be private and have accessor methods. [VisibilityModifier]
1373-maximum-sum-bst-in-binary-tree/TreeNode.java:54:13: Variable 'totalSum' must be private and have accessor methods. [VisibilityModifier]
1373-maximum-sum-bst-in-binary-tree/TreeNode.java:55:17: Variable 'isBST' must be private and have accessor methods. [VisibilityModifier]
1373-maximum-sum-bst-in-binary-tree/TreeNode.java:57:9: Redundant 'public' modifier. [RedundantModifier]
1373-maximum-sum-bst-in-binary-tree/TreeNode.java:59:9: Redundant 'public' modifier. [RedundantModifier]
1373-maximum-sum-bst-in-binary-tree/TreeNode.java:59:27: 'min' hides a field. [HiddenField]
1373-maximum-sum-bst-in-binary-tree/TreeNode.java:59:36: 'max' hides a field. [HiddenField]
1373-maximum-sum-bst-in-binary-tree/TreeNode.java:59:45: 'totalSum' hides a field. [HiddenField]
1373-maximum-sum-bst-in-binary-tree/TreeNode.java:59:63: 'isBST' hides a field. [HiddenField]
1373-maximum-sum-bst-in-binary-tree/TreeNode.java:57:	UncommentedEmptyConstructor:	Document empty constructor
",0,0,0
"import java.util.*;  class Solution {     public double frogPosition(int n, int[][] edges, int t, int target) {         // Create an adjacency list representation of the graph         List<List<Integer>> graph = new ArrayList<>();         for (int i = 0; i <= n; i++) {             graph.add(new ArrayList<>());         }         for (int[] edge : edges) {             int u = edge[0];             int v = edge[1];             graph.get(u).add(v);             graph.get(v).add(u);         }                  // Create a visited array to keep track of visited vertices         boolean[] visited = new boolean[n+1];         visited[1] = true;                  // Create a queue for BFS traversal         Queue<Integer> queue = new LinkedList<>();         queue.add(1);                  // Initialize the probabilities array         double[] probabilities = new double[n+1];         probabilities[1] = 1.0;                  // Perform BFS traversal         while (!queue.isEmpty() && t > 0) {             int size = queue.size();             while (size-- > 0) {                 int u = queue.poll();                 int count = 0;                 for (int v : graph.get(u)) {                     if (!visited[v]) {                         count++;                     }                 }                 for (int v : graph.get(u)) {                     if (!visited[v]) {                         visited[v] = true;                         queue.add(v);                         probabilities[v] = probabilities[u] / count;                     }                 }                 if (count > 0) {                     probabilities[u] = 0.0;                 }             }             t--;         }                  // Return the probability of reaching the target vertex         return probabilities[target];     } }",1,"1377-frog-position-after-t-seconds/Solution.java:51:	AvoidReassigningParameters:	Avoid reassigning parameters such as 't'
",0,1,0
"class Solution {     public int maxPerformance(int n, int[] speed, int[] efficiency, int k) {         int[][] engineers = new int[n][2];         for(int i=0; i<n; i++){             engineers[i][0] = speed[i];             engineers[i][1] = efficiency[i];         }         Arrays.sort(engineers, (a,b)->b[1]-a[1]);         PriorityQueue<Integer> pq = new PriorityQueue<>(k);         long speedSum=0, res=0;         for(int[] engineer: engineers){             if(pq.size() == k){                 speedSum -= pq.poll();             }             pq.offer(engineer[0]);             speedSum += engineer[0];             res = Math.max(res, speedSum*engineer[1]);         }         return (int)(res%1000000007);     } }",1,"1383-maximum-performance-of-a-team/Solution.java:10:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int maxSizeSlices(int[] slices) {         int n = slices.length;         int m = n / 3;         int[][] dp = new int[n][m + 1];                  // case 1: include the first slice         for (int j = 1; j <= m; j++) {             dp[0][j] = slices[0];         }                  // case 2: do not include the first slice         for (int i = 1; i < n; i++) {             for (int j = 1; j <= m; j++) {                 dp[i][j] = Math.max(dp[i-1][j], (i >= 2 ? dp[i-2][j-1] : 0) + slices[i]);             }         }                  // calculate the maximum sum by considering all possible scenarios         int maxSum = 0;         for (int j = 1; j <= m; j++) {             maxSum = Math.max(maxSum, dp[n-1][j]);             maxSum = Math.max(maxSum, dp[n-2][j]);         }         return maxSum;     } }",0,,0,0,0
"class Solution {     public String longestPrefix(String s) {         int n = s.length();         int[] lps = new int[n];         int len = 0;         int i = 1;         while (i < n) {             if (s.charAt(i) == s.charAt(len)) {                 len++;                 lps[i] = len;                 i++;             } else {                 if (len != 0) {                     len = lps[len - 1];                 } else {                     lps[i] = 0;                     i++;                 }             }         }         int prefixLength = lps[n - 1];         return s.substring(0, prefixLength);     } }",1,"1392-longest-happy-prefix/Solution.java:13:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",0,0,0
"class Solution {          private static final int MOD = 1000000007;          public int findGoodStrings(int n, String s1, String s2, String evil) {         int[][][] dp = new int[n][2][2];         boolean[] prefix = new boolean[n];         boolean[] suffix = new boolean[n];         int maxLen = evil.length();         int[] lps = new int[maxLen];         buildLPS(evil, lps);         int ans = dfs(0, n, s1, s2, prefix, suffix, lps, dp);         return ans;     }          private int dfs(int idx, int n, String s1, String s2, boolean[] prefix, boolean[] suffix, int[] lps, int[][][] dp) {         if (idx == n) {             return 1;         }         if (dp[idx][prefix[idx] ? 1 : 0][suffix[idx] ? 1 : 0] != 0) {             return dp[idx][prefix[idx] ? 1 : 0][suffix[idx] ? 1 : 0];         }         char minC = prefix[idx] ? 'a' : s1.charAt(idx);         char maxC = suffix[idx] ? 'z' : s2.charAt(idx);         long ans = 0;         for (char c = minC; c <= maxC; c++) {             if (evilMatch(prefix, suffix, lps, c, idx)) {                 continue;             }             prefix[idx + 1] = prefix[idx] && c == s1.charAt(idx);             suffix[idx + 1] = suffix[idx] && c == s2.charAt(idx);             ans += dfs(idx + 1, n, s1, s2, prefix, suffix, lps, dp);             ans %= MOD;         }         dp[idx][prefix[idx] ? 1 : 0][suffix[idx] ? 1 : 0] = (int) ans;         return (int) ans;     }          private boolean evilMatch(boolean[] prefix, boolean[] suffix, int[] lps, char c, int idx) {         String str = """";         if (prefix[idx]) {             str += c;         }         for (int i = 0; i < idx; i++) {             if (prefix[i]) {                 str += 'a';             } else if (suffix[i]) {                 str += 'z';             } else {                 str += (char)('a' - 1);             }         }         int j = 0;         for (int i = 1; i < str.length(); i++) {             while (j > 0 && str.charAt(i) != evil.charAt(j)) {                 j = lps[j - 1];             }             if (str.charAt(i) == evil.charAt(j)) {                 j++;             }             if (j == evil.length()) {                 return true;             }         }         return false;     }          private void buildLPS(String pat, int[] lps) {         lps[0] = 0;         int j = 0;         for (int i = 1; i < pat.length(); i++) {             while (j > 0 && pat.charAt(i) != pat.charAt(j)) {                 j = lps[j - 1];             }             if (pat.charAt(i) == pat.charAt(j)) {                 j++;             }             lps[i] = j;         }     } }",1,"1397-find-all-good-strings/Solution.java:16:17: More than 7 parameters (found 8). [ParameterNumber]
1397-find-all-good-strings/Solution.java:12:	UnnecessaryLocalBeforeReturn:	Consider simply returning the value vs storing it in local variable 'ans'
1397-find-all-good-strings/Solution.java:16:	NPathComplexity:	The method 'dfs(int, int, String, String, boolean[], boolean[], int[], int[][][])' has an NPath complexity of 480, current threshold is 200
1397-find-all-good-strings/Solution.java:42:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
1397-find-all-good-strings/Solution.java:46:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
1397-find-all-good-strings/Solution.java:48:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
1397-find-all-good-strings/Solution.java:50:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
",0,0,0
"import java.util.ArrayList; import java.util.HashMap; import java.util.List;  class Solution {     public List<String> wordBreak(String s, List<String> wordDict) {         List<String> result = new ArrayList<>();          // Creating a set of all words in wordDict for faster lookup         HashMap<String, Boolean> map = new HashMap<>();         for (String word : wordDict) {             map.put(word, true);         }          // Recursive function to build sentences         sentenceBuilder(s, map, """", result);          return result;     }      private void sentenceBuilder(String s, HashMap<String, Boolean> map, String sentence, List<String> result) {         // If entire string s has been processed, add the sentence to result         if (s.length() == 0) {             result.add(sentence.trim());             return;         }          // Loop through string s, trying to add each substring as a word         for (int i = 1; i <= s.length(); i++) {             String word = s.substring(0, i);              // If the substring is a word in dictionary, add it to current sentence and look for next word             if (map.containsKey(word)) {                 sentenceBuilder(s.substring(i), map, sentence + "" "" + word, result);             }         }     } }",1,"140-word-break-ii/Solution.java:10:	LooseCoupling:	Avoid using implementation types like 'HashMap'; use the interface instead
140-word-break-ii/Solution.java:21:	LooseCoupling:	Avoid using implementation types like 'HashMap'; use the interface instead
",0,0,0
class Solution {     public int maxSatisfaction(int[] satisfaction) {         Arrays.sort(satisfaction);         int n = satisfaction.length;         int res = 0;         int total = 0;         for (int i = n - 1; i >= 0 && satisfaction[i] > -total; --i) {             total += satisfaction[i];             res += total;         }         return res;     } },0,,0,0,0
"class Solution {     public String stoneGameIII(int[] stoneValue) {         int n = stoneValue.length;         int[] dp = new int[n+1];         for (int i = n-1; i >= 0; i--) {             int take = 0, sum = 0;             dp[i] = Integer.MIN_VALUE;             for (int j = i; j < Math.min(i+3, n); j++) {                 sum += stoneValue[j];                 take = Math.max(take, sum - dp[j+1]);             }             dp[i] = take;         }         int aliceScore = dp[0];         int bobScore = Arrays.stream(stoneValue).sum() - aliceScore;         if (aliceScore > bobScore) {             return ""Alice"";         } else if (aliceScore < bobScore) {             return ""Bob"";         } else {             return ""Tie"";         }     } }",1,"1406-stone-game-iii/Solution.java:6:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
class Solution {     public int numOfWays(int n) {         int MOD = 1000000007;         long[][] dp = new long[n][3];         dp[0][0] = 6;         dp[0][1] = 6;         dp[0][2] = 6;                  for (int i = 1; i < n; i++) {             dp[i][0] = (2 * dp[i - 1][0] + 2 * dp[i - 1][1] + 2 * dp[i - 1][2]) % MOD;             dp[i][1] = (2 * dp[i - 1][0] + 3 * dp[i - 1][1] + 2 * dp[i - 1][2]) % MOD;             dp[i][2] = (2 * dp[i - 1][0] + 2 * dp[i - 1][1] + 3 * dp[i - 1][2]) % MOD;         }                  return (int) ((dp[n - 1][0] + dp[n - 1][1] + dp[n - 1][2]) % MOD);     } } ,0,,0,0,0
"class Solution {     public int numberOfArrays(String s, int k) {         final int MOD = 1000000007;         int n = s.length();         long[] dp = new long[n+1];         dp[n] = 1;                  for(int i=n-1;i>=0;i--) {             if(s.charAt(i) == '0') {                 dp[i] = 0;             } else {                 long num = 0;                 for(int j=i;j<n;j++) {                     num = num*10 + (s.charAt(j)-'0');                     if(num > k) {                         break;                     }                     dp[i] = (dp[i] + dp[j+1])%MOD;                 }             }         }         return (int)dp[0];     } }",1,"1416-restore-the-array/Solution.java:14:	UselessParentheses:	Useless parentheses.
",0,0,0
"class Solution {    public int numOfArrays(int n, int m, int k) {         int mod = 1000000007;        int[][][] dp = new int[n + 1][m + 1][k + 1];         for (int i = 1; i <= m; i++) {            dp[1][i][1] = 1;        }         for (int i = 2; i <= n; i++) {            for (int j = 1; j <= m; j++) {                for (int l = 1; l <= k; l++) {                    dp[i][j][l] = (int) ((long)dp[i][j - 1][l] + (long)dp[i - 1][j - 1][l - 1] * j % mod) % mod;                }            }        }         return dp[n][m][k];    } }",1,"1420-build-array-where-you-can-find-the-maximum-exactly-k-comparisons/Solution.java:14:	UnnecessaryCast:	Unnecessary cast (long)
",0,0,0
"class Solution {     public int constrainedSubsetSum(int[] nums, int k) {         int n = nums.length;         int[] dp = new int[n];         int maxSum = Integer.MIN_VALUE;         Deque<Integer> deque = new LinkedList<>(); // for storing the indices of valid elements                  for (int i = 0; i < n; i++) {             // remove the index which is out of the current window             while (!deque.isEmpty() && deque.peekFirst() < i - k) {                 deque.removeFirst();             }                          // update the dp value for index i using the values of valid indices in the deque             dp[i] = nums[i];             if (!deque.isEmpty()) {                 dp[i] += dp[deque.peekFirst()];             }                          // remove the invalid indices till we have current element greater than the back of deque             while (!deque.isEmpty() && dp[i] >= dp[deque.peekLast()]) {                 deque.removeLast();             }             deque.addLast(i);                          // update the maxSum             maxSum = Math.max(maxSum, dp[i]);         }                  return maxSum;     } }",1,"1425-constrained-subsequence-sum/Solution.java:8:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
",0,0,0
class Solution {     public int numberWays(List<List<Integer>> hats) {         int MOD = 1000000007;         int n = hats.size();         int allMask = (1 << n) - 1;         int h = hats.stream().mapToInt(hat -> hat.size()).max().getAsInt();         int[] dp = new int[1 << n];         dp[0] = 1;         for (int i = 1; i <= h; i++) {             int[] ndp = new int[1 << n];             for (List<Integer> person : hats) {                 for (int hat : person) {                     for (int mask = allMask; mask >= 0; mask--) {                         if ((mask & (1 << hats.indexOf(person))) == 0) {                             int nmask = mask | (1 << hats.indexOf(person));                             ndp[nmask] = (ndp[nmask] + dp[mask]) % MOD;                             break;                         }                     }                 }             }             dp = ndp;         }         return dp[allMask];     } },1,"1434-number-of-ways-to-wear-different-hats-to-each-other/Solution.java:12:	UnusedLocalVariable:	Avoid unused local variables such as 'hat'.
",0,0,0
"import java.util.*;  class Solution {     public int kthSmallest(int[][] mat, int k) {         int m = mat.length;         int n = mat[0].length;         // Maintain a priority queue to keep track of each combination's sum         PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());         // Add the sum of the first row to the queue initially         for (int i = 0; i < n; i++) {             pq.offer(mat[0][i]);         }         // Loop for each of the remaining (m - 1) rows         for (int i = 1; i < m; i++) {             // Create a new priority queue to store the sums of the current row             PriorityQueue<Integer> rowSum = new PriorityQueue<>(Collections.reverseOrder());             // Loop through each of the existing elements in the queue, and each of the elements in the current row             // Compute the sum, and push it onto the ""rowSum"" queue             while (!pq.isEmpty()) {                 int currSum = pq.poll();                 for (int j = 0; j < n; j++) {                     rowSum.offer(currSum + mat[i][j]);                     if (rowSum.size() > k) {                         rowSum.poll();                     }                 }             }             // Add the sums from the ""rowSum"" queue to the main queue             pq.addAll(rowSum);         }         // Return the kth element from the queue         return pq.poll();     } }",1,"1439-find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/Solution.java:8:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
1439-find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/Solution.java:16:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
",0,0,0
"class Solution {     public int ways(String[] pizza, int k) {         int mod = 1000000007;         int m = pizza.length;         int n = pizza[0].length();         int[][] apples = new int[m + 1][n + 1];         for (int i = 1; i <= m; i++) {             for (int j = 1; j <= n; j++) {                 apples[i][j] = apples[i - 1][j] + apples[i][j - 1] - apples[i - 1][j - 1] + (pizza[i - 1].charAt(j - 1) == 'A' ? 1 : 0);             }         }          int[][][] dp = new int[m][n][k];         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 dp[i][j][0] = 1;             }         }          for (int r = 1; r < k; r++) {             for (int i = 0; i < m; i++) {                 for (int j = 0; j < n; j++) {                     int sum = 0;                     for (int p = i + 1; p < m; p++) {                         if (apples[p][n] - apples[i][n] - apples[p][j] + apples[i][j] > 0) {                             sum += dp[p][j][r - 1];                             sum %= mod;                         }                     }                      for (int p = j + 1; p < n; p++) {                         if (apples[m][p] - apples[m][j] - apples[i][p] + apples[i][j] > 0) {                             sum += dp[i][p][r - 1];                             sum %= mod;                         }                     }                      dp[i][j][r] = sum;                 }             }         }          return dp[0][0][k - 1];     } }",0,,0,0,0
"class Solution {     public String largestNumber(int[] cost, int target) {         int[] dp = new int[target + 1];         Arrays.fill(dp, -10001); // some small value which can possibly never be attained.         dp[0] = 0;         for (int t = 1; t <= target; ++t) {             for (int i = 0; i < 9; ++i) {                 if (t >= cost[i]) {                     dp[t] = Math.max(dp[t], dp[t - cost[i]] + 1);                 }             }         }         if (dp[target] < 0) {             return ""0"";         }         StringBuilder stringBuilder = new StringBuilder();         for (int i = 8, t = target; i >= 0; i--) {             while (t >= cost[i] && dp[t] == dp[t - cost[i]] + 1) {                 stringBuilder.append(i + 1);                 t -= cost[i];             }         }         return stringBuilder.toString();     } }",1,"1449-form-largest-integer-with-digits-that-add-up-to-target/Solution.java:17:	ForLoopVariableCount:	Too many control variables in the for statement
",0,0,0
"import java.util.*;  class Solution {     public int numPoints(int[][] darts, int r) {         int n = darts.length;         int maxPoints = 1;                  for(int i=0; i<n; i++) {             for(int j=i+1; j<n; j++) {                 // calculate distance between two points                 double dist = calcDistance(darts[i], darts[j]);                                  // if distance is greater than 2*r, then circle with                 // radius r cannot pass through both points.                 if(dist > 2*r) continue;                                  // calculate center of the circle using midpoint formula                 int[] center = calcMidPoint(darts[i], darts[j]);                                  int points = 0;                 for(int k=0; k<n; k++) {                     if(isInsideCircle(center, r, darts[k]))                         points++;                 }                                  maxPoints = Math.max(maxPoints, points);             }         }                  return maxPoints;     }          private double calcDistance(int[] point1, int[] point2) {         int x1 = point1[0];         int y1 = point1[1];         int x2 = point2[0];         int y2 = point2[1];         return Math.sqrt(Math.pow(x1-x2,2) + Math.pow(y1-y2,2));     }          private int[] calcMidPoint(int[] point1, int[] point2) {         int x1 = point1[0];         int y1 = point1[1];         int x2 = point2[0];         int y2 = point2[1];         return new int[]{ (x1+x2)/2, (y1+y2)/2 };     }          private boolean isInsideCircle(int[] center, int r, int[] point) {         int x = point[0];         int y = point[1];         int cx = center[0];         int cy = center[1];         return Math.pow(x-cx,2) + Math.pow(y-cy,2) <= Math.pow(r,2) + 0.000001;     } }",1,"1453-maximum-number-of-darts-inside-of-a-circular-dartboard/Solution.java:1:	UnnecessaryImport:	Unused import 'java.util.*'
",0,0,0
"class Solution {     public int maxDotProduct(int[] nums1, int[] nums2) {         int n = nums1.length, m = nums2.length;         int dp[][] = new int[n + 1][m + 1];         for (int i = 0; i <= n; i++)             Arrays.fill(dp[i], -10000000);         for (int i = 1; i <= n; i++) {             for (int j = 1; j <= m; j++) {                 int curr = nums1[i - 1] * nums2[j - 1];                 dp[i][j] = curr + Math.max(dp[i - 1][j - 1], 0);                 dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);                 dp[i][j] = Math.max(dp[i][j], dp[i][j - 1]);             }         }         return dp[n][m];     } }",1,"1458-max-dot-product-of-two-subsequences/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1458-max-dot-product-of-two-subsequences/Solution.java:4:15: Array brackets at illegal position. [ArrayTypeStyle]
1458-max-dot-product-of-two-subsequences/Solution.java:4:17: Array brackets at illegal position. [ArrayTypeStyle]
",1,0,0
"class Solution {     public int cherryPickup(int[][] grid) {         int N = grid.length, M = grid[0].length;         int dp[][][] = new int[N][M][M];          for (int i = N - 1; i >= 0; i--) {             for (int j = 0; j < M; j++) {                 for (int k = 0; k < M; k++) {                        int res = (j == k) ? grid[i][j] : grid[i][j] + grid[i][k];                                          if(i != N-1){                         int max = 0;                         for(int jj = j - 1; jj <= j + 1; jj++){                             for(int kk = k - 1; kk <= k + 1; kk++){                                 if(jj >= 0 && jj < M && kk >= 0 && kk < M){                                     max = Math.max(max, dp[i+1][jj][kk]);                                 }                             }                         }                         res += max;                     }                                          dp[i][j][k] = res;                 }             }         }          return dp[0][0][M-1];     } }",1,"1463-cherry-pickup-ii/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1463-cherry-pickup-ii/Solution.java:4:15: Array brackets at illegal position. [ArrayTypeStyle]
1463-cherry-pickup-ii/Solution.java:4:17: Array brackets at illegal position. [ArrayTypeStyle]
1463-cherry-pickup-ii/Solution.java:4:19: Array brackets at illegal position. [ArrayTypeStyle]
",1,0,0
class Solution {     public double getProbability(int[] balls) {         int totalBalls = 0;         for(int i=0; i<balls.length; i++){             totalBalls += balls[i];         }         int n = totalBalls/2;         double[][] dp = new double[n+1][n+1];         dp[0][0] = 1;         double s1 = 0;         for(int i=0; i<balls.length; i++){             int colorCount = balls[i];             s1 += colorCount;             for(int j=n; j>=colorCount; j--){                 for(int k=n; k>=colorCount; k--){                     dp[j][k] += dp[j-colorCount][k-colorCount];                 }             }         }         double s2 = totalBalls-s1;         double ans = 0;         for(int i=0; i<=n; i++){             for(int j=0; j<=n; j++){                 if(Math.abs(i-j) > Math.abs(s1-s2)/2) continue;                 if(i+j != n) continue;                 double p1 = dp[i][j];                 double p2 = dp[n-i][n-j];                 if(i==j) ans += p1 * p2;                 else ans += 2 * p1 * p2;             }         }         return ans / ((factorial(totalBalls/2))*(factorial(totalBalls/2)));     }          private int factorial(int n){         int res = 1;         for(int i=2; i<=n; i++){             res *= i;         }         return res;     } },1,"1467-probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/Solution.java:4:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
1467-probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/Solution.java:11:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
1467-probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/Solution.java:32:	UselessParentheses:	Useless parentheses.
1467-probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/Solution.java:32:	UselessParentheses:	Useless parentheses.
",0,0,1
"class Solution {     public int minCost(int[] houses, int[][] cost, int m, int n, int target) {         int[][][] dp = new int[m][n][target + 1];                  // Fill the dp table with maximum integer value         for(int i = 0; i < m; i++) {             for(int j = 0; j < n; j++) {                 Arrays.fill(dp[i][j], Integer.MAX_VALUE);             }         }                  // Initialize the dp table for the first house         if(houses[0] == 0) {             for(int j = 0; j < n; j++) {                 dp[0][j][1] = cost[0][j];             }         } else {             dp[0][houses[0] - 1][1] = 0;         }                  // Fill the dp table for the remaining houses         for(int i = 1; i < m; i++) {             if(houses[i] == 0) {                 for(int j = 0; j < n; j++) {                     for(int k = 1; k <= target; k++) {                         for(int c = 0; c < n; c++) {                             if(c == j) {                                 dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][j][k] + cost[i][j]);                             } else if(k > 1) {                                 dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][c][k - 1] + cost[i][j]);                             }                         }                     }                 }             } else {                 int j = houses[i] - 1;                 for(int k = 1; k <= target; k++) {                     for(int c = 0; c < n; c++) {                         if(c == j) {                             dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][j][k]);                         } else if(k > 1) {                             dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][c][k - 1]);                         }                     }                 }             }         }                  // Find the minimum cost for target neighborhoods         int result = Integer.MAX_VALUE;         for(int j = 0; j < n; j++) {             result = Math.min(result, dp[m - 1][j][target]);         }                  return result == Integer.MAX_VALUE ? -1 : result;     } }",1,"1473-paint-house-iii/Solution.java:2:	NPathComplexity:	The method 'minCost(int[], int[][], int, int, int)' has an NPath complexity of 648, current threshold is 200
",0,0,0
"class Solution {     public int minDistance(int[] houses, int k) {         // sort the array of house positions         Arrays.sort(houses);                  // initialize the memo table for storing previously computed results         int[][] memo = new int[houses.length][k+1];         for (int i=0; i<memo.length; i++) {             Arrays.fill(memo[i], -1);         }                  // call the recursive helper function to compute the minimum distance         return dfs(houses, 0, k, memo);     }          private int dfs(int[] houses, int i, int k, int[][] memo) {         // base cases: if we have no more houses or no more mailboxes to put         if (i == houses.length) {             return 0;         }         if (k == 0) {             return Integer.MAX_VALUE;         }                  // check memo table for pre-computed result         if (memo[i][k] != -1) {             return memo[i][k];         }                  int ans = Integer.MAX_VALUE;                  // try all possible positions for the next mailbox         for (int j=i; j<houses.length; j++) {             int mid = i + (j - i) / 2;             int cost = 0;                          // compute the sum of distances from the mailbox to all houses in its range             for (int l=i; l<=j; l++) {                 cost += Math.abs(houses[l] - houses[mid]);             }                          // recursively compute the minimum cost of the remaining houses with one less mailbox             ans = Math.min(ans, cost + dfs(houses, j+1, k-1, memo));         }                  // store result in memo table and return         memo[i][k] = ans;         return ans;     } }",1,"1478-allocate-mailboxes/Solution.java:8:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class TreeAncestor {     int maxN, maxLog;     int parent[][], depth[];          public TreeAncestor(int n, int[] parent) {         maxN = n;         maxLog = (int) (Math.log(maxN)/Math.log(2)) + 1;         this.parent = new int[maxN][maxLog];         depth = new int[maxN];                  for(int i=0;i<maxN;i++) {             Arrays.fill(this.parent[i], -1);         }                  for(int i=0;i<maxN;i++) {             this.parent[i][0] = parent[i];         }                  for(int j=0;j<maxLog-1;j++) {             for(int i=0;i<maxN;i++) {                 if(this.parent[i][j] != -1) {                     this.parent[i][j+1] = parent[parent[i][j]];                 }             }         }                  for(int i=0;i<maxN;i++) {             if(depth[i] == 0) {                 dfs(i, -1, 0);             }         }     }          public void dfs(int u, int p, int d) {         parent[u][0] = p;         depth[u] = d;                  for(int i=0;i<maxLog;i++) {             if(parent[u][i] != -1) {                 parent[u][i+1] = parent[parent[u][i]][i];             } else {                 break;             }         }                  for(int v=0;v<maxN;v++) {             if(v != u && v != p && parent[v][0] == u) {                 dfs(v, u, d+1);             }         }     }          public int getKthAncestor(int node, int k) {         if(depth[node] < k) {             return -1;         }                  for(int i=0;i<maxLog;i++) {             if((k & (1<<i)) > 0) {                 node = parent[node][i];             }             if(node == -1) {                 return -1;             }         }                  return node;     } }  /** * Your TreeAncestor object will be instantiated and called as such: * TreeAncestor obj = new TreeAncestor(n, parent); * int param_1 = obj.getKthAncestor(node,k); */",1,"1483-kth-ancestor-of-a-tree-node/TreeAncestor.java:2:5: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1483-kth-ancestor-of-a-tree-node/TreeAncestor.java:2:9: Variable 'maxN' must be private and have accessor methods. [VisibilityModifier]
1483-kth-ancestor-of-a-tree-node/TreeAncestor.java:2:15: Variable 'maxLog' must be private and have accessor methods. [VisibilityModifier]
1483-kth-ancestor-of-a-tree-node/TreeAncestor.java:3:5: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1483-kth-ancestor-of-a-tree-node/TreeAncestor.java:3:9: Variable 'parent' must be private and have accessor methods. [VisibilityModifier]
1483-kth-ancestor-of-a-tree-node/TreeAncestor.java:3:15: Array brackets at illegal position. [ArrayTypeStyle]
1483-kth-ancestor-of-a-tree-node/TreeAncestor.java:3:17: Array brackets at illegal position. [ArrayTypeStyle]
1483-kth-ancestor-of-a-tree-node/TreeAncestor.java:3:21: Variable 'depth' must be private and have accessor methods. [VisibilityModifier]
1483-kth-ancestor-of-a-tree-node/TreeAncestor.java:3:26: Array brackets at illegal position. [ArrayTypeStyle]
1483-kth-ancestor-of-a-tree-node/TreeAncestor.java:5:5: Redundant 'public' modifier. [RedundantModifier]
1483-kth-ancestor-of-a-tree-node/TreeAncestor.java:5:38: 'parent' hides a field. [HiddenField]
1483-kth-ancestor-of-a-tree-node/TreeAncestor.java:29:	ConstructorCallsOverridableMethod:	Overridable method called during object construction: TreeAncestor.dfs(int, int, int)
1483-kth-ancestor-of-a-tree-node/TreeAncestor.java:39:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
1483-kth-ancestor-of-a-tree-node/TreeAncestor.java:60:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'node'
",1,1,0
"class Solution {     public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {         int m = edges.length;         // Add index of edge to original array         for (int i = 0; i < m; i++) {             edges[i] = new int[]{edges[i][0], edges[i][1], edges[i][2], i};         }         // Sort edges based on their weight         Arrays.sort(edges, Comparator.comparingInt(a -> a[2]));         // Get weight of Minimum Spanning Tree         int minWeight = getMSTWeight(n, edges, -1, null);         List<Integer> critical = new ArrayList<>();         List<Integer> pseudoCritical = new ArrayList<>();          // Iterate through each edge and check if it is critical or pseudo-critical         for (int i = 0; i < m; i++) {             // Check if edge is critical             int weightWithout = getMSTWeight(n, edges, i, null);             if (weightWithout > minWeight) {                 critical.add(edges[i][3]);                 continue;             }             // Check if edge is pseudo-critical             int weightWith = getMSTWeight(n, edges, -1, edges[i]);             if (weightWith == minWeight) {                 pseudoCritical.add(edges[i][3]);             }         }         return Arrays.asList(critical, pseudoCritical);     }      /**      * Utility method to get weight of Minimum Spanning Tree      * @param n Number of vertices      * @param edges Edge list      * @param exclude Edge to exclude from calculation      * @param include Edge to include in calculation      * @return Weight of Minimum Spanning Tree      */     private int getMSTWeight(int n, int[][] edges, int exclude, int[] include) {         UnionFind uf = new UnionFind(n);         int weight = 0;         if (include != null) {             uf.union(include[0], include[1]);             weight += include[2];         }         for (int i = 0; i < edges.length; i++) {             if (i == exclude) {                 continue;             }             int[] edge = edges[i];             if (uf.find(edge[0]) != uf.find(edge[1])) {                 uf.union(edge[0], edge[1]);                 weight += edge[2];             }         }         // Check if we have a valid MST, otherwise return maximum value         return uf.getCount() == 1 ? weight : Integer.MAX_VALUE;     } }  /**  * Union-Find data structure used to check for cycles in MST  */ class UnionFind {     int[] parent;     int[] size;     int count;      public UnionFind(int n) {         parent = new int[n];         size = new int[n];         Arrays.fill(size, 1);         for (int i = 0; i < n; i++) {             parent[i] = i;         }         count = n;     }      public int getCount() {         return count;     }      public int find(int x) {         while (x != parent[x]) {             parent[x] = parent[parent[x]];             x = parent[x];         }         return x;     }      public boolean union(int x, int y) {         int rootX = find(x);         int rootY = find(y);         if (rootX == rootY) {             return false;         }         if (size[rootX] > size[rootY]) {             parent[rootY] = rootX;             size[rootX] += size[rootY];         } else {             parent[rootX] = rootY;             size[rootY] += size[rootX];         }         count--;         return true;     } }",1,"1489-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/Solution.java:66:11: Variable 'parent' must be private and have accessor methods. [VisibilityModifier]
1489-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/Solution.java:67:11: Variable 'size' must be private and have accessor methods. [VisibilityModifier]
1489-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/Solution.java:68:9: Variable 'count' must be private and have accessor methods. [VisibilityModifier]
1489-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/Solution.java:70:5: Redundant 'public' modifier. [RedundantModifier]
1489-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/Solution.java:87:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'x'
",0,1,0
"class Solution {     public int maxPoints(int[][] points) {         if (points == null || points.length == 0) {             return 0;         }         if (points.length == 1) {             return 1;         }         int maxCount = 0;         for (int i = 0; i < points.length; i++) {             Map<Double, Integer> slopeMap = new HashMap<>();             int samePointCount = 1;             int verticalCount = 0;             for (int j = i + 1; j < points.length; j++) {                 int x1 = points[i][0];                 int y1 = points[i][1];                 int x2 = points[j][0];                 int y2 = points[j][1];                 if (x1 == x2) {                     if (y1 == y2) {                         samePointCount++;                     } else {                         verticalCount++;                     }                 } else {                     double slope = (y2 - y1) * 1.0 / (x2 - x1);                     slopeMap.put(slope, slopeMap.getOrDefault(slope, 0) + 1);                 }                            }             int localMax = Math.max(verticalCount, samePointCount);             for (int count : slopeMap.values()) {                 localMax = Math.max(localMax, count + samePointCount);             }             maxCount = Math.max(maxCount, localMax);                   }         return maxCount;     } }",0,,0,0,0
"class Solution {     public int minNumberOfSemesters(int n, int[][] relations, int k) {         // Initialize the prerequisites         int[] prerequisites = new int[n];         // Loop for each course in the relations         for(int[] relation : relations) {             // Set the prerequisite for the next course             prerequisites[relation[1]-1] |= 1<<(relation[0]-1);         }          // Initialize the dp array         int[] dp = new int[1<<n];         Arrays.fill(dp, n);         dp[0] = 0;          // Loop for each mask of courses taken         for(int mask=0 ; mask<(1<<n) ; mask++) {             // Loop for each possible subset of valid courses             for(int subset=mask ; subset>0 ; subset=(subset-1)&mask) {                 // Check if the subset satisfies the prerequisite                 if((prerequisites[Integer.bitCount(subset)-1]&mask)==prerequisites[Integer.bitCount(subset)-1]) {                     // Check if the number of courses in the subset is less than or equal to k                     if(Integer.bitCount(subset)<=k) {                         dp[mask|subset] = Math.min(dp[mask|subset], dp[mask]+1);                     }                 }             }         }          // Return the minimum number of semesters         return dp[(1<<n)-1];     } }",1,"1494-parallel-courses-ii/Solution.java:23:	CollapsibleIfStatements:	This if statement could be combined with its parent
",0,0,0
"class Solution {     public int findMaxValueOfEquation(int[][] points, int k) {         int len = points.length;           // max heap sorted by yi-xi earlier          PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->(b[1]-b[0])-(a[1]-a[0]));           // Solution: yi + yj + |xi - xj|         //          yi + yj + xj - xi          int max = Integer.MIN_VALUE;          for(int[] p: points){             // remove the points that are out of scope              while(!pq.isEmpty() && p[0]-pq.peek()[0]>k){                 pq.poll();              }             if(!pq.isEmpty()){                 int[] q = pq.peek();                  max = Math.max(max, p[1]+q[1]+p[0]-q[0]);              }             pq.offer(p);          }         return max;      } }",1,"1499-max-value-of-equation/Solution.java:3:	UnusedLocalVariable:	Avoid unused local variables such as 'len'.
1499-max-value-of-equation/Solution.java:6:	UselessParentheses:	Useless parentheses.
",0,0,0
"class Solution {     public String minInteger(String num, int k) {         char[] digits = num.toCharArray();         int n = digits.length;                  // we will use segment tree to update and query         SegmentTree segmentTree = new SegmentTree(n);                  // build initial tree         for (int i = 0; i < n; i++) {             segmentTree.updatePoint(i, digits[i] - '0');         }                  // we need to do at most n swaps to sort the array         for (int swaps = 0; swaps < n; swaps++) {             boolean didSwap = false;                          // check for all possible swaps within k limit             for (int i = 0; i < n && i <= k; i++) {                 int j = segmentTree.queryRange(i + 1, Math.min(i + k, n - 1));                 if (j > i) {                     segmentTree.updateRange(i, j, -1);                     segmentTree.updatePoint(j, digits[i] - '0');                     digits[j] = digits[i];                     digits[i] = (char) (segmentTree.queryPoint(i) + '0');                     k -= (j - i);                     didSwap = true;                     break;                 }             }                          if (!didSwap) {                 // if no more swaps are possible, we can stop                 break;             }         }                  return new String(digits);     }          static class SegmentTree {         private int n;         private int[] tree;          public SegmentTree(int n) {             this.n = n;             this.tree = new int[4 * n];         }                  private void updatePoint(int i, int value) {             updatePoint(0, 0, n - 1, i, value);         }                  private int queryPoint(int i) {             return queryPoint(0, 0, n - 1, i);         }                  private void updateRange(int ql, int qr, int delta) {             updateRange(0, 0, n - 1, ql, qr, delta);         }          private int queryRange(int ql, int qr) {             return queryRange(0, 0, n - 1, ql, qr);         }          private void updatePoint(int v, int tl, int tr, int i, int value) {             if (tl == tr) {                 tree[v] = value;             } else {                 int tm = (tl + tr) / 2;                 if (i <= tm) {                     updatePoint(2 * v + 1, tl, tm, i, value);                 } else {                     updatePoint(2 * v + 2, tm + 1, tr, i, value);                 }                 tree[v] = Math.min(tree[2 * v + 1], tree[2 * v + 2]);             }         }          private int queryPoint(int v, int tl, int tr, int i) {             if (tl == tr) {                 return tree[v];             } else {                 int tm = (tl + tr) / 2;                 if (i <= tm) {                     return queryPoint(2 * v + 1, tl, tm, i);                 } else {                     return queryPoint(2 * v + 2, tm + 1, tr, i);                 }             }         }                  private void updateRange(int v, int tl, int tr, int ql, int qr, int delta) {             if (qr < tl || tr < ql) {                 return;             }             if (ql <= tl && tr <= qr) {                 tree[v] += delta;             } else {                 int tm = (tl + tr) / 2;                 updateRange(2 * v + 1, tl, tm, ql, qr, delta);                 updateRange(2 * v + 2, tm + 1, tr, ql, qr, delta);                 tree[v] = Math.min(tree[2 * v + 1], tree[2 * v + 2]);             }         }          private int queryRange(int v, int tl, int tr, int ql, int qr) {             if (qr < tl || tr < ql) {                 return n;             }             if (ql <= tl && tr <= qr) {                 return tree[v] <= 0 ? n : v - (n - tr) / 2;             } else {                 int tm = (tl + tr) / 2;                 int qlIndex = queryRange(2 * v + 1, tl, tm, ql, qr);                 if (qlIndex <= qr) {                     return qlIndex;                 } else {                     return queryRange(2 * v + 2, tm + 1, tr, ql, qr);                 }             }         }     } }",1,"1505-minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/Solution.java:45:9: Redundant 'public' modifier. [RedundantModifier]
1505-minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/Solution.java:45:32: 'n' hides a field. [HiddenField]
1505-minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/Solution.java:26:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'k'
1505-minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/Solution.java:38:	StringInstantiation:	Avoid instantiating String objects; this is usually unnecessary.
",0,1,0
class Solution {     public boolean winnerSquareGame(int n) {         boolean[] dp = new boolean[n+1];         for (int i = 1; i <= n; i++) {             for (int j = 1; j*j <= i; j++) {                 if (!dp[i-j*j]) {                     dp[i] = true;                     break;                 }             }         }         return dp[n];     } },0,,0,0,0
"class Solution {     public double getMinDistSum(int[][] positions) {         double minX = Double.MAX_VALUE;         double maxX = Double.MIN_VALUE;         double minY = Double.MAX_VALUE;         double maxY = Double.MIN_VALUE;         double delta = 100; // initial delta value         for (int[] pos : positions) {             minX = Math.min(minX, pos[0]);             maxX = Math.max(maxX, pos[0]);             minY = Math.min(minY, pos[1]);             maxY = Math.max(maxY, pos[1]);         }         double centerX = (minX + maxX) / 2;         double centerY = (minY + maxY) / 2;         double minDistSum = getDistSum(centerX, centerY, positions);         while (delta > 1e-5) { // tolerance value             boolean foundBetter = false;             for (double dx = -1; dx <= 1; dx += 1) { // try all possible deltas                 for (double dy = -1; dy <= 1; dy += 1) {                     double x = centerX + delta * dx;                     double y = centerY + delta * dy;                     double distSum = getDistSum(x, y, positions);                     if (distSum < minDistSum) {                         minDistSum = distSum;                         centerX = x;                         centerY = y;                         foundBetter = true;                     }                 }             }             if (!foundBetter) {                 delta /= 2; // decrease the delta value             }         }         return minDistSum;     }          private double getDistSum(double x, double y, int[][] positions) {         double distSum = 0;         for (int[] pos : positions) {             distSum += getDist(x, y, pos[0], pos[1]);         }         return distSum;     }          private double getDist(double x1, double y1, double x2, double y2) {         return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));     } }",0,,0,0,0
"import java.util.*;  class Solution {     public List<String> maxNumOfSubstrings(String s) {         List<String> result = new ArrayList<>();         int[][] ranges = new int[26][2];         Arrays.fill(ranges, new int[] {s.length(), -1});         char[] arr = s.toCharArray();         for (int i = 0; i < arr.length; i++) {             int c = arr[i] - 'a';             ranges[c][0] = Math.min(ranges[c][0], i);             ranges[c][1] = Math.max(ranges[c][1], i);         }         List<int[]> list = new ArrayList<>();         for (int i = 0; i < 26; i++) {             int[] range = ranges[i];             if (range[0] != s.length()) {                 int left = range[0];                 int right = range[1];                 for (int j = left; j <= right; j++) {                     int[] cur = ranges[arr[j] - 'a'];                     left = Math.min(left, cur[0]);                     right = Math.max(right, cur[1]);                 }                 if (left == range[0]) {                     list.add(new int[] {left, right});                 }             }         }         list.sort((a, b) -> Integer.compare(a[1], b[1]));         int right = -1;         for (int[] range : list) {             if (range[0] > right) {                 result.add(s.substring(range[0], range[1] + 1));                 right = range[1];             }         }         return result;     } }",0,,0,0,0
"class Solution {     public int closestToTarget(int[] arr, int target) {         int minDiff = Integer.MAX_VALUE;         Set<Integer> currentSet = new HashSet<>();         for (int i = 0; i < arr.length; i++) {             Set<Integer> newSet = new HashSet<>();             newSet.add(arr[i]);             for (int x : currentSet) {                 newSet.add(arr[i] & x);             }             for (int x : newSet) {                 minDiff = Math.min(minDiff, Math.abs(x - target));             }             currentSet = newSet;         }         return minDiff;     } }",1,"1521-find-a-value-of-a-mysterious-function-closest-to-target/Solution.java:5:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
class Solution {     public int minNumberOperations(int[] target) {         int operationCount = target[0];         for (int i = 1; i < target.length; i++) {             if (target[i] > target[i-1]) {                 operationCount += target[i] - target[i-1];             }         }         return operationCount;     } },0,,0,0,0
"class Solution {     public int getLengthOfOptimalCompression(String s, int k) {         int n = s.length();         int[][] dp = new int[n + 1][k + 1];         for (int i = n - 1; i >= 0; i--) {             for (int j = 0; j <= k; j++) {                 int delete = Math.min(j + 1, k + 1); // delete the current character                 dp[i][j] = dp[i + 1][delete - 1] + 1; // case 1: delete current character                 for (int end = i + 1; end <= n; end++) { // case 2: keep current character, and delete a group after it                     int count = count(s, i, end - 1);                     if (count > 1) {                         dp[i][j] = Math.min(dp[i][j], dp[end][j + end - i - count] + 2);                     } else {                         dp[i][j] = Math.min(dp[i][j], dp[end][j] + 1);                     }                 }             }         }         return dp[0][0];     }      private int count(String s, int start, int end) {         int count = 1;         for (int i = start + 1; i <= end; i++) {             if (s.charAt(i) == s.charAt(i - 1)) {                 count++;             }         }         return count;     } }",0,,0,0,0
"class Solution {     public int maxSum(int[] nums1, int[] nums2) {         int i = 0, j = 0;         long sum1 = 0, sum2 = 0, res = 0;         int mod = 1000000007;                  while (i < nums1.length && j < nums2.length) {             if (nums1[i] < nums2[j]) {                 sum1 += nums1[i++];             } else if (nums1[i] > nums2[j]) {                 sum2 += nums2[j++];             } else { // current element is common                 res = (res + Math.max(sum1, sum2) + nums1[i])%mod; // select the greater sum and add the common element                 sum1 = 0; sum2 = 0; // reset sum from both arrays as we are starting a new path                 i++; j++;             }         }                  while (i < nums1.length) sum1 += nums1[i++]; // process remaining elements in nums1                  while (j < nums2.length) sum2 += nums2[j++]; // process remaining elements in nums2                  res = (res + Math.max(sum1, sum2))%mod; // add the max sum from the last path                  return (int) res; // return the result as integer     } }",1,"1537-get-the-maximum-score/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1537-get-the-maximum-score/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int findMin(int[] nums) {         int left=0, right= nums.length-1;         while(left<right)         {             int mid=(left+right)/2;             if(nums[mid]>nums[right])             {                 left=mid+1;             }             else if(nums[mid]<nums[right])             {                 right=mid;             }             else              {                 right--;             }         }          return nums[left];     } }",1,"154-find-minimum-in-rotated-sorted-array-ii/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
154-find-minimum-in-rotated-sorted-array-ii/Solution.java:5:9: '{' at column 9 should be on the previous line. [LeftCurly]
154-find-minimum-in-rotated-sorted-array-ii/Solution.java:8:13: '{' at column 13 should be on the previous line. [LeftCurly]
154-find-minimum-in-rotated-sorted-array-ii/Solution.java:10:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
154-find-minimum-in-rotated-sorted-array-ii/Solution.java:12:13: '{' at column 13 should be on the previous line. [LeftCurly]
154-find-minimum-in-rotated-sorted-array-ii/Solution.java:14:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
154-find-minimum-in-rotated-sorted-array-ii/Solution.java:16:13: '{' at column 13 should be on the previous line. [LeftCurly]
",1,0,0
"class Solution {     public int longestAwesome(String s) {         int n = s.length(), mask = 0, res = 1;         int[] dp = new int[1024]; // since input consists only of digits, we can use bit mask of maximum length 10         Arrays.fill(dp, n); // all values in dp set to maximum possible length                  dp[0] = -1;         for (int i = 0; i < n; i++) {             // flipping the bit corresponding to the current digit             mask ^= 1 << (s.charAt(i) - '0');                          // considering the case where the whole string s[0:i] forms the awesome substring             res = Math.max(res, i - dp[mask]);                          // considering the cases where substrings s[0:j] and s[0:i] (where j<i) form the awesome substring             for (int j = 0; j < 10; j++) {                 res = Math.max(res, i - dp[mask ^ (1 << j)]);             }             dp[mask] = Math.min(dp[mask], i);         }         return res;     } }",1,"1542-find-longest-awesome-substring/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int minCost(int n, int[] cuts) {         // Adding 0 and n to cuts         int[] nums = new int[cuts.length + 2];         nums[0] = 0;         nums[nums.length - 1] = n;         for (int i = 0; i < cuts.length; i++) {             nums[i + 1] = cuts[i];         }          // Sorting the cuts         Arrays.sort(nums);          // Initialization         int[][] dp = new int[nums.length][nums.length];          // Calculating minimum cost         for (int gap = 2; gap < nums.length; gap++) {             for (int left = 0; left < nums.length - gap; left++) {                 int right = left + gap;                 dp[left][right] = Integer.MAX_VALUE;                  for (int k = left + 1; k < right; k++) {                     dp[left][right] = Math.min(dp[left][right], dp[left][k] + dp[k][right] + nums[right] - nums[left]);                 }             }         }         return dp[0][nums.length - 1];     } }",1,"1547-minimum-cost-to-cut-a-stick/Solution.java:7:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
",0,0,0
"class Solution {     public int minDays(int n) {         Map<Integer, Integer> memo = new HashMap<>();         return dfs(n, memo);     }          private int dfs(int n, Map<Integer, Integer> memo){         if(n <= 1)             return n;                  if(memo.containsKey(n))             return memo.get(n);          int res = n;         if(n%2 == 0)             res = Math.min(res, 1+dfs(n/2, memo));         if(n%3 == 0)             res = Math.min(res, 1+dfs(2*(n/3), memo));                  memo.put(n, res);         return res;     } }",0,,0,0,0
"class Solution {     int[] cache;     public int stoneGameV(int[] stoneValue) {         int n = stoneValue.length;         cache = new int[n];         Arrays.fill(cache, -1);         return dfs(stoneValue, 0, n - 1);     }          private int dfs(int[] stoneValue, int start, int end) {          if (start == end) {             return 0;         }         if (cache[start] != -1) {             return cache[start];         }         int res = 0;         int leftSum = 0, rightSum = 0;         for (int i = start; i < end; i++) {             if (leftSum <= rightSum) {                 leftSum += stoneValue[i];                 res = Math.max(res, leftSum + dfs(stoneValue, start, i));             } else {                 rightSum += stoneValue[i];                 res = Math.max(res, rightSum + dfs(stoneValue, i + 1, end));             }         }         cache[start] = res;         return res;     } }",1,"1563-stone-game-v/Solution.java:2:11: Variable 'cache' must be private and have accessor methods. [VisibilityModifier]
1563-stone-game-v/Solution.java:18:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     int m, n;     int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};          public int minDays(int[][] grid) {         m = grid.length;         n = grid[0].length;                  if (!isConnected(grid)) return 0;                  for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 if (grid[i][j] == 0) continue;                                  grid[i][j] = 0;                 if (!isConnected(grid)) return 1;                                  grid[i][j] = 1;             }         }         return 2;     }          private boolean isConnected(int[][] grid) {         int count = 0;         boolean[][] visited = new boolean[m][n];                  for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 if (grid[i][j] == 0 || visited[i][j]) continue;                                  count++;                 if (count > 1) return false;                                  dfs(grid, visited, i, j);             }         }         return count == 1;     }          private void dfs(int[][] grid, boolean[][] visited, int x, int y) {         visited[x][y] = true;         for (int[] d : dir) {             int nx = x + d[0];             int ny = y + d[1];                          if (nx < 0 || ny < 0 || nx >= m || ny >= n || grid[nx][ny] == 0 || visited[nx][ny]) continue;                          dfs(grid, visited, nx, ny);         }     } }",1,"1568-minimum-number-of-days-to-disconnect-island/Solution.java:2:5: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1568-minimum-number-of-days-to-disconnect-island/Solution.java:2:9: Variable 'm' must be private and have accessor methods. [VisibilityModifier]
1568-minimum-number-of-days-to-disconnect-island/Solution.java:2:12: Variable 'n' must be private and have accessor methods. [VisibilityModifier]
1568-minimum-number-of-days-to-disconnect-island/Solution.java:3:13: Variable 'dir' must be private and have accessor methods. [VisibilityModifier]
",1,0,0
"class Solution {     public int numOfWays(int[] nums) {         int N = nums.length;         long[][] dp = new long[N+1][N+1];         for (int i = 0; i <= N; i++) {             dp[i][0] = 1;         }         for (int i = 1; i <= N; i++) {             for (int j = 1; j <= i; j++) {                 if (nums[i-1] > nums[j-1]) {                     dp[i][j] = dp[i-1][j-1] + dp[i-1][j];                 } else {                     dp[i][j] = dp[i-1][j-1];                 }             }         }         long ans1 = dfs(dp, N, N);         long ans2 = dfs(dp, N-1, N);         int MOD = 1000000007;         return (int) ((ans1 - ans2 + MOD) % MOD);     }          private long dfs(long[][] dp, int i, int j) {         if (i == 0 || j == 0) {             return 1;         }         if (i < j) {             return 0;         }         return dfs(dp, i-1, j) * dp[i-1][j] + dfs(dp, i-1, j-1) * dp[i-1][j-1];     } }",0,,0,0,0
"class Solution {     public int countRoutes(int[] locations, int start, int finish, int fuel) {         int MOD = 1000000007;         int n = locations.length;         int[][] dp = new int[n][fuel+1];         for(int i=0;i<n;i++){             Arrays.fill(dp[i],-1);         }                  return dfs(start,finish,fuel,locations,dp,MOD);     }          public int dfs(int cur,int finish,int fuel,int[] locations,int[][] dp,int MOD){         if(fuel<0){             return 0;         }         if(dp[cur][fuel]!=-1){             return dp[cur][fuel];         }         int ways = 0;         if(cur==finish){             ways = 1;         }         for(int i=0;i<locations.length;i++){             if(i != cur){                 int dist = Math.abs(locations[cur]-locations[i]);                 ways = (ways+dfs(i,finish,fuel-dist,locations,dp,MOD))%MOD;             }         }         return dp[cur][fuel] = ways;     } }",1,"1575-count-all-possible-routes/Solution.java:30:30: Inner assignments should be avoided. [InnerAssignment]
",0,0,0
"class Solution {     public int maxNumEdgesToRemove(int n, int[][] edges) {         // Create union find data structure for type 1 and type 2 edges         UnionFind uf1 = new UnionFind(n);         UnionFind uf2 = new UnionFind(n);                  // Add edges which can be traversed by both Alice and Bob         int count = 0;         for(int[] edge : edges) {             if(edge[0] == 3) {                 if(uf1.union(edge[1]-1, edge[2]-1)) {                     uf2.union(edge[1]-1, edge[2]-1);                     count++;                 }             }         }                  // Add edges which can be traversed by Alice only         for(int[] edge : edges) {             if(edge[0] == 1) {                 if(!uf1.union(edge[1]-1, edge[2]-1)) {                     return -1;                 }                 count++;             }         }                  // Add edges which can be traversed by Bob only         for(int[] edge : edges) {             if(edge[0] == 2) {                 if(!uf2.union(edge[1]-1, edge[2]-1)) {                     return -1;                 }                 count++;             }         }                  // Check if any node is not connected after removing edges         if(uf1.count != 1 || uf2.count != 1) {             return -1;         }                  return edges.length - count;     }          class UnionFind {         int[] parent;         int count;                  public UnionFind(int n) {             parent = new int[n];             for(int i=0; i<n; i++) {                 parent[i] = i;             }             count = n;         }                  public int find(int x) {             if(parent[x] != x) {                 parent[x] = find(parent[x]);             }             return parent[x];         }                  public boolean union(int x, int y) {             int rootX = find(x);             int rootY = find(y);                          if(rootX == rootY) {                 return false;             }                          parent[rootX] = rootY;             count--;             return true;         }     } }",1,"1579-remove-max-number-of-edges-to-keep-graph-fully-traversable/Solution.java:47:15: Variable 'parent' must be private and have accessor methods. [VisibilityModifier]
1579-remove-max-number-of-edges-to-keep-graph-fully-traversable/Solution.java:48:13: Variable 'count' must be private and have accessor methods. [VisibilityModifier]
1579-remove-max-number-of-edges-to-keep-graph-fully-traversable/Solution.java:50:9: Redundant 'public' modifier. [RedundantModifier]
1579-remove-max-number-of-edges-to-keep-graph-fully-traversable/Solution.java:11:	CollapsibleIfStatements:	This if statement could be combined with its parent
",0,0,0
"class Solution {     public boolean isTransformable(String s, String t) {         int n = s.length();         int[] sPos = new int[10], tPos = new int[10];         // Initialize positions of digits in s and t         for (int i = 0; i < n; i++) {             sPos[s.charAt(i) - '0'] = i;             tPos[t.charAt(i) - '0'] = i;         }         // Check if s can be transformed into t         for (int digit = 0; digit < 10; digit++) {             int sIndex = sPos[digit], tIndex = tPos[digit];             // Check if digit appears in s and t             if (sIndex == 0 && tIndex != 0) {                 return false;             }             // Check if sorting was necessary to move digit in s             for (int i = 0; i < digit; i++) {                 int sortedIndex = sPos[i];                 if (sortedIndex < sIndex && sortedIndex >= 1 && s.charAt(sortedIndex - 1) <= digit) {                     return false;                 }             }         }         return true;     } }",1,"1585-check-if-string-is-transformable-with-substring-sort-operations/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1585-check-if-string-is-transformable-with-substring-sort-operations/Solution.java:12:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public boolean isPrintable(int[][] targetGrid) {         int n = targetGrid.length;         int m = targetGrid[0].length;                  int[][] pairs = new int[61][4];         for(int i=0; i<61; i++) Arrays.fill(pairs[i], Integer.MAX_VALUE);                  for(int i=0;i<n;i++) {             for(int j=0; j<m; j++) {                 int color = targetGrid[i][j];                 // Updating bounds for the color                 pairs[color][0] = Math.min(pairs[color][0], i);                 pairs[color][1] = Math.min(pairs[color][1], j);                 pairs[color][2] = Math.max(pairs[color][2], i);                 pairs[color][3] = Math.max(pairs[color][3], j);             }         }         return canPaint(targetGrid, pairs, 1, 60);     }          public boolean canPaint(int[][] grid, int[][] pairs, int color, int maxColor) {         // Base case: we have already painted all colors         if(color > maxColor) return true;                  while(!isDone(grid, pairs, color)) {             int rows = grid.length;             int cols = grid[0].length;             int top = pairs[color][0];             int left = pairs[color][1];             int bottom = pairs[color][2];             int right = pairs[color][3];              // Fill the color in the square until the last position where there is the same color everywhere             for(int i=top; i<=bottom; i++) {                 for(int j=left; j<=right; j++) {                     if(grid[i][j]!=color) continue;                     boolean canFill = true;                                          for(int k=top;k<=bottom;k++) {                         for(int l=left;l<=right;l++) {                             if(grid[k][l]==0 || grid[k][l]==color || grid[k][l] > maxColor || pairs[grid[k][l]][0] > top || pairs[grid[k][l]][1] > left || pairs[grid[k][l]][2] < bottom || pairs[grid[k][l]][3] < right){                                 continue;                             }                             canFill = false;                             break;                         }                         if(!canFill) break;                     }                     if(canFill) {                         grid[i][j] = 0;                         pairs[color][0] = Math.min(pairs[color][0], i);                         pairs[color][1] = Math.min(pairs[color][1], j);                         pairs[color][2] = Math.max(pairs[color][2], i);                         pairs[color][3] = Math.max(pairs[color][3], j);                     }                 }             }         }         // Check if we can paint the next color         return canPaint(grid, pairs, color+1, maxColor);     }          public boolean isDone(int[][] grid, int[][] pairs, int color) {         int top = pairs[color][0];         int left = pairs[color][1];         int bottom = pairs[color][2];         int right = pairs[color][3];                  for(int i=top;i<=bottom;i++) {             for(int j=left;j<=right;j++) {                 if(grid[i][j]!=color) return false;             }         }         return true;     } }",1,"1591-strange-printer-ii/Solution.java:27:	UnusedLocalVariable:	Avoid unused local variables such as 'rows'.
1591-strange-printer-ii/Solution.java:28:	UnusedLocalVariable:	Avoid unused local variables such as 'cols'.
1591-strange-printer-ii/Solution.java:46:	AvoidBranchingStatementAsLastInLoop:	Avoid using a branching statement as the last in a loop.
",0,0,0
"class Solution {     public int connectTwoGroups(List<List<Integer>> cost) {         int size1 = cost.size(), size2 = cost.get(0).size();         // dp[i][mask]: minimum cost to cover ith point of group1 and subset of points in group2 represented by mask         int[][] dp = new int[size1][1 << size2];         // Initialize dp with -1         for (int[] row : dp) {             Arrays.fill(row, -1);         }         // Initialize dp[0] with cost to connect first point of group1 with all points of group2         for (int i = 0; i < size2; i++) {             int mask = 1 << i;             dp[0][mask] = cost.get(0).get(i);         }         // Build dp array         for (int i = 1; i < size1; i++) {             for (int mask = 1; mask < (1 << size2); mask++) {                 int minCost = Integer.MAX_VALUE;                 // Calculate cost to connect ith point of group1 with each point j in the group2 subset represented by mask                 for (int j = 0; j < size2; j++) {                     if ((mask & (1 << j)) != 0) {                         int group2Subset = mask ^ (1 << j);                         int costToConnect = cost.get(i).get(j);                         int costWithSubset = dp[i - 1][group2Subset];                         int totalCost = costToConnect + costWithSubset;                         minCost = Math.min(minCost, totalCost);                     }                 }                 // Calculate cost to connect ith point of group1 with all points in group2 subset represented by mask                 dp[i][mask] = minCost;                 // Calculate cost to connect each point in group1 subset with group2 subset represented by mask                 for (int k = i - 1; k >= 0; k--) {                     int group1Subset = (1 << (i - k)) - 1;                     int costWithSubset = dp[k][mask];                     int totalCost = costWithSubset + dp[i][group1Subset];                     minCost = Math.min(minCost, totalCost);                 }                 // Update dp[i][mask] with minimum cost                 dp[i][mask] = Math.min(dp[i][mask], minCost);             }         }         // Return minimum cost to connect all points in both groups         return dp[size1 - 1][(1 << size2) - 1];     } }",1,"1595-minimum-cost-to-connect-two-groups-of-points/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int maximumRequests(int n, int[][] requests) {         // Initialize an array to keep track of the employees in each building         int[] employees = new int[n];                  // Initialize a variable to keep track of the maximum number of achievable requests         int maxRequests = 0;                  // Use a recursive helper function to generate all possible combinations of request assignments         backtrack(requests, employees, 0, 0, maxRequests);                  return maxRequests;     }          private void backtrack(int[][] requests, int[] employees, int index, int currRequests, int maxRequests) {         // If all requests have been considered, check if the assignment is valid and update the maxRequests variable if necessary         if (index == requests.length) {             for (int i = 0; i < employees.length; i++) {                 if (employees[i] != 0) {                     return;                 }             }             maxRequests = Math.max(maxRequests, currRequests);             return;         }                  // Consider assigning the current request         employees[requests[index][0]]--;         employees[requests[index][1]]++;         backtrack(requests, employees, index+1, currRequests+1, maxRequests);                  // Consider not assigning the current request         employees[requests[index][0]]++;         employees[requests[index][1]]--;         backtrack(requests, employees, index+1, currRequests, maxRequests);     } }",1,"1601-maximum-number-of-achievable-transfer-requests/Solution.java:18:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
1601-maximum-number-of-achievable-transfer-requests/Solution.java:23:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'maxRequests'
1601-maximum-number-of-achievable-transfer-requests/Solution.java:23:	UnusedAssignment:	The value assigned to variable 'maxRequests' is never used
",0,1,1
"class Solution {     public List<Integer> busiestServers(int k, int[] arrival, int[] load) {         int[] requestsHandled = new int[k]; // to keep track of the number of requests handled by each server         PriorityQueue<Integer> availableServers = new PriorityQueue<>(); // to keep track of available servers                  for(int i=0; i<k; i++){             availableServers.offer(i); // add all servers to the available servers list         }                  TreeMap<Integer, Integer> requestCompletionTimes = new TreeMap<>(); // to keep track of the completion times of requests                  for(int i=0; i<arrival.length; i++){             int arrivalTime = arrival[i];             int requestLoad = load[i];                          while(!requestCompletionTimes.isEmpty() && requestCompletionTimes.firstKey()<=arrivalTime){ // check if any requests have been completed                 int serverId = requestCompletionTimes.remove(requestCompletionTimes.firstKey()); // get the server that has completed the request                 availableServers.offer(serverId); // add the server to the list of available servers             }                          if(availableServers.isEmpty()){ // if there are no available servers                 continue; // skip this request             }                          int assignedServerId = (i%k); // get the server assigned according to the algorithm             if(!availableServers.contains(assignedServerId)){ // if the assigned server is not available                 assignedServerId = availableServers.poll(); // assign the request to the next available server             }                          requestsHandled[assignedServerId]++; // increment the count of requests handled by the assigned server             requestCompletionTimes.put(arrivalTime+requestLoad, assignedServerId); // add the completion time of the request         }                  List<Integer> busiestServers = new ArrayList<>();         int maxRequestsHandled = 0;         for(int i=0; i<k; i++){             if(requestsHandled[i] > maxRequestsHandled){                 maxRequestsHandled = requestsHandled[i];                 busiestServers.clear();                 busiestServers.add(i);             } else if(requestsHandled[i] == maxRequestsHandled){                 busiestServers.add(i);             }                }                  return busiestServers;     } }",1,"1606-find-servers-that-handled-most-number-of-requests/Solution.java:25:	UselessParentheses:	Useless parentheses.
",0,0,0
"import java.util.*;  class Solution {     public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {         int n = points.size();         double[] angles = new double [2 * n];         int idx = 0, maxPoints = 0;         for (List<Integer> point : points) {             int x = point.get(0) - location.get(0);             int y = point.get(1) - location.get(1);             if (x == 0 && y == 0) {                 maxPoints++;                 continue;             }             angles[idx++] = Math.atan2(y, x) * 180 / Math.PI;         }         Arrays.sort(angles, 0, idx);         double[] tmp = new double [angles.length * 2];         for (int i = 0; i < idx; i++) {             tmp[i] = angles[i] + 360;         }         for (int i = 0; i < idx; i++) {             tmp[i + idx] = angles[i];         }         int l = 0, r = 0;         while (r < tmp.length) {             while (tmp[r] - tmp[l] > angle) {                 l++;             }             maxPoints = Math.max(maxPoints, r - l + 1);             r++;         }         return maxPoints;     } }",1,"1610-maximum-number-of-visible-points/Solution.java:7:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1610-maximum-number-of-visible-points/Solution.java:25:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1610-maximum-number-of-visible-points/Solution.java:22:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
",1,0,0
class Solution {     public int minimumOneBitOperations(int n) {         int ans = 0;         while (n > 0) {             ans ^= n;             n >>= 1;         }         return ans;     } },1,"1611-minimum-one-bit-operations-to-make-integers-zero/Solution.java:6:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
",0,1,0
"class Solution {     public int[] countSubgraphsForEachDiameter(int n, int[][] edges) {         // Initialize adjacency matrix         int[][] adj = new int[n][n];         for(int i=0; i<n-1; i++) {             int u = edges[i][0] - 1;             int v = edges[i][1] - 1;             adj[u][v] = 1;             adj[v][u] = 1;         }         // Compute All Pair Shortest Path         int[][] dist = new int[n][n];         for(int i=0; i<n; i++) {             for(int j=0; j<n; j++) {                 if(i == j) {                     dist[i][j] = 0;                 } else if(adj[i][j] == 1) {                     dist[i][j] = 1;                 } else {                     dist[i][j] = n;                 }             }         }         for(int k=0; k<n; k++) {             for(int i=0; i<n; i++) {                 for(int j=0; j<n; j++) {                     dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);                 }             }         }         // Compute subtree count for each diameter          int[] res = new int[n-1];         for(int mask=1; mask<(1<<n); mask++) {             int count = Integer.bitCount(mask);             if(count < 2) {                 continue;             }             int leaves = count - 1;             boolean[] isLeaf = new boolean[n];             for(int i=0; i<n; i++) {                 if(((1<<i) & mask) != 0) {                     boolean leaf = true;                     for(int j=0; j<n; j++) {                         if(j != i && ((1<<j) & mask) != 0 && adj[i][j] == 1) {                             leaf = false;                             break;                         }                     }                     isLeaf[i] = leaf;                     if(!leaf) {                         leaves--;                     }                 }             }             if(leaves > 1) {                 continue;             }             int[] nodes = new int[count];             int index = 0;             for(int i=0; i<n; i++) {                 if(((1<<i) & mask) != 0) {                     nodes[index] = i;                     index++;                 }             }             int diameter = 0;             for(int i=0; i<count; i++) {                 for(int j=i+1; j<count; j++) {                     diameter = Math.max(diameter, dist[nodes[i]][nodes[j]]);                 }             }             if(diameter > 0) {                 res[diameter-1]++;             }         }         return res;     } }",1,"1617-count-subtrees-with-max-distance-between-cities/Solution.java:2:	NPathComplexity:	The method 'countSubgraphsForEachDiameter(int, int[][])' has an NPath complexity of 34600, current threshold is 200
1617-count-subtrees-with-max-distance-between-cities/Solution.java:39:	LinguisticNaming:	Linguistics Antipattern - The variable 'isLeaf' indicates linguistically it is a boolean, but it is 'boolean[]'
",0,0,0
"class Fancy {     List<Integer> nums;     int mul, add;     final int MOD = 1000000007;      public Fancy() {         nums = new ArrayList<>();         mul = 1;         add = 0;     }      public void append(int val) {         nums.add((val - add + MOD) % MOD * qmi(mul, MOD - 2) % MOD);     }      public void addAll(int inc) {         add = (add + inc) % MOD;     }      public void multAll(int m) {         mul = mul * m % MOD;         add = add * m % MOD;     }      public int getIndex(int idx) {         if (idx >= nums.size())             return -1;         return (int) ((long) nums.get(idx) * mul % MOD + add);     }      private int qmi(int a, int b) {         int res = 1 % MOD;         a %= MOD;         while (b > 0) {             if ((b & 1) == 1)                 res = res * a % MOD;             a = a * a % MOD;             b >>= 1;         }         return res;     } }  /**  * Your Fancy object will be instantiated and called as such:  * Fancy obj = new Fancy();  * obj.append(val);  * obj.addAll(inc);  * obj.multAll(m);  * int param_4 = obj.getIndex(idx);  */",1,"1622-fancy-sequence/Fancy.java:2:19: Variable 'nums' must be private and have accessor methods. [VisibilityModifier]
1622-fancy-sequence/Fancy.java:3:5: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1622-fancy-sequence/Fancy.java:3:9: Variable 'mul' must be private and have accessor methods. [VisibilityModifier]
1622-fancy-sequence/Fancy.java:3:14: Variable 'add' must be private and have accessor methods. [VisibilityModifier]
1622-fancy-sequence/Fancy.java:4:15: Variable 'MOD' must be private and have accessor methods. [VisibilityModifier]
1622-fancy-sequence/Fancy.java:6:5: Redundant 'public' modifier. [RedundantModifier]
1622-fancy-sequence/Fancy.java:4:	FinalFieldCouldBeStatic:	This final field could be made static
1622-fancy-sequence/Fancy.java:33:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'a'
1622-fancy-sequence/Fancy.java:38:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'b'
",1,1,0
"import java.util.*;  class Solution {     public List<Boolean> areConnected(int n, int threshold, int[][] queries) {         List<Boolean> answer = new ArrayList<Boolean>();         int[] parent = new int[n+1];          for(int i=1; i<=n; i++){             parent[i]=i;         }          for(int i=threshold+1;i<=n;i++){             for(int j=2;i*j<=n;j++){                 union(parent,i,i*j);             }         }          for(int[] query:queries){             if(find(parent,query[0])==find(parent,query[1])){                 answer.add(true);             }             else{                 answer.add(false);             }         }         return answer;     }      public int find(int[] parent,int node){         if(parent[node]!=node){             parent[node]=find(parent,parent[node]);         }         return parent[node];     }      public void union(int[] parent,int node1, int node2){         parent[find(parent,node1)]=find(parent,node2);     }  }",1,"1627-graph-connectivity-with-threshold/Solution.java:21:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
1627-graph-connectivity-with-threshold/Solution.java:5:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new ArrayList<>()`
",0,0,0
"class Solution {     public int[][] matrixRankTransform(int[][] matrix) {         int m = matrix.length;         int n = matrix[0].length;         int[][] answer = new int[m][n];         Map<Integer, List<int[]>> map = new TreeMap<>(); // TreeMap ensures that keys are sorted automatically         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 int[] cell = {i, j};                 List<int[]> list = map.getOrDefault(matrix[i][j], new ArrayList<>());                 list.add(cell);                 map.put(matrix[i][j], list); // group cells with the same value together             }         }         int[] rowRank = new int[m];         int[] colRank = new int[n];         for (int value : map.keySet()) {             List<int[]> cells = map.get(value);             int[][] submatrix = new int[cells.size()][2];             int i = 0;             for (int[] cell : cells) {                 submatrix[i++] = cell;             }             int rank = 0;             int[] rankList = new int[cells.size()]; // keep track of rank for each cell in the submatrix             for (int j = 0; j < submatrix.length; j++) {                 int r = submatrix[j][0];                 int c = submatrix[j][1];                 rank = Math.max(rank, Math.max(rowRank[r], colRank[c])); // find the highest rank in the same row or column             }             rank++; // increment the rank             for (int j = 0; j < submatrix.length; j++) {                 int r = submatrix[j][0];                 int c = submatrix[j][1];                 answer[r][c] = rank; // set the rank for the cell                 rowRank[r] = rank; // save the rank for the row                 colRank[c] = rank; // save the rank for the column             }         }         return answer;     } }",1,"1632-rank-transform-of-a-matrix/Solution.java:25:	UnusedLocalVariable:	Avoid unused local variables such as 'rankList'.
1632-rank-transform-of-a-matrix/Solution.java:26:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
1632-rank-transform-of-a-matrix/Solution.java:32:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public static int numWays(String[] words, String target) {         int l = words[0].length();         int n = words.length;         int[][] count = new int[l][26];         for (int i = 0; i < l; i++) {             for (int j = 0; j < n; j++) {                 count[i][words[j].charAt(i) - 'a']++;             }         }         return dfs(count, target.toCharArray(), 0, 0, new Integer[l][target.length()]);     }          private static final int MOD = 1000000007;          private static int dfs(int[][] count, char[] target, int t, int w, Integer[][] dp) {         if (t == target.length) {             return 1;         }         if (dp[w][t] != null) {             return dp[w][t];         }         long res = 0;         for (int i = w; i < count.length; i++) {             res += count[i][target[t] - 'a'] * dfs(count, target, t + 1, i + 1, dp);             res %= MOD;         }         dp[w][t] = (int)res;         return dp[w][t];     } }",1,"1639-number-of-ways-to-form-a-target-string-given-a-dictionary/Solution.java:1:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
1639-number-of-ways-to-form-a-target-string-given-a-dictionary/Solution.java:1:	UseUtilityClass:	This utility class has a non-private constructor
1639-number-of-ways-to-form-a-target-string-given-a-dictionary/Solution.java:14:	FieldDeclarationsShouldBeAtStartOfClass:	Fields should be declared at the top of the class, before any method declarations, constructors, initializers or inner classes.
",0,0,0
"class Solution {     public int maximumGap(int[] nums) {         int len = nums.length;         if (len < 2) {             return 0;         }         int maxNum = nums[0], minNum = nums[0];         for (int num : nums) {             maxNum = Math.max(maxNum, num);             minNum = Math.min(minNum, num);         }         int bucketSize = Math.max((maxNum - minNum) / (len - 1), 1);         int bucketNum = (maxNum - minNum) / bucketSize + 1;         int[] bucketMax = new int[bucketNum];         int[] bucketMin = new int[bucketNum];         Arrays.fill(bucketMax, Integer.MIN_VALUE);         Arrays.fill(bucketMin, Integer.MAX_VALUE);         for (int num : nums) {             int bucketIdx = (num - minNum) / bucketSize;             bucketMax[bucketIdx] = Math.max(bucketMax[bucketIdx], num);             bucketMin[bucketIdx] = Math.min(bucketMin[bucketIdx], num);         }         int prevMax = minNum, maxGap = 0;         for (int i = 0; i < bucketNum; i++) {             if (bucketMax[i] == Integer.MIN_VALUE && bucketMin[i] == Integer.MAX_VALUE) {                 continue;             }             maxGap = Math.max(maxGap, bucketMin[i] - prevMax);             prevMax = bucketMax[i];         }         return maxGap;     } }",1,"164-maximum-gap/Solution.java:7:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
164-maximum-gap/Solution.java:23:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public String kthSmallestPath(int[] destination, int k) {         int rows = destination[0];         int cols = destination[1];                  int[][] dp = new int[rows+1][cols+1];         for(int i=0; i<=rows; i++) {             dp[i][0] = 1;         }         for(int j=0; j<=cols; j++) {             dp[0][j] = 1;         }                  for(int i=1; i<=rows; i++) {             for(int j=1; j<=cols; j++) {                 dp[i][j] = dp[i-1][j] + dp[i][j-1];             }         }                  StringBuilder sb = new StringBuilder();         int i=0, j=0;         while(i<rows && j<cols) {             if(dp[rows-i-1][cols-j]>k) {                 sb.append(""H"");                 j++;             } else {                 sb.append(""V"");                 k -= dp[rows-i-1][cols-j];                 i++;             }         }         while(i<rows) {             sb.append(""V"");             i++;         }         while(j<cols) {             sb.append(""H"");             j++;         }                  return sb.toString();     } }",1,"1643-kth-smallest-instructions/Solution.java:21:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1643-kth-smallest-instructions/Solution.java:24:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
1643-kth-smallest-instructions/Solution.java:27:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
1643-kth-smallest-instructions/Solution.java:28:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'k'
1643-kth-smallest-instructions/Solution.java:33:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
1643-kth-smallest-instructions/Solution.java:37:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
",1,1,0
"class Solution {     public int createSortedArray(int[] instructions) {         int MOD = 1000000007;         int n = instructions.length;         int[] bit = new int[100001];         int ans = 0;         for (int i = 0; i < n; i++) {             int leftCost = query(bit, instructions[i] - 1);             int rightCost = i - query(bit, instructions[i]);             ans = (ans + Math.min(leftCost, rightCost)) % MOD;             update(bit, instructions[i]);         }         return ans;     }      private void update(int[] bit, int index) {         for (int i = index; i < 100001; i += i & -i) {             bit[i]++;         }     }      private int query(int[] bit, int index) {         int sum = 0;         for (int i = index; i > 0; i -= i & -i) {             sum += bit[i];         }         return sum;     } }",0,,0,0,0
"class Solution {     public boolean canDistribute(int[] nums, int[] quantity) {         Map<Integer, Integer> freqMap = new HashMap<>();         //count frequency of each number in the nums array         for(int num : nums) {             freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);         }         List<Integer> freqList = new ArrayList<>(freqMap.values());         int[] freqArr = new int[freqList.size()];         //convert the frequency list to an array for easier manipulation         for(int i = 0; i < freqList.size(); i++) {             freqArr[i] = freqList.get(i);         }         Arrays.sort(quantity);         return dfs(freqArr, quantity, quantity.length - 1);     }          private boolean dfs(int[] freqArr, int[] quantity, int idx) {         if(idx < 0) {             return true;         }         Arrays.sort(freqArr);         for(int i = freqArr.length - 1; i >= 0; i--) {             if(freqArr[i] >= quantity[idx]) {                 freqArr[i] -= quantity[idx];                 if(dfs(freqArr, quantity, idx - 1)) {                     return true;                 }                 freqArr[i] += quantity[idx];             }         }         return false;     } }",0,,0,0,0
"class Solution {     public int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {         // generate all possible combinations of introverts and extroverts placement         int[][] bothPlacements = new int[introvertsCount + extrovertsCount][2];         int k = 0;         for (int i = 0; i < introvertsCount; i++) {             bothPlacements[k++] = new int[] {1, 120, -30};         }         for (int i = 0; i < extrovertsCount; i++) {             bothPlacements[k++] = new int[] {2, 40, 20};         }         List<int[]> allPlacements = new ArrayList<>();         dfs(0, bothPlacements, new int[m * n], allPlacements);                  // calculate happiness for each placement and return the maximum happiness         int maxHappiness = 0;         for (int[] placement : allPlacements) {             boolean[][] grid = new boolean[m][n];             int happiness = 0;             for (int i = 0; i < placement.length; i++) {                 int x = i / n;                 int y = i % n;                 if (placement[i] == 0) {                     continue;                 }                 happiness += bothPlacements[placement[i]-1][1];                 int neighborHappiness = 0;                 if (x > 0 && grid[x-1][y]) {                     neighborHappiness += bothPlacements[placement[i]-1][2];                     neighborHappiness += bothPlacements[placement[(x-1)*n+y]-1][2];                 }                 if (y > 0 && grid[x][y-1]) {                     neighborHappiness += bothPlacements[placement[i]-1][2];                     neighborHappiness += bothPlacements[placement[x*n+(y-1)]-1][2];                 }                 if (x < m-1 && grid[x+1][y]) {                     neighborHappiness += bothPlacements[placement[i]-1][2];                     neighborHappiness += bothPlacements[placement[(x+1)*n+y]-1][2];                 }                 if (y < n-1 && grid[x][y+1]) {                     neighborHappiness += bothPlacements[placement[i]-1][2];                     neighborHappiness += bothPlacements[placement[x*n+(y+1)]-1][2];                 }                 happiness += neighborHappiness;                 grid[x][y] = true;             }             maxHappiness = Math.max(maxHappiness, happiness);         }         return maxHappiness;     }          private void dfs(int pos, int[][] placements, int[] current, List<int[]> all) {         if (pos == current.length) {             all.add(current.clone());             return;         }         for (int i = 0; i < placements.length; i++) {             if (placements[i][0] == 0) {                 continue;             }             int[] copy = current.clone();             copy[pos] = i+1;             placements[i][0]--;             dfs(pos+1, placements, copy, all);             placements[i][0]++;         }     } }",1,"1659-maximize-grid-happiness/Solution.java:2:	NPathComplexity:	The method 'getMaxGridHappiness(int, int, int, int)' has an NPath complexity of 656, current threshold is 200
1659-maximize-grid-happiness/Solution.java:34:	UselessParentheses:	Useless parentheses.
1659-maximize-grid-happiness/Solution.java:42:	UselessParentheses:	Useless parentheses.
",0,0,0
"class Solution {     public int minimumEffort(int[][] tasks) {         int initialEnergy = 0;         int requiredEnergy = 0;                  // Sort the tasks in decreasing order of the difference between the actual and minimum effort         Arrays.sort(tasks, (a,b) -> (b[1]-b[0]) - (a[1]-a[0]));                  // Calculate the required initial energy         for(int i=0; i<tasks.length; i++){             requiredEnergy += tasks[i][0];             initialEnergy = Math.max(initialEnergy, requiredEnergy + tasks[i][1] - tasks[i][0]);         }                  return initialEnergy;     } }",1,"1665-minimum-initial-energy-to-finish-tasks/Solution.java:7:	UselessParentheses:	Useless parentheses.
1665-minimum-initial-energy-to-finish-tasks/Solution.java:10:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int minimumMountainRemovals(int[] nums) {                  int n = nums.length;         int result = 0;         int leftMax[] = new int[n];         int rightMax[] = new int[n];          // Calculate the left and right maximum heights         leftMax[0] = 0;         int max = 0;         for (int i = 1; i < n; i++) {             leftMax[i] = max = Math.max(max, nums[i - 1]);         }          rightMax[n - 1] = 0;         max = 0;         for (int i = n - 2; i >= 0; i--) {             rightMax[i] = max = Math.max(max, nums[i + 1]);         }          // Iterate through each element and find the height that should be removed          for (int i = 1; i < n - 1; i++) {             int heightToRemove = Math.min(leftMax[i], rightMax[i]) - nums[i];             if (heightToRemove > 0)                 result += heightToRemove;         }          return result;     } }",1,"1671-minimum-number-of-removals-to-make-mountain-array/Solution.java:6:20: Array brackets at illegal position. [ArrayTypeStyle]
1671-minimum-number-of-removals-to-make-mountain-array/Solution.java:7:21: Array brackets at illegal position. [ArrayTypeStyle]
1671-minimum-number-of-removals-to-make-mountain-array/Solution.java:13:30: Inner assignments should be avoided. [InnerAssignment]
1671-minimum-number-of-removals-to-make-mountain-array/Solution.java:19:31: Inner assignments should be avoided. [InnerAssignment]
",0,0,0
"class Solution {     public int minimumDeviation(int[] nums) {         PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> b-a);         int minDev = Integer.MAX_VALUE;         for(int num: nums) {             if(num % 2 == 0) {                 pq.add(num);             } else {                 pq.add(num * 2);             }         }         int max = pq.peek();         while(!pq.isEmpty()) {             int curr = pq.poll();             minDev = Math.min(minDev, max - curr);             if(curr % 2 == 0) {                 pq.add(curr / 2);                 max = Math.max(max, curr / 2);             } else {                 break;             }         }         return minDev;     } }",0,,0,0,0
"import java.util.Arrays;  class Solution {     public int minimumIncompatibility(int[] nums, int k) {         Arrays.sort(nums); // sort the array to make it easier to check for duplicates         int n = nums.length;         int subsetSize = n / k;         // edge cases         if (k == 1) return 0;         if (n % k != 0) return -1;          // dp state         int[][] dp = new int[n][1 << n];         for (int i = 0; i < n; i++) {             Arrays.fill(dp[i], -1);         }          // Base case of DP. If we have only one subset,         // then the incompatibility is zero.         for (int i = 0; i < n; i++) {             dp[i][1 << i] = 0;         }          // main DP loop         for (int mask = 0; mask < (1 << n); mask++) {             int cnt = Integer.bitCount(mask);             if (cnt % subsetSize != 0) {                 continue;             }             int[] set = getSet(nums, mask);             if (hasDuplicates(set)) {                 continue;             }             for (int i = 0; i < n; i++) {                 if ((mask & (1 << i)) != 0) {                     for (int j = 0; j < n; j++) {                         if ((mask & (1 << j)) == 0) {                             int newMask = mask | (1 << j);                             int index = Arrays.binarySearch(set, nums[j]);                             if (index < 0) index = -index - 1;                             if (dp[i][mask] != -1) {                                 int incompatibility = getIncompatibility(set, index);                                 if (dp[j][newMask] == -1 || dp[j][newMask] > dp[i][mask] + incompatibility) {                                     dp[j][newMask] = dp[i][mask] + incompatibility;                                 }                             }                         }                     }                 }             }         }          // find the smallest incompatibility         int ans = -1;         for (int i = 0; i < n; i++) {             if (dp[i][(1 << n) - 1] != -1) {                 if (ans == -1 || ans > dp[i][(1 << n) - 1]) {                     ans = dp[i][(1 << n) - 1];                 }             }         }         return ans;     }      // helper function to get a subset of nums with the elements     // represented by the bits in mask     private int[] getSet(int[] nums, int mask) {         int n = nums.length;         int[] set = new int[Integer.bitCount(mask)];         int index = 0;         for (int i = 0; i < n; i++) {             if ((mask & (1 << i)) != 0) {                 set[index++] = nums[i];             }         }         return set;     }      // helper function to check if set has duplicates     private boolean hasDuplicates(int[] set) {         int n = set.length;         for (int i = 1; i < n; i++) {             if (set[i - 1] == set[i]) {                 return true;             }         }         return false;     }      // helper function to get the incompatibility of a set     private int getIncompatibility(int[] set, int index) {         int n = set.length;         if (index == 0) {             return set[n - 1] - set[0];         }         if (index == n - 1) {             return set[n - 1] - set[0];         }         return set[index] - set[index - 1] + set[index + 1] - set[index];     } }",1,"1681-minimum-incompatibility/Solution.java:4:	NPathComplexity:	The method 'minimumIncompatibility(int[], int)' has an NPath complexity of 3920, current threshold is 200
1681-minimum-incompatibility/Solution.java:7:	PrematureDeclaration:	Declaration of 'subsetSize' can be moved closer to its usages
1681-minimum-incompatibility/Solution.java:40:	AvoidDeeplyNestedIfStmts:	Deeply nested if..then statements are hard to read
1681-minimum-incompatibility/Solution.java:41:	AvoidDeeplyNestedIfStmts:	Deeply nested if..then statements are hard to read
1681-minimum-incompatibility/Solution.java:57:	CollapsibleIfStatements:	This if statement could be combined with its parent
",0,0,0
"class Solution {     public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {                  int n = boxes.length;                  // Minimum number of trips to deliver all boxes         int trips = 0;                  // Calculate the minimum trips to deliver boxes         for(int i = 0, j = 0, sumWeight = 0, count = 0; i < n; i++) {                          // If port is not the same for consecutive boxes             if(i == 0 || boxes[i][0] != boxes[i-1][0]) {                                  trips++;             }                          // Add box weight and count             sumWeight += boxes[i][1];             count++;                          // If container limits are exceeded             while(sumWeight > maxWeight || count > maxBoxes || (j < i && sumWeight + boxes[j][1] > maxWeight)) {                                  sumWeight -= boxes[j][1];                 count--;                 j++;                                  // If last delivery and no more boxes remain to be picked                 if(boxes[j-1][0] != boxes[j][0] && count == maxBoxes - 1) {                                          sumWeight -= boxes[j][1];                     count--;                     j++;                 }             }                      }                  return trips;     } }",1,"1687-delivering-boxes-from-storage-to-ports/Solution.java:10:	ForLoopVariableCount:	Too many control variables in the for statement
",0,0,0
"class Solution {     public int maxHeight(int[][] cuboids) {         int n = cuboids.length;         for (int[] c : cuboids) {             Arrays.sort(c);         }         Arrays.sort(cuboids, (a, b) -> {             if (a[0] != b[0]) {                 return Integer.compare(a[0], b[0]);             }             if (a[1] != b[1]) {                 return Integer.compare(a[1], b[1]);             }             return Integer.compare(a[2], b[2]);         });         int[] dp = new int[n];         for (int i = 0; i < n; i++) {             dp[i] = cuboids[i][2];         }         int ans = dp[0];         for (int i = 1; i < n; i++) {             int h = 0;             for (int j = 0; j < i; j++) {                 if (cuboids[i][0] >= cuboids[j][0] && cuboids[i][1] >= cuboids[j][1]                         && cuboids[i][2] >= cuboids[j][2]) {                     h = Math.max(h, dp[j]);                 }             }             dp[i] += h;             ans = Math.max(ans, dp[i]);         }         return ans;     } }",0,,0,0,0
"class Solution {     public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {         // Sort the edges by their weight         Arrays.sort(edgeList, Comparator.comparingInt(a -> a[2]));                  // Initialize parent array for union-find algorithm         int[] parent = new int[n];         for (int i = 0; i < n; i++) {             parent[i] = i;         }                  boolean[] result = new boolean[queries.length];         int index = 0;                  // Sort the queries by their limit         int[][] sortedQueries = new int[queries.length][4];         for (int i = 0; i < queries.length; i++) {             sortedQueries[i][0] = queries[i][0];             sortedQueries[i][1] = queries[i][1];             sortedQueries[i][2] = queries[i][2];             sortedQueries[i][3] = i;         }         Arrays.sort(sortedQueries, Comparator.comparingInt(a -> a[2]));                  for (int[] query : sortedQueries) {             int p = query[0];             int q = query[1];             int limit = query[2];             int queryIndex = query[3];                          // Remove edges greater than the current limit             while (index < edgeList.length && edgeList[index][2] < limit) {                 int u = edgeList[index][0];                 int v = edgeList[index][1];                 union(parent, u, v);                 index++;             }                          // Check if p and q are connected             result[queryIndex] = find(parent, p) == find(parent, q);         }                  return result;     }          public int find(int[] parent, int u) {         while (parent[u] != u) {             parent[u] = parent[parent[u]];             u = parent[u];         }         return u;     }          public void union(int[] parent, int u, int v) {         int rootU = find(parent, u);         int rootV = find(parent, v);         parent[rootU] = rootV;     } }",1,"1697-checking-existence-of-edge-length-limited-paths/Solution.java:49:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'u'
",0,1,0
"class Solution {     public int minMoves(int[] nums, int k) {         List<Integer> onesIndex = new ArrayList<>();         for (int i = 0; i < nums.length; i++) {             if (nums[i] == 1) {                 onesIndex.add(i);             }         }         int onesCount = onesIndex.size();         int[] prefix = new int[onesCount + 1];         for (int i = 1; i <= onesCount; i++) {             prefix[i] = prefix[i-1] + onesIndex.get(i-1);         }         int medianIndex = k / 2;         int targetLength = k % 2 == 0 ? 2 * prefix[medianIndex] - medianIndex : 2 * prefix[medianIndex + 1] - (medianIndex + 1) - onesIndex.get(medianIndex);         int minMoves = Integer.MAX_VALUE;         for (int i = 0; i + k - 1 < onesCount; i++) {             int leftIndex = i;             int rightIndex = i + k - 1;             int leftMidIndex = leftIndex + k / 2;             int rightMidIndex = rightIndex - k / 2;             int leftSum = prefix[leftMidIndex] - prefix[leftIndex];             int rightSum = prefix[rightIndex] - prefix[rightMidIndex];             int moves = targetLength - (rightSum - leftSum);             minMoves = Math.min(minMoves, moves);         }         return minMoves;     } }",0,,0,0,0
"class Solution {     public int[] maximizeXor(int[] nums, int[][] queries) {         int[] res = new int[queries.length];         int i = 0;         TrieNode root = new TrieNode();         for (int x : nums) {             TrieNode curr = root;             for (int k = 31; k >= 0; k--) {                 int b = (x >> k) & 1;                 if (curr.children[b] == null) {                     curr.children[b] = new TrieNode();                 }                 curr = curr.children[b];             }             curr.val = x;         }         for (int[] query : queries) {             int xi = query[0], mi = query[1];             int max = -1;             TrieNode curr = root;             for (int k = 31; k >= 0 && curr != null; k--) {                 int xb = (xi >> k) & 1, mb = (mi >> k) & 1;                 if (mb == 1) {                     TrieNode child = curr.children[xb == 1 ? 0 : 1];                     if (child != null) {                         max = Math.max(max, xi ^ child.maxXor(xi));                     }                     curr = curr.children[xb];                 } else {                     curr = curr.children[xb];                 }             }             res[i++] = max;         }         return res;     } }  class TrieNode {     TrieNode[] children;     int val;     public TrieNode() {         children = new TrieNode[2];         val = -1;     }     public int maxXor(int x) {         TrieNode curr = this;         int res = 0;         for (int k = 31; k >= 0 && curr != null; k--) {             int b = (x >> k) & 1;             if (curr.children[b == 1 ? 0 : 1] != null) {                 res += (1 << k);                 curr = curr.children[b == 1 ? 0 : 1];             } else {                 curr = curr.children[b];             }         }         return res;     } }",1,"1707-maximum-xor-with-an-element-from-array/Solution.java:18:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1707-maximum-xor-with-an-element-from-array/Solution.java:22:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1707-maximum-xor-with-an-element-from-array/Solution.java:40:16: Variable 'children' must be private and have accessor methods. [VisibilityModifier]
1707-maximum-xor-with-an-element-from-array/Solution.java:41:9: Variable 'val' must be private and have accessor methods. [VisibilityModifier]
1707-maximum-xor-with-an-element-from-array/Solution.java:42:5: Redundant 'public' modifier. [RedundantModifier]
",1,0,0
"class Solution {     public int minOperations(int[] target, int[] arr) {         Map<Integer, Integer> indexMap = new HashMap<>();                  for(int i=0; i<target.length; i++){             indexMap.put(target[i], i);         }                  List<Integer> subSeqList = new ArrayList<>();         for(int i=0; i<arr.length; i++){             if(indexMap.containsKey(arr[i])){                 subSeqList.add(indexMap.get(arr[i]));             }         }                  int[] subSeq = new int[subSeqList.size()];         for(int i=0; i<subSeqList.size(); i++){             subSeq[i] = subSeqList.get(i);         }                  int[] dp = new int[subSeq.length];         int len = 0;         for(int i=0; i<subSeq.length; i++){             int idx = Arrays.binarySearch(dp, 0, len, subSeq[i]);             if(idx < 0){                 idx = -(idx+1);             }             dp[idx] = subSeq[i];             if(idx == len){                 len++;             }         }         return target.length - len;     } }",1,"1713-minimum-operations-to-make-a-subsequence/Solution.java:10:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
1713-minimum-operations-to-make-a-subsequence/Solution.java:23:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"import java.util.*;  class Solution {     public int checkWays(int[][] pairs) {         Map<Integer, Set<Integer>> graph = new HashMap<>();         for (int[] pair : pairs) {             int x = pair[0], y = pair[1];             graph.computeIfAbsent(x, k -> new HashSet<>()).add(y);             graph.computeIfAbsent(y, k -> new HashSet<>()).add(x);         }         List<Integer> nodes = new ArrayList<>(graph.keySet());         int n = nodes.size();         int[] degree = new int[n];         for (int i = 0; i < n; i++) {             int x = nodes.get(i);             Set<Integer> neighbors = graph.get(x);             degree[i] = neighbors.size();             if (neighbors.contains(x)) return 0; // self-loop is not allowed             for (int j : neighbors) {                 int k = nodes.indexOf(j);                 if (k < i) return 0; // no cycles allowed                 degree[k]++;             }         }         int[] rank = new int[n];         for (int i = 0; i < n; i++) {             int minDegree = n + 1, minIndex = -1;             for (int j = i; j < n; j++) {                 if (degree[j] < minDegree) {                     minDegree = degree[j];                     minIndex = j;                 }             }             if (minDegree == n + 1) return 0; // isolated node found             if (degree[minIndex] != i) return 0; // non-consecutive degree found             rank[minIndex] = i;             degree[minIndex] = n + 2; // mark as used             for (int j : graph.get(nodes.get(minIndex))) {                 int k = nodes.indexOf(j);                 if (degree[k] > i) degree[k]--; // decrease degree of neighbors not processed yet             }         }         int[] parent = new int[n];         Arrays.fill(parent, -1);         for (int x : nodes) {             for (int y : graph.get(x)) {                 int i = nodes.indexOf(x), j = nodes.indexOf(y);                 if (rank[i] < rank[j]) parent[j] = i;                 else parent[i] = j;             }         }         int[] rootCount = new int[n];         int[] depth = new int[n];         for (int i = 0; i < n; i++) {             if (parent[i] == -1) { // i is a root                 rootCount[rank[i]]++;                 if (rootCount[rank[i]] > 1) return 2; // multiple roots found             } else {                 depth[i] = depth[parent[i]] + 1;             }         }         int maxDepth = Arrays.stream(depth).max().getAsInt();         int[] depthCount = new int[maxDepth + 1];         for (int d : depth) depthCount[d]++;         if (Arrays.stream(depthCount).filter(c -> c >= 2).count() > 0) return 2; // multiple subtrees found         return 1;     } }",1,"1719-number-of-ways-to-reconstruct-a-tree/Solution.java:7:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1719-number-of-ways-to-reconstruct-a-tree/Solution.java:27:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1719-number-of-ways-to-reconstruct-a-tree/Solution.java:47:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1719-number-of-ways-to-reconstruct-a-tree/Solution.java:4:	NcssCount:	The method 'checkWays(int[][])' has a NCSS line count of 62.
1719-number-of-ways-to-reconstruct-a-tree/Solution.java:4:	NPathComplexity:	The method 'checkWays(int[][])' has an NPath complexity of 33152, current threshold is 200
1719-number-of-ways-to-reconstruct-a-tree/Solution.java:5:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
",1,0,0
"class Solution {     public int minimumTimeRequired(int[] jobs, int k) {         int left = 0, right = 0;                  // Find the maximum and total workload         for(int job : jobs) {             right += job;             left = Math.max(left, job);         }                  // Perform binary search to find the optimal maximum workload         while(left < right) {             int mid = left + (right - left) / 2;             if(isValid(jobs, k, mid)) {                 right = mid;             } else {                 left = mid + 1;             }         }                  return left;     }          private boolean isValid(int[] jobs, int k, int maxWorkload) {         int[] workers = new int[k];         return backtrack(jobs, 0, workers, maxWorkload);     }          private boolean backtrack(int[] jobs, int i, int[] workers, int maxWorkload) {         // Base case: all jobs have been assigned         if(i == jobs.length) {             return true;         }                  int currJob = jobs[i];                  // Try assigning the job to each worker         for(int j = 0; j < workers.length; j++) {             // If this worker can't handle the job, move on to the next worker             if(workers[j] + currJob > maxWorkload) {                 continue;             }                          workers[j] += currJob;             boolean res = backtrack(jobs, i+1, workers, maxWorkload);             if(res) {                 return true;             }             workers[j] -= currJob;         }                  return false;     } }",1,"1723-find-minimum-time-to-finish-all-jobs/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     private static int[][] dirs = {{0,1}, {0,-1}, {1,0}, {-1,0}};     private static final int MAX_TURNS = 1000;          public boolean canMouseWin(String[] grid, int catJump, int mouseJump) {         int rows = grid.length;         int cols = grid[0].length();         int[] catPos = new int[2], mousePos = new int[2], foodPos = new int[2];         for (int i = 0; i < rows; i++) {             for (int j = 0; j < cols; j++) {                 char c = grid[i].charAt(j);                 if (c == 'C') {                     catPos[0] = i;                     catPos[1] = j;                 } else if (c == 'M') {                     mousePos[0] = i;                     mousePos[1] = j;                 } else if (c == 'F') {                     foodPos[0] = i;                     foodPos[1] = j;                 }             }         }         int[][][][][] memo = new int[rows][cols][rows][cols][2];         return dfs(grid, catPos, mousePos, foodPos, catJump, mouseJump, 0, true, memo) == 1;     }          private int dfs(String[] grid, int[] catPos, int[] mousePos, int[] foodPos,                      int catJump, int mouseJump, int turns, boolean mouseTurn, int[][][][][] memo) {         if (turns == MAX_TURNS) {             return 0;         }         if (catPos[0] == mousePos[0] && catPos[1] == mousePos[1]) {             return -1;         }         if (foodPos[0] == mousePos[0] && foodPos[1] == mousePos[1]) {             return 1;         }         int mRow = mousePos[0], mCol = mousePos[1];         int cRow = catPos[0], cCol = catPos[1];         if (memo[cRow][cCol][mRow][mCol][mouseTurn ? 1 : 0] != 0) {             return memo[cRow][cCol][mRow][mCol][mouseTurn ? 1 : 0];         }         int result = mouseTurn ? -1 : 1; // default value; assume win/lose and try to update         if (mouseTurn) {             for (int[] dir : dirs) { // try all possible mouse moves                 for (int k = 1; k <= mouseJump; k++) { // try different jump lengths                     int nextRow = mRow + k * dir[0];                     int nextCol = mCol + k * dir[1];                     if (nextRow < 0 || nextRow >= grid.length || nextCol < 0 || nextCol >= grid[0].length()) {                         break; // out of bounds                     }                     char c = grid[nextRow].charAt(nextCol);                     if (c == '#') {                         break; // hit a wall                     }                     if (c == 'C') { // mouse cannot jump over cat directly                         continue;                     }                     int val = dfs(grid, catPos, new int[] {nextRow, nextCol}, foodPos,                                    catJump, mouseJump, turns + 1, !mouseTurn, memo);                     result = Math.max(result, val); // trying to win for mouse -> take the best result                     if (result == 1) { // mouse already won                         break;                     }                 }                 if (result == 1) { // no need to look more, mouse already won                     break;                 }             }         } else { // cat turn             for (int[] dir : dirs) { // try all possible cat moves                 for (int k = 1; k <= catJump; k++) { // try different jump lengths                     int nextRow = cRow + k * dir[0];                     int nextCol = cCol + k * dir[1];                     if (nextRow < 0 || nextRow >= grid.length || nextCol < 0 || nextCol >= grid[0].length()) {                         break; // out of bounds                     }                     char c = grid[nextRow].charAt(nextCol);                     if (c == '#') {                         break; // hit a wall                     }                     if (c == 'M') { // cat can jump over mouse directly                         int val = dfs(grid, new int[] {nextRow, nextCol}, new int[] {nextRow, nextCol}, foodPos,                                        catJump, mouseJump, turns + 1, !mouseTurn, memo);                         result = Math.min(result, val); // trying to win for cat -> take the worst result                         if (result == -1) { // cat already won                             break;                         }                     } else { // cat cannot jump over empty spaces nor food                         int val = dfs(grid, new int[] {nextRow, nextCol}, mousePos, foodPos,                                        catJump, mouseJump, turns + 1, !mouseTurn, memo);                         result = Math.min(result, val); // trying to win for cat -> take the worst result                         if (result == -1) { // cat already won                             break;                         }                     }                 }                 if (result == -1) { // no need to look more, cat already won                     break;                 }             }         }         memo[cRow][cCol][mRow][mCol][mouseTurn ? 1 : 0] = result;         return result;     } }",1,"1728-cat-and-mouse-ii/Solution.java:8:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1728-cat-and-mouse-ii/Solution.java:28:17: More than 7 parameters (found 9). [ParameterNumber]
1728-cat-and-mouse-ii/Solution.java:39:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1728-cat-and-mouse-ii/Solution.java:40:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1728-cat-and-mouse-ii/Solution.java:28:	NPathComplexity:	The method 'dfs(String[], int[], int[], int[], int, int, int, boolean, int[][][][][])' has an NPath complexity of 35856, current threshold is 200
",1,0,0
"class Solution {     private static final int MOD = 1000000007;      public int[] waysToFillArray(int[][] queries) {         int[] ans = new int[queries.length];         int idx = 0;         for (int[] query : queries) {             long res = 1;             int n = query[0], k = query[1];             // Find prime factors of k             List<Integer> factors = primeFactors(k);             // For each prime factor, apply the formula to find the count of ways             for (int f : factors) {                 int cnt = 0;                 // Count the occurrence of each prime factor in the array                 while (k % f == 0) {                     k /= f;                     cnt++;                 }                 // Apply formula                 res = (res * combination(n + cnt - 1, cnt)) % MOD;             }             if (k > 1) {                 res = (res * n) % MOD;             }             ans[idx++] = (int) res;         }         return ans;     }      // Method to find prime factors of a number     private List<Integer> primeFactors(int n) {         List<Integer> factors = new ArrayList<>();         for (int i = 2; i * i <= n; i++) {             while (n % i == 0) {                 factors.add(i);                 n /= i;             }         }         if (n > 1) factors.add(n);         return factors;     }      // Method to calculate combination nCr     private long combination(int n, int r) {         r = Math.min(r, n - r);         long res = 1;         for (int i = 0; i < r; i++) {             res = res * (n - i) % MOD;             res = res * pow(i + 1, MOD - 2) % MOD;         }         return res;     }      // Method to calculate pow(a, b) % MOD     private long pow(int a, int b) {         if (b == 0) {             return 1;         }         long res = pow(a, b / 2);         if (b % 2 == 1) {             return res * res % MOD * a % MOD;         }         return res * res % MOD;     } }",1,"1735-count-ways-to-make-array-with-product/Solution.java:9:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1735-count-ways-to-make-array-with-product/Solution.java:21:	UselessParentheses:	Useless parentheses.
1735-count-ways-to-make-array-with-product/Solution.java:24:	UselessParentheses:	Useless parentheses.
1735-count-ways-to-make-array-with-product/Solution.java:37:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
1735-count-ways-to-make-array-with-product/Solution.java:46:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'r'
",1,1,0
"class Solution {     public int minimumBoxes(int n) {         // calculate the number of boxes that can be placed on the bottom layer         int bottomLayer = 0;         int height = 0;         while (bottomLayer + height * (height + 1) / 2 < n) {             bottomLayer += height * (height + 1) / 2;             height++;         }         // if all boxes fit on the bottom layer, return the number of boxes         if (bottomLayer == n) {             return bottomLayer;         }         // calculate the number of boxes on the last layer         int lastLayer = n - bottomLayer;         // calculate the number of boxes on the penultimate layer         int penLayer = height * (height + 1) / 2;         // if there are not enough boxes for a complete penultimate layer, return the number of boxes on the first two layers         if (lastLayer < penLayer - bottomLayer) {             return bottomLayer + lastLayer;         }         // otherwise, calculate the number of boxes on the first three layers         int topLayer = lastLayer - (penLayer - bottomLayer);         return bottomLayer + penLayer + topLayer;     } }",0,,0,0,0
"class Solution {     public int calculateMinimumHP(int[][] dungeon) {         int m = dungeon.length;         int n = dungeon[0].length;         int[][] dp = new int[m][n];         dp[m-1][n-1] = Math.max(1, 1 - dungeon[m-1][n-1]);         for(int i = m-2; i >= 0; i--){             dp[i][n-1] = Math.max(1, dp[i+1][n-1] - dungeon[i][n-1]);         }         for(int j = n-2; j >= 0; j--){             dp[m-1][j] = Math.max(1, dp[m-1][j+1] - dungeon[m-1][j]);         }         for(int i = m-2; i >= 0; i--){             for(int j = n-2; j >= 0; j--){                 int right = Math.max(1, dp[i][j+1] - dungeon[i][j]);                 int down = Math.max(1, dp[i+1][j] - dungeon[i][j]);                 dp[i][j] = Math.min(right, down);             }         }         return dp[0][0];     } }",0,,0,0,0
class Solution {     public boolean checkPartitioning(String s) {         int n = s.length();         boolean[][] dp = new boolean[n][n];         for (int i = n - 1; i >= 0; i--) {             for (int j = i; j < n; j++) {                 dp[i][j] = (s.charAt(i) == s.charAt(j)) && (j - i < 3 || dp[i + 1][j - 1]);             }         }         for (int i = 1; i < n - 1; i++) {             for (int j = i; j < n - 1; j++) {                 if (dp[0][i - 1] && dp[i][j] && dp[j + 1][n - 1]) {                     return true;                 }             }         }         return false;     } },0,,0,0,0
"class Solution {// Solution class starts     public int maxValue(int[][] events, int k) {         Arrays.sort(events, (a, b) -> Integer.compare(a[0], b[0])); //sorting the events based on start date         PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder()); // to store attended events based on their value          int idx = 0;         int n = events.length;         int ans = 0;                  for (int d = 1; d <= 100000; d++) {//considering all possible dates                          while (!pq.isEmpty() && pq.peek() < d) {//checking if any of the attended events has ended on or before this date                 pq.poll();//removing the ended event             }              while (idx < n && events[idx][0] == d) {//checking if any of the events starts on this date                 pq.offer(events[idx++][2]);//adding the event to the attended events based on their value             }              int sum = 0;             PriorityQueue<Integer> copy = new PriorityQueue<>(pq);             for (int i = 0; i < k && !copy.isEmpty(); i++) {//checking largest k elements from the attended events                 sum += copy.poll();//calculating the total sum of their values             }                          ans = Math.max(ans, sum);         }         return ans;     } } // Solution class ends",0,,0,0,0
"class Solution {     public int minAbsDifference(int[] nums, int goal) {         int n = nums.length;         int ans = Math.abs(goal);         Set<Integer> set1 = new HashSet<>();         Set<Integer> set2 = new HashSet<>();          dfs(0, n / 2, 0, nums, set1); // First DFS on the first half of the array         dfs(n / 2, n, 0, nums, set2); // Second DFS on the second half of the array          List<Integer> list2 = new ArrayList<>(set2);         Collections.sort(list2); // Sorting to apply binary search          for (int num : set1) {             int complement = goal - num;             if (set2.contains(complement)) {                 return 0; // The goal is already achieved             }             int i = binarySearch(list2, complement);             if (i < list2.size()) {                 ans = Math.min(ans, list2.get(i) - complement);             }             if (i > 0) {                 ans = Math.min(ans, complement - list2.get(i - 1));             }         }          return ans;     }      private void dfs(int i, int j, int sum, int[] nums, Set<Integer> set) {         if (i == j) {             set.add(sum);             return;         }         dfs(i + 1, j, sum + nums[i], nums, set);         dfs(i + 1, j, sum, nums, set);     }      private int binarySearch(List<Integer> list, int target) {         int lo = 0, hi = list.size() - 1;         while (lo <= hi) {             int mid = lo + (hi - lo) / 2;             if (list.get(mid) < target) {                 lo = mid + 1;             } else {                 hi = mid - 1;             }         }         return lo;     } }",1,"1755-closest-subsequence-sum/Solution.java:41:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int minTrioDegree(int n, int[][] edges) {         int minDegree = Integer.MAX_VALUE;         boolean[][] graph = new boolean[n][n]; // construct graph         int[] degree = new int[n];         for (int[] edge : edges) {             int u = edge[0] - 1;             int v = edge[1] - 1;             graph[u][v] = graph[v][u] = true;             degree[u]++;             degree[v]++;         }         for (int i = 0; i < n; i++) {             for (int j = i + 1; j < n; j++) {                 if (graph[i][j]) {                     for (int k = j + 1; k < n; k++) {                         if (graph[i][k] && graph[j][k]) {                             minDegree = Math.min(minDegree, degree[i] + degree[j] + degree[k] - 6);                         }                     }                 }             }         }         return minDegree == Integer.MAX_VALUE ? -1 : minDegree;     } }",1,"1761-minimum-degree-of-a-connected-trio-in-a-graph/Solution.java:9:39: Inner assignments should be avoided. [InnerAssignment]
",0,0,0
"import java.util.*;  class Solution {     public int[] getCoprimes(int[] nums, int[][] edges) {         int n = nums.length;         List<Integer>[] adj = new List[n];         for (int i = 0; i < n; i++) {             adj[i] = new ArrayList<>();         }         for (int[] edge : edges) {             int u = edge[0], v = edge[1];             adj[u].add(v);             adj[v].add(u);         }         int[] ans = new int[n];         Arrays.fill(ans, -1);         Map<Integer, List<Pair>> factors = new HashMap<>();         for (int i = 1; i <= 50; i++) {             factors.put(i, new ArrayList<>());             for (int j = 1; j <= 50; j++) {                 if (gcd(i, j) == 1) {                     factors.get(i).add(new Pair(gcd(i, j), j));                 }             }         }         boolean[] visited = new boolean[n];         dfs(0, -1, nums, adj, visited, ans, factors);         return ans;     }          private void dfs(int u, int parent, int[] nums, List<Integer>[] adj, boolean[] visited, int[] ans, Map<Integer, List<Pair>> factors) {         visited[u] = true;         List<Pair> pairs = new ArrayList<>();         int maxDepth = -1;         for (Pair p : factors.get(nums[u])) {             if (!p.x.equals(1) && maxDepth < ans[p.x]) {                 maxDepth = ans[p.x];                 pairs.clear();                 pairs.add(p);             } else if (!p.x.equals(1) && maxDepth == ans[p.x]) {                 pairs.add(p);             }         }         for (int v : adj[u]) {             if (v == parent || visited[v]) continue;             for (Pair p : pairs) {                 if (gcd(p.y, nums[v]) == 1) {                     ans[v] = u;                     break;                 }             }             dfs(v, u, nums, adj, visited, ans, factors);         }     }          private Integer gcd(Integer a, Integer b) {         if (a == 0) return b;         return gcd(b % a, a);     }          private class Pair {         Integer x;         Integer y;                  Pair(Integer x, Integer y) {             this.x = x;             this.y = y;         }     } }",1,"1766-tree-of-coprimes/Solution.java:11:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1766-tree-of-coprimes/Solution.java:62:17: Variable 'x' must be private and have accessor methods. [VisibilityModifier]
1766-tree-of-coprimes/Solution.java:63:17: Variable 'y' must be private and have accessor methods. [VisibilityModifier]
1766-tree-of-coprimes/Solution.java:65:22: 'x' hides a field. [HiddenField]
1766-tree-of-coprimes/Solution.java:65:33: 'y' hides a field. [HiddenField]
1766-tree-of-coprimes/Solution.java:17:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
",1,0,0
"class Solution {     public int maximumScore(int[] nums, int[] multipliers) {         int m = multipliers.length;         int n = nums.length;         int[][] memo = new int[m + 1][m + 1];                 for (int[] arr : memo) Arrays.fill(arr, Integer.MIN_VALUE);                 return dfs(memo, nums, multipliers, 0, n - 1, 0);             }          private int dfs(int[][] memo, int[] nums, int[] multipliers, int l, int r, int k) {         if (k == multipliers.length) return 0;         if (memo[l][k] != Integer.MIN_VALUE) return memo[l][k];         int left = multipliers[k] * nums[l] + dfs(memo, nums, multipliers, l + 1, r, k + 1);         int right = multipliers[k] * nums[r] + dfs(memo, nums, multipliers, l, r - 1, k + 1);         return memo[l][k] = Math.max(left, right);     } }",1,"1770-maximum-score-from-performing-multiplication-operations/Solution.java:15:27: Inner assignments should be avoided. [InnerAssignment]
",0,0,0
"class Solution {     public int longestPalindrome(String word1, String word2) {         String fullString = word1 + word2;         int n = fullString.length();         int[][] dp = new int[n][n];          for (int i = n - 1; i >= 0; i--) {             dp[i][i] = 1;             for (int j = i + 1; j < n; j++) {                 if (fullString.charAt(i) == fullString.charAt(j)) {                     dp[i][j] = dp[i + 1][j - 1] + 2;                 } else {                     dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);                 }             }         }          int len = 0;         for (int i = 0; i < word1.length(); i++) {             for (int j = 0; j < word2.length(); j++) {                 if (word1.charAt(i) == word2.charAt(j)) {                     int prev = i > 0 && j > 0 ? dp[i - 1][j - 1] : 0;                     len = Math.max(len, prev + 2);                 }             }         }          return len;     } }",0,,0,0,0
"class Solution {     public double[] getCollisionTimes(int[][] cars) {         int n = cars.length;         double[] res = new double[n];         Stack<Integer> stack = new Stack<>();         // initialize res array with -1         Arrays.fill(res, -1);         for (int i = n - 1; i >= 0; i--) {             int pos = cars[i][0], speed = cars[i][1];             while (!stack.isEmpty()) {                 int j = stack.peek();                 int pos2 = cars[j][0], speed2 = cars[j][1];                 if (speed <= speed2 || (double) (pos2 - pos) / (speed - speed2) >= res[j] && res[j] > 0) {                     // current car will never catch up to or overtake the car in front of it                     // or it will catch up to it later than the car in front of it will collide with the car in front of it                     break;                 }                 // the car in front of it is going to collide with the car in front of it                 res[i] = (double) (pos2 - pos) / (speed - speed2);                 stack.pop();             }             stack.push(i);         }         return res;     } }",1,"1776-car-fleet-ii/Solution.java:9:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1776-car-fleet-ii/Solution.java:12:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int[] countPairs(int n, int[][] edges, int[] queries) {         int m = edges.length;         int[] deg = new int[n+1];         for (int i = 0; i < m; i++) {             deg[edges[i][0]]++;             deg[edges[i][1]]++;         }         int[] cnt = new int[m+1];         for (int i = 0; i < m; i++) {             int x = edges[i][0], y = edges[i][1];             if (x > y) {                 int t = x; x = y; y = t;             }             cnt[i+1] = deg[x] + deg[y] - 2;         }         Arrays.sort(cnt);            int q = queries.length;         int[] ans = new int[q];         for (int i = 0; i < q; i++) {             int l = 0, r = m, mid;             while (l < r) {                 mid = (l+r) >> 1;                 if (cnt[mid] > queries[i]) r = mid;                 else l = mid+1;             }             ans[i] = m-l;         }         return ans;     } }",1,"1782-count-pairs-of-nodes/Solution.java:11:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1782-count-pairs-of-nodes/Solution.java:21:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int minChanges(int[] nums, int k) {         int n = nums.length;         int[][] freq = new int[k][1024];         int[] last = new int[k];         Arrays.fill(last, -1);         for (int i = 0; i < n; i++) {             freq[i % k][nums[i]]++;         }         int[][] dp = new int[k + 1][1024];         Arrays.fill(dp[0], n / k);         for (int i = 1; i <= k; i++) {             Arrays.fill(dp[i], Integer.MAX_VALUE);             int sum = 0;             int minPrev = Integer.MAX_VALUE;             for (int j = 0; j < 1024; j++) {                 int minRow = Integer.MAX_VALUE;                 for (int l = 0; l < k; l++) {                     minRow = Math.min(minRow, freq[l][j ^ sum]);                 }                 dp[i][j] = Math.min(dp[i][j], minPrev + n / k - sum - minRow);             }             minPrev = Integer.MAX_VALUE;             for (int j = 0; j < 1024; j++) {                 minPrev = Math.min(minPrev, dp[i - 1][j] - j);             }             sum++;         }         return dp[k][0];     } }",1,"1787-make-the-xor-of-all-segments-equal-to-zero/Solution.java:27:	UnusedAssignment:	The updated value of variable 'sum' is never used
",0,0,0
"class Solution {     public int maximumScore(int[] nums, int k) {                  int left = k, right = k, n = nums.length, maxScore = 0;         int minNum = nums[k];    // find the smallest number in the subarray                  while (left > 0 || right < n-1) {             if (left == 0) right++;             else if (right == n-1) left--;             else if (nums[left-1] > nums[right+1]) left--;             else right++;             minNum = Math.min(minNum, Math.min(nums[left], nums[right]));    // update the minimum number             maxScore = Math.max(maxScore, minNum * (right - left + 1));    // update the maximum score         }                  return maxScore;     } }",1,"1793-maximum-score-of-a-good-subarray/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int maxScore(int[] nums) {         Arrays.sort(nums); //sorting the array to facilitate faster gcd calculation         int n = nums.length/2;         int[][] dp = new int[n+1][1<<n]; //using bit manipulation to store which elements are already used         return dfs(nums, dp, 1, 0, n); //starting the recursion with score=1, used=0, and remaining elements=n     }      private int dfs(int[] nums, int[][] dp, int score, int used, int remain) {         if (remain == 0) return 0; //base case         if (dp[remain][used] != 0) return dp[remain][used]; //memoization         int maxScore = 0;         for (int i = 0; i < 2*n; i++) {             if ((used & 1<<i) == 0) { //if element is not used already                 for (int j = i+1; j < 2*n; j++) {                     if ((used & 1<<j) == 0) { //if element is not used already                         int newScore = score * gcd(nums[i], nums[j]) * remain;                         int newUsed = used | 1<<i | 1<<j; //making the elements used                         int curScore = newScore + dfs(nums, dp, score+1, newUsed, remain-1);                         maxScore = Math.max(maxScore, curScore);                     }                 }             }          }         dp[remain][used] = maxScore; //storing the result for future reference         return maxScore;     }      private int gcd(int x, int y) {         if (y == 0) return x;         return gcd(y, x % y);     } }",0,,0,0,0
"class Solution {     public int countPairs(int[] nums, int low, int high) {         int count = 0;         int n = nums.length;         for(int i=0;i<n;i++){             for(int j=i+1;j<n;j++){                 int xor = nums[i] ^ nums[j];                 if(xor>=low && xor<=high){                     count++;                 }             }         }         return count;     } }",0,,0,0,0
"class Solution {     public int maxNiceDivisors(int primeFactors) {         if (primeFactors == 1)             return 1;         long mod = (long)1e9+7;         //Maximum number of threes we can take         long threes = primeFactors/3;         if(primeFactors%3 == 1)             threes--;         //Maximum number of twos we can take         long twos = (primeFactors - threes*3)/2;         //Calculate the result with 3^threes * 2^twos         long res = 1, base = 3;         while (threes > 0) {             if (threes % 2 == 1)                 res = (res * base) % mod;             base = (base * base) % mod;             threes >>= 1;         }         base = 2;         while (twos > 0) {             if (twos % 2 == 1)                 res = (res * base) % mod;             base = (base * base) % mod;             twos >>= 1;         }         return (int)res;     } }",1,"1808-maximize-number-of-nice-divisors/Solution.java:13:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1808-maximize-number-of-nice-divisors/Solution.java:16:	UselessParentheses:	Useless parentheses.
1808-maximize-number-of-nice-divisors/Solution.java:17:	UselessParentheses:	Useless parentheses.
1808-maximize-number-of-nice-divisors/Solution.java:23:	UselessParentheses:	Useless parentheses.
1808-maximize-number-of-nice-divisors/Solution.java:24:	UselessParentheses:	Useless parentheses.
",1,0,0
"import java.util.*;  class Solution {     public int maxHappyGroups(int batchSize, int[] groups) {         int n = groups.length;         int[] cnt = new int[batchSize];         int res = 0;          // Count the number of groups that can be served immediately         for (int i = 0; i < n; i++) {             int rem = groups[i] % batchSize;             if (rem == 0) {                 res++;             } else {                 cnt[rem]++;             }         }          // Serve groups with remainder (batchSize - r)         for (int r = 1; r < batchSize; r++) {             if (cnt[r] == 0) {                 continue;             }             int rem = batchSize - r;             while (true) {                 // Check if we have a group that can be served together with the current group                 boolean found = false;                 for (int i = r + 1; i < batchSize; i++) {                     if (cnt[i] > 0) {                         cnt[i]--;                         found = true;                         break;                     }                 }                 if (!found) {                     // We cannot find a group to serve together with the current group                     break;                 }                 rem = (rem + r) % batchSize;             }             if (rem == 0) {                 res++;             } else {                 cnt[rem]++;             }         }          return res + (cnt[0] > 0 ? 1 : 0); // Handle groups with zero remainder separately     } }",1,"1815-maximum-number-of-groups-getting-fresh-donuts/Solution.java:1:	UnnecessaryImport:	Unused import 'java.util.*'
",0,0,0
"import java.util.*;  class Solution {     public int countDifferentSubsequenceGCDs(int[] nums) {         int n = nums.length;         boolean[] possibleGCDs = new boolean[200001];         for (int i = 0; i < n; i++) {             possibleGCDs[nums[i]] = true;         }         int ans = 0;         for (int i = 1; i <= 200000; i++) {             int gcd = 0;             for (int j = i; j <= 200000; j += i) {                 if (possibleGCDs[j]) {                     gcd = gcd == 0 ? j : gcd(gcd, j);                 }             }             if (gcd == i) {                 ans++;             }         }         return ans;     }          private int gcd(int a, int b) {         while (b != 0) {             int temp = b;             b = a % b;             a = temp;         }         return a;     } }",1,"1819-number-of-different-subsequences-gcds/Solution.java:1:	UnnecessaryImport:	Unused import 'java.util.*'
1819-number-of-different-subsequences-gcds/Solution.java:28:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'b'
1819-number-of-different-subsequences-gcds/Solution.java:29:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'a'
",0,1,0
"class MKAverage {          private int m;     private int k;     private List<Integer> stream;          public MKAverage(int m, int k) {         this.m = m;         this.k = k;         this.stream = new ArrayList<>();     }          public void addElement(int num) {         stream.add(num);     }          public int calculateMKAverage() {         int n = stream.size();         if (n < m) {             return -1;         }         List<Integer> sublist = new ArrayList<>(stream.subList(n - m, n));         Collections.sort(sublist);         sublist = sublist.subList(k, m - k);         int sum = 0;         for (int num : sublist) {             sum += num;         }         return sum / (m - 2 * k);     } }",1,"1825-finding-mk-average/MKAverage.java:7:5: Redundant 'public' modifier. [RedundantModifier]
1825-finding-mk-average/MKAverage.java:7:26: 'm' hides a field. [HiddenField]
1825-finding-mk-average/MKAverage.java:7:33: 'k' hides a field. [HiddenField]
",0,0,0
class Solution {   public int makeStringSorted(String s) {     int n = s.length();     int[] fact = new int[n];     fact[0] = 1;     for (int i = 1; i < n; i++) {       fact[i] = (int) ((long) fact[i - 1] * i % mod);     }     long res = 0;     int[] cnt = new int[26];     for (int i = n - 1; i >= 0; i--) {       int c = s.charAt(i) - 'a';       int cur = 0;       for (int j = 0; j < c; j++) {         cur += cnt[j];       }       res = (res + (long) cur * fact[n - i - 1] % mod) % mod;       cnt[c]++;     }     return (int) res;   }    private static final int mod = 1_000_000_007; },1,"1830-minimum-number-of-operations-to-make-string-sorted/Solution.java:23:	FieldDeclarationsShouldBeAtStartOfClass:	Fields should be declared at the top of the class, before any method declarations, constructors, initializers or inner classes.
",0,0,0
"class Solution {     public int getXORSum(int[] arr1, int[] arr2) {         int andResult = 0;         for(int i=0;i<arr1.length;i++){             for(int j=0;j<arr2.length;j++){                 andResult ^= arr1[i] & arr2[j]; //calculating XOR of each AND result             }         }         return andResult;     } }",1,"1835-find-xor-sum-of-all-pairs-bitwise-and/Solution.java:4:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
1835-find-xor-sum-of-all-pairs-bitwise-and/Solution.java:5:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int maxBuilding(int n, int[][] restrictions) {             // sort restrictions in ascending order of their id         Arrays.sort(restrictions, Comparator.comparingInt(r -> r[0]));                  // adjust restrictions to fill the gap between two existing buildings         for(int i=1; i<restrictions.length; i++) {             int id1 = restrictions[i-1][0];             int id2 = restrictions[i][0];             int height1 = restrictions[i-1][1];             int height2 = restrictions[i][1];             int heightDiff = id2 - id1;             int maxHeight = Math.min(height1 + heightDiff, height2);             restrictions[i][1] = Math.min(restrictions[i][1],  maxHeight);          }                  // adjust restrictions to fill the gap between first building and the first restriction         if(restrictions.length > 0) {             restrictions[0][1] = Math.min(restrictions[0][1], restrictions[0][0] - 1);         }                  // adjust restrictions to fill the gap between last building and the last restriction         if(restrictions.length > 0 && restrictions[restrictions.length-1][0] != n) {             restrictions = Arrays.copyOf(restrictions, restrictions.length+1);             restrictions[restrictions.length-1] = new int[]{n, Integer.MAX_VALUE};          }                        // adjust restrictions to make sure every building can be built          for(int i=1; i<restrictions.length; i++) {             int id1 = restrictions[i-1][0];             int id2 = restrictions[i][0];             int height1 = restrictions[i-1][1];             int height2 = restrictions[i][1];             if(height2 - height1 > id2 - id1) {                 int maxHeight = (height1 + height2 + id2 - id1) / 2;                 restrictions[i-1][1] = maxHeight - id1 + height1;                 restrictions[i][1] = maxHeight - id2 + height2;             }         }                   // calculate the max height for each building         int prevId = 0, prevHeight = 0, maxHeight = 0;         for(int[] restriction : restrictions) {             int id = restriction[0], height = restriction[1];             maxHeight = Math.max(maxHeight, (prevHeight + height + id - prevId) / 2);             prevId = id;             prevHeight = height;         }         return maxHeight;     } }",1,"1840-maximum-building-height/Solution.java:43:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1840-maximum-building-height/Solution.java:45:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1840-maximum-building-height/Solution.java:25:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'restrictions'
",1,1,0
"import java.util.Arrays; import java.util.PriorityQueue;  class Solution {     public int[] closestRoom(int[][] rooms, int[][] queries) {         int n = rooms.length;         int k = queries.length;         Integer[] ans = new Integer[k];         for (int i = 0; i < k; i++) ans[i] = i;         Arrays.sort(rooms, (a, b) -> (b[1] - a[1]));         Arrays.sort(ans, (a, b) -> (queries[b][1] - queries[a][1]));         int j = 0;         PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> (b - a));         int[] res = new int[k];         for (int i = 0; i < k; i++) {             int index = ans[i];             int pre = queries[index][0];             int minSize = queries[index][1];             while (j < n && rooms[j][1] >= minSize) {                 pq.offer(rooms[j++][0]);             }             while (!pq.isEmpty()) {                 int id = pq.poll();                 if (res[index] == 0 || Math.abs(res[index] - pre) > Math.abs(id - pre)                         || (Math.abs(res[index] - pre) == Math.abs(id - pre) && id < res[index]))                     res[index] = id;             }             if (res[index] == 0)                 res[index] = -1;         }         return res;     } }",1,"1847-closest-room/Solution.java:10:	UselessParentheses:	Useless parentheses.
1847-closest-room/Solution.java:11:	UselessParentheses:	Useless parentheses.
1847-closest-room/Solution.java:13:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
1847-closest-room/Solution.java:13:	UselessParentheses:	Useless parentheses.
",0,0,0
"class Solution {     public int[] minInterval(int[][] intervals, int[] queries) {         int[] res = new int[queries.length];         Arrays.fill(res, -1);         PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[1] - a[0] - b[1] + b[0]);         Map<Integer, List<Integer>> map = new HashMap<Integer, List<Integer>>(queries.length);         for (int i = 0; i < queries.length; ++i)             map.put(queries[i], map.getOrDefault(queries[i], new LinkedList<Integer>()));         Arrays.sort(intervals, (a, b) -> a[0] - b[0]);         for (int[] iv : intervals) {             while (!pq.isEmpty() && pq.peek()[1] < iv[0]) {                 int[] tmp = pq.poll();                 for (int i : map.get(tmp[2]))                     if (res[i] == -1)                         res[i] = tmp[1] - tmp[0] + 1;             }             for (Map.Entry<Integer, List<Integer>> entry : map.entrySet())                 if (entry.getKey() >= iv[0] && entry.getKey() <= iv[1])                     entry.getValue().add(pq.offer(new int[]{iv[0], iv[1], entry.getKey()}) ? new Integer(pq.size() - 1) : -1);         }         while (!pq.isEmpty()) {             int[] tmp = pq.poll();             for (int i : map.get(tmp[2]))                 if (res[i] == -1)                     res[i] = tmp[1] - tmp[0] + 1;         }         return res;     } }",1,"1851-minimum-interval-to-include-each-query/Solution.java:2:	NPathComplexity:	The method 'minInterval(int[][], int[])' has an NPath complexity of 208, current threshold is 200
1851-minimum-interval-to-include-each-query/Solution.java:7:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
1851-minimum-interval-to-include-each-query/Solution.java:19:	PrimitiveWrapperInstantiation:	Do not use `new Integer(...)`, prefer `Integer.valueOf(...)`
1851-minimum-interval-to-include-each-query/Solution.java:19:	UnnecessaryBoxing:	Unnecessary explicit boxing
",0,0,1
"class Solution {     public int largestPathValue(String colors, int[][] edges) {         int n = colors.length();         List<List<Integer>> adj = new ArrayList<>();         int[] inDegree = new int[n];         int[] colorCount = new int[26];         for (int i = 0; i < n; i++) {             adj.add(new ArrayList<>());         }         for (int[] edge : edges) {             int u = edge[0];             int v = edge[1];             adj.get(u).add(v);             inDegree[v]++;         }          Queue<Integer> queue = new LinkedList<>();         for (int i = 0; i < n; i++) {             if (inDegree[i] == 0) {                 queue.offer(i);             }         }          int count = 0;         int res = 0;          while (!queue.isEmpty()) {             int curr = queue.poll();             count++;             colorCount[colors.charAt(curr) - 'a']++;             res = Math.max(res, colorCount[colors.charAt(curr) - 'a']);             for (int next : adj.get(curr)) {                 inDegree[next]--;                 if (inDegree[next] == 0) {                     queue.offer(next);                     for (int i = 0; i < 26; i++) {                         colorCount[i] = Math.max(colorCount[i], colorCount[i + 26]);                     }                 }             }         }          return (count == n) ? res : -1;     } }",0,,0,0,0
"class Solution {     public int sumOfFlooredPairs(int[] nums) {         int MOD = 1000000007;         int[] count = new int[100001];         for (int num : nums) {             count[num]++;         }         for (int i = 1; i <= 100000; i++) {             count[i] += count[i - 1];         }         long ans = 0;         for (int i = 1; i <= 100000; i++) {             if (count[i] == count[i - 1]) {                 continue;             }             long sum = 0;             for (int j = 1; i * j <= 100000; j++) {                 int l = i * j - 1, r = Math.min(i * (j + 1) - 1, 100000);                 sum += (count[r] - count[l]) * j % MOD;             }             ans += sum * (count[i] - count[i - 1]);             ans %= MOD;         }         return (int) ans;     } }",1,"1862-sum-of-floored-pairs/Solution.java:18:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int rearrangeSticks(int n, int k) {         long[][] dp = new long[n+1][k+1];         int mod = 1000000007;         for (int i = 1; i <= n; i++) {             for (int j = 1; j <= k; j++) {                 if (i == j) {                     dp[i][j] = 1;                 } else {                     dp[i][j] = (dp[i-1][j-1] + dp[i-1][j]*(i-1)) % mod;                 }             }         }         return (int)dp[n][k];     } }",0,,0,0,0
"class Solution {     public int stoneGameVIII(int[] stones) {         int n = stones.length;         for (int i = 1; i < n; i++) {             stones[i] += stones[i - 1];         }         int res = stones[n - 1];         for (int i = n - 2; i > 0; i--) {             res = Math.max(res, stones[i] - res);         }         return res;     } }",0,,0,0,0
"class Solution {     public int minimumXORSum(int[] nums1, int[] nums2) {         int n = nums1.length;         int[] dp = new int[1 << n];         Arrays.fill(dp, Integer.MAX_VALUE);         dp[0] = 0;         for (int mask = 0; mask < (1 << n); mask++) {             int count = Integer.bitCount(mask);             for (int i = 0; i < n; i++) {                 if ((mask & (1 << i)) == 0) {                     dp[mask | (1 << i)] = Math.min(dp[mask | (1 << i)], dp[mask] + (nums1[count] ^ nums2[i]));                 }             }         }         return dp[(1 << n) - 1];     } }",0,,0,0,0
"class Solution {     public int maxProfit(int k, int[] prices) {         int n = prices.length;         if (n < 2 || k == 0) {             return 0;         }         if (k >= n/2) {             int maxProfit = 0;             for (int i = 1; i < n; i++) {                 if (prices[i] > prices[i-1]) {                     maxProfit += prices[i] - prices[i-1];                 }             }             return maxProfit;         }         int[] buy = new int[k];         int[] sell = new int[k];         Arrays.fill(buy, Integer.MIN_VALUE);         for (int price : prices) {             for (int i = 0; i < k; i++) {                 buy[i] = Math.max(buy[i], i == 0 ? 0 - price : sell[i-1] - price);                 sell[i] = Math.max(sell[i], buy[i] + price);             }         }         return sell[k-1];     } }",0,,0,0,0
"class Solution {     public int minSkips(int[] dist, int speed, int hoursBefore) {         int n = dist.length;         int[][] dp = new int[n][n+1];                  // initialize the dp table         for (int i = 0; i < n; i++) {             for (int j = 1; j <= n; j++) {                 dp[i][j] = -1;             }         }         dp[0][0] = dist[0];         dp[0][1] = Math.ceil((double)dist[0] / speed);                  // fill the dp table         for (int i = 1; i < n; i++) {             dp[i][0] = dp[i-1][0] + dist[i]; // no skips             for (int j = 1; j <= i+1; j++) {                 int skip = dp[i-1][j-1]; // skip current rest                 if (skip != -1) {                     skip += dist[i];                 }                 int no_skip = dp[i-1][j] + dist[i]; // don't skip                 dp[i][j] = Math.min(skip, no_skip);                 if (j == i+1) {                     // add any remaining time after the last road                     double time_needed = (double)dp[i][j] / speed;                     double time_left = hoursBefore - time_needed;                     if (time_left >= 0 && time_left < 1) {                         dp[i][j]++;                     }                 }             }         }                  // find the minimum number of skips that allows arriving on time         for (int j = 0; j <= n; j++) {             double time_needed = (double)dp[n-1][j] / speed;             if (time_needed <= hoursBefore) {                 return j;             }         }         return -1;     } }  ",0,,0,0,0
"class Solution {     public int minWastedSpace(int[] packages, int[][] boxes) {         Arrays.sort(packages);         long res = Long.MAX_VALUE, space = 0;         int mod = 1000000007;         for (int[] supplier : boxes) {             Arrays.sort(supplier);             if (supplier[supplier.length - 1] < packages[packages.length - 1]) continue; // It is impossible that the largest package can fit in the boxes of this supplier             int j = 0; // j points to the smallest box that cannot fit the package             for (int p : packages) {                 int idx = binarySearch(supplier, j, supplier.length, p);                 space += (long) (idx - j) * p;                 j = idx;                 if (j == supplier.length) break;             }             res = Math.min(res, space);             space = 0;         }         return res == Long.MAX_VALUE ? -1 : (int)(res % mod);     }      private int binarySearch(int[] supplier, int l, int r, int p) {         while (l < r) {             int mid = l + (r - l) / 2;             if (supplier[mid] <= p) l = mid + 1;             else r = mid;         }         return l;     } }",1,"1889-minimum-space-wasted-from-packaging/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1889-minimum-space-wasted-from-packaging/Solution.java:25:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'l'
1889-minimum-space-wasted-from-packaging/Solution.java:26:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'r'
",1,1,0
"class Solution {     public int minOperationsToFlip(String expression) {         Stack<Integer> stack = new Stack<>();         int level = 0, cost = 0;         char[] exp = expression.toCharArray();         for (int i = 0; i < exp.length; i++) {             char ch = exp[i];             if (ch == '(') {                 level++;                 if (level % 2 == 0) {                     stack.push(-1);                 } else {                     stack.push(-2);                 }             } else if (ch == ')') {                 if (stack.peek() < 0) {                     stack.pop();                 } else {                     stack.push(-3);                     cost++;                 }                 level--;             } else if (ch == '&') {                 if (level % 2 == 0) {                     stack.push(1);                 } else {                     stack.push(2);                 }             } else if (ch == '|') {                 if (level % 2 == 0) {                     stack.push(3);                 } else {                     stack.push(4);                 }             } else {                 stack.push((int) (ch - '0'));             }         }         if (stack.size() == 1) {             return cost;         }         Stack<Integer> newStack = new Stack<>();         while (!stack.isEmpty()) {             int top = stack.pop();             if (top < 0) {                 newStack.push(top);             } else if (top == 1 || top == 2 || top == 3 || top == 4) {                 int a = newStack.pop();                 int b = newStack.pop();                 if (top == 1) {                     newStack.push(a & b);                 } else if (top == 2) {                     newStack.push(a | b);                 } else if (top == 3) {                     newStack.push((a | b) ^ 1);                 } else if (top == 4) {                     newStack.push((a & b) ^ 1);                 }             } else {                 newStack.push(top);             }         }         int res = newStack.pop();         while (!newStack.isEmpty()) {             res ^= newStack.pop();         }         return cost + res;     } }",1,"1896-minimum-cost-to-change-the-final-value-of-expression/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1896-minimum-cost-to-change-the-final-value-of-expression/Solution.java:2:	NcssCount:	The method 'minOperationsToFlip(String)' has a NCSS line count of 62.
1896-minimum-cost-to-change-the-final-value-of-expression/Solution.java:2:	NPathComplexity:	The method 'minOperationsToFlip(String)' has an NPath complexity of 440, current threshold is 200
1896-minimum-cost-to-change-the-final-value-of-expression/Solution.java:6:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
1896-minimum-cost-to-change-the-final-value-of-expression/Solution.java:36:	UnnecessaryCast:	Unnecessary cast (int)
",1,0,1
"class Solution {     public int[] earliestAndLatest(int n, int firstPlayer, int secondPlayer) {         int rounds = 0;         int earliestRound = Integer.MAX_VALUE;         int latestRound = Integer.MIN_VALUE;                  // Create an array of players and set their initial positions         int[] players = new int[n];         for (int i = 1; i <= n; i++) {             players[i-1] = i;         }                  // Keep playing rounds until the two players are next to each other         while (Math.abs(firstPlayer - secondPlayer) > 1) {             int left = 0;             int right = players.length - 1;             rounds++;                          // Play each match in the round             while (left < right) {                 // Check if the players are the two we're looking for                 if ((players[left] == firstPlayer && players[right] == secondPlayer) ||                      (players[left] == secondPlayer && players[right] == firstPlayer)) {                     earliestRound = Math.min(earliestRound, rounds);                     latestRound = Math.max(latestRound, rounds);                 }                                  // Determine the winner of the current match                 if (players[left] == firstPlayer || players[right] == firstPlayer) {                     left = players[left] == firstPlayer ? left : left + 1;                     right = players[right] == firstPlayer ? right : right - 1;                 } else if (players[left] == secondPlayer || players[right] == secondPlayer) {                     left = players[left] == secondPlayer ? left : left + 1;                     right = players[right] == secondPlayer ? right : right - 1;                 } else {                     left++;                     right--;                 }             }                          // Reorder the list of players based on their initial positions             int[] newOrder = new int[players.length];             for (int i = 0; i < players.length; i++) {                 newOrder[players[i] - 1] = players[i];             }             players = newOrder;                          // If the number of players is odd, the player in the middle advances automatically             if (players.length % 2 == 1) {                 int[] temp = new int[players.length - 1];                 for (int i = 0; i < temp.length; i++) {                     temp[i] = players[i];                 }                 players = temp;             }         }                  // Return the earliest and latest possible rounds         return new int[] {earliestRound, latestRound};     } }",1,"1900-the-earliest-and-latest-rounds-where-players-compete/Solution.java:2:	NPathComplexity:	The method 'earliestAndLatest(int, int, int)' has an NPath complexity of 674, current threshold is 200
1900-the-earliest-and-latest-rounds-where-players-compete/Solution.java:14:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
1900-the-earliest-and-latest-rounds-where-players-compete/Solution.java:43:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
1900-the-earliest-and-latest-rounds-where-players-compete/Solution.java:51:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
",0,0,1
"import java.util.*;  class MovieRentingSystem {          private int n;     private int[][] entries;      private Map<Integer, TreeSet<int[]>> unrentedMovies; // movieId -> {shopId, price}     private Map<Integer, Map<Integer, Integer>> rentedMovies; // shopId -> {movieId, price}          public MovieRentingSystem(int n, int[][] entries) {         this.n = n;         this.entries = entries;         this.unrentedMovies = new HashMap<>();         this.rentedMovies = new HashMap<>();         for (int i = 0; i < entries.length; i++) {             int shopId = entries[i][0];             int movieId = entries[i][1];             int price = entries[i][2];             if (!unrentedMovies.containsKey(movieId)) {                 unrentedMovies.put(movieId, new TreeSet<>((a, b) -> a[1] != b[1] ? a[1] - b[1] : a[0] - b[0]));             }             unrentedMovies.get(movieId).add(new int[] {shopId, price});         }     }          public List<Integer> search(int movie) {         List<Integer> res = new ArrayList<>();         if (unrentedMovies.containsKey(movie)) {             Iterator<int[]> iter = unrentedMovies.get(movie).iterator();             while (iter.hasNext() && res.size() < 5) {                 int[] shopInfo = iter.next();                 int shopId = shopInfo[0];                 res.add(shopId);             }         }         return res;     }          public void rent(int shop, int movie) {         int price = unrentedMovies.get(movie).floor(new int[] {shop, 10001})[1];         unrentedMovies.get(movie).remove(new int[] {shop, price});         if (!rentedMovies.containsKey(shop)) {             rentedMovies.put(shop, new HashMap<>());         }         rentedMovies.get(shop).put(movie, price);     }          public void drop(int shop, int movie) {         int price = rentedMovies.get(shop).get(movie);         if (!unrentedMovies.containsKey(movie)) {             unrentedMovies.put(movie, new TreeSet<>((a, b) -> a[1] != b[1] ? a[1] - b[1] : a[0] - b[0]));         }         unrentedMovies.get(movie).add(new int[] {shop, price});         rentedMovies.get(shop).remove(movie);     }          public List<List<Integer>> report() {         List<List<Integer>> res = new ArrayList<>();         TreeSet<int[]> rentedMoviesSet = new TreeSet<>((a, b) -> a[1] != b[1] ? a[1] - b[1] : a[0] != b[0] ? a[0] - b[0] : a[2] - b[2]);         for (int shopId : rentedMovies.keySet()) {             Map<Integer, Integer> movies = rentedMovies.get(shopId);             for (int movieId : movies.keySet()) {                 int price = movies.get(movieId);                 rentedMoviesSet.add(new int[] {shopId, movieId, price});             }         }         Iterator<int[]> iter = rentedMoviesSet.iterator();         while (iter.hasNext() && res.size() < 5) {             int[] movieInfo = iter.next();             int shopId = movieInfo[0];             int movieId = movieInfo[1];             res.add(Arrays.asList(shopId, movieId));         }         return res;     } }  /**  * Your MovieRentingSystem object will be instantiated and called as such:  * MovieRentingSystem obj = new MovieRentingSystem(n, entries);  * List<Integer> param_1 = obj.search(movie);  * obj.rent(shop,movie);  * obj.drop(shop,movie);  * List<List<Integer>> param_4 = obj.report();  */",1,"1912-design-movie-rental-system/MovieRentingSystem.java:11:5: Redundant 'public' modifier. [RedundantModifier]
1912-design-movie-rental-system/MovieRentingSystem.java:11:35: 'n' hides a field. [HiddenField]
1912-design-movie-rental-system/MovieRentingSystem.java:11:46: 'entries' hides a field. [HiddenField]
1912-design-movie-rental-system/MovieRentingSystem.java:5:	UnusedPrivateField:	Avoid unused private fields such as 'n'.
1912-design-movie-rental-system/MovieRentingSystem.java:6:	UnusedPrivateField:	Avoid unused private fields such as 'entries'.
1912-design-movie-rental-system/MovieRentingSystem.java:8:	LooseCoupling:	Avoid using implementation types like 'TreeSet'; use the interface instead
1912-design-movie-rental-system/MovieRentingSystem.java:13:	ArrayIsStoredDirectly:	The user-supplied array 'entries' is stored directly.
1912-design-movie-rental-system/MovieRentingSystem.java:16:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
1912-design-movie-rental-system/MovieRentingSystem.java:21:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
1912-design-movie-rental-system/MovieRentingSystem.java:52:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
1912-design-movie-rental-system/MovieRentingSystem.java:60:	LooseCoupling:	Avoid using implementation types like 'TreeSet'; use the interface instead
1912-design-movie-rental-system/MovieRentingSystem.java:60:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
1912-design-movie-rental-system/MovieRentingSystem.java:60:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",0,0,1
"class Solution {     public int waysToBuildRooms(int[] prevRoom) {         int n = prevRoom.length;         List<Integer>[] graph = new List[n];         for (int i = 0; i < n; i++) {             graph[i] = new ArrayList<>();         }         for (int i = 1; i < n; i++) {             graph[prevRoom[i]].add(i);         }         int[] size = new int[n];         size[0] = 1;         calcSize(graph, size, 0);         int[] fact = new int[n + 1];         fact[0] = 1;         for (int i = 1; i <= n; i++) {             fact[i] = (int)((long)fact[i - 1] * i % MOD);         }         int[] inv = new int[n + 1];         inv[n] = inv(fact[n]);         for (int i = n - 1; i >= 0; i--) {             inv[i] = (int)((long)inv[i + 1] * (i + 1) % MOD);         }         int res = 1;         for (int i = 1; i < n; i++) {             res = (int)((long)res * fact[size[i] - 1] % MOD * inv[size[i]] % MOD);         }         return res;     }          private static final int MOD = 1000000007;          private static void calcSize(List<Integer>[] graph, int[] size, int u) {         for (int v : graph[u]) {             calcSize(graph, size, v);             size[u] += size[v];         }         size[u]++;     }          private static int inv(int x) {         int y = MOD - 2, res = 1;         while (y > 0) {             if ((y & 1) == 1) {                 res = (int)((long)res * x % MOD);             }             x = (int)((long)x * x % MOD);             y >>= 1;         }         return res;     } }",1,"1916-count-ways-to-build-rooms-in-an-ant-colony/Solution.java:42:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1916-count-ways-to-build-rooms-in-an-ant-colony/Solution.java:31:	FieldDeclarationsShouldBeAtStartOfClass:	Fields should be declared at the top of the class, before any method declarations, constructors, initializers or inner classes.
1916-count-ways-to-build-rooms-in-an-ant-colony/Solution.java:47:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'x'
",1,1,0
"import java.util.*;  class Solution {     public int longestCommonSubpath(int n, int[][] paths) {         int m = paths.length;         int minLength = Integer.MAX_VALUE;         for (int i = 0; i < m; i++) {             minLength = Math.min(minLength, paths[i].length);         }         int left = 1; // minimum length of the common path         int right = minLength; // maximum length of the common path         while (left <= right) {             int mid = (left + right) / 2;             if (hasCommonSubpath(n, paths, mid)) {                 left = mid + 1;             } else {                 right = mid - 1;             }         }         return right; // right is the maximum length of the common path     }          private boolean hasCommonSubpath(int n, int[][] paths, int length) {         Set<Long> set = new HashSet<>();         for (int i = 0; i < paths.length; i++) {             long hash = getHash(paths[i], length, n);             set.add(hash);         }         for (int i = length; i < paths[0].length; i++) {             set.remove(getHash(paths[0], i - length, i, n));             set.add(getHash(paths[0], i - length + 1, i + 1, n));             if (set.size() == paths.length) {                 return true;             }         }         return false;     }          private long getHash(int[] path, int length, int n) {         long hash = 0;         long base = 1;         for (int i = length - 1; i >= 0; i--) {             hash += path[i] * base;             hash %= n;             if (i > 0) {                 base = base * 256 % n;             }         }         return hash;     }          private long getHash(int[] path, int start, int end, int n) {         long hash = 0;         long base = 1;         for (int i = end - 1; i >= start; i--) {             hash += path[i] * base;             hash %= n;             base = base * 256 % n;         }         return hash;     } }",1,"1923-longest-common-subpath/Solution.java:25:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"import java.util.*;  class Solution {     public int minCost(int maxTime, int[][] edges, int[] passingFees) {         int n = passingFees.length;         Map<Integer, List<int[]>> graph = new HashMap<>();         for (int[] edge : edges) {             int u = edge[0], v = edge[1], w = edge[2];             graph.computeIfAbsent(u, k -> new ArrayList<>()).add(new int[]{v, w});             graph.computeIfAbsent(v, k -> new ArrayList<>()).add(new int[]{u, w});         }          int[][] dp = new int[n][maxTime + 1];         for (int[] row : dp) Arrays.fill(row, Integer.MAX_VALUE);         dp[0][0] = passingFees[0];          Queue<int[]> queue = new LinkedList<>();         queue.offer(new int[]{0, 0});         while (!queue.isEmpty()) {             int[] curr = queue.poll();             int u = curr[0], t = curr[1];             if (u == n - 1) return dp[u][t];              if (t >= maxTime) continue;             for (int[] edge : graph.getOrDefault(u, new ArrayList<>())) {                 int v = edge[0], w = edge[1];                 if (t + w <= maxTime && dp[u][t] + passingFees[v] < dp[v][t + w]) {                     dp[v][t + w] = dp[u][t] + passingFees[v];                     queue.offer(new int[]{v, t + w});                 }             }         }         return -1;     } } ",1,"1928-minimum-cost-to-reach-destination-in-time/Solution.java:8:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1928-minimum-cost-to-reach-destination-in-time/Solution.java:21:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1928-minimum-cost-to-reach-destination-in-time/Solution.java:26:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1928-minimum-cost-to-reach-destination-in-time/Solution.java:6:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
",1,0,0
"class Solution {     public int colorTheGrid(int m, int n) {         int mod = 1000000007;         int[][] dp = new int[n][1 << (2 * m)];  // dp[i][mask] represents the number of valid ways to color the i-th column with mask as its color configuration         for (int i = 0; i < (1 << (2 * m)); i++) {  // initialize the first column             if (checkValid(i, m))                 dp[0][i] = 1;         }         for (int i = 1; i < n; i++) {             for (int j = 0; j < (1 << (2 * m)); j++) {                 if (!checkValid(j, m))                     continue;                 for (int k = 0; k < (1 << (2 * m)); k++) {                     if (!checkValid(k, m) || overlap(j, k))                         continue;                     dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;                 }             }         }         int res = 0;         for (int i = 0; i < (1 << (2 * m)); i++) {             res = (res + dp[n - 1][i]) % mod;         }         return res;     }          private boolean checkValid(int num, int m) {  // check if a color configuration is valid         for (int i = 0; i < m; i++) {             int cur = (num >> (2 * i)) & 3;             if (i > 0 && cur == ((num >> (2 * (i - 1))) & 3))                 return false;         }         return true;     }          private boolean overlap(int num1, int num2) {  // check if two color configurations overlap         for (int i = 0; i < m; i++) {             int cur1 = (num1 >> (2 * i)) & 3;             int cur2 = (num2 >> (2 * i)) & 3;             if (cur1 == cur2)                 return true;         }         return false;     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public TreeNode canMerge(List<TreeNode> trees) {         Map<Integer, TreeNode> rootsMap = new HashMap<>();         Set<Integer> leafSet = new HashSet<>();         for (int i = 0; i < trees.size(); i++) {             TreeNode root = trees.get(i);             rootsMap.put(root.val, root);             if (root.left != null) {                 leafSet.add(root.left.val);             }             if (root.right != null) {                 leafSet.add(root.right.val);             }          }          // Find the root and set of leaves         TreeNode root = null;         for (TreeNode node : trees) {             if (!leafSet.contains(node.val)) {                 if (root != null || !isValidRoot(node, rootsMap)) {                     return null;                 } else {                     root = node;                 }             }         }          // Merge trees         while (rootsMap.size() > 1) {             TreeNode leaf = null;             TreeNode treeRoot = null;             for (TreeNode node : trees) {                 if (leafSet.contains(node.val)) {                     leaf = node;                 } else if (rootsMap.containsKey(node.val)) {                     treeRoot = node;                 }             }             if (treeRoot == null || leaf == null || !isValidMerge(treeRoot, leaf, rootsMap)) {                 return null;             } else {                 if (leaf.val == treeRoot.left.val) {                     treeRoot.left = leaf;                 } else {                     treeRoot.right = leaf;                 }                 leafSet.remove(leaf.val);                 rootsMap.remove(treeRoot.val);             }         }         return root;     }      // Check if root is a valid root     private boolean isValidRoot(TreeNode root, Map<Integer, TreeNode> rootsMap) {         boolean isLeftValid = (root.left == null || rootsMap.containsKey(root.left.val));         boolean isRightValid = (root.right == null || rootsMap.containsKey(root.right.val));         return isLeftValid && isRightValid;     }      // Check if tree1 can be merged with tree2     private boolean isValidMerge(TreeNode tree1, TreeNode tree2, Map<Integer, TreeNode> rootsMap) {         if (tree1 == null || tree2 == null) {             return false;         }         if (tree1.val == tree2.val) {             return false;         }         if (tree1.left != null && !rootsMap.containsKey(tree1.left.val)) {             return false;         }         if (tree1.right != null && !rootsMap.containsKey(tree1.right.val)) {             return false;         }         boolean isLeftValid = (tree2.left == null || rootsMap.containsKey(tree2.left.val));         boolean isRightValid = (tree2.right == null || rootsMap.containsKey(tree2.right.val));         return isLeftValid && isRightValid && isBSTValid(tree1.val, tree2, Integer.MIN_VALUE, Integer.MAX_VALUE);     }      // Check if the tree is a valid BST     private boolean isBSTValid(int rootVal, TreeNode node, int minVal, int maxVal) {         if (node == null) {             return true;         }         if (node.val <= minVal || node.val >= maxVal) {             return false;         }         if (node.val < rootVal) {             return isBSTValid(rootVal, node.left, minVal, node.val);         } else {             return isBSTValid(rootVal, node.right, node.val, maxVal);         }     } }",1,"1932-merge-bsts-to-create-single-bst/TreeNode.java:17:	LinguisticNaming:	Linguistics Antipattern - The method 'canMerge' indicates linguistically it returns a boolean, but it returns 'TreeNode'
1932-merge-bsts-to-create-single-bst/TreeNode.java:17:	NPathComplexity:	The method 'canMerge(List<TreeNode>)' has an NPath complexity of 525, current threshold is 200
1932-merge-bsts-to-create-single-bst/TreeNode.java:71:	UselessParentheses:	Useless parentheses.
1932-merge-bsts-to-create-single-bst/TreeNode.java:72:	UselessParentheses:	Useless parentheses.
1932-merge-bsts-to-create-single-bst/TreeNode.java:90:	UselessParentheses:	Useless parentheses.
1932-merge-bsts-to-create-single-bst/TreeNode.java:91:	UselessParentheses:	Useless parentheses.
",0,0,0
"class Solution {     static int MAXN = 200005;     static int level[];     static int LEV = 0;     static int parent[][];     static int BIT[][];     static int depth[];     static int in[];     static int out[];     static int LCA_Euler[];     static int Euler_walk[];     static boolean vis[];     static int tree[];     static int maxNode;      static void init(){         LEV = (int) Math.ceil(Math.log(MAXN) / Math.log(2));         parent = new int[MAXN][LEV + 1];         BIT = new int[MAXN][LEV + 1];         depth = new int[MAXN];         in = new int[MAXN];         out = new int[MAXN];         LCA_Euler = new int[MAXN];         Euler_walk = new int[MAXN << 1];         vis = new boolean[MAXN];         tree = new int[MAXN];     }      static void DFS(ArrayList<ArrayList<Integer>> graph, int cur, int dep){         vis[cur] = true;         in[cur] = ++ maxNode;         LCA_Euler[maxNode] = cur;         depth[cur] = dep;         for(int i = 1;i <= LEV;i ++){             parent[cur][i] = parent[parent[cur][i - 1]][i - 1];             BIT[cur][i] = Math.max(BIT[cur][i - 1], BIT[parent[cur][i - 1]][i - 1]);         }         for(int i = 0;i < graph.get(cur).size();i ++){             int next = graph.get(cur).get(i);             if(!vis[next]){                 parent[next][0] = cur;                 BIT[next][0] = tree[next];                 DFS(graph, next, dep + 1);                 LCA_Euler[++ maxNode] = cur;             }         }         out[cur] = maxNode;         Euler_walk[maxNode] = cur;     }      static int LCA(int x, int y){         if(depth[x] < depth[y]) return LCA(y, x);         for(int i = LEV;i >= 0;i --)             if(depth[parent[x][i]] >= depth[y])                 x = parent[x][i];         if(x == y) return x;         for(int i = LEV;i >= 0;i --)             if(parent[x][i] != parent[y][i]){                 x = parent[x][i];                 y = parent[y][i];             }         return parent[x][0];     }      static int query(int x, int lca){         int res = Integer.MIN_VALUE;         for(int i = LEV;i >= 0;i --)             if(depth[parent[x][i]] >= depth[lca]){                 res = Math.max(res, BIT[x][i]);                 x = parent[x][i];             }         return res;     }      static void add(int x, int v){         for(;x < MAXN;x += (x & -x)) tree[x] = Math.max(tree[x], v);     }      static int query(int x){         int res = Integer.MIN_VALUE;         for(;x > 0;x -= (x & -x)) res = Math.max(res, tree[x]);         return res;     }      public static int[] maxGeneticDifference(int[] parents, int[][] queries) {         init();         ArrayList<ArrayList<Integer>> graph = new ArrayList<>();         for(int i = 0;i <= MAXN;i ++) graph.add(new ArrayList<>());         int n = parents.length, q = queries.length;         for(int i = 0;i < n;i ++)             if(parents[i] != -1){                 graph.get(i).add(parents[i]);                 graph.get(parents[i]).add(i);             }         for(int i = 0;i < q;i ++){             queries[i][1] += MAXN;             graph.get(queries[i][0]).add(i + n);         }         DFS(graph, 0, 0);         for(int i = 0;i <= maxNode;i ++)             add(in[LCA_Euler[i]], BIT[LCA_Euler[i]][0]);         int ans[] = new int[q];         for(int i = 0;i < q;i ++){             int x = queries[i][0], val = queries[i][1] - MAXN, lca = LCA(x, val);             ans[i] = Math.max(query(x, lca), query(val, lca));         }         return ans;     } }",1,"1938-maximum-genetic-difference-query/Solution.java:1:1: Utility classes should not have a public or default constructor. [HideUtilityClassConstructor]
1938-maximum-genetic-difference-query/Solution.java:2:16: Variable 'MAXN' must be private and have accessor methods. [VisibilityModifier]
1938-maximum-genetic-difference-query/Solution.java:3:16: Variable 'level' must be private and have accessor methods. [VisibilityModifier]
1938-maximum-genetic-difference-query/Solution.java:3:21: Array brackets at illegal position. [ArrayTypeStyle]
1938-maximum-genetic-difference-query/Solution.java:4:16: Variable 'LEV' must be private and have accessor methods. [VisibilityModifier]
1938-maximum-genetic-difference-query/Solution.java:5:16: Variable 'parent' must be private and have accessor methods. [VisibilityModifier]
1938-maximum-genetic-difference-query/Solution.java:5:22: Array brackets at illegal position. [ArrayTypeStyle]
1938-maximum-genetic-difference-query/Solution.java:5:24: Array brackets at illegal position. [ArrayTypeStyle]
1938-maximum-genetic-difference-query/Solution.java:6:16: Variable 'BIT' must be private and have accessor methods. [VisibilityModifier]
1938-maximum-genetic-difference-query/Solution.java:6:19: Array brackets at illegal position. [ArrayTypeStyle]
1938-maximum-genetic-difference-query/Solution.java:6:21: Array brackets at illegal position. [ArrayTypeStyle]
1938-maximum-genetic-difference-query/Solution.java:7:16: Variable 'depth' must be private and have accessor methods. [VisibilityModifier]
1938-maximum-genetic-difference-query/Solution.java:7:21: Array brackets at illegal position. [ArrayTypeStyle]
1938-maximum-genetic-difference-query/Solution.java:8:16: Variable 'in' must be private and have accessor methods. [VisibilityModifier]
1938-maximum-genetic-difference-query/Solution.java:8:18: Array brackets at illegal position. [ArrayTypeStyle]
1938-maximum-genetic-difference-query/Solution.java:9:16: Variable 'out' must be private and have accessor methods. [VisibilityModifier]
1938-maximum-genetic-difference-query/Solution.java:9:19: Array brackets at illegal position. [ArrayTypeStyle]
1938-maximum-genetic-difference-query/Solution.java:10:16: Variable 'LCA_Euler' must be private and have accessor methods. [VisibilityModifier]
1938-maximum-genetic-difference-query/Solution.java:10:25: Array brackets at illegal position. [ArrayTypeStyle]
1938-maximum-genetic-difference-query/Solution.java:11:16: Variable 'Euler_walk' must be private and have accessor methods. [VisibilityModifier]
1938-maximum-genetic-difference-query/Solution.java:11:26: Array brackets at illegal position. [ArrayTypeStyle]
1938-maximum-genetic-difference-query/Solution.java:12:20: Variable 'vis' must be private and have accessor methods. [VisibilityModifier]
1938-maximum-genetic-difference-query/Solution.java:12:23: Array brackets at illegal position. [ArrayTypeStyle]
1938-maximum-genetic-difference-query/Solution.java:13:16: Variable 'tree' must be private and have accessor methods. [VisibilityModifier]
1938-maximum-genetic-difference-query/Solution.java:13:20: Array brackets at illegal position. [ArrayTypeStyle]
1938-maximum-genetic-difference-query/Solution.java:14:16: Variable 'maxNode' must be private and have accessor methods. [VisibilityModifier]
1938-maximum-genetic-difference-query/Solution.java:89:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1938-maximum-genetic-difference-query/Solution.java:102:16: Array brackets at illegal position. [ArrayTypeStyle]
1938-maximum-genetic-difference-query/Solution.java:104:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1938-maximum-genetic-difference-query/Solution.java:1:	UseUtilityClass:	This utility class has a non-private constructor
1938-maximum-genetic-difference-query/Solution.java:2:	MutableStaticState:	Do not use non-final non-private static fields
1938-maximum-genetic-difference-query/Solution.java:3:	MutableStaticState:	Do not use non-final non-private static fields
1938-maximum-genetic-difference-query/Solution.java:4:	MutableStaticState:	Do not use non-final non-private static fields
1938-maximum-genetic-difference-query/Solution.java:5:	MutableStaticState:	Do not use non-final non-private static fields
1938-maximum-genetic-difference-query/Solution.java:6:	MutableStaticState:	Do not use non-final non-private static fields
1938-maximum-genetic-difference-query/Solution.java:7:	MutableStaticState:	Do not use non-final non-private static fields
1938-maximum-genetic-difference-query/Solution.java:8:	MutableStaticState:	Do not use non-final non-private static fields
1938-maximum-genetic-difference-query/Solution.java:9:	MutableStaticState:	Do not use non-final non-private static fields
1938-maximum-genetic-difference-query/Solution.java:10:	MutableStaticState:	Do not use non-final non-private static fields
1938-maximum-genetic-difference-query/Solution.java:11:	MutableStaticState:	Do not use non-final non-private static fields
1938-maximum-genetic-difference-query/Solution.java:12:	MutableStaticState:	Do not use non-final non-private static fields
1938-maximum-genetic-difference-query/Solution.java:13:	MutableStaticState:	Do not use non-final non-private static fields
1938-maximum-genetic-difference-query/Solution.java:14:	MutableStaticState:	Do not use non-final non-private static fields
1938-maximum-genetic-difference-query/Solution.java:29:	MethodNamingConventions:	The static method name 'DFS' doesn't match '[a-z][a-zA-Z0-9]*'
1938-maximum-genetic-difference-query/Solution.java:51:	MethodNamingConventions:	The static method name 'LCA' doesn't match '[a-z][a-zA-Z0-9]*'
1938-maximum-genetic-difference-query/Solution.java:55:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'x'
1938-maximum-genetic-difference-query/Solution.java:60:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'y'
1938-maximum-genetic-difference-query/Solution.java:70:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'x'
1938-maximum-genetic-difference-query/Solution.java:76:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'x'
1938-maximum-genetic-difference-query/Solution.java:81:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'x'
",1,1,0
class Solution {     public int[] canSeePersonsCount(int[] heights) {         int n = heights.length;         int[] ans = new int[n];         Stack<Integer> stack = new Stack<Integer>();                  for(int i = n-1; i>=0; i--) {             while(!stack.isEmpty() && heights[i] > stack.peek()) {                 stack.pop();                 ans[i]++;             }             if(!stack.isEmpty()) ans[i]++;             stack.push(heights[i]);         }         return ans;     } },1,"1944-number-of-visible-people-in-a-queue/Solution.java:2:	LinguisticNaming:	Linguistics Antipattern - The method 'canSeePersonsCount' indicates linguistically it returns a boolean, but it returns 'int[]'
",0,0,0
"class Solution {     public List<List<String>> deleteDuplicateFolder(List<List<String>> paths) {         // Initialize the root node of the tree         Trie root = new Trie("""");          // Insert all the paths in the tree         for (List<String> path : paths) {             insertPath(root, path);         }          // Find and mark duplicate subtrees         markDuplicates(root);          // Delete marked subtrees         deleteDuplicates(root);          // Create a list to store the remaining paths         List<List<String>> ans = new ArrayList<>();          // Traverse the tree and add all remaining paths to the answer list         traverse(root, new ArrayList<>(), ans);          return ans;     }      // Trie data structure for storing the file system tree     class Trie {         Map<String, Trie> children;         boolean isDuplicate;          Trie(String str) {             children = new HashMap<>();             isDuplicate = false;         }     }      // Recursively insert a path in the trie     private void insertPath(Trie node, List<String> path) {         for (String folder : path) {             if (!node.children.containsKey(folder)) {                 node.children.put(folder, new Trie(folder));             }             node = node.children.get(folder);         }     }      // Recursively mark duplicate subtrees     private String markDuplicates(Trie node) {         // Create a string representation of the subtree rooted at the current node         StringBuilder sb = new StringBuilder();         for (Trie child : node.children.values()) {             sb.append(""("").append(child.children.size()).append(markDuplicates(child)).append("")"");         }         String subtree = sb.toString();          // If the current subtree is already seen, mark it as duplicate         if (subtree.length() > 0) {             node.isDuplicate = true;         }          return subtree;     }      // Recursively delete marked subtrees     private void deleteDuplicates(Trie node) {         List<String> toRemove = new ArrayList<>();         for (Map.Entry<String, Trie> entry : node.children.entrySet()) {             // Recursively delete marked subtrees             deleteDuplicates(entry.getValue());             if (entry.getValue().isDuplicate) {                 toRemove.add(entry.getKey());             }         }         for (String key : toRemove) {             node.children.remove(key);         }     }      // Recursively traverse the file system tree and add all remaining paths to the answer list     private void traverse(Trie node, List<String> path, List<List<String>> ans) {         if (node.children.isEmpty()) {             // If the current node is a leaf, add the path to the answer list             ans.add(new ArrayList<>(path));             return;         }         for (Map.Entry<String, Trie> entry : node.children.entrySet()) {             if (!entry.getValue().isDuplicate) {                 // Recursively traverse non-duplicate children                 path.add(entry.getKey());                 traverse(entry.getValue(), path, ans);                 path.remove(path.size() - 1);             }         }     } }  ",1,"1948-delete-duplicate-folders-in-system/Solution.java:28:27: Variable 'children' must be private and have accessor methods. [VisibilityModifier]
1948-delete-duplicate-folders-in-system/Solution.java:29:17: Variable 'isDuplicate' must be private and have accessor methods. [VisibilityModifier]
1948-delete-duplicate-folders-in-system/Solution.java:31:	UnusedFormalParameter:	Avoid unused constructor parameters such as 'str'.
1948-delete-duplicate-folders-in-system/Solution.java:43:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'node'
1948-delete-duplicate-folders-in-system/Solution.java:52:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
1948-delete-duplicate-folders-in-system/Solution.java:52:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
",0,1,0
class Solution {     public int countSpecialSubsequences(int[] nums) {         int n = nums.length;         int[] dp = new int[3];                  for (int i = 0; i < n; i++) {             dp[nums[i]] = ((dp[nums[i]] + dp[nums[i]] + (nums[i] == 0 ? 1 : dp[nums[i] - 1])) % 1000000007);         }                  return dp[2];     } }   // Time Complexity: O(n) // Space Complexity: O(1),0,,0,0,0
"class Solution {     public long maxProduct(String s) {         int n = s.length();         int[] pal = new int[n];         Arrays.fill(pal, 1);         int start = 0, mid = 0, end = 0;          // find the longest odd length palindrome centred at each index         for (int i = 0; i < n; i++) {             int len = (i > end) ? 1 : Math.min(pal[start + mid - i], end - i + 1);             while (i - len >= 0 && i + len < n && s.charAt(i - len) == s.charAt(i + len))                 len++;             pal[i] = len;             if (i + len - 1 > end) {                 start = i - len + 1;                 mid = i;                 end = i + len - 1;             }         }          long ans = 0;          // find the maximum product of non-intersecting odd length palindromes         for (int i = 0; i < n; i++) {             for (int j = i + 2; j < n; j += 2) {                 int left = i + ((j - i) / 2);                 int right = left + 1;                 if (left + 1 <= j - 1 && pal[left + 1] >= left - i + 1 && pal[j] >= j - right) {                     ans = Math.max(ans, (long)(left - i + 1) * (j - right + 1));                 }             }         }          return ans;     } }",1,"1960-maximum-product-of-the-length-of-two-palindromic-substrings/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int[] longestObstacleCourseAtEachPosition(int[] obstacles) {         int n = obstacles.length;         int[] ans = new int[n];         List<Integer> lis = new ArrayList<>(); // ""obstacle course"" represented as a list of heights         for (int i = 0; i < n; i++) {             int idx = Collections.binarySearch(lis, obstacles[i]); // search for the index of the next taller obstacle             if (idx < 0) {                 idx = -(idx + 1); // if the obstacle is not present in the list, binary search returns its ""insertion point""             }             ans[i] = idx + 1; // length of the obstacle course is the length of the LIS ending with the current obstacle (plus one to account for the current obstacle)             if (idx == lis.size()) {                 lis.add(obstacles[i]); // if the obstacle is the tallest among the chosen obstacles so far, add it to the ""obstacle course""             } else {                 lis.set(idx, obstacles[i]); // otherwise, update the obstacle at the current index             }         }         return ans;     } }",0,,0,0,0
"class Solution {     public int latestDayToCross(int row, int col, int[][] cells) {         int left = 1, right = cells.length;         while (left <= right) {             int mid = left + (right - left) / 2;             int[][] grid = new int[row][col];             for (int i = 0; i < mid; i++) {                 int r = cells[i][0] - 1;                 int c = cells[i][1] - 1;                 grid[r][c] = 1;             }             if (canCross(grid)) {                 left = mid + 1;             } else {                 right = mid - 1;             }         }         return right;     }          private boolean canCross(int[][] grid) {         int m = grid.length, n = grid[0].length;         boolean[][] visited = new boolean[m][n];         for (int j = 0; j < n; j++) {             if (grid[0][j] == 0 && dfs(grid, visited, 0, j)) {                 return true;             }         }         return false;     }          private boolean dfs(int[][] grid, boolean[][] visited, int i, int j) {         int m = grid.length, n = grid[0].length;         if (i == m - 1) {             return true;         }         visited[i][j] = true;         int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};         for (int[] dir : directions) {             int r = i + dir[0];             int c = j + dir[1];             if (r < 0 || r >= m || c < 0 || c >= n || grid[r][c] == 1 || visited[r][c]) {                 continue;             }             if (dfs(grid, visited, r, c)) {                 return true;             }         }         return false;     } }",1,"1970-last-day-where-you-can-still-cross/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1970-last-day-where-you-can-still-cross/Solution.java:22:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1970-last-day-where-you-can-still-cross/Solution.java:33:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1970-last-day-where-you-can-still-cross/Solution.java:33:	PrematureDeclaration:	Declaration of 'n' can be moved closer to its usages
",1,0,0
"class Solution {     public int numberOfCombinations(String num) {         int mod = 1000000007;         int n = num.length();         int[][] dp = new int[n+1][n+1];         dp[0][0] = 1;                  // Build the dp table         for (int i = 1; i <= n; i++) {             dp[i][i] = 1;             dp[i][0] = 1;             for (int j = 1; j < i; j++) {                 int num1 = Integer.parseInt(num.substring(j-1, i));                 if (num.charAt(j-1) != '0' && num1 <= 1000000) {                     dp[i][j] = (dp[i-1][j-1] + dp[i-1][j]) % mod;                 } else {                     dp[i][j] = dp[i-1][j-1];                 }             }         }                  return dp[n][n];     } } ",0,,0,0,0
"class Solution {     public int[] recoverArray(int n, int[] sums) {         int[] ans = new int[n];         Arrays.sort(sums);         List<Integer> used = new ArrayList<>();         for (int i = 0; i < n; i++) {             ans[i] = sums[2*i+1] - sums[2*i];             used.add(sums[2*i]);             used.add(sums[2*i+1]);         }         for (int x : sums) {             if (!used.contains(x)) {                 int sign = x < 0 ? -1 : 1;                 int num = Math.abs(x);                 for (int i = 0; i < n; i++) {                     if (num == ans[i]) {                         ans[i] *= sign;                         break;                     }                 }             }         }         return ans;     } }",0,,0,0,0
"class Solution {     public int numberOfUniqueGoodSubsequences(String binary) {         int mod = 1000000007;         int dp0 = 0, dp1 = 0, ans = 0;         for(char ch: binary.toCharArray()) {             if(ch == '1') {                 dp1 = (dp0 + dp1 + 1) % mod;             } else {                 dp0 = (dp0 + dp1) % mod;             }         }         ans = (dp0 + dp1) % mod;         if(binary.indexOf('0') != -1) ans++; // add 1 if the binary string contains 0         return ans;     } }",1,"1987-number-of-unique-good-subsequences/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1987-number-of-unique-good-subsequences/Solution.java:4:	UnusedAssignment:	The initializer for variable 'ans' is never used (overwritten on line 12)
",1,0,0
"import java.util.*;  class Solution {      private static final int MOD = 1000000007;     private static final int MAX_PRIME = 31;      public int numberOfGoodSubsets(int[] nums) {         int n = nums.length;         int[] primes = sieve(MAX_PRIME);          int[] cntPrimes = new int[MAX_PRIME];         for (int num : nums) {             int mask = 0;             for (int i = 0; i < primes.length; i++) {                 while (num % primes[i] == 0) {                     mask |= 1 << i;                     num /= primes[i];                 }             }             if (num > 1) continue;             cntPrimes[mask]++;         }          int[][] dp = new int[1 << primes.length][n + 1];         for (int i = 0; i < 1 << primes.length; i++) {             Arrays.fill(dp[i], -1);         }         for (int i = 0; i < primes.length; i++) {             if (cntPrimes[1 << i] > 0) {                 dp[1 << i][1] = 1;             }         }         for (int i = 2; i <= n; i++) {             for (int mask = 0; mask < 1 << primes.length; mask++) {                 if (dp[mask][i - 1] >= 0) {                     dp[mask][i] = dp[mask][i - 1];                 }                 for (int sub = mask; sub > 0; sub = (sub - 1) & mask) {                     if (dp[sub][i - 1] >= 0 && cntPrimes[mask ^ sub] > 0 && (sub & (sub - 1)) == 0) {                         long tmp = (long) dp[sub][i - 1] * cntPrimes[mask ^ sub];                         dp[mask][i] = (int) ((dp[mask][i] + tmp) % MOD);                     }                 }             }         }          int res = 0;         for (int i = 0; i < 1 << primes.length; i++) {             if (dp[i][n] >= 0) {                 long tmp = 1;                 for (int j = 0; j < primes.length; j++) {                     if (((1 << j) & i) > 0) {                         tmp = (tmp * cntPrimes[1 << j]) % MOD;                     }                 }                 res = (res + (int) ((dp[i][n] * tmp) % MOD)) % MOD;             }         }         return res;     }      private int[] sieve(int n) {         boolean[] isPrim = new boolean[n + 1];         Arrays.fill(isPrim, true);         List<Integer> primList = new ArrayList<>();         for (int i = 2; i <= n; i++) {             if (isPrim[i]) {                 primList.add(i);                 for (int j = i * 2; j <= n; j += i) {                     isPrim[j] = false;                 }             }         }         int[] primes = new int[primList.size()];         for (int i = 0; i < primes.length; i++) {             primes[i] = primList.get(i);         }         return primes;     } }",1,"1994-the-number-of-good-subsets/Solution.java:8:	NPathComplexity:	The method 'numberOfGoodSubsets(int[])' has an NPath complexity of 2520, current threshold is 200
1994-the-number-of-good-subsets/Solution.java:54:	UselessParentheses:	Useless parentheses.
1994-the-number-of-good-subsets/Solution.java:57:	UselessParentheses:	Useless parentheses.
1994-the-number-of-good-subsets/Solution.java:64:	LinguisticNaming:	Linguistics Antipattern - The variable 'isPrim' indicates linguistically it is a boolean, but it is 'boolean[]'
",0,0,0
"import java.util.*; class Solution {     public boolean gcdSort(int[] nums) {         int n = nums.length;         UnionFindSet ufs = new UnionFindSet(100001);         int[] sortedNums = Arrays.copyOf(nums, n);         Arrays.sort(sortedNums);         Map<Integer, List<Integer>> samePos = new HashMap<>();         for (int i = 0; i < n; i++) {             int num = nums[i], sortedNum = sortedNums[i];             if (num != sortedNum) {                 int p = i, q = samePos.computeIfAbsent(sortedNum, k -> new ArrayList<>()).get(0);                 if (ufs.find(num) != ufs.find(sortedNum)) {                     ufs.union(num, sortedNum);                 } else {                     for (; p != q; p = q, q = samePos.computeIfAbsent(sortedNums[p] = nums[q], k -> new ArrayList<>()).get(0)) {                         ufs.union(nums[p], nums[q]);                     }                 }             }             samePos.computeIfAbsent(num, k -> new ArrayList<>()).add(i);         }         for (int i = 0; i < n; i++) {             if (ufs.find(nums[i]) != ufs.find(sortedNums[i])) {                 return false;             }         }         return true;     }      private static class UnionFindSet {         private int[] parent;         public UnionFindSet(int n) {             parent = new int[n];             for (int i = 0; i < n; i++) parent[i] = i;         }         public void union(int x, int y) {             parent[find(x)] = find(y);         }         public int find(int x) {             if (parent[x] != x) parent[x] = find(parent[x]);             return parent[x];         }     } }",1,"1998-gcd-sort-of-an-array/Solution.java:10:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1998-gcd-sort-of-an-array/Solution.java:12:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
1998-gcd-sort-of-an-array/Solution.java:16:85: Inner assignments should be avoided. [InnerAssignment]
1998-gcd-sort-of-an-array/Solution.java:33:9: Redundant 'public' modifier. [RedundantModifier]
1998-gcd-sort-of-an-array/Solution.java:8:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
1998-gcd-sort-of-an-array/Solution.java:13:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",1,0,0
"class Solution {     public int[] smallestMissingValueSubtree(int[] parents, int[] nums) {         int n = parents.length;         int[] result = new int[n];         Arrays.fill(result, 1);     //initial value, if no missing number, then 1 will be the result.          Map<Integer, List<Integer>> tree = new HashMap<>();   //build a subtree using hash map         for (int i = 0; i < n; i++) {     //initialize each node in the tree with an empty list.             tree.put(i, new ArrayList<>());         }         //build tree from parents array         for (int i = 1; i < n; i++) {     //start from 1 because parents[0]=-1, which is the root             int parent = parents[i];             tree.get(parent).add(i);      //add the current number as a child of the parent         }          int[] smallestMissing = new int[n];         Arrays.fill(smallestMissing, 1);    //initialize smallestMissing with 1         Set<Integer> seen = new HashSet<>();         int missing = 1;        //the smallest missing number starts from 1          //process each node in a reverse level order (from bottom to top)         //to calculate the smallest missing number in its subtree         for (int i = n - 1; i >= 0; i--) {             int num = nums[i];              //if the current number is missing, then update missing and mark it as seen             if (!seen.contains(num)) {                 while (seen.contains(missing)) {    //if there are duplicate smallest numbers, skip them                     missing++;                 }                 smallestMissing[i] = missing;                 seen.add(num);             }              //update the smallest missing number recursively             for (int child : tree.get(i)) {                 smallestMissing[i] = Math.min(smallestMissing[i], smallestMissing[child]);             }         }          //calculate the result based on the smallest missing number of the parent         int min = Integer.MAX_VALUE;         for (int i = 0; i < n; i++) {             min = Math.min(min, smallestMissing[i]);             result[i] = min;         }         return result;     } }",0,,0,0,0
"class Solution {     public int minOperations(int[] nums) {         Set<Integer> set = new HashSet<>();         int max = Integer.MIN_VALUE;         int min = Integer.MAX_VALUE;                  for(int num: nums) {             set.add(num);             max = Math.max(max, num);             min = Math.min(min, num);         }                  int expectedLength = max - min + 1;         if(expectedLength == set.size()) {             return 0;         } else {             return nums.length - expectedLength;         }     } }",0,,0,0,0
"class Solution {     public String longestSubsequenceRepeatedK(String s, int k) {         int n = s.length();         HashMap<String, Integer> freq = new HashMap<>();         for (int i = 0; i < n; i++) {             // generating all subsequences of s             for (int j = i; j < n; j++) {                         String subseq = s.substring(i, j + 1);                 // check if subsequence is repeated k times                 if (checkRepeated(s, subseq, k)) {                     // update frequency of subsequence                     freq.put(subseq, freq.getOrDefault(subseq, 0) + 1);                 }             }         }         // get longest subsequence repeated k times         String ans = """";         for (String subseq : freq.keySet()) {             if (freq.get(subseq) == k) {                 if (subseq.length() > ans.length() ||                      (subseq.length() == ans.length() && subseq.compareTo(ans) > 0)) {                     ans = subseq;                 }             }         }         return ans;     }          private boolean checkRepeated(String s, String subseq, int k) {         int cur = 0; // current count of subsequence         for (int i = 0; i < s.length(); i++) {             if (s.charAt(i) == subseq.charAt(cur)) {                 cur++;                 if (cur == subseq.length()) {                     cur = 0;                     k--;                     if (k == 0) {                         return true;                     }                 }             }         }         return false;     } }",1,"2014-longest-subsequence-repeated-k-times/Solution.java:20:	CollapsibleIfStatements:	This if statement could be combined with its parent
2014-longest-subsequence-repeated-k-times/Solution.java:36:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'k'
2014-longest-subsequence-repeated-k-times/Solution.java:37:	AvoidDeeplyNestedIfStmts:	Deeply nested if..then statements are hard to read
",0,1,0
"class Solution {     public int scoreOfStudents(String s, int[] answers) {         int correctAnswer = evaluateExpression(s);         Set<Integer> possibleAnswers = getPossibleAnswers(s);         int score = 0;         for (int answer : answers) {             if (answer == correctAnswer) {                 score += 5;             } else if (possibleAnswers.contains(answer)) {                 score += 2;             }         }         return score;     }          private int evaluateExpression(String s) {         int result = 0;         int num = 0;         char operator = '+';         for (int i = 0; i < s.length(); i++) {             char c = s.charAt(i);             if (Character.isDigit(c)) {                 num = num * 10 + (c - '0');             }             if (!Character.isDigit(c) || i == s.length() - 1) {                 if (operator == '+') {                     result += num;                 } else {                     result *= num;                 }                 num = 0;                 operator = c;             }         }         return result;     }          private Set<Integer> getPossibleAnswers(String s) {         Set<Integer> possibleAnswers = new HashSet<>();         backtrack(s, 0, new StringBuilder(), possibleAnswers);         return possibleAnswers;     }          private void backtrack(String s, int index, StringBuilder sb, Set<Integer> possibleAnswers) {         if (index == s.length()) {             int answer = evaluateExpression(sb.toString());             possibleAnswers.add(answer);             return;         }         char c = s.charAt(index);         if (c == '*' || c == '+') {             backtrack(s, index + 1, sb.append(c), possibleAnswers);             sb.deleteCharAt(sb.length() - 1);         } else {             for (int i = index; i < s.length(); i++) {                 char digit = s.charAt(i);                 if (digit != '0' && (i == index || s.charAt(i - 1) != '0')) {                     sb.append(digit);                     backtrack(s, i + 1, sb, possibleAnswers);                     sb.delete(sb.length() - (i - index + 1), sb.length());                 }             }         }     } }",1,"2019-the-score-of-students-solving-math-expression/Solution.java:23:	UselessParentheses:	Useless parentheses.
",0,0,0
"class Solution {     public int waysToPartition(int[] nums, int k) {         int n = nums.length;         int[] leftSum = new int[n];         int[] rightSum = new int[n];         leftSum[0] = nums[0];         for (int i = 1; i < n; i++) {             leftSum[i] = leftSum[i - 1] + nums[i];         }         rightSum[n - 1] = nums[n - 1];         for (int i = n - 2; i >= 0; i--) {             rightSum[i] = rightSum[i + 1] + nums[i];         }         Map<Integer, Long> leftCount = new HashMap<>();         Map<Integer, Long> rightCount = new HashMap<>();         for (int i = 0; i < n - 1; i++) {             int diff = leftSum[i] - rightSum[i + 1];             if (leftCount.containsKey(diff)) {                 leftCount.put(diff, leftCount.get(diff) + 1);             } else {                 leftCount.put(diff, 1L);             }         }         int maxCount = 0;         for (Map.Entry<Integer, Long> entry : leftCount.entrySet()) {             maxCount = Math.max(maxCount, Math.toIntExact(entry.getValue()));         }         for (int i = 0; i < n; i++) {             int diff = k - nums[i];             if (leftCount.containsKey(diff)) {                 maxCount = Math.max(maxCount, Math.toIntExact(leftCount.get(diff) + (i == 0 ? 0 : 1)                      + (i == n - 1 ? 0 : rightCount.getOrDefault(-diff, 0L))));             }         }         return maxCount;     } }",0,,0,0,0
"class Solution {     public String smallestSubsequence(String s, int k, char letter, int repetition) {         int[] count = new int[26];         for (char c : s.toCharArray()) {             count[c - 'a']++;         }         PriorityQueue<Character> pq = new PriorityQueue<>((a, b) -> {             if (count[a - 'a'] == count[b - 'a']) {                 return a - b;             } else {                 return count[a - 'a'] - count[b - 'a'];             }         });         for (char c : s.toCharArray()) {             pq.add(c);         }         StringBuilder sb = new StringBuilder();         Set<Character> used = new HashSet<>();         while (sb.length() < k) {             char c = pq.poll();             if (c == letter) {                 repetition--;             }             if (!used.contains(c) && repetition <= count[c - 'a']) {                 sb.append(c);                 used.add(c);             }             if (pq.size() + sb.length() < k) {                 break;             }         }         return sb.toString();     } }",1,"2030-smallest-k-length-subsequence-with-occurrences-of-a-letter/Solution.java:22:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'repetition'
",0,1,0
"class Solution {     public int minimumDifference(int[] nums) {         int n = nums.length / 2;         int totalSum = 0;         for(int num: nums){             totalSum += num;         }                  //initializing dp[][], dp[i][j] denotes whether there exists any subset of nums[0:i] which has a sum of j         boolean[][] dp = new boolean[n + 1][totalSum / 2 + 1];         dp[0][0] = true; //empty subset has a sum of 0                  //filling in rest of dp[][]         for(int i = 1; i <= n; i++){             for(int j = 0; j <= totalSum / 2; j++){                 if(j >= nums[i - 1]){                     dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];                 } else{                     dp[i][j] = dp[i - 1][j];                 }             }         }                  //finding maximum sum that we can achieve from the first half         int maxSum = 0;         for(int i = totalSum / 2; i >= 0; i--){             if(dp[n][i]){                 maxSum = i;                 break;             }         }                  //calculating minimum difference between totalSum and double of maxSum         return Math.abs(totalSum - 2 * maxSum);     } }",0,,0,0,0
"class Solution {     public long kthSmallestProduct(int[] nums1, int[] nums2, long k) {         int n1 = nums1.length;         int n2 = nums2.length;         int neg1 = 0; // index of the first negative element in nums1         while (neg1 < n1 && nums1[neg1] < 0) {             neg1++;         }         int neg2 = 0; // index of the first negative element in nums2         while (neg2 < n2 && nums2[neg2] < 0) {             neg2++;         }         long lo = Integer.MIN_VALUE;         long hi = Integer.MAX_VALUE;         while (lo <= hi) {             long mid = lo + (hi - lo) / 2;             long count = countPairs(nums1, nums2, mid, neg1, neg2);             if (count < k) {                 lo = mid + 1;             } else {                 hi = mid - 1;             }         }         return lo;     }          private long countPairs(int[] nums1, int[] nums2, long val, int neg1, int neg2) {         long count = 0;         int pos1 = neg1; // index of the first non-negative element in nums1         for (int i = 0; i < neg2; i++) {             while (pos1 < nums1.length && (long) nums1[pos1] * nums2[i] <= val) {                 pos1++;             }             count += pos1 - neg1;         }         int pos2 = neg2; // index of the first non-negative element in nums2         for (int i = 0; i < neg1; i++) {             while (pos2 < nums2.length && (long) nums1[i] * nums2[pos2] <= val) {                 pos2++;             }             count += pos2 - neg2;         }         for (int i = neg1; i < nums1.length; i++) {             while (pos2 < nums2.length && (long) nums1[i] * nums2[pos2] <= val) {                 pos2++;             }             count += pos2 - neg2;         }         for (int i = neg2; i < nums2.length; i++) {             while (pos1 < nums1.length && (long) nums1[pos1] * nums2[i] <= val) {                 pos1++;             }             count += pos1 - neg1;         }         return count;     } }",1,"2040-kth-smallest-product-of-two-sorted-arrays/Solution.java:27:	NPathComplexity:	The method 'countPairs(int[], int[], long, int, int)' has an NPath complexity of 256, current threshold is 200
",0,0,0
"class Solution {     public int secondMinimum(int n, int[][] edges, int time, int change) {         // Create an adjacency list representation of the graph         List<List<Integer>> graph = new ArrayList<>();         for (int i = 0; i < n; i++) {             graph.add(new ArrayList<>());         }         for (int[] edge : edges) {             int u = edge[0] - 1;             int v = edge[1] - 1;             graph.get(u).add(v);             graph.get(v).add(u);         }                  // Initialize distances to infinity         int[] dist = new int[n];         Arrays.fill(dist, Integer.MAX_VALUE);                  // Initialize queue for BFS         Queue<Integer> queue = new LinkedList<>();                  // ""Start at 1, time elapsed=0""         queue.offer(0);         dist[0] = 0;         int minTime = 0;                  while (!queue.isEmpty()) {             int u = queue.poll();             for (int v : graph.get(u)) {                 // ""wait at 4 for 4 minutes""                 int waitingTime = (minTime - dist[u]) % change;                 if (waitingTime != 0) {                     waitingTime = change - waitingTime;                 }                                  // Calculate time taken to traverse edge                 int timeTaken = dist[u] + waitingTime + time;                                  if (timeTaken < dist[v]) {                     dist[v] = timeTaken;                     queue.offer(v);                 }                                  // Update minTime if possible                 if (v == n - 1) {                     minTime = dist[v];                 }             }         }                  // Find second minimum time         int secondMin = Integer.MAX_VALUE;         for (int u = 0; u < n; u++) {             for (int v : graph.get(u)) {                 int timeTaken = dist[u] + time + dist[v];                 int waitingTime = (minTime - dist[u]) % change;                 if (waitingTime != 0) {                     waitingTime = change - waitingTime;                 }                 timeTaken += waitingTime;                 if (timeTaken > minTime && timeTaken < secondMin) {                     secondMin = timeTaken;                 }             }         }                  return secondMin;     } }",1,"2045-second-minimum-time-to-reach-destination/Solution.java:2:	NPathComplexity:	The method 'secondMinimum(int, int[][], int, int)' has an NPath complexity of 320, current threshold is 200
",0,0,0
"class Solution {     public int minimumTime(int n, int[][] relations, int[] time) {         // Build the adjacency list representation of the graph         List<Integer>[] adj = new List[n];         for (int i = 0; i < n; i++) {             adj[i] = new ArrayList<>();         }         int[] inDegrees = new int[n];         for (int[] rel : relations) {             int prev = rel[0] - 1;             int next = rel[1] - 1;             adj[prev].add(next);             inDegrees[next]++;         }          // Use a priority queue to keep track of the courses that can be taken         PriorityQueue<Integer> pq = new PriorityQueue<>();         for (int i = 0; i < n; i++) {             if (inDegrees[i] == 0) {                 pq.offer(i);             }         }          // Use an array to keep track of the earliest completion time of each course         int[] earliestTime = new int[n];         Arrays.fill(earliestTime, -1);          // Process the courses in topological order         int totalTime = 0;         while (!pq.isEmpty()) {             int course = pq.poll();             earliestTime[course] = totalTime;             totalTime += time[course];             for (int next : adj[course]) {                 inDegrees[next]--;                 if (inDegrees[next] == 0) {                     pq.offer(next);                 }             }         }          // Check if there is any course that cannot be taken (i.e., has non-zero in-degree)         for (int i = 0; i < n; i++) {             if (inDegrees[i] > 0) {                 return -1;             }         }          // Return the total time needed to complete all the courses         return totalTime;     } }",0,,0,0,0
"class Solution {     public int countCombinations(String[] pieces, int[][] positions) {         int n = pieces.length;         int[][] board = new int[8][8]; // initialize empty board         for (int i = 0; i < n; i++) {             int r = positions[i][0] - 1; // convert 1-based index to 0-based index             int c = positions[i][1] - 1;             if (pieces[i].equals(""rook"")) {                 board[r][c] = 1; // mark rook's position             } else if (pieces[i].equals(""bishop"")) {                 board[r][c] = 2; // mark bishop's position             } else { // queen                 board[r][c] = 3; // mark queen's position             }         }         int count = 0; // initialize valid move combination count         for (int r1 = 0; r1 < 8; r1++) {             for (int c1 = 0; c1 < 8; c1++) {                 for (int r2 = 0; r2 < 8; r2++) {                     for (int c2 = 0; c2 < 8; c2++) {                         if (isValidMove(board, r1, c1, r2, c2)) {                             count++;                         }                     }                 }             }         }         return count;     }          private boolean isValidMove(int[][] board, int r1, int c1, int r2, int c2) {         if (board[r1][c1] == 0 || board[r2][c2] != 0) {             return false; // invalid if source is empty or destination is occupied         }         int pieceType = board[r1][c1];         if (pieceType == 1) { // rook             if (r1 != r2 && c1 != c2) {                 return false; // invalid if not moving horizontally or vertically             }             int dr = Integer.signum(r2 - r1);             int dc = Integer.signum(c2 - c1);             int r = r1 + dr;             int c = c1 + dc;             while (r != r2 || c != c2) {                 if (board[r][c] != 0) {                     return false; // invalid if any intermediate square is occupied                 }                 r += dr;                 c += dc;             }         } else if (pieceType == 2) { // bishop             if (Math.abs(r1 - r2) != Math.abs(c1 - c2)) {                 return false; // invalid if not moving diagonally             }             int dr = Integer.signum(r2 - r1);             int dc = Integer.signum(c2 - c1);             int r = r1 + dr;             int c = c1 + dc;             while (r != r2 || c != c2) {                 if (board[r][c] != 0) {                     return false; // invalid if any intermediate square is occupied                 }                 r += dr;                 c += dc;             }         } else { // queen             if (r1 == r2 || c1 == c2) { // moving horizontally or vertically                 int dr = Integer.signum(r2 - r1);                 int dc = Integer.signum(c2 - c1);                 int r = r1 + dr;                 int c = c1 + dc;                 while (r != r2 || c != c2) {                     if (board[r][c] != 0) {                         return false; // invalid if any intermediate square is occupied                     }                     r += dr;                     c += dc;                 }             } else if (Math.abs(r1 - r2) == Math.abs(c1 - c2)) { // moving diagonally                 int dr = Integer.signum(r2 - r1);                 int dc = Integer.signum(c2 - c1);                 int r = r1 + dr;                 int c = c1 + dc;                 while (r != r2 || c != c2) {                     if (board[r][c] != 0) {                         return false; // invalid if any intermediate square is occupied                     }                     r += dr;                     c += dc;                 }             } else {                 return false; // invalid if not moving horizontally, vertically, or diagonally             }         }         return true;     } }",1,"2056-number-of-valid-move-combinations-on-chessboard/Solution.java:8:	LiteralsFirstInComparisons:	Position literals first in String comparisons
2056-number-of-valid-move-combinations-on-chessboard/Solution.java:10:	LiteralsFirstInComparisons:	Position literals first in String comparisons
",0,0,0
"class Solution {     public boolean possiblyEquals(String s1, String s2) {         return getOriginalStrings(s1).contains(getOriginalStrings(s2));     }          private Set<String> getOriginalStrings(String s) {         Set<String> originalStrings = new HashSet<>();         originalStrings.add(s);         for (int i = 0; i < s.length(); i++) {             for (int j = i + 1; j <= s.length(); j++) {                 String substring = s.substring(i, j);                 if (substring.matches(""[a-z]+"")) {                     continue;                 }                 Set<String> newOriginalStrings = new HashSet<>();                 for (String originalString : originalStrings) {                     String[] substrings = originalString.split(substring);                     if (substrings.length > 1) {                         StringBuilder builder = new StringBuilder();                         for (String s : substrings) {                             builder.append(s.length() > 0 ? s.length() : substring);                             builder.append(substring);                         }                         builder.setLength(builder.length() - substring.length());                         newOriginalStrings.add(builder.toString());                     } else {                         newOriginalStrings.add(originalString);                     }                 }                 originalStrings = newOriginalStrings;             }         }         return originalStrings;     } }",1,"2060-check-if-an-original-string-exists-given-two-encoded-strings/Solution.java:21:	ConsecutiveAppendsShouldReuse:	StringBuffer (or StringBuilder).append is called consecutively without reusing the target variable.
",0,0,0
"import java.util.*;  class Solution {     public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {         int n = values.length;          // create the graph         List<List<int[]>> graph = new ArrayList<>();         for (int i = 0; i < n; i++) {             graph.add(new ArrayList<>());         }         for (int[] edge : edges) {             int u = edge[0];             int v = edge[1];             int time = edge[2];             graph.get(u).add(new int[]{v, time});             graph.get(v).add(new int[]{u, time});         }          PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);         pq.add(new int[]{0, 0}); // node 0 with distance 0          int[] maxQuality = new int[n];         Arrays.fill(maxQuality, -1);         maxQuality[0] = values[0];          boolean[] visited = new boolean[n];          while (!pq.isEmpty()) {             int[] curr = pq.poll();             int node = curr[0];             int currTime = curr[1];              if (visited[node]) {                 continue;             }             visited[node] = true;              for (int[] neighbor : graph.get(node)) {                 int nextNode = neighbor[0];                 int nextTime = currTime + neighbor[1];                  if (nextTime > maxTime) {                     continue;                 }                  int quality = maxQuality[node];                 if (values[nextNode] > 0) {                     quality += values[nextNode];                 }                  if (maxQuality[nextNode] < quality) {                     maxQuality[nextNode] = quality;                 }                  pq.add(new int[]{nextNode, nextTime});             }         }          return maxQuality[0];     } }",1,"2065-maximum-path-quality-of-a-graph/Solution.java:20:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
",0,0,0
"class Solution {     public int maxTaskAssign(int[] tasks, int[] workers, int pills, int strength) {         int assignedTasks = 0;         boolean[] assigned = new boolean[tasks.length];                  // Sort the tasks and workers array in descending order         Arrays.sort(tasks);         Arrays.sort(workers);         reverseArray(tasks);         reverseArray(workers);                  // Assign tasks to workers with strength greater than or equal to task strength         for (int i = 0; i < workers.length; i++) {             for (int j = 0; j < tasks.length; j++) {                 if (!assigned[j] && workers[i] >= tasks[j]) {                     assignedTasks++;                     assigned[j] = true;                     break;                 }             }         }                  // Use at most pills to increase worker strength and assign remaining tasks         for (int i = 0; i < pills && assignedTasks < tasks.length; i++) {             for (int j = 0; j < workers.length; j++) {                 if (workers[j] < strength) {                     workers[j] += strength;                     for (int k = 0; k < tasks.length; k++) {                         if (!assigned[k] && workers[j] >= tasks[k]) {                             assignedTasks++;                             assigned[k] = true;                             break;                         }                     }                     break;                 }             }         }                  return assignedTasks;     }          public void reverseArray(int[] arr) {         int i = 0, j = arr.length - 1;         while (i < j) {             int temp = arr[i];             arr[i] = arr[j];             arr[j] = temp;             i++;             j--;         }     } }",1,"2071-maximum-number-of-tasks-you-can-assign/Solution.java:44:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2071-maximum-number-of-tasks-you-can-assign/Solution.java:13:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",1,0,1
"class Solution {     public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {         // Create a adjacency matrix for checking if two people can become friends directly         boolean[][] canBeFriends = new boolean[n][n];         for (int i = 0; i < n; i++) {             Arrays.fill(canBeFriends[i], true);         }         for (int[] r : restrictions) {             canBeFriends[r[0]][r[1]] = false;             canBeFriends[r[1]][r[0]] = false;         }                  // Create a adjacency list for indirect friendship checks         List<List<Integer>> adjList = new ArrayList<>();         for (int i = 0; i < n; i++) {             adjList.add(new ArrayList<>());         }         for (int[] r : restrictions) {             adjList.get(r[0]).add(r[1]);             adjList.get(r[1]).add(r[0]);         }                  // Process the friend requests         boolean[] result = new boolean[requests.length];         for (int i = 0; i < requests.length; i++) {             int u = requests[i][0];             int v = requests[i][1];             if (canBeFriends[u][v]) {                 result[i] = true;                 canBeFriends[u][v] = false;                 canBeFriends[v][u] = false;                 for (Integer friend : adjList.get(u)) {                     if (canBeFriends[friend][v]) {                         adjList.get(friend).add(v);                         adjList.get(v).add(friend);                     }                     if (canBeFriends[friend][u]) {                         adjList.get(friend).add(v);                         adjList.get(v).add(friend);                     }                 }                 for (Integer friend : adjList.get(v)) {                     if (canBeFriends[friend][u]) {                         adjList.get(friend).add(u);                         adjList.get(u).add(friend);                     }                     if (canBeFriends[friend][v]) {                         adjList.get(friend).add(u);                         adjList.get(u).add(friend);                     }                 }             }         }         return result;     } }",1,"2076-process-restricted-friend-requests/Solution.java:2:	NPathComplexity:	The method 'friendRequests(int, int[][], int[][])' has an NPath complexity of 432, current threshold is 200
2076-process-restricted-friend-requests/Solution.java:4:	LinguisticNaming:	Linguistics Antipattern - The variable 'canBeFriends' indicates linguistically it is a boolean, but it is 'boolean[][]'
",0,0,0
"class Solution {     public long kMirror(int k, int n) {         int count = 0; // Keep track of the number of k-mirror numbers found         long sum = 0; // Keep track of the sum of k-mirror numbers found         int num = 1; // Start with number 1         while(count < n) { // Keep looping until n k-mirror numbers are found             if(isKMirror(num, k)) { // Check if num is a k-mirror number                 count++; // If it is, increment the count and add it to the sum                 sum += num;             }             num++; // Increment the number to check the next one         }         return sum;     }          // Helper method to check if a number is a k-mirror number     private boolean isKMirror(int num, int k) {         String base10 = String.valueOf(num); // Convert num to base-10 string         String baseK = convertToBaseK(num, k); // Convert num to base-k string         return base10.equals(new StringBuilder(base10).reverse().toString()) && baseK.equals(new StringBuilder(baseK).reverse().toString());         // Return true if both base-10 and base-k representations are palindromic     }          // Helper method to convert a number to base-k string     private String convertToBaseK(int num, int k) {         StringBuilder sb = new StringBuilder(); // Use StringBuilder for efficiency         while(num >= k) { // Keep dividing the number by k until it is less than k             sb.append(num % k); // Append the remainder to the string             num /= k;         }         sb.append(num); // Append the last quotient to the string         return sb.reverse().toString(); // Reverse the string and return it     } }",1,"2081-sum-of-k-mirror-numbers/Solution.java:29:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'num'
",0,1,0
class Solution {          public int countPyramids(int[][] grid) {                  int m = grid.length;         int n = grid[0].length;                  int count = 0;                  // Checking for pyramids         for(int r = 0; r < m-1; r++) {             for(int c = 0; c < n; c++) {                                  if(grid[r][c] == 1) {                                          int h = 0;                     int countCells = 0;                                          while(r+h < m && c-h >= 0 && c+h < n && grid[r+h][c-h] == 1 && grid[r+h][c+h] == 1) {                         countCells += (2*h + 1);                         h++;                     }                                          count += (countCells > 1) ? 1 : 0;                                      }                              }         }                  // Checking for inverse pyramids         for(int r = m-1; r > 0; r--) {             for(int c = 0; c < n; c++) {                                  if(grid[r][c] == 1) {                                          int h = 0;                     int countCells = 0;                                          while(r-h >= 0 && c-h >= 0 && c+h < n && grid[r-h][c-h] == 1 && grid[r-h][c+h] == 1) {                         countCells += (2*h + 1);                         h++;                     }                                          count += (countCells > 1) ? 1 : 0;                                      }                              }         }                  return count;              }    },1,"2088-count-fertile-pyramids-in-a-land/Solution.java:3:	NPathComplexity:	The method 'countPyramids(int[][])' has an NPath complexity of 225, current threshold is 200
",0,0,0
"import java.util.*;  class Solution {     public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {         Map<Integer, List<int[]>> meetingsMap = new HashMap<>();  // mapping each time to its meetings         Set<Integer> secretSet = new HashSet<>();  // set of people who have the secret         secretSet.add(0);  // initializing the set with person 0 who initially has the secret         Queue<Integer> queue = new LinkedList<>(Collections.singleton(0));  // queue of people who have the secret and ready to share it                  for (int[] meeting : meetings) {             meetingsMap.computeIfAbsent(meeting[2], k -> new ArrayList<>()).add(new int[]{meeting[0], meeting[1]});         }                  while (!queue.isEmpty()) {             int currPerson = queue.poll();             int currTime = secretSet.size();  // to keep track of the time when the secret was shared with this person                          if (meetingsMap.containsKey(currTime)) {  // if there are meetings at this time                 for (int[] meeting : meetingsMap.get(currTime)) {                     if (meeting[0] == currPerson && !secretSet.contains(meeting[1])) {                         secretSet.add(meeting[1]);                         queue.offer(meeting[1]);                     } else if (meeting[1] == currPerson && !secretSet.contains(meeting[0])) {                         secretSet.add(meeting[0]);                         queue.offer(meeting[0]);                     }                 }             }         }                  List<Integer> result = new ArrayList<>(secretSet);         Collections.sort(result);         return result;     } }",1,"2092-find-all-people-with-secret/Solution.java:5:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
",0,0,0
"class Solution {     public int[][] validArrangement(int[][] pairs) {                  // create a map to store the pairs with start index as key         Map<Integer, int[]> map = new HashMap<>();         for (int[] pair : pairs) {             map.put(pair[0], pair);         }                  // create the result array         int[][] result = new int[pairs.length][2];                  // start building the result array starting from a random pair         int[] currentPair = pairs[0];         result[0] = currentPair;                  // iterate through the rest of the pairs         for (int i = 1; i < pairs.length; i++) {             int[] nextPair = map.get(currentPair[1] - 1);             result[i] = nextPair;             currentPair = nextPair;         }                  // return the result array         return result;     } }",0,,0,0,0
"import java.util.*;  class SORTracker {          private Map<String, Integer> locations;     private List<Map.Entry<String, Integer>> sortedLocations;     private int queryCount;      public SORTracker() {         this.locations = new HashMap<>();         this.sortedLocations = new ArrayList<>();         this.queryCount = 0;     }          public void add(String name, int score) {         if (!locations.containsKey(name)) {             locations.put(name, score);             sortedLocations.add(new AbstractMap.SimpleEntry<>(name, score));             Collections.sort(sortedLocations, (a, b) -> {                 if (a.getValue().equals(b.getValue())) {                     return a.getKey().compareTo(b.getKey());                 } else {                     return b.getValue() - a.getValue();                 }             });         } else {             locations.put(name, score);             int index = -1;             for (int i = 0; i < sortedLocations.size(); i++) {                 if (sortedLocations.get(i).getKey().equals(name)) {                     index = i;                     break;                 }             }             if (index >= 0) {                 sortedLocations.remove(index);             }             sortedLocations.add(new AbstractMap.SimpleEntry<>(name, score));             Collections.sort(sortedLocations, (a, b) -> {                 if (a.getValue().equals(b.getValue())) {                     return a.getKey().compareTo(b.getKey());                 } else {                     return b.getValue() - a.getValue();                 }             });         }     }          public String get() {         String result = sortedLocations.get(queryCount).getKey();         queryCount++;         return result;     } }  /**  * Your SORTracker object will be instantiated and called as such:  * SORTracker obj = new SORTracker();  * obj.add(name,score);  * String param_2 = obj.get();  */",1,"2102-sequentially-ordinal-rank-tracker/SORTracker.java:9:5: Redundant 'public' modifier. [RedundantModifier]
2102-sequentially-ordinal-rank-tracker/SORTracker.java:16:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",0,0,0
"class Solution {     public int maxTotalFruits(int[][] fruits, int startPos, int k) {         int n = fruits.length;         int maxFruits = 0;         int left = startPos, right = startPos;         int currFruits = 0;         Map<Integer, Integer> basket = new HashMap<>();                  while (right < n) {             int newPosition = fruits[right][0];             int newFruits = fruits[right][1];                          if (!basket.containsKey(newPosition)) {                 while (basket.size() == 2) {                     int oldPosition = fruits[left][0];                     int oldFruits = fruits[left][1];                     basket.put(oldPosition, basket.get(oldPosition) - 1);                     if (basket.get(oldPosition) == 0) {                         basket.remove(oldPosition);                     }                     left++;                 }             }                          if (basket.containsKey(newPosition)) {                 basket.put(newPosition, basket.get(newPosition) + newFruits);             } else {                 basket.put(newPosition, newFruits);             }                          currFruits += newFruits;             maxFruits = Math.max(maxFruits, currFruits);                          right++;                          if (right - left > k) {                 int oldPosition = fruits[left][0];                 int oldFruits = fruits[left][1];                 basket.put(oldPosition, basket.get(oldPosition) - 1);                 if (basket.get(oldPosition) == 0) {                     basket.remove(oldPosition);                 }                 currFruits -= oldFruits;                 left++;             }         }                  return maxFruits;     } }",1,"2106-maximum-fruits-harvested-after-at-most-k-steps/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2106-maximum-fruits-harvested-after-at-most-k-steps/Solution.java:16:	UnusedLocalVariable:	Avoid unused local variables such as 'oldFruits'.
",1,0,0
"class Solution {     public int kIncreasing(int[] arr, int k) {         int n = arr.length;         int[] dp = new int[n]; // dp[i] stores the minimum number of operations required for the subarray ending at index i         int operations = 0; // total number of operations required                  for (int i = 0; i < n; i++) {             int minPrev = Integer.MAX_VALUE; // minimum element in the previous k elements                          // check if we have k elements to the left             if (i >= k) {                 // exclude elements that are more than k positions away                 for (int j = 1; j <= k; j++) {                     minPrev = Math.min(minPrev, arr[i - j]);                 }             } else {                 // if we don't have enough elements to the left, consider all of them                 for (int j = 0; j < i; j++) {                     minPrev = Math.min(minPrev, arr[j]);                 }             }                          if (arr[i] <= minPrev) {                 // no operation needed                 dp[i] = 0;             } else {                 // need to update element at index i                 operations += (arr[i] - minPrev);                                  if (i >= k) {                     // need to subtract the difference between arr[i-k] and minPrev                     // because it will be counted twice (i.e., already accounted for when we processed arr[i-k])                     operations -= (arr[i-k] - minPrev);                 }             }                          // add the number of operations required for previous subarray             // to get the number of operations required for the current subarray             dp[i] += (i > 0) ? dp[i-1] : 0;             dp[i] += operations;         }                  return dp[n-1];     } }",0,,0,0,0
"class Solution {     public String abbreviateProduct(int left, int right) {         long product = 1;         int zeros = 0;         for (int i = left; i <= right; i++) {             product *= i;             // Count trailing zeros             while (product % 10 == 0) {                 zeros++;                 product /= 10;             }             // Keep only last 10 digits             product %= 10000000000L;         }         String pre = Long.toString(product);         String suf = """";         int d = pre.length() + zeros;         // Abbreviate if d > 10         if (d > 10) {             suf = pre.substring(d - 5);             pre = pre.substring(0, 5);         }         String res = pre + suf;         if (zeros > 0) {             res += ""e"" + zeros;         }         return res;     } }",0,,0,0,0
"import java.util.ArrayList; import java.util.List;  class Solution {     private static final int[][] DIRECTIONS = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};          public List<String> findWords(char[][] board, String[] words) {         Trie trie = new Trie();         for (String word : words) {             trie.insert(word);         }                  int rows = board.length, cols = board[0].length;         List<String> result = new ArrayList<>();         boolean[][] visited = new boolean[rows][cols];         StringBuilder sb = new StringBuilder();          for (int i = 0; i < rows; i++) {             for (int j = 0; j < cols; j++) {                 backtrack(board, visited, trie.getRoot(), i, j, sb, result);             }         }                  return result;     }          private void backtrack(char[][] board, boolean[][] visited, TrieNode trieNode, int i, int j, StringBuilder sb, List<String> result) {         if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || visited[i][j]) {             return;         }         char c = board[i][j];         TrieNode nextNode = trieNode.getNext(c);         if (nextNode == null) {             return;         }                  visited[i][j] = true;         sb.append(c);         if (nextNode.isWord()) {             result.add(sb.toString());             nextNode.setWord(false);         }          for (int[] dir : DIRECTIONS) {             backtrack(board, visited, nextNode, i + dir[0], j + dir[1], sb, result);         }          sb.deleteCharAt(sb.length() - 1);         visited[i][j] = false;     } }  class Trie {     private TrieNode root;      Trie() {         root = new TrieNode();     }          TrieNode getRoot() {         return root;     }          void insert(String word) {         TrieNode currNode = root;         for (char c : word.toCharArray()) {             currNode = currNode.getNext(c);         }         currNode.setWord(true);     } }  class TrieNode {     private static final int ALPHABET_SIZE = 26;     private TrieNode[] links;     private boolean isWord;      TrieNode() {         links = new TrieNode[ALPHABET_SIZE];     }          TrieNode getNext(char c) {         int index = c - 'a';         if (links[index] == null) {             links[index] = new TrieNode();         }         return links[index];     }          void setWord(boolean isWord) {         this.isWord = isWord;     }          boolean isWord() {         return isWord;     } }",1,"212-word-search-ii/Solution.java:13:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
212-word-search-ii/Solution.java:90:26: 'isWord' hides a field. [HiddenField]
212-word-search-ii/Solution.java:76:	AvoidFieldNameMatchingMethodName:	Field isWord has the same name as a method
",1,0,0
"class Solution {     public int[] recoverArray(int[] nums) {         int n = nums.length / 2;         Arrays.sort(nums);         Map<Integer, Integer> freq = new HashMap<>();         List<Integer> lower = new ArrayList<>();         List<Integer> higher = new ArrayList<>();         for (int num : nums) {             freq.put(num, freq.getOrDefault(num, 0) + 1);             if (freq.get(num) > n) {                 lower.add(num);                 higher.add(num);             } else if (!lower.contains(num - lower.get(0))) {                 lower.add(num - lower.get(0));             } else {                 higher.add(num - lower.get(0));             }         }         int[] arr = new int[n];         int idx = 0;         for (int num : lower) {             arr[idx++] = num;         }         for (int num : higher) {             arr[idx++] = num;         }         return arr;     } }",1,"2122-recover-the-original-array/Solution.java:13:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",0,0,0
"class Solution {     public int maximumInvitations(int[] favorite) {         int n = favorite.length;         boolean[] visited = new boolean[n];         int ans = 0;                  for (int i = 0; i < n; i++) {             if (!visited[i]) {                 int j = i;                 int cnt = 0;                 boolean[] seat = new boolean[n];                                  // finding the largest match                 while (!visited[j] && !seat[favorite[j]]) {                     visited[j] = true;                     cnt++;                     seat[favorite[j]] = true;                                          // moving to the next position in circular table                     j = (j + 1) % n;                 }                                  ans = Math.max(ans, cnt);             }         }                  return ans;     } }",0,,0,0,0
"class Solution {     public boolean possibleToStamp(int[][] grid, int stampHeight, int stampWidth) {         int m = grid.length, n = grid[0].length;          boolean[][] visited = new boolean[m][n]; // to keep track of each cell that is stamped         boolean stamped; // to check if we have stamped any cell in a pass          while (true) {             stamped = false;             // iterate over each cell in grid and try to stamp it             for (int i = 0; i <= m - stampHeight; i++) {                 for (int j = 0; j <= n - stampWidth; j++) {                     if (grid[i][j] == 0 && canStamp(grid, visited, i, j, stampHeight, stampWidth)) {                         stamp(grid, visited, i, j, stampHeight, stampWidth);                         stamped = true;                     }                 }             }             if (!stamped) { // if no cells were stamped in a pass, break out of loop                 break;             }         }          // check if all cells have been visited         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 if (grid[i][j] == 0 && !visited[i][j]) {                     return false;                 }             }         }         return true;     }      private void stamp(int[][] grid, boolean[][] visited, int row, int col, int sH, int sW) {         for (int i = row; i < row + sH; i++) {             for (int j = col; j < col + sW; j++) {                 visited[i][j] = true;                 grid[i][j] = 1;             }         }     }      private boolean canStamp(int[][] grid, boolean[][] visited, int row, int col, int sH, int sW) {         for (int i = row; i < row + sH; i++) {             for (int j = col; j < col + sW; j++) {                 if (grid[i][j] == 1 || visited[i][j]) {                     return false;                 }             }         }         return true;     } }",1,"2132-stamping-the-grid/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int earliestFullBloom(int[] plantTime, int[] growTime) {         int n = plantTime.length;                  // function to check if all flowers have bloomed on a given day         // using binary search to optimize the time complexity         // we can check if all flowers will bloom on day k or not                  boolean allFlowersHaveBloomed(int k) {             int[] blooming = new int[n]; // array to maintain the bloom time for each flower                          // calculate the bloom time for each flower             for (int i = 0; i < n; i++) {                 if (k >= plantTime[i]) {                     int bloomTime = k + growTime[i];                     if (bloomTime > k) {                         blooming[i] = bloomTime;                     }                 }             }                          Arrays.sort(blooming); // sort the bloom time array                          // check if all flowers have bloomed by comparing each bloom time with the previous one             for (int i = 1; i < n; i++) {                 if (blooming[i] < blooming[i - 1]) {                     return false;                 }             }                          return true;         }                  // binary search to find the earliest day when all flowers have bloomed         int left = 0, right = 100000; // right is set to the maximum bloom time         while (left < right) {             int mid = left + (right - left) / 2;             if (allFlowersHaveBloomed(mid)) {                 right = mid;             } else {                 left = mid + 1;             }         }                  return right; // return the earliest day when all flowers have bloomed     } }",1,"2136-earliest-possible-day-of-full-bloom/Solution.java	-	ParseException: Parse exception in file '2136-earliest-possible-day-of-full-bloom/Solution.java': Encountered ""("" at line 9, column 38.
",0,0,0
"class Solution {     public String shortestPalindrome(String s) {         int n = s.length();         if(n == 0){             return s;         }         StringBuilder sb = new StringBuilder(s);         String rev = sb.reverse().toString();         for(int i = 0; i < n; i++){             if(s.substring(0, n - i).equals(rev.substring(i))){                 return rev.substring(0, i) + s;             }         }         return rev + s;     } }",0,,0,0,0
"class Solution {     public long maxRunTime(int n, int[] batteries) {         // Initialize left and right pointers         int left = 0;         int right = 0;                  // Initialize maxMinutes to 0         long maxMinutes = 0;                  // Initialize totalMinutes to the sum of all batteries         long totalMinutes = 0;         for(int i = 0; i < batteries.length; i++) {             totalMinutes += batteries[i];         }                  // Loop through all the batteries         while(right < batteries.length) {             // If you can currently run all the computers simultaneously             if(2 * Math.min(batteries[left], batteries[right]) <= totalMinutes) {                 // Update maxMinutes if possible                 maxMinutes = Math.max(maxMinutes, Math.min(batteries[left], batteries[right]));                                  // Move the left pointer to the right                 left++;             }             // If you can't currently run all the computers simultaneously             else {                 // Move the right pointer to the right                 right++;             }         }                  return maxMinutes;     } }",1,"2141-maximum-running-time-of-n-computers/Solution.java:25:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2141-maximum-running-time-of-n-computers/Solution.java:12:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int numberOfWays(String corridor) {         int n = corridor.length();         int mod = 1000000007;                  // Count number of S's and P's         int numSeats = 0, numPlants = 0;         for (int i = 0; i < n; i++) {             if (corridor.charAt(i) == 'S') {                 numSeats++;             } else {                 numPlants++;             }         }                  // If there are no seats or only one seat, cannot divide into sections         if (numSeats <= 1) {             return 0;         }                  // Calculate the number of ways to install dividers         long ways = 1;         for (int i = 1; i < numSeats; i++) {             ways = (ways * (numPlants - i + 1)) % mod;             ways = (ways * modInverse(i)) % mod;         }                  return (int) ways;     }          // Calculate modular inverse using extended Euclidean algorithm     // (Assumes mod is prime)     private int modInverse(int x) {         int mod = 1000000007;         int y = mod - 2;         int res = 1;         while (y > 0) {             if (y % 2 == 1) {                 res = (res * x) % mod;             }             x = (x * x) % mod;             y /= 2;         }         return res;     } }",1,"2147-number-of-ways-to-divide-a-long-corridor/Solution.java:7:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2147-number-of-ways-to-divide-a-long-corridor/Solution.java:4:	PrematureDeclaration:	Declaration of 'mod' can be moved closer to its usages
2147-number-of-ways-to-divide-a-long-corridor/Solution.java:24:	UselessParentheses:	Useless parentheses.
2147-number-of-ways-to-divide-a-long-corridor/Solution.java:25:	UselessParentheses:	Useless parentheses.
2147-number-of-ways-to-divide-a-long-corridor/Solution.java:39:	UselessParentheses:	Useless parentheses.
2147-number-of-ways-to-divide-a-long-corridor/Solution.java:41:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'x'
2147-number-of-ways-to-divide-a-long-corridor/Solution.java:41:	UselessParentheses:	Useless parentheses.
",1,1,0
"class Solution {     public int maximumGood(int[][] statements) {         int n = statements.length;         int[] people = new int[n]; // 0 for bad, 1 for good, 2 for undecided                  // Check each person as the key         for (int k = 0; k < n; k++) {             // Assume that the key person is good and check for contradictions             boolean isGood = true;             for (int i = 0; i < n; i++) {                 if (i == k) continue;                 int statement = statements[i][k];                 if (statement == 0 && people[i] == 1) {                     // Contradiction: person i said key person k is bad but k is assumed to be good                     isGood = false;                     break;                 } else if (statement == 1 && people[i] == 0) {                     // Contradiction: person i said key person k is good but k is assumed to be bad                     isGood = false;                     break;                 } else if (statement == 2) {                     // No information, skip                     continue;                 }             }             if (isGood) {                 // Assuming key person is good, update people array accordingly                 for (int i = 0; i < n; i++) {                     if (i == k) continue;                     int statement = statements[k][i];                     if (statement == 0) {                         // Key person said person i is bad, thus i must be bad                         people[i] = 0;                     } else if (statement == 1) {                         // Key person said person i is good, thus i must be good                         people[i] = 1;                     }                 }             } else {                 // Assuming key person is bad, update people array accordingly                 for (int i = 0; i < n; i++) {                     if (i == k) continue;                     int statement = statements[k][i];                     if (statement == 0) {                         // Key person said person i is bad, no new information                     } else if (statement == 1) {                         // Key person said person i is good, thus k must be lying and i is good                         people[i] = 1;                     }                 }                 people[k] = 0; // Key person is bad             }         }                  // Count the number of good people         int count = 0;         for (int i = 0; i < n; i++) {             if (people[i] == 1) count++;         }         return count;     } }",1,"2151-maximum-good-people-based-on-statements/Solution.java:44:41: Must have at least one statement. [EmptyBlock]
2151-maximum-good-people-based-on-statements/Solution.java:2:	NPathComplexity:	The method 'maximumGood(int[][])' has an NPath complexity of 549, current threshold is 200
2151-maximum-good-people-based-on-statements/Solution.java:44:	EmptyControlStatement:	Empty if statement
",0,0,0
"class Solution {     public String subStrHash(String s, int power, int modulo, int k, int hashValue) {         int n = s.length();         int p = power;         int m = modulo;         int K = k;         int h = hashValue;                  // Loop through all substrings of size k         for (int i = 0; i <= n - K; i++) {             String sub = s.substring(i, i + K);             int val = 0;             int mult = 1;                          // Compute hash of substring             for (int j = K - 1; j >= 0; j--) {                 int c = sub.charAt(j) - 'a' + 1;                 val = (val + c * mult) % m;                 mult = (mult * p) % m;             }                          // Check if hash matches specified value             if (val == h) {                 return sub;             }         }                  // Should never happen since there is always a solution         return """";     } }",1,"2156-find-substring-with-given-hash-value/Solution.java:19:	UselessParentheses:	Useless parentheses.
",0,0,0
"class Solution {     public int[] groupStrings(String[] words) {         Map<String, List<String>> groups = new HashMap<>();         for (String word : words) {             String code = getCode(word);             if (!groups.containsKey(code)) {                 groups.put(code, new ArrayList<>());             }             groups.get(code).add(word);         }         int maxGroupSize = 0;         for (List<String> group : groups.values()) {             maxGroupSize = Math.max(maxGroupSize, group.size());         }         return new int[]{groups.size(), maxGroupSize};     }      private String getCode(String word) {         int offset = word.charAt(0) - 'a';         StringBuilder sb = new StringBuilder();         for (int i = 0; i < word.length(); i++) {             char c = (char) (word.charAt(i) - offset);             if (c < 'a') {                 c += 26;             }             sb.append(c);         }         return sb.toString();     } }",0,,0,0,0
"class Solution {     public long minimumDifference(int[] nums) {         int n = nums.length / 3;         Arrays.sort(nums); // sorting elements to remove minimum elements later to minimize the difference in sums         long diff = Long.MAX_VALUE;         long sum = 0;         long[] prefixSum = new long[3 * n + 1];         for (int i = 1; i <= 3 * n; i++)             prefixSum[i] = prefixSum[i - 1] + nums[i - 1];          for (int i = n; i <= 2 * n; i++) { // taking subsequence of n elements from nums and checking this condition for each of the n elements subsequence             // (prefixSum[i]-prefixSum[i-n]) takes the sum of i-n to i, prefixSum[3*n]-prefixSum[2*n-i] takes the sum from i to 3*n-1             // Total sum = prefixSum[3*n]- prefixSum[i]+(prefixSum[i]-prefixSum[i-n]) = prefixSum[3*n] - prefixSum[i-n] which is equal to sum of removed n elements             sum = prefixSum[3 * n] - prefixSum[i] + prefixSum[i-n];             diff = Math.min(diff, Math.abs(sum - (prefixSum[3 * n] - sum)));         }         return diff;     } }",1,"2163-minimum-difference-in-sums-after-removal-of-elements/Solution.java:6:	UnusedAssignment:	The initializer for variable 'sum' is never used (overwritten on line 14)
",0,0,0
"class Solution {     public int minimumTime(String s) {         int n = s.length();         int left = 0, right = n-1;         int ans = 0;         while (left < right) {             if (s.charAt(left) == '0') {                 ++left;             }             else if (s.charAt(right) == '0') {                 --right;             }             else {                 ++left;                 --right;                 ans += 2;             }         }         if (s.charAt(left) == '1') {             ++ans;         }         return ans;     } }",1,"2167-minimum-time-to-remove-all-cars-containing-illegal-goods/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2167-minimum-time-to-remove-all-cars-containing-illegal-goods/Solution.java:9:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2167-minimum-time-to-remove-all-cars-containing-illegal-goods/Solution.java:12:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",1,0,0
"class Solution {     public int maximumANDSum(int[] nums, int numSlots) {         int n = nums.length;         int maxAndSum = 0;         for(int i=0; i<n; i++) {             int countPos = (1<<((int)(Math.log(nums[i])/Math.log(2))))+1;             int c=0, tempAns=0;             for(int j=countPos; j>=1; j>>=1) {                 if((c==0 && (j&numSlots)!=0) || (c==1 && j<=nums[i])) {                     tempAns += j;                     c = 1 - c;                 }             }             maxAndSum += nums[i] & tempAns;         }         return maxAndSum;     } }",1,"2172-maximum-and-sum-of-array/Solution.java:7:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public long goodTriplets(int[] nums1, int[] nums2) {         int n = nums1.length;         long count = 0;          //iterating through all the possible triplet combinations and checking the conditions         for (int i = 0; i < n; i++) {             for (int j = i + 1; j < n; j++) {                 for (int k = j + 1; k < n; k++) {                     if (nums1[i] < nums1[j] && nums1[j] < nums1[k] && nums2[i] < nums2[j] && nums2[j] < nums2[k])                         count++;                 }             }         }         return count;     } }",0,,0,0,0
"import java.util.*;  class Solution {     public List<List<Integer>> getSkyline(int[][] buildings) {         List<List<Integer>> skyline = new ArrayList<>();         List<int[]> criticalPoints = new ArrayList<>();          // Add all critical points (start and end points) to a list         for (int[] building : buildings) {             criticalPoints.add(new int[] {building[0], -building[2]});             criticalPoints.add(new int[] {building[1], building[2]});         }          // Sort the critical points by their x-coordinate         Collections.sort(criticalPoints, (a, b) -> {             if (a[0] != b[0]) {                 return a[0] - b[0];             } else {                 return a[1] - b[1];             }         });          // Use a priority queue to keep track of the maximum height at each x-coordinate         PriorityQueue<Integer> heightQueue = new PriorityQueue<>(Collections.reverseOrder());         heightQueue.offer(0);         int maxHeight = 0;          // Add key points to the skyline whenever there is a change in the maximum height         for (int[] point : criticalPoints) {             if (point[1] < 0) {                 heightQueue.offer(-point[1]);             } else {                 heightQueue.remove(point[1]);             }              int currHeight = heightQueue.peek();             if (currHeight != maxHeight) {                 skyline.add(Arrays.asList(point[0], currHeight));                 maxHeight = currHeight;             }         }          return skyline;     } }",1,"218-the-skyline-problem/Solution.java:16:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
218-the-skyline-problem/Solution.java:24:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
",0,0,0
"class Solution {     public long countPairs(int[] nums, int k) {         int n = nums.length;         int[] freq = new int[k];         for (int i = 0; i < n; i++) {             freq[nums[i] % k]++;         }         long count = 0;         for (int i = 0; i < k; i++) {             if (freq[i] == 0) continue;             int j = (k - i) % k;             if (j == i) {                 count += freq[i] * (freq[i] - 1L) / 2;             } else if (j < i || freq[j] == 0) {                 continue;             } else {                 count += (long) freq[i] * freq[j];             }         }         return count;     } }",0,,0,0,0
"class Solution {     public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {         int n = tires.length;         int[][] dp = new int[n][numLaps + 1];         for (int i = 0; i < n; i++) {             Arrays.fill(dp[i], Integer.MAX_VALUE / 3);             dp[i][0] = 0;         }         for (int j = 1; j < numLaps + 1; j++) {             for (int i = 0; i < n; i++) {                 for (int k = 0; k < n; k++) {                     int wait = i == k ? 0 : changeTime;                     dp[i][j] = Math.min(dp[i][j], dp[k][j - 1] + wait + wires[i][0] * wires[i][1] * (j - 1));                 }             }         }         int ans = Integer.MAX_VALUE/3;         for (int i = 0; i < n; i++) {             ans = Math.min(ans, dp[i][numLaps] + wires[i][0] * wires[i][1] * numLaps);         }         return ans;     } }",0,,0,0,0
"class Solution {     public int minMovesToMakePalindrome(String s) {         int n = s.length();         int count = 0;         char[] arr = s.toCharArray();                  // Start from both ends of the string         for(int i=0, j=n-1; i<j; ) {             if(arr[i] != arr[j]) {                 // If characters do not match, find the next matching character from either end                 int k = j;                 while(i<k && arr[i] != arr[k]) {                     k--;                     count++;                 }                 if(i == k) {                     // If characters from both ends do not match, swap them                     swap(arr, i, j-1);                     count++;                 }                 else {                     // If the matching character from left is found before the right character, swap left and right characters                     while(k < j) {                         swap(arr, k, k+1);                         k++;                         count++;                     }                     i++;                     j--;                 }             }             else {                 i++;                 j--;             }         }                  return count;     }          // Helper function to swap characters at index i and j in a character array     private void swap(char[] arr, int i, int j) {         char temp = arr[i];         arr[i] = arr[j];         arr[j] = temp;     } }",1,"2193-minimum-number-of-moves-to-make-palindrome/Solution.java:8:34: ';' is followed by whitespace. [EmptyForIteratorPad]
2193-minimum-number-of-moves-to-make-palindrome/Solution.java:20:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2193-minimum-number-of-moves-to-make-palindrome/Solution.java:31:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2193-minimum-number-of-moves-to-make-palindrome/Solution.java:8:	ForLoopVariableCount:	Too many control variables in the for statement
2193-minimum-number-of-moves-to-make-palindrome/Solution.java:9:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",0,0,0
"import java.util.*;  class Solution {     public List<Integer> replaceNonCoprimes(int[] nums) {         int n = nums.length;         List<Integer> modifiedList = new ArrayList<Integer>();          for (int i = 0; i < n; i++) {             if (i == 0)                 modifiedList.add(nums[i]);              if (i > 0 && gcd(nums[i], nums[i-1]) > 1) {                 int lcm = findLCM(nums[i], nums[i-1]);                 modifiedList.remove(modifiedList.size()-1);                 modifiedList.add(lcm);             } else if (i > 0) {                 modifiedList.add(nums[i]);             }         }          int m = modifiedList.size();         int[] modifiedArray = new int[m];         for (int i = 0; i < m; i++) {             modifiedArray[i] = modifiedList.get(i);         }          List<Integer> finalList = replaceNonCoprimes(modifiedArray);         return finalList;     }      public int gcd(int a, int b) {         if (b == 0)             return a;                  return gcd(b, a%b);     }      public int findLCM(int a, int b) {         return (a*b) / gcd(a, b);     }      public static void main(String[] args) {         Solution s = new Solution();         int[] nums = {6,4,3,2,7,6,2};         List<Integer> result = s.replaceNonCoprimes(nums);         System.out.println(result);     } }",1,"2197-replace-non-coprime-numbers-in-array/Solution.java:6:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new ArrayList<>()`
2197-replace-non-coprime-numbers-in-array/Solution.java:27:	UnnecessaryLocalBeforeReturn:	Consider simply returning the value vs storing it in local variable 'finalList'
2197-replace-non-coprime-numbers-in-array/Solution.java:39:	UselessParentheses:	Useless parentheses.
",0,0,0
"class Solution {     public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {         int n = nums.length;         for (int i = 0; i < n; i++) {             for (int j = i + 1; j < n && j <= i + indexDiff; j++) {                 long diff = (long) nums[i] - (long) nums[j];                 if (Math.abs(diff) <= valueDiff) {                     return true;                 }             }         }         return false;     } }",1,"220-contains-duplicate-iii/Solution.java:6:	UnnecessaryCast:	Unnecessary cast (long)
220-contains-duplicate-iii/Solution.java:6:	UnnecessaryCast:	Unnecessary cast (long)
",0,0,0
"import java.util.*;  class Solution {     class Node {         int index;         long weight;          public Node(int ind, long w) {             this.index = ind;             this.weight = w;         }     }      public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {         List<int[]>[] graph = new ArrayList[n];         for (int i = 0; i < n; i++) {             graph[i] = new ArrayList<int[]>();         }         for (int[] edge : edges) {             int u = edge[0], v = edge[1], w = edge[2];             graph[u].add(new int[] {v, w});         }          long[] dist1 = new long[n];         long[] dist2 = new long[n];         long[] dist3 = new long[n];         Arrays.fill(dist1, Long.MAX_VALUE);         Arrays.fill(dist2, Long.MAX_VALUE);         Arrays.fill(dist3, Long.MAX_VALUE);          PriorityQueue<Node> pq = new PriorityQueue<>((a, b) -> Long.compare(a.weight, b.weight));         dist1[src1] = 0;         pq.offer(new Node(src1, 0));         while (!pq.isEmpty()) {             Node cur = pq.poll();             int u = cur.index;             long w = cur.weight;             if (dist2[u] != Long.MAX_VALUE && dist3[u] != Long.MAX_VALUE)                 break;             if (dist1[u] < w) continue;             for (int[] neighbor : graph[u]) {                 int v = neighbor[0], weight = neighbor[1];                 if (dist1[v] > w + weight) {                     dist1[v] = w + weight;                     pq.offer(new Node(v, dist1[v]));                 }                 if (dist2[v] > dist2[u] + weight) {                     dist2[v] = dist2[u] + weight;                     pq.offer(new Node(v, dist2[v]));                 }             }         }          pq.clear();         dist2[src2] = 0;         pq.offer(new Node(src2, 0));         while (!pq.isEmpty()) {             Node cur = pq.poll();             int u = cur.index;             long w = cur.weight;             if (dist1[u] != Long.MAX_VALUE && dist3[u] != Long.MAX_VALUE)                 break;             if (dist2[u] < w) continue;             for (int[] neighbor : graph[u]) {                 int v = neighbor[0], weight = neighbor[1];                 if (dist2[v] > w + weight) {                     dist2[v] = w + weight;                     pq.offer(new Node(v, dist2[v]));                 }                 if (dist3[v] > dist3[u] + weight) {                     dist3[v] = dist3[u] + weight;                     pq.offer(new Node(v, dist3[v]));                 }             }         }          long ans = Long.MAX_VALUE;         for (int i = 0; i < n; i++) {             if (dist1[i] == Long.MAX_VALUE || dist2[i] == Long.MAX_VALUE || dist3[i] == Long.MAX_VALUE)                 continue;             ans = Math.min(ans, dist1[i] + dist2[i] + dist3[i]);         }         return ans == Long.MAX_VALUE ? -1 : ans;     } }",1,"2203-minimum-weighted-subgraph-with-the-required-paths/Solution.java:5:13: Variable 'index' must be private and have accessor methods. [VisibilityModifier]
2203-minimum-weighted-subgraph-with-the-required-paths/Solution.java:6:14: Variable 'weight' must be private and have accessor methods. [VisibilityModifier]
2203-minimum-weighted-subgraph-with-the-required-paths/Solution.java:8:9: Redundant 'public' modifier. [RedundantModifier]
2203-minimum-weighted-subgraph-with-the-required-paths/Solution.java:20:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2203-minimum-weighted-subgraph-with-the-required-paths/Solution.java:42:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2203-minimum-weighted-subgraph-with-the-required-paths/Solution.java:65:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2203-minimum-weighted-subgraph-with-the-required-paths/Solution.java:14:	NPathComplexity:	The method 'minimumWeight(int, int[][], int, int, int)' has an NPath complexity of 57660, current threshold is 200
2203-minimum-weighted-subgraph-with-the-required-paths/Solution.java:17:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new ArrayList<>()`
2203-minimum-weighted-subgraph-with-the-required-paths/Solution.java:31:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
",1,0,0
"class Solution {     public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {         int n = floor.length();         int[] counts = new int[n + 1];         for (int i = 0; i < n; i++) {             counts[i + 1] = counts[i] + (floor.charAt(i) == '1' ? 1 : 0);         }         int minWhiteTiles = n;         for (int i = 0; i <= n - numCarpets * carpetLen; i++) {             int j = i + numCarpets * carpetLen;             int whiteTiles = counts[j] - counts[i];             minWhiteTiles = Math.min(minWhiteTiles, whiteTiles);             for (int k = i + 1; k <= j - carpetLen; k++) {                 whiteTiles = counts[k + carpetLen] - counts[k] + counts[j] - counts[i] - whiteTiles;                 minWhiteTiles = Math.min(minWhiteTiles, whiteTiles);             }         }         return minWhiteTiles;     } }",0,,0,0,0
"class Solution {     public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {         int n = s.length();         char[] arr = s.toCharArray();         int[] longestLengths = new int[queryIndices.length];         int[] counts = new int[26];         int maxCount = 0;         int numMaxCount = 0;         for (int i = 0; i < n; i++) {             char c = arr[i];             counts[c - 'a']++;             if (counts[c - 'a'] > maxCount) {                 maxCount = counts[c - 'a'];                 numMaxCount = 1;             } else if (counts[c - 'a'] == maxCount) {                 numMaxCount++;             }             for (int j = 0; j < queryIndices.length; j++) {                 if (queryIndices[j] == i) {                     char newC = queryCharacters.charAt(j);                     counts[arr[i] - 'a']--;                     counts[newC - 'a']++;                     if (newC == arr[queryIndices[j]]) {                         longestLengths[j] = Math.max(longestLengths[j], maxCount);                     } else {                         if (numMaxCount == 1) {                             longestLengths[j] = Math.max(longestLengths[j], maxCount + 1);                         } else {                             longestLengths[j] = Math.max(longestLengths[j], maxCount);                         }                     }                     arr[i] = newC;                 }             }         }         return longestLengths;     } }",0,,0,0,0
"import java.util.*;  class Solution {     public int maxValueOfCoins(List<List<Integer>> piles, int k) {         PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a, b) -> b - a);         for (List<Integer> pile : piles) {             for (int coin : pile) {                 pq.offer(coin);             }         }         int maxProfit = 0;         for (int i = 0; i < k; i++) {             maxProfit += pq.poll();         }         return maxProfit;     } }",1,"2218-maximum-value-of-k-coins-from-piles/Solution.java:5:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
2218-maximum-value-of-k-coins-from-piles/Solution.java:5:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new PriorityQueue<>((a, b) -> b - a)`
",0,0,0
"class Solution {     public long sumScores(String s) {         int n = s.length();         long sum = 0, prefix = 0;         for (int i = 0; i < n; i++) {             if (s.charAt(i) == s.charAt(n - 1)) {                 prefix++;             } else {                 prefix = 0;             }             sum += prefix;         }         return sum;     } }",1,"2223-sum-of-scores-of-built-strings/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Encrypter {     private Map<Character, String> encryptionMap;     private Map<String, List<Character>> decryptionMap;      public Encrypter(char[] keys, String[] values, String[] dictionary) {         encryptionMap = new HashMap<>();         decryptionMap = new HashMap<>();         for (int i = 0; i < keys.length; i++) {             encryptionMap.put(keys[i], values[i]);             String s = values[i];             if (!decryptionMap.containsKey(s)) {                 decryptionMap.put(s, new ArrayList<>());             }             decryptionMap.get(s).add(keys[i]);         }     }          public String encrypt(String word1) {         StringBuilder sb = new StringBuilder();         for (char c : word1.toCharArray()) {             if (encryptionMap.containsKey(c)) {                 sb.append(encryptionMap.get(c));             } else {                 return """";             }         }         return sb.toString();     }          public int decrypt(String word2) {         int count = 0;         for (int i = 0; i < word2.length(); i += 2) {             String s = word2.substring(i, i + 2);             if (decryptionMap.containsKey(s)) {                 for (char c : decryptionMap.get(s)) {                     String decrypted = word2.substring(0, i) + c + word2.substring(i + 2);                     if (Arrays.asList(dictionary).contains(decrypted)) {                         count++;                     }                 }             }         }         return count;     } }  /**  * Your Encrypter object will be instantiated and called as such:  * Encrypter obj = new Encrypter(keys, values, dictionary);  * String param_1 = obj.encrypt(word1);  * int param_2 = obj.decrypt(word2);  */",1,"2227-encrypt-and-decrypt-strings/Encrypter.java:5:5: Redundant 'public' modifier. [RedundantModifier]
2227-encrypt-and-decrypt-strings/Encrypter.java:5:	UnusedFormalParameter:	Avoid unused constructor parameters such as 'dictionary'.
",0,0,0
"class Solution {     public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {         long currentFlowers = 0;         int completeGardens = 0;         int incompleteGardens = 0;         int minFlowers = Integer.MAX_VALUE;         for (int i = 0; i < flowers.length; i++) {             if (flowers[i] >= target) {                 completeGardens++;                 currentFlowers += flowers[i];             } else {                 incompleteGardens++;                 minFlowers = Math.min(minFlowers, flowers[i]);                 currentFlowers += flowers[i];             }         }         if (incompleteGardens == 0) {             return currentFlowers * full;         }         long maxAdditionalFlowers = newFlowers;         long additionalFlowers = Math.min(maxAdditionalFlowers, (long) (target * incompleteGardens - currentFlowers));         long beauty = completeGardens * full;         beauty += minFlowers * Math.min(partial, additionalFlowers);         maxAdditionalFlowers -= additionalFlowers;         beauty += Math.min(maxAdditionalFlowers, (long) ((incompleteGardens - 1) * target)) * partial;         return beauty;     } }",1,"2234-maximum-total-beauty-of-the-gardens/Solution.java:7:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
2234-maximum-total-beauty-of-the-gardens/Solution.java:21:	UnnecessaryCast:	Unnecessary cast (long)
",0,0,1
"class Solution {     public int calculate(String s) {         // Stack to keep track of numbers and signs         Stack<Integer> stack = new Stack<>();         // Initialize variables         int num = 0;         char sign = '+';         // Loop over string         for (int i = 0; i < s.length(); i++) {             char c = s.charAt(i);             // If character is a digit, update the number             if (Character.isDigit(c)) {                 num = num * 10 + (c - '0');             }             // If character is not a digit and not a space or if it is the last character in the string, perform calculation             if ((!Character.isDigit(c) && c != ' ') || i == s.length() - 1) {                 // Perform calculation based on the previous sign                 if (sign == '+') {                     stack.push(num);                 } else if (sign == '-') {                     stack.push(-num);                 } else if (sign == '*') {                     stack.push(stack.pop() * num);                 } else if (sign == '/') {                     stack.push(stack.pop() / num);                 }                 // Update the sign and reset the number                 sign = c;                 num = 0;             }         }         // Sum up the numbers in the stack         int result = 0;         while (!stack.isEmpty()) {             result += stack.pop();         }         return result;     } }",1,"224-basic-calculator/Solution.java:13:	UselessParentheses:	Useless parentheses.
",0,0,0
"import java.util.*;  class Solution {     public int maximumScore(int[] scores, int[][] edges) {         int n = scores.length;                  // build the adjacency list of the graph         List<List<Integer>> adjList = new ArrayList<>();         for (int i = 0; i < n; i++) {             adjList.add(new ArrayList<>());         }         for (int[] edge : edges) {             int u = edge[0], v = edge[1];             adjList.get(u).add(v);             adjList.get(v).add(u);         }          // sort the nodes by decreasing score         List<Integer> nodes = new ArrayList<>();         for (int i = 0; i < n; i++) {             nodes.add(i);         }         nodes.sort((i, j) -> Integer.compare(scores[j], scores[i]));          int maxScore = -1; // the maximum score found so far         Set<Integer> seen = new HashSet<>(); // nodes that have been considered         for (int i = 0; i < n; i++) {             int u = nodes.get(i);             if (seen.contains(u)) {                 continue;             }             seen.add(u);             for (int v : adjList.get(u)) {                 seen.add(v);             }             for (int j = i + 1; j < n; j++) {                 int v = nodes.get(j);                 if (seen.contains(v)) {                     continue;                 }                 seen.add(v);                 for (int w : adjList.get(v)) {                     seen.add(w);                 }                 for (int k = j + 1; k < n; k++) {                     int w = nodes.get(k);                     if (seen.contains(w)) {                         continue;                     }                     seen.add(w);                     for (int x : adjList.get(w)) {                         seen.add(x);                     }                     int score = scores[u] + scores[v] + scores[w] + scores[nodes.get(n-1)];                     maxScore = Math.max(maxScore, score);                     seen.remove(x);                 }                 seen.remove(v);             }             seen.remove(u);         }         return maxScore;     } }",1,"2242-maximum-score-of-a-node-sequence/Solution.java:13:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2242-maximum-score-of-a-node-sequence/Solution.java:4:	NPathComplexity:	The method 'maximumScore(int[], int[][])' has an NPath complexity of 680, current threshold is 200
",1,0,0
"class Solution {     int[] visited;     Map<Integer, Set<Character>> graph;     int maxLength;          public int longestPath(int[] parent, String s) {         visited = new int[parent.length];         graph = new HashMap<Integer, Set<Character>>();         maxLength = 0;                  buildGraph(parent, s);                  for (int i = 0; i < parent.length; i++) {             if (visited[i] == 0) {                 dfs(i, s.charAt(i), 0);             }         }                  return maxLength;     }          private void buildGraph(int[] parent, String s) {         for (int i = 0; i < parent.length; i++) {             if (graph.containsKey(i) == false) {                 graph.put(i, new HashSet<Character>());             }                          if (graph.containsKey(parent[i]) == false) {                 graph.put(parent[i], new HashSet<Character>());             }                          graph.get(i).add(s.charAt(i));             graph.get(parent[i]).add(s.charAt(i));         }     }          private void dfs(int node, char currentChar, int length) {         visited[node] = 1;         maxLength = Math.max(maxLength, length);                  for (int child : graph.keySet()) {             if (child != node && graph.get(child).contains(currentChar)) {                 continue;             }              dfs(child, s.charAt(child), length + 1);         }     } }",1,"2246-longest-path-with-different-adjacent-characters/Solution.java:2:11: Variable 'visited' must be private and have accessor methods. [VisibilityModifier]
2246-longest-path-with-different-adjacent-characters/Solution.java:3:34: Variable 'graph' must be private and have accessor methods. [VisibilityModifier]
2246-longest-path-with-different-adjacent-characters/Solution.java:4:9: Variable 'maxLength' must be private and have accessor methods. [VisibilityModifier]
2246-longest-path-with-different-adjacent-characters/Solution.java:24:38: Expression can be simplified. [SimplifyBooleanExpression]
2246-longest-path-with-different-adjacent-characters/Solution.java:28:46: Expression can be simplified. [SimplifyBooleanExpression]
2246-longest-path-with-different-adjacent-characters/Solution.java:24:	SimplifyBooleanExpressions:	Avoid unnecessary comparisons in boolean expressions
2246-longest-path-with-different-adjacent-characters/Solution.java:28:	SimplifyBooleanExpressions:	Avoid unnecessary comparisons in boolean expressions
",0,0,0
"class Solution {     public int[] fullBloomFlowers(int[][] flowers, int[] people) {         Arrays.sort(flowers, (a, b) -> a[0] - b[0]); //sort the flowers array by start time         int[] ans = new int[people.length];         Arrays.fill(ans, -1); // mark all answer entries as -1 initially         int maxEnd = -1; //tracks the maximum end time for current bloomed flowers         int count = 0; //tracks the number of bloomed flowers as we iterate through the flowers array         for(int i = 0; i < flowers.length; i++){             while(count < people.length && maxEnd < people[count]){ //iterate through the people array                 if(ans[count] == -1 && flowers[i][0] <= people[count] && flowers[i][1] >= people[count]){ //if this is the first time we're seeing this person, and they arrive during the blooming window                     ans[count] = 1; //this person sees one bloomed flower                 }                 else if(ans[count] != -1 && flowers[i][0] <= people[count] && flowers[i][1] >= people[count]){ //if this is not the first time we're seeing this person, and they arrive during the blooming window                     ans[count]++; //increment the number of bloomed flowers they see                 }                 else if(flowers[i][0] > people[count]){ //if the current flower doesn't bloom before the current person arrives                     break; //stop iterating through people array                  }                 count++; //move to the next person             }             maxEnd = Math.max(maxEnd, flowers[i][1]); //update maxEnd time         }         return ans;     } }",1,"2251-number-of-flowers-in-full-bloom/Solution.java:12:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2251-number-of-flowers-in-full-bloom/Solution.java:15:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
2251-number-of-flowers-in-full-bloom/Solution.java:8:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int maximumMinutes(int[][] grid) {         int m = grid.length;    // number of rows         int n = grid[0].length; // number of columns                  // create a queue to store the cells that are on fire         Queue<int[]> fire = new LinkedList<>();                  // add all the cells that are initially on fire to the queue         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 if (grid[i][j] == 1) {                     fire.offer(new int[]{i, j});                 }             }         }                  // if there is no fire, return 0         if (fire.isEmpty()) {             return 0;         }                  int[][] dirs = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};         int[][] dist = new int[m][n]; // to store the minimum distance from the starting cell to each cell         for (int[] row : dist) {             Arrays.fill(row, Integer.MAX_VALUE);         }         dist[0][0] = 0; // distance to starting cell is 0                  // BFS on the fire         while (!fire.isEmpty()) {             int size = fire.size();             for (int i = 0; i < size; i++) {                 int[] curr = fire.poll();                 int r = curr[0];                 int c = curr[1];                 // spread fire to adjacent grass cells                 for (int[] dir : dirs) {                     int nr = r + dir[0];                     int nc = c + dir[1];                     if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] == 2) {                         continue;                     }                     if (dist[nr][nc] > dist[r][c] + 1) {                         dist[nr][nc] = dist[r][c] + 1;                         fire.offer(new int[]{nr, nc});                     }                 }             }         }                  // if the ending cell is unreachable, return -1         if (dist[m-1][n-1] == Integer.MAX_VALUE) {             return -1;         }                  return dist[m-1][n-1] == 0 ? 109 : dist[m-1][n-1];     } }",1,"2258-escape-the-spreading-fire/Solution.java:2:	NPathComplexity:	The method 'maximumMinutes(int[][])' has an NPath complexity of 1440, current threshold is 200
",0,0,0
class Solution {     public long appealSum(String s) {         long sum = 0;         for(int i=0; i<s.length(); i++){  // iterate over all substrings             Set<Character> set = new HashSet<>(); // to store distinct characters             for(int j=i; j<s.length(); j++){ // iterate over substring starting at i                 set.add(s.charAt(j));                   sum += set.size(); // add the appeal of substring to the total sum             }         }         return sum;     } },0,,0,0,0
"class Solution {     private boolean isInsideGrid(int row, int col, int m, int n) {         return row >= 0 && row < m && col >= 0 && col < n;     }      private boolean isValidPath(char[][] grid, int row, int col, int m, int n) {         char curr = grid[row][col];         if (curr == '(') {             return isInsideGrid(row, col + 1, m, n) && (grid[row][col + 1] ==  ')' || grid[row][col + 1] == '1' || grid[row][col + 1] == '4') &&                    isInsideGrid(row + 1, col, m, n) && (grid[row + 1][col] == ')' || grid[row + 1][col] == '2' || grid[row + 1][col] == '3');         } else if (curr == ')') {             return isInsideGrid(row, col - 1, m, n) && (grid[row][col - 1] == '(' || grid[row][col - 1] == '2' || grid[row][col - 1] == '3') &&                    isInsideGrid(row - 1, col, m, n) && (grid[row - 1][col] == '(' || grid[row - 1][col] == '1' || grid[row - 1][col] == '4');         } else if (curr == '1') {             return isInsideGrid(row, col + 1, m, n) && (grid[row][col + 1] == ')' || grid[row][col + 1] == '1' || grid[row][col + 1] == '4') &&                    isInsideGrid(row - 1, col, m, n) && (grid[row - 1][col] == '(' || grid[row - 1][col] == '1' || grid[row - 1][col] == '4');         } else if (curr == '2') {             return isInsideGrid(row + 1, col, m, n) && (grid[row + 1][col] == ')' || grid[row + 1][col] == '2' || grid[row + 1][col] == '3') &&                    isInsideGrid(row, col + 1, m, n) && (grid[row][col + 1] == '(' || grid[row][col + 1] == '2' || grid[row][col + 1] == '3');         } else if (curr == '3') {             return isInsideGrid(row + 1, col, m, n) && (grid[row + 1][col] == ')' || grid[row + 1][col] == '2' || grid[row + 1][col] == '3') &&                    isInsideGrid(row, col - 1, m, n) && (grid[row][col - 1] == '(' || grid[row][col - 1] == '2' || grid[row][col - 1] == '3');         } else { // curr == '4'             return isInsideGrid(row - 1, col, m, n) && (grid[row - 1][col] == '(' || grid[row - 1][col] == '1' || grid[row - 1][col] == '4') &&                    isInsideGrid(row, col - 1, m, n) && (grid[row][col - 1] == ')' || grid[row][col - 1] == '1' || grid[row][col - 1] == '4');         }     }      public boolean hasValidPath(char[][] grid) {         int m = grid.length;         int n = grid[0].length;          boolean[][] visited = new boolean[m][n];         Queue<int[]> queue = new LinkedList<>();         queue.offer(new int[]{0, 0});          while (!queue.isEmpty()) {             int[] curr = queue.poll();             int row = curr[0];             int col = curr[1];             visited[row][col] = true;              if (row == m - 1 && col == n - 1) {                 return true;             }              if (isValidPath(grid, row, col, m, n)) {                 if (isInsideGrid(row, col + 1, m, n) && !visited[row][col + 1]) {                     queue.offer(new int[]{row, col + 1});                 }                 if (isInsideGrid(row + 1, col, m, n) && !visited[row + 1][col]) {                     queue.offer(new int[]{row + 1, col});                 }                 if (isInsideGrid(row, col - 1, m, n) && !visited[row][col - 1]) {                     queue.offer(new int[]{row, col - 1});                 }                 if (isInsideGrid(row - 1, col, m, n) && !visited[row - 1][col]) {                     queue.offer(new int[]{row - 1, col});                 }             }         }          return false;     } }",1,"2267-check-if-there-is-a-valid-parentheses-string-path/Solution.java:29:	NPathComplexity:	The method 'hasValidPath(char[][])' has an NPath complexity of 247, current threshold is 200
",0,0,0
"class Solution {     public int largestVariance(String s) {         int largestVariance = 0;         int[] occurrences = new int[26]; // holds the number of occurrences of each character         for (int i = 0; i < s.length(); i++) {             occurrences[s.charAt(i) - 'a']++;             for (int j = 0; j < 26; j++) {                 if (occurrences[j] > 0) {                     for (int k = j + 1; k < 26; k++) {                         if (occurrences[k] > 0) {                             largestVariance = Math.max(largestVariance, Math.abs(occurrences[j] - occurrences[k]));                         }                     }                 }             }         }         return largestVariance;     } }",0,,0,0,0
"import java.util.*;  class CountIntervals {     private Set<Integer> set;      public CountIntervals() {         set = new HashSet<>();     }      public void add(int left, int right) {         for (int i = left; i <= right; i++) {             set.add(i);         }     }      public int count() {         return set.size();     } }",1,"2276-count-integers-in-intervals/CountIntervals.java:6:5: Redundant 'public' modifier. [RedundantModifier]
",0,0,0
"class Solution {     public int totalStrength(int[] strength) {         int n = strength.length;         int mod = 1000000007;         long ans = 0;         for (int i = 0; i < n; i++) {             // find the max range of left and right subarray             // so that there will be overlap with the current element             int l = i, r = i;             while (l >= 0 && strength[l] >= strength[i]) {                 l--;             }             while (r < n && strength[r] >= strength[i]) {                 r++;             }             // calculate the contribution of current element             ans = (ans + ((long) strength[i] * (sum(strength, l + 1, i) + sum(strength, i, r)) % mod)) % mod;         }         return (int) ans;     }          // calculate sum from l to r-1, inclusive     private int sum(int[] arr, int l, int r) {         int s = 0;         for (int i = l; i < r; i++) {             s += arr[i];         }         return s;     } }",1,"2281-sum-of-total-strength-of-wizards/Solution.java:9:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"import java.util.*;  class BookMyShow {     private int n, m;     private Map<Integer, TreeSet<Integer>> avail;      public BookMyShow(int n, int m) {         this.n = n;         this.m = m;         this.avail = new HashMap<>();         for (int i = 0; i < n; i++) {             avail.put(i, new TreeSet<>(IntStream.range(0, m).boxed().collect(Collectors.toList())));         }     }          public int[] gather(int k, int maxRow) {         for (int r = 0; r <= maxRow; r++) {             TreeSet<Integer> s = avail.get(r);             Integer c = s.ceiling(0);             while (c != null && c + k <= m && s.containsAll(IntStream.range(c, c + k).boxed().collect(Collectors.toList()))) {                 for (int i = c; i < c + k; i++) {                     s.remove(i);                 }                 return new int[]{r, c};             }         }         return new int[]{};     }          public boolean scatter(int k, int maxRow) {         int count = 0;         for (int r = 0; r <= maxRow; r++) {             TreeSet<Integer> s = avail.get(r);             int c = s.first();             while (c + k <= m) {                 if (!s.containsAll(IntStream.range(c, c + k).boxed().collect(Collectors.toList()))) {                     break;                 }                 for (int i = c; i < c + k; i++) {                     s.remove(i);                 }                 count += k;                 if (count == k) {                     return true;                 }                 c = s.first();             }         }         return false;     } }  /**  * Your BookMyShow object will be instantiated and called as such:  * BookMyShow obj = new BookMyShow(n, m);  * int[] param_1 = obj.gather(k,maxRow);  * boolean param_2 = obj.scatter(k,maxRow);  */",1,"2286-booking-concert-tickets-in-groups/BookMyShow.java:4:5: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2286-booking-concert-tickets-in-groups/BookMyShow.java:7:5: Redundant 'public' modifier. [RedundantModifier]
2286-booking-concert-tickets-in-groups/BookMyShow.java:7:27: 'n' hides a field. [HiddenField]
2286-booking-concert-tickets-in-groups/BookMyShow.java:7:34: 'm' hides a field. [HiddenField]
2286-booking-concert-tickets-in-groups/BookMyShow.java:4:	UnusedPrivateField:	Avoid unused private fields such as 'n'.
2286-booking-concert-tickets-in-groups/BookMyShow.java:5:	LooseCoupling:	Avoid using implementation types like 'TreeSet'; use the interface instead
2286-booking-concert-tickets-in-groups/BookMyShow.java:18:	LooseCoupling:	Avoid using implementation types like 'TreeSet'; use the interface instead
2286-booking-concert-tickets-in-groups/BookMyShow.java:24:	AvoidBranchingStatementAsLastInLoop:	Avoid using a branching statement as the last in a loop.
2286-booking-concert-tickets-in-groups/BookMyShow.java:33:	LooseCoupling:	Avoid using implementation types like 'TreeSet'; use the interface instead
",1,0,0
"class Solution {     public int minimumObstacles(int[][] grid) {         int m = grid.length; //Number of rows         int n = grid[0].length; //Number of columns                  //If there is no obstacle or only one cell is in grid         if(grid[0][0] == 0 && grid[m-1][n-1]==0 && m*n>1){             int[][] distance = new int[m][n];             boolean[][] visited = new boolean[m][n];             distance[0][0] = 1; //Initial distance from source node             Queue<int[]> queue = new LinkedList<>();             queue.offer(new int[]{0,0});             visited[0][0] = true; //Marked as visited                          //Breadth-First Search to explore the grid and find the target             while(!queue.isEmpty()){                 int[] cur = queue.poll();                 int row = cur[0];                 int col = cur[1];                 if(row == m-1 && col == n-1) return distance[m-1][n-1]-1;                 //Up row                 if(row-1 >= 0 && !visited[row-1][col] && grid[row-1][col]==0){                     visited[row-1][col] = true;                     distance[row-1][col] = distance[row][col]+1;                     queue.offer(new int[]{row-1, col});                 }                 //Down row                 if(row+1 < m && !visited[row+1][col] && grid[row+1][col]==0){                     visited[row+1][col] = true;                     distance[row+1][col] = distance[row][col]+1;                     queue.offer(new int[]{row+1, col});                 }                 //Left column                 if(col-1 >= 0 && !visited[row][col-1] && grid[row][col-1]==0){                     visited[row][col-1] = true;                     distance[row][col-1] = distance[row][col]+1;                     queue.offer(new int[]{row, col-1});                 }                 //Right column                 if(col+1 < n && !visited[row][col+1] && grid[row][col+1]==0){                     visited[row][col+1] = true;                     distance[row][col+1] = distance[row][col]+1;                     queue.offer(new int[]{row, col+1});                 }             }             //Goal is not reachable             return -1;         }         //If the grid is not useful or goal is not reachable         return 0;     } }",1,"2290-minimum-obstacle-removal-to-reach-corner/Solution.java:2:	NPathComplexity:	The method 'minimumObstacles(int[][])' has an NPath complexity of 772, current threshold is 200
",0,0,0
"class TextEditor {      private StringBuilder text;     private int cursor;      public TextEditor() {         text = new StringBuilder();         cursor = 0;     }      public void addText(String newText) {         text.insert(cursor, newText);         cursor += newText.length();     }      public int deleteText(int k) {         int numDeleted = Math.min(k, cursor);         text.delete(cursor - numDeleted, cursor);         cursor -= numDeleted;         return numDeleted;     }      public String cursorLeft(int k) {         int numToMove = Math.min(k, cursor);         int start = cursor - numToMove;         String left = text.substring(start, cursor);         cursor = start;         return left;     }      public String cursorRight(int k) {         int numToMove = Math.min(k, text.length() - cursor);         int end = cursor + numToMove;         String right = text.substring(cursor, end);         cursor = end;         return right;     } }",1,"2296-design-a-text-editor/TextEditor.java:6:5: Redundant 'public' modifier. [RedundantModifier]
2296-design-a-text-editor/TextEditor.java:3:	AvoidStringBufferField:	StringBuffers can grow quite a lot, and so may become a source of memory leak (if the owning class has a long life time).
",0,0,0
"class Solution {     public boolean matchReplacement(String s, String sub, char[][] mappings) {         // Create a map of characters in sub with their possible mappings          Map<Character, Set<Character>> map = new HashMap<>();         for (char[] mapping : mappings) {             char oldi = mapping[0];             char newi = mapping[1];             if (!map.containsKey(oldi)) {                 map.put(oldi, new HashSet<>());             }             map.get(oldi).add(newi);         }          // Check if sub can be formed by replacing characters in s         int si = 0;         for (char subChar : sub.toCharArray()) {             // Check if s has reached its end             if (si >= s.length()) {                 return false;             }             char sChar = s.charAt(si);             if (sChar == subChar) {                 // Characters match, move to next character in s and sub                 si++;             } else {                 // Check if sChar has a possible mapping to subChar                 if (!map.containsKey(sChar) || !map.get(sChar).contains(subChar)) {                     return false;                 }             }         }         return true;     } }",0,,0,0,0
"class Solution {     public long countSubarrays(int[] nums, long k) {         int n = nums.length;         long count = 0, sum = 0, product = 0;         int left = 0, right = 0;         while(right < n){             sum += nums[right];             product = sum * (right - left + 1);             while(product >= k && left <= right){                 sum -= nums[left];                 left++;                 product = sum * (right - left + 1);             }             count += right - left + 1;             right++;         }         return count;     } }",1,"2302-count-subarrays-with-score-less-than-k/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2302-count-subarrays-with-score-less-than-k/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2302-count-subarrays-with-score-less-than-k/Solution.java:4:	UnusedAssignment:	The initializer for variable 'product' is never used (overwritten on line 8)
",1,0,0
"import java.util.HashSet;  class Solution {     public int distinctNames(String[] ideas) {         HashSet<String> set = new HashSet<>();         int count = 0;          for (int i = 0; i < ideas.length; i++) {             for (int j = i + 1; j < ideas.length; j++) {                 String ideaA = ideas[i], ideaB = ideas[j];                 String newIdeaA = ideaB.charAt(0) + ideaA.substring(1);                 String newIdeaB = ideaA.charAt(0) + ideaB.substring(1);                  if (!set.contains(newIdeaA) && !set.contains(newIdeaB)) {                     set.add(newIdeaA);                     set.add(newIdeaB);                     count++;                 }             }         }          return count;     } }",1,"2306-naming-a-company/Solution.java:10:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2306-naming-a-company/Solution.java:5:	LooseCoupling:	Avoid using implementation types like 'HashSet'; use the interface instead
",1,0,0
"class Solution {     public int sellWood(int m, int n, int[][] prices) {         int[][] memo = new int[m][n];         return dfs(0, 0, m, n, prices, memo);     }      private int dfs(int i, int j, int m, int n, int[][] prices, int[][] memo) {         if (memo[i][j] > 0) {             return memo[i][j];         }         int ans = 0;         for (int k = 0; k < prices.length; k++) {             int x = prices[k][0], y = prices[k][1], p = prices[k][2];             if (i + x <= m && j + y <= n) {                 int[][] A = partition(i, j, i + x - 1, j + y - 1);                 ans = Math.max(ans, dfs(i, j + y, m, n, prices, memo) + dfs(A[0][0], A[0][1], m, n, prices, memo) + dfs(A[1][0], A[1][1], m, n, prices, memo) + p);                 ans = Math.max(ans, dfs(i + x, j, m, n, prices, memo) + dfs(A[0][0], A[0][1], m, n, prices, memo) + dfs(A[1][0], A[1][1], m, n, prices, memo) + p);                 ans = Math.max(ans, dfs(i, j + y, m, n, prices, memo) + dfs(A[0][0], A[0][1], m, n, prices, memo) + dfs(A[1][0], A[1][1], m, n, prices, memo) + p);                 ans = Math.max(ans, dfs(i + x, j, m, n, prices, memo) + dfs(A[0][0], A[0][1], m, n, prices, memo) + dfs(A[1][0], A[1][1], m, n, prices, memo) + p);             }         }         memo[i][j] = ans;         return ans;     }      private int[][] partition(int i1, int j1, int i2, int j2) {         int[][] A = new int[2][2];         if (i2 - i1 > j2 - j1) {             A[0] = new int[]{i1, j1};             A[1] = new int[]{i2, j1};         } else {             A[0] = new int[]{i1, j1};             A[1] = new int[]{i1, j2};         }         return A;     } }",1,"2312-selling-pieces-of-wood/Solution.java:13:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2312-selling-pieces-of-wood/Solution.java:12:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",1,0,1
"class Solution {     public int distinctSequences(int n) {         final int mod = 1000000007;         // dp array to store number of distinct sequences up to i         int[] dp = new int[n + 1];         dp[1] = 6;         if (n >= 2) {             dp[2] = 36;         }         // loop from 3 to n         for (int i = 3; i <= n; i++) {             // for each i, we calculate the number of distinct sequences up to i             // by considering each dice roll that can be added to each of the previous sequences             // and checking if the two adjacent numbers in the new sequence have gcd 1             // and there is a gap of 2 or more between equal values             long count = 0;             for (int prev = 1; prev <= 6; prev++) {                 for (int pprev = 1; pprev <= 6; pprev++) {                     if (gcd(prev, pprev) == 1) {                         for (int k = 1; k <= 6; k++) {                             if (k == prev || k == pprev) {                                 continue;                             }                             // check if we can add k to the previous sequence                             if (i == 3 || k != dp[i - 3] || dp[i - 2] != dp[i - 3] || dp[i - 1] != dp[i - 3]) {                                 // if we can add k, add the number of sequences that end with prev,pprev to count                                 count += dp[i - 2];                                 count %= mod;                             }                         }                     }                 }             }             dp[i] = (int)count;         }         return dp[n];     }          // helper method to calculate gcd     private int gcd(int a, int b) {         return b == 0 ? a : gcd(b, a % b);     } }",0,,0,0,0
"class Solution {     public int maximumScore(int[] nums1, int[] nums2) {         int n = nums1.length;                  // total sum of nums1 and nums2         int sum1 = 0;         int sum2 = 0;         for (int i = 0; i < n; i++) {             sum1 += nums1[i];             sum2 += nums2[i];         }                  // find the maximum score without any swaps         int maxScore = Math.max(sum1, sum2);                  // track the running sum of differences in the subarray         int currDiff = 0;         // track the maximum difference seen so far         int maxDiff = 0;         // iterate through each index and consider swapping the subarrays         for (int i = 0; i < n - 1; i++) {             // update the running sum of differences             currDiff += nums1[i] - nums2[i];             // if the running sum is negative, set it to 0             currDiff = Math.max(currDiff, 0);             // update the maximum difference seen so far             maxDiff = Math.max(maxDiff, currDiff);             // calculate the potential score if we swap the subarrays at this index             int score = sum1 - currDiff + maxDiff;             // update the maximum score seen so far             maxScore = Math.max(maxScore, score);         }                  return maxScore;     } }",0,,0,0,0
"class Solution {     public int minimumScore(int[] nums, int[][] edges) {         int n = nums.length;         int res = Integer.MAX_VALUE;         for (int[] e : edges) {             int u = e[0], v = e[1];             List<Integer>[] adj = new List[n];             for (int i = 0; i < n; i++) {                 adj[i] = new ArrayList<>();             }             for (int[] edge : edges) {                 int x = edge[0], y = edge[1];                 if (u != x && u != y && v != x && v != y) {                     adj[x].add(y);                     adj[y].add(x);                 }             }             int[] val = new int[n];             for (int i = 0; i < n; i++) {                 val[i] = nums[i];             }             int[] xor = new int[3];             dfs(u, -1, adj, val, xor, 0);             dfs(v, -1, adj, val, xor, 1);             res = Math.min(res, xor[0] - xor[2]);             res = Math.min(res, xor[1] - xor[2]);         }         return res;     }          private void dfs(int u, int p, List<Integer>[] adj, int[] val, int[] xor, int idx) {         xor[idx] ^= val[u];         for (int v : adj[u]) {             if (v != p) {                 dfs(v, u, adj, val, xor, idx);             }         }     } }",1,"2322-minimum-score-after-removals-on-a-tree/Solution.java:6:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2322-minimum-score-after-removals-on-a-tree/Solution.java:12:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2322-minimum-score-after-removals-on-a-tree/Solution.java:19:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
",1,0,0
"class Solution {     public int countPaths(int[][] grid) {         int m = grid.length, n = grid[0].length;         int mod = 1000000007;                  // dp[i][j] represents the number of strictly increasing paths          // starting from cell (i, j)         long[][] dp = new long[m][n];                  // Initialize all cells with 1 as every cell is a valid path itself         for (int i = 0; i < m; i++) {             Arrays.fill(dp[i], 1);         }                  // Sort the Cells in increasing order of their value         List<Cell> cells = new ArrayList<>();         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 cells.add(new Cell(i, j, grid[i][j]));                 }         }         Collections.sort(cells, (c1, c2) -> Integer.compare(c1.val, c2.val));                  // For each cell (i, j), update dp[i][j] with the sum of dp[next_i][next_j]          // where (next_i, next_j) is a neighbor of (i, j) and grid[next_i][next_j] > grid[i][j].         for (Cell cell : cells) {             int i = cell.i, j = cell.j;             for (int[] dir : new int[][] {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}) {                 int next_i = i + dir[0], next_j = j + dir[1];                 if (next_i < 0 || next_j < 0 || next_i >= m || next_j >= n) {                     continue;                 }                 if (grid[next_i][next_j] > grid[i][j]) {                     dp[i][j] += dp[next_i][next_j];                     dp[i][j] %= mod;                 }             }         }                  // Calculate the sum of all dp[i][j]         long ans = 0;         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 ans += dp[i][j];                 ans %= mod;             }         }                  return (int) ans;     }          class Cell {         int i, j, val;         Cell(int i, int j, int val) {             this.i = i;             this.j = j;             this.val = val;         }     } }",1,"2328-number-of-increasing-paths-in-a-grid/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2328-number-of-increasing-paths-in-a-grid/Solution.java:27:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2328-number-of-increasing-paths-in-a-grid/Solution.java:29:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2328-number-of-increasing-paths-in-a-grid/Solution.java:53:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2328-number-of-increasing-paths-in-a-grid/Solution.java:53:13: Variable 'i' must be private and have accessor methods. [VisibilityModifier]
2328-number-of-increasing-paths-in-a-grid/Solution.java:53:16: Variable 'j' must be private and have accessor methods. [VisibilityModifier]
2328-number-of-increasing-paths-in-a-grid/Solution.java:53:19: Variable 'val' must be private and have accessor methods. [VisibilityModifier]
2328-number-of-increasing-paths-in-a-grid/Solution.java:54:18: 'i' hides a field. [HiddenField]
2328-number-of-increasing-paths-in-a-grid/Solution.java:54:25: 'j' hides a field. [HiddenField]
2328-number-of-increasing-paths-in-a-grid/Solution.java:54:32: 'val' hides a field. [HiddenField]
2328-number-of-increasing-paths-in-a-grid/Solution.java:2:	NPathComplexity:	The method 'countPaths(int[][])' has an NPath complexity of 216, current threshold is 200
",1,0,0
"class Solution {     public int countDigitOne(int n) {         int ones = 0;         for (long m = 1; m <= n; m *= 10) {             long a = n/m, b = n%m;             ones += (a + 8) / 10 * m + (a % 10 == 1 ? b + 1 : 0);         }         return ones;     } }",1,"233-number-of-digit-one/Solution.java:5:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int validSubarraySize(int[] nums, int threshold) {         int n = nums.length;         int left = 1, right = n;         int ans = -1;         while (left <= right) {             int mid = (left + right) / 2;             boolean found = false;             double sum = 0;             for (int i = 0; i < mid; i++)                 sum += nums[i];             if (sum >= threshold * mid) {                 found = true;             }             for (int i = mid; i < n; i++) {                 sum += nums[i] - nums[i - mid];                 if (sum >= threshold * mid) {                     found = true;                     break;                 }             }             if (found) {                 ans = mid;                 left = mid + 1;             } else {                 right = mid - 1;             }         }         return ans;     } }",1,"2334-subarray-with-elements-greater-than-varying-threshold/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int idealArrays(int n, int maxValue) {         int MOD = 1000000007;                  // Initialize dp array                  // dp[i][j] represents number of ideal arrays of length i where the last element is j         int[][] dp = new int[n+1][maxValue+1];                  // Base cases         for(int i=1; i<=maxValue; i++) {             dp[1][i] = 1; // There is only one ideal array of lenth 1 with each element         }                  // Populate dp array for length 2 to n         for(int i=2; i<=n; i++) {             long sum = 0; // To handle overflow             for(int j=1; j<=maxValue; j++) {                 sum += dp[i-1][j];                 sum %= MOD;                 dp[i][j] = (int)sum;             }                          for(int j=1; j<=maxValue; j++) {                 for(int k=j+j; k<=maxValue; k+=j) {                     dp[i][k] += dp[i-1][j];                     dp[i][k] %= MOD;                 }             }         }                  int result = 0;         for(int i=1; i<=maxValue; i++) {             result += dp[n][i];             result %= MOD;         }                  return result;     } }",0,,0,0,0
"class Solution {     public int minDeletions(int[] nums, int[] numsDivide) {         // Find the minimum element in nums         int minNum = Integer.MAX_VALUE;         for (int num : nums) {             minNum = Math.min(minNum, num);         }                  // Check if minNum divides all elements in numsDivide         for (int num : numsDivide) {             if (num % minNum != 0) {                 // minNum does not divide num                 // We need to delete elements from nums                 int count = 0;                 for (int i = 0; i < nums.length; i++) {                     if (nums[i] == minNum) {                         count++;                     }                 }                 return count;             }         }         return 0;     } }",1,"2344-minimum-deletions-to-make-array-divisible/Solution.java:15:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int shortestSequence(int[] rolls, int k) {         Set<List<Integer>> set = new HashSet<>();         List<Integer> seq = new ArrayList<>();         for(int roll : rolls){             seq.add(roll);             set.add(new ArrayList<>(seq));         }         int len = 1;         while(true){             List<List<Integer>> newSeqs = new ArrayList<>();             for(List<Integer> prevSeq : set){                 for(int i = 1; i <= k; i++){                     List<Integer> newSeq = new ArrayList<>(prevSeq);                     newSeq.add(i);                     if(!set.contains(newSeq)){                         newSeqs.add(newSeq);                     }                 }             }             if(newSeqs.isEmpty()){                 return len;             }             set.addAll(newSeqs);             len++;         }     } }",0,,0,0,0
"class Solution {     public long countExcellentPairs(int[] nums, int k) {         long count = 0;         for (int i = 0; i < nums.length; i++) {             for (int j = i; j < nums.length; j++) {                 int num1 = nums[i];                 int num2 = nums[j];                 if (num1 == num2 && Integer.bitCount(num1) + Integer.bitCount(num2) >= k) {                     count++;                 } else if (num1 != num2) {                     int or = num1 | num2;                     int and = num1 & num2;                     int bitCountOr = Integer.bitCount(or);                     int bitCountAnd = Integer.bitCount(and);                     if (bitCountOr + bitCountAnd >= k) {                         count++;                     }                 }             }         }         return count;     } }",0,,0,0,0
"class Solution {     public int longestCycle(int[] edges) {         int n = edges.length;         int ans = 0;                  for (int i = 0; i < n; i++) {             int slow = i, fast = i;             while (edges[fast] != -1 && edges[fast] != i) {                 slow = edges[slow];                 fast = edges[edges[fast]];                 if (slow == fast) {                     // cycle found                     int len = 0;                     do {                         slow = edges[slow];                         fast = edges[edges[fast]];                         len++;                     } while (slow != fast);                     ans = Math.max(ans, len);                     break;                 }             }         }         return ans == 0 ? -1 : ans;     } }",1,"2360-longest-cycle-in-a-graph/Solution.java:7:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
class Solution {     public int minimumReplacement(int[] nums) {         int n = nums.length;         int ans = 0;         for(int i=1;i<n;i++) {             if(nums[i]<nums[i-1]) {                 int diff = nums[i-1]-nums[i];                 ans+=countOperations(diff);                 nums[i]+=diff;             }         }         return ans;     }          private int countOperations(int diff) {         int sum = 0;         for(int i=30;i>=0;i--) {             int current = 1<<i;             if(diff>=current) {                 int quotient = diff/current;                 diff-=quotient*current;                 sum+=quotient;             }         }         return sum;     } },1,"2366-minimum-replacements-to-sort-the-array/Solution.java:21:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'diff'
",0,1,0
class Solution {     public int countSpecialNumbers(int n) {         int count = 0;         for (int i = 1; i <= n; i++) {             boolean[] digits = new boolean[10];             int num = i;             while (num > 0) {                 int digit = num % 10;                 if (digits[digit]) {                     break;                 }                 digits[digit] = true;                 num /= 10;             }             if (num == 0) {                 count++;             }         }         return count;     } },0,,0,0,0
"class Solution {     public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {         int n = nums.length;         int m = removeQueries.length;         long[] answer = new long[m + 1];          // Get segment sums before removals         List<Long> segmentSums = new ArrayList<>();         long sum = 0;         for (int num : nums) {             if (num == 0) {                 segmentSums.add(sum);                 sum = 0;             } else {                 sum += num;             }         }         segmentSums.add(sum);          // Apply removals and get maximum segment sums         TreeSet<Integer> removedIndices = new TreeSet<>();         for (int i = 0; i < m; i++) {             int query = removeQueries[i];             removedIndices.add(query);             int leftIndex = removedIndices.lower(query) != null ? removedIndices.lower(query) + 1 : 0;             int rightIndex = removedIndices.higher(query) != null ? removedIndices.higher(query) - 1 : n - 1;             long maxSegmentSum = 0;             for (int j = leftIndex; j <= rightIndex; j++) {                 maxSegmentSum = Math.max(maxSegmentSum, segmentSums.get(j));             }             answer[i] = maxSegmentSum;         }          // Add remaining maximum segment sum         answer[m] = removedIndices.isEmpty() ? segmentSums.get(0) : 0;         int leftIndex = removedIndices.lower(n) != null ? removedIndices.lower(n) + 1 : 0;         int rightIndex = n - 1;         long maxSegmentSum = 0;         for (int j = leftIndex; j <= rightIndex; j++) {             maxSegmentSum = Math.max(maxSegmentSum, segmentSums.get(j));         }         answer[m] += maxSegmentSum;          return answer;     } }",1,"2382-maximum-segment-sum-after-removals/Solution.java:2:	NPathComplexity:	The method 'maximumSegmentSum(int[], int[])' has an NPath complexity of 216, current threshold is 200
",0,0,0
"class Solution {     public long kSum(int[] nums, int k) {         Arrays.sort(nums); // Sort the array in non-increasing order         long left = Integer.MIN_VALUE; // Set the range of possible answers         long right = 0;         for (int i = 0; i < nums.length; i++) {             left = Math.max(left, nums[i]); // Update left range with current element             right += nums[i]; // Add current element to right range         }         while (left < right) { // Perform binary search             long mid = left + (right - left) / 2;             int count = getCount(nums, mid); // Get the number of subsequence sums greater than or equal to mid             if (count < k) {                 left = mid + 1; // kth largest sum is greater than mid, so search higher             } else {                 right = mid; // kth largest sum is less than or equal to mid, so search lower             }         }         return left;     }          private int getCount(int[] nums, long target) {         int count = 0;         int left = 0;         int right = nums.length - 1;         while (left < right) { // Two pointer approach             if ((long) nums[left] + (long) nums[right] >= target) { // If sum of two pointers is greater than or equal to target, all the sums from left to right will also be greater than or equal to target                 count += right - left; // Add the number of valid subsequence sums to the count                 right--; // Decrement right pointer             } else {                 left++; // Increment left pointer             }         }         return count;     } }",1,"2386-find-the-k-sum-of-an-array/Solution.java:6:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
2386-find-the-k-sum-of-an-array/Solution.java:27:	UnnecessaryCast:	Unnecessary cast (long)
2386-find-the-k-sum-of-an-array/Solution.java:27:	UnnecessaryCast:	Unnecessary cast (long)
",0,0,1
"class Solution {     public int[] maxSlidingWindow(int[] nums, int k) {         int n = nums.length;         if (n == 0 || k == 0) {             return new int[0];         }         if (k == 1) {             return nums;         }          int[] left = new int[n];         left[0] = nums[0];         int[] right = new int[n];         right[n - 1] = nums[n - 1];         for (int i = 1; i < n; i++) {             // from left to right             if (i % k == 0) {                 left[i] = nums[i];             } else {                 left[i] = Math.max(left[i - 1], nums[i]);             }              // from right to left             int j = n - i - 1;             if ((j + 1) % k == 0) {                 right[j] = nums[j];             } else {                 right[j] = Math.max(right[j + 1], nums[j]);             }         }          int[] output = new int[n - k + 1];         for (int i = 0; i < n - k + 1; i++) {             output[i] = Math.max(right[i], left[i + k - 1]);         }          return output;     } }",0,,0,0,0
"import java.util.*;  class Solution {     public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {         int[][] ans = new int[k][k];         Map<Integer, Set<Integer>> rowCandidates = new HashMap<>();         Map<Integer, Set<Integer>> colCandidates = new HashMap<>();         int[] rowAbove = new int[k];         int[] rowBelow = new int[k];         int[] colLeft = new int[k];         int[] colRight = new int[k];          // Initialize candidate sets for each row and column         for (int i = 0; i < k; i++) {             rowCandidates.put(i, new HashSet<>());             colCandidates.put(i, new HashSet<>());             for (int j = 1; j <= k; j++) {                 rowCandidates.get(i).add(j);  // All numbers are candidates initially                 colCandidates.get(i).add(j);             }         }          // Initialize row and column constraints         for (int[] rc : rowConditions) {             int above = rc[0] - 1, below = rc[1] - 1;             rowAbove[below] = Math.max(rowAbove[below], above + 1);  // Record highest allowed row for each number             rowBelow[above] = Math.max(rowBelow[above], below + 1);  // Record lowest allowed row for each number         }         for (int[] cc : colConditions) {             int left = cc[0] - 1, right = cc[1] - 1;             colLeft[right] = Math.max(colLeft[right], left + 1);    // Record highest allowed column for each number             colRight[left] = Math.max(colRight[left], right + 1);   // Record lowest allowed column for each number         }          // Solve the matrix row by row         for (int i = 0; i < k; i++) {             if (!solveRow(i, ans, rowAbove, rowBelow, rowCandidates, colCandidates)) {                 return new int[0][0];  // No solution found             }         }          return ans;     }      private boolean solveRow(int row, int[][] matrix, int[] rowAbove, int[] rowBelow,                              Map<Integer, Set<Integer>> rowCandidates, Map<Integer, Set<Integer>> colCandidates) {         int k = matrix.length;          // Determine the set of candidates for each cell in this row         List<Set<Integer>> cellCandidates = new ArrayList<>();         for (int i = 0; i < k; i++) {             cellCandidates.add(new HashSet<>(rowCandidates.get(row)));  // Start with all candidates             for (int j = 0; j < row; j++) {                 cellCandidates.get(i).remove(matrix[j][i]);  // Remove numbers already used in upper rows             }             for (int j = 0; j < k; j++) {                 if (colCandidates.get(j).contains(matrix[row][j])) {  // If this number can be placed in column j                     cellCandidates.get(i).retainAll(colCandidates.get(j));  // Remove candidates that can't appear in this column                 }             }             if (cellCandidates.get(i).isEmpty()) {                 return false;  // No candidate available for this cell             }         }          // Try to assign a candidate to each cell in the row         List<Integer> cells = new ArrayList<>();         for (int i = 0; i < k; i++) {             cells.add(i);         }         Collections.shuffle(cells);  // Randomize the order of the cells to break ties         for (int i : cells) {             int num = getRandomElement(cellCandidates.get(i));             matrix[row][i] = num;             rowCandidates.get(row).remove(num);             colCandidates.get(i).remove(num);         }          // Check if the row constraints are satisfied         for (int i = 0; i < k; i++) {             if (matrix[row][i] > 0) {                 if (matrix[row][i] <= rowAbove[i] || matrix[row][i] >= rowBelow[i]) {                     return false;                 }             }         }          return true;  // This row has been successfully filled with numbers     }      private int getRandomElement(Set<Integer> set) {         int idx = new Random().nextInt(set.size());         int i = 0;         for (int num : set) {             if (i == idx) {                 return num;             }             i++;         }         return -1;  // This should never happen     } }",1,"2392-build-a-matrix-with-conditions/Solution.java:25:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2392-build-a-matrix-with-conditions/Solution.java:30:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2392-build-a-matrix-with-conditions/Solution.java:6:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
2392-build-a-matrix-with-conditions/Solution.java:7:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
2392-build-a-matrix-with-conditions/Solution.java:45:	NPathComplexity:	The method 'solveRow(int, int[][], int[], int[], Map<Integer, Set<Integer>>, Map<Integer, Set<Integer>>)' has an NPath complexity of 260, current threshold is 200
2392-build-a-matrix-with-conditions/Solution.java:82:	CollapsibleIfStatements:	This if statement could be combined with its parent
",1,0,0
"class Solution {     public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {         int n = chargeTimes.length;         int maxRobots = 0;                  for (int i = 0; i < n; i++) {             long totalCost = 0;             int robots = 0;             int maxCharge = 0;                          for (int j = i; j < n; j++) {                 int charge = chargeTimes[j];                 if (charge > maxCharge) {                     maxCharge = charge;                 }                                  totalCost += runningCosts[j];                 if (totalCost + maxCharge <= budget) {                     robots++;                 } else {                     break;                 }             }                          if (robots > maxRobots) {                 maxRobots = robots;             }         }                  return maxRobots;     } }",0,,0,0,0
"class Solution {      public int mostBooked(int n, int[][] meetings) {         int[] rooms = new int[n]; //store the end time of meetings         Arrays.fill(rooms, Integer.MAX_VALUE); // initially, all rooms are empty         int maxRoom = 0; //track the room that held the maximum number of meetings         Arrays.sort(meetings, (a,b) -> a[0]-b[0]); //sort meetings by start time                  for(int i=0; i<meetings.length; i++){             int[] meeting = meetings[i];             int idx = getNearestRoom(rooms, meeting[0]); //find the closest room that was vacated             if(idx != -1){ //if a room is found                 rooms[idx] = meeting[1]; //book meeting in that room                 maxRoom = Math.max(maxRoom, idx); //update maxRoom if necessary             }         }         return maxRoom;     }               //finds the nearest room that is vacated     private int getNearestRoom(int[] rooms, int start){         int idx = -1;         int minTime = Integer.MAX_VALUE;         for(int i=0; i<rooms.length; i++){             if(rooms[i] <= start && rooms[i] < minTime){ //room is vacated before or at start time                 minTime = rooms[i]; //update the time the room is vacated                 idx = i; //update the room index             }         }         if(idx == -1) return Arrays.binarySearch(rooms, start); //all rooms are in use, return the nearest empty room         return idx;     } }",1,"2402-meeting-rooms-iii/Solution.java:8:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int lengthOfLIS(int[] nums, int k) {         int n = nums.length;         int[] dp = new int[n];         Arrays.fill(dp, 1);         int result = 1;          for (int i = 1; i < n; i++) {             for (int j = 0; j < i; j++) {                 if (nums[i] > nums[j] && nums[i] - nums[j] <= k) {                     dp[i] = Math.max(dp[i], dp[j] + 1);                 }             }             result = Math.max(result, dp[i]);         }          return result;     } }",0,,0,0,0
class Solution {     public long minimumMoney(int[][] transactions) {         long money = 0;         for (int[] transaction : transactions) {             money += transaction[0];         }                  PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());         for (int[] transaction : transactions) {             pq.offer(transaction[1]);             if (pq.size() > transaction[0]) {                 money -= pq.poll();             }         }         return money;     } } ,0,,0,0,0
class Solution {     public int[] sumPrefixScores(String[] words) {         int[] prefixScores = new int[words.length];         for(int i=0; i<words.length; i++) {             int score = 0;             for(int j=0; j<words.length; j++) {                 if(words[j].startsWith(words[i])) {                     score++;                 }             }             for(int k=0; k<words[i].length(); k++) {                 prefixScores[i] += score;             }         }         return prefixScores;     } },1,"2416-sum-of-prefix-scores-of-strings/Solution.java:6:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int numberOfGoodPaths(int[] vals, int[][] edges) {         // Construct the tree using adjacency list         List<List<Integer>> adjList = new ArrayList<>();         for (int i = 0; i < vals.length; i++) {             adjList.add(new ArrayList<>());         }         for (int[] edge : edges) {             adjList.get(edge[0]).add(edge[1]);             adjList.get(edge[1]).add(edge[0]);         }                  // Initialize count of good paths         int count = 0;                  // Perform dfs from each node to find good paths         for (int i = 0; i < vals.length; i++) {             count += dfs(i, i, vals, adjList, new boolean[vals.length]);         }                  return count;     }          private int dfs(int root, int curr, int[] vals, List<List<Integer>> adjList, boolean[] visited) {         if (curr != root && vals[root] != vals[curr]) {             return 0; // Not a good path         }         visited[curr] = true;         int count = 1; // Current node is a good path of length 1         for (int neighbor : adjList.get(curr)) {             if (!visited[neighbor]) {                 count += dfs(root, neighbor, vals, adjList, visited);             }         }         return count;     } }",1,"2421-number-of-good-paths/Solution.java:5:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public long numberOfPairs(int[] nums1, int[] nums2, int diff) {         int n = nums1.length;         long count = 0;         for(int i = 0; i < n; i++){             for(int j = i + 1; j < n; j++){                 if(nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff){                     count++;                 }             }         }         return count;     } }",0,,0,0,0
"class Solution {     public int deleteString(String s) {         int n = s.length();         if (n == 1) return 1;                  int maxOps = n;         for (int i = 1; i <= n / 2; i++) {             int tempOps = 1;             String pattern = s.substring(0, i);             int j = i;             while (j <= n - i && s.substring(j, j + i).equals(pattern)) {                 j += i;                 tempOps++;             }             if (j < n) tempOps += deleteString(s.substring(j));             maxOps = Math.min(maxOps, tempOps);         }         return maxOps;     } }",0,,0,0,0
"class Solution {     public int numberOfPaths(int[][] grid, int k) {         int m = grid.length;         int n = grid[0].length;         int[][] dp = new int[m][n];         dp[0][0] = grid[0][0] % k == 0 ? 1 : 0;         for (int i = 1; i < m; i++) {             dp[i][0] = (dp[i-1][0] + (grid[i][0] % k == 0 ? 1 : 0)) % 1000000007;         }         for (int j = 1; j < n; j++) {             dp[0][j] = (dp[0][j-1] + (grid[0][j] % k == 0 ? 1 : 0)) % 1000000007;         }         for (int i = 1; i < m; i++) {             for (int j = 1; j < n; j++) {                 dp[i][j] = ((dp[i-1][j] + dp[i][j-1]) % 1000000007 + (grid[i][j] % k == 0 ? 1 : 0)) % 1000000007;             }         }         return dp[m-1][n-1];     } }",0,,0,0,0
"class Solution {     public int componentValue(int[] nums, int[][] edges) {         int n = nums.length;         int totalSum = 0;         for (int i = 0; i < n; i++) {             totalSum += nums[i];         }         if (totalSum % n != 0)             return 0;         int individualSum = totalSum / n;         Map<Integer, Integer> valueToCount = new HashMap<>();         for (int i = 0; i < n; i++) {             valueToCount.put(nums[i], valueToCount.getOrDefault(nums[i], 0) + 1);         }         Map<Integer, List<Integer>> graph = new HashMap<>();         for (int i = 0; i < n; i++) {             graph.put(i, new ArrayList<Integer>());         }         for (int[] edge : edges) {             graph.get(edge[0]).add(edge[1]);             graph.get(edge[1]).add(edge[0]);         }         Set<Integer> visited = new HashSet<>();         int result = 0;         for (int i = 0; i < n; i++) {             if (!visited.contains(i)) {                 int sum = dfs(i, visited, graph, nums);                 if (sum == individualSum * valueToCount.get(nums[i]))                     continue;                 result += Math.abs(sum - (individualSum * valueToCount.get(nums[i])));             }         }         return result;     }      public int dfs(int node, Set<Integer> visited, Map<Integer, List<Integer>> graph, int[] nums) {         visited.add(node);         int sum = nums[node];         for (int n : graph.get(node)) {             if (!visited.contains(n)) {                 sum += dfs(n, visited, graph, nums);             }         }         return sum;     } }",0,,0,0,0
"class Solution {     public long countSubarrays(int[] nums, int minK, int maxK) {         int n = nums.length;         int count = 0;         for (int i = 0; i < n; i++) {             if (nums[i] == maxK) { // we found a potential subarray                 int j = i; // j is the end index of subarray                 while (j < n && nums[j] == maxK) { // traverse right side to find the true end                     j++;                 }                 if (nums[i] == minK && nums[j - 1] == maxK) { // if the subarray satisfies conditions                     count += (j - i) * (j - i + 1) / 2; // add total possible subarrays                     i = j - 1; // set i for next subarray                 }             }         }         return count;     } }",0,,0,0,0
"class Solution {     public long minCost(int[] nums, int[] cost) {         int n = nums.length;         int minValue = nums[0];         long totalCost = 0, currentCost = 0;         for (int i = 0; i < n; i++) {             minValue = Math.min(minValue, nums[i]);             currentCost = 0;             while (i < n && nums[i] == nums[i + 1]) {                 i++;                 currentCost += cost[i];  // Summing the cost of same numbers                 minValue = Math.min(minValue, nums[i]);             }             totalCost += currentCost - cost[i] * (i + 1);             // Subtracting the cost of all current numbers except the minimum             totalCost += (long) minValue * (i + 1) - currentCost;         }         return totalCost;     } }",1,"2448-minimum-cost-to-make-array-equal/Solution.java:5:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2448-minimum-cost-to-make-array-equal/Solution.java:5:	UnusedAssignment:	The initializer for variable 'currentCost' is never used (overwritten on line 8)
",1,0,0
"class Solution {     public long makeSimilar(int[] nums, int[] target) {         Map<Integer, Integer> numFreq = new HashMap<>();         Map<Integer, Integer> targetFreq = new HashMap<>();         int n = nums.length;                  // Count frequencies of elements in nums and target         for (int i = 0; i < n; i++) {             numFreq.put(nums[i], numFreq.getOrDefault(nums[i], 0) + 1);             targetFreq.put(target[i], targetFreq.getOrDefault(target[i], 0) + 1);         }                  int minOperations = 0;                  // Check each element of nums and target         for (int i = 0; i < n; i++) {             int num = nums[i];             int targetNum = target[i];                          // If the frequency of the element is different in nums and target             if (!numFreq.get(num).equals(targetFreq.get(targetNum))) {                 int diff = targetNum - num;                                  // Check if there is a matching frequency for the difference in nums                 if (numFreq.containsKey(diff) && numFreq.get(diff).equals(targetFreq.get(diff))) {                     minOperations++;                     numFreq.put(num, numFreq.get(num) - 1);                     numFreq.put(diff, numFreq.get(diff) + 1);                     nums[i] = targetNum;                 } else {                     // If there is no match, then we need to perform two operations                     minOperations += 2;                     numFreq.put(num, numFreq.get(num) - 1);                     numFreq.put(targetNum, numFreq.getOrDefault(targetNum, 0) + 1);                     nums[i] = targetNum;                 }             }         }                  return minOperations;     } }",0,,0,0,0
"class Solution {     public int[] secondGreaterElement(int[] nums) {         int n = nums.length;         int[] ans = new int[n];         Stack<Integer> stack = new Stack<>();         TreeMap<Integer, Integer> map = new TreeMap<>();         for (int i = n - 1; i >= 0; i--) {             while (!stack.isEmpty() && nums[i] > stack.peek()) {                 map.put(stack.pop(), nums[i]);             }             stack.push(nums[i]);         }         while (!stack.isEmpty()) {             map.put(stack.pop(), -1);         }         for (int i = 0; i < n; i++) {             ans[i] = map.getOrDefault(nums[i], -1);         }         return ans;     } }",0,,0,0,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public int[] treeQueries(TreeNode root, int[] queries) {         int[] heights = new int[queries.length]; // to store the heights of the tree after each query                  for (int i = 0; i < queries.length; i++) {             TreeNode target = findNode(root, queries[i]); // find the node to be removed             int currHeight = height(root); // find the current height of the tree             removeNode(target); // remove the node from the tree             int newHeight = height(root); // find the new height of the tree             heights[i] = newHeight; // store the new height in the heights array             addNode(root, target); // add the removed node back to the tree         }                  return heights;     }          // helper method to find the node with the given value in the tree     private TreeNode findNode(TreeNode root, int value) {         if (root == null || root.val == value) {             return root;         } else {             TreeNode left = findNode(root.left, value);             TreeNode right = findNode(root.right, value);             if (left != null) {                 return left;             } else if (right != null) {                 return right;             } else {                 return null;             }         }     }          // helper method to remove the given node from the tree     private void removeNode(TreeNode node) {         if (node == null) {             return;         }         if (node.left != null) {             node.left = null;         }         if (node.right != null) {             node.right = null;         }     }          // helper method to add the given node back to the tree     private void addNode(TreeNode root, TreeNode node) {         if (root == null) {             return;         }         if (root.left == null) {             root.left = node;         } else if (root.right == null) {             root.right = node;         } else {             addNode(root.left, node);         }     }          // helper method to find the height of the tree     private int height(TreeNode root) {         if (root == null) {             return 0;         }         return 1 + Math.max(height(root.left), height(root.right));     } }",1,"2458-height-of-binary-tree-after-subtree-removal-queries/TreeNode.java:22:	UnusedLocalVariable:	Avoid unused local variables such as 'currHeight'.
2458-height-of-binary-tree-after-subtree-removal-queries/TreeNode.java:55:	NullAssignment:	Assigning an Object to null is a code smell.  Consider refactoring.
2458-height-of-binary-tree-after-subtree-removal-queries/TreeNode.java:58:	NullAssignment:	Assigning an Object to null is a code smell.  Consider refactoring.
",0,0,0
"import java.util.*;  class Solution {     public long minimumTotalDistance(List<Integer> robot, int[][] factory) {         long totalDistance = 0;         int n = robot.size();         int[] robots = new int[n];         int[] factoryPositions = new int[factory.length];         int[] factoryLimits = new int[factory.length];         for (int i = 0; i < n; i++) {             robots[i] = robot.get(i);         }         for (int i = 0; i < factory.length; i++) {             factoryPositions[i] = factory[i][0];             factoryLimits[i] = factory[i][1];         }         Arrays.sort(robots);         Arrays.sort(factoryPositions);          for (int i = 0; i < n; i++) {             int p = findNearestFactory(robots[i], factoryPositions, factoryLimits);             totalDistance += Math.abs(factoryPositions[p] - robots[i]);         }         return totalDistance;     }     private int findNearestFactory(int position, int[] factoryPositions, int[] factoryLimits) {         int index = Arrays.binarySearch(factoryPositions, position);         if (index >= 0) {             return index;         }         index = -index - 1;         if (index == 0) {             return 0;         }         if (index == factoryPositions.length) {             return index - 1;         }         if (factoryLimits[index - 1] > 0 && position - factoryPositions[index - 1] <= factoryPositions[index] - position) {             factoryLimits[index - 1]--;             return index - 1;         }         factoryLimits[index]--;         return index;     } }",0,,0,0,0
"class Solution {     public String[] splitMessage(String message, int limit) {         ArrayList<String> parts = new ArrayList<>();         int n = message.length();         int numParts = (n + limit - 1) / limit;         if (numParts > 9999) {             return new String[0];         }         for (int i = 0; i < numParts; i++) {             int start = i * limit;             int end = Math.min(start + limit, n);             String part = message.substring(start, end);             part += ""<"" + (i+1) + ""/"" + numParts + "">"";             parts.add(part);         }         return parts.toArray(new String[0]);     } }",1,"2468-split-message-based-on-limit/Solution.java:13:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
",0,0,0
"class Solution {     public int maxPalindromes(String s, int k) {         int n = s.length();         int count = 0;         for (int i = 0; i < n; i++) {             for (int j = i + k; j <= n; j++) {                 String sub = s.substring(i, j);                 if (isPalindrome(sub) && sub.length() >= k) {                     count++;                     i = j - 1;                     break;                 }             }         }         return count;     }          private boolean isPalindrome(String s) {         int i = 0, j = s.length() - 1;         while (i < j) {             if (s.charAt(i) != s.charAt(j)) {                 return false;             }             i++;             j--;         }         return true;     } }",1,"2472-maximum-number-of-non-overlapping-palindrome-substrings/Solution.java:19:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"import java.util.*;  class Solution {     public int beautifulPartitions(String s, int k, int minLength) {         final int MOD = 1_000_000_007;         int n = s.length();         int[][][] dp = new int[n+1][k+1][2];         dp[0][0][1] = 1;         int[] primes = {2, 3, 5, 7};                  for(int i=1; i<=n; i++) {             for(int j=1; j<=k; j++) {                 for(int p=0; p<2; p++) {                     char c = s.charAt(i-1);                     for(int prime : primes) {                         boolean isPrime = (c-'0') == prime;                         int idx = isPrime ? 0 : 1;                                                  if(i>=minLength && j>=1 && isPrime) {                             dp[i][j][idx] += dp[i-minLength][j-1][p];                             dp[i][j][idx] %= MOD;                         }                         dp[i][j][idx] += dp[i-1][j][p];                         dp[i][j][idx] %= MOD;                     }                 }             }         }         return dp[n][k][0];     } }",1,"2478-number-of-beautiful-partitions/Solution.java:1:	UnnecessaryImport:	Unused import 'java.util.*'
",0,0,0
class Solution {     public int countPalindromes(String s) {         int mod = 1000000007; // 10^9 + 7         int n = s.length();         int[][] dp = new int[n][n];          // initialize the diagonal elements (substrings of length 1)         for (int i = 0; i < n; i++) {             dp[i][i] = 1;         }          for (int len = 2; len <= n; len++) {             for (int i = 0; i < n - len + 1; i++) {                 int j = i + len - 1;                 if (s.charAt(i) == s.charAt(j)) {                     dp[i][j] = ((dp[i+1][j] % mod + dp[i][j-1] % mod) % mod + 1) % mod;                 } else {                     dp[i][j] = ((dp[i+1][j] % mod + dp[i][j-1] % mod) % mod - dp[i+1][j-1] % mod + mod) % mod;                 }             }         }          return dp[0][n-1];     } },0,,0,0,0
"class Solution {     public int countSubarrays(int[] nums, int k) {         int count=0;         for(int i=0;i<nums.length;i++){             if(nums[i]==k)                 count++;             int sum=nums[i];             for(int j=i+1;j<nums.length;j++){                 sum+=nums[j];                  if(sum/((j-i)+1)==k)                     count++;             }         }         return count;     } }",1,"2488-count-subarrays-with-median-k/Solution.java:10:	UselessParentheses:	Useless parentheses.
",0,0,0
"import java.util.*;  class Solution {     public int magnificentSets(int n, int[][] edges) {         // Initialize adjacency list and visited array         List<Integer>[] adjList = new ArrayList[n];         for (int i = 0; i < n; i++) {             adjList[i] = new ArrayList<>();         }         boolean[] visited = new boolean[n];          // Create adjacency list         for (int[] edge : edges) {             int u = edge[0] - 1;             int v = edge[1] - 1;             adjList[u].add(v);             adjList[v].add(u);         }          // Initialize group array and group count         int[] group = new int[n];         int groupCount = 0;          // Traverse each unvisited node and its connected components         for (int i = 0; i < n; i++) {             if (!visited[i]) {                 // Start a new group                 groupCount++;                 group[i] = groupCount;                 visited[i] = true;                 Queue<Integer> queue = new LinkedList<>();                 queue.offer(i);                  // BFS to add nodes to group                 while (!queue.isEmpty()) {                     int u = queue.poll();                     for (int v : adjList[u]) {                         if (!visited[v]) {                             group[v] = group[u] == groupCount ? groupCount + 1 : groupCount;                             visited[v] = true;                             queue.offer(v);                         } else if (group[v] == group[u]) {                             // Two nodes in same group but not satisfying condition                             return -1;                         }                     }                 }             }         }          return groupCount;     } }",1,"2493-divide-nodes-into-the-maximum-number-of-groups/Solution.java:38:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",0,0,0
"class Solution {     public long minimumTotalCost(int[] nums1, int[] nums2) {         int n = nums1.length;         long totalCost = 0;         int[] diff = new int[n];         for (int i = 0; i < n; i++) {             diff[i] = nums1[i] - nums2[i];             totalCost += Math.abs(diff[i]);         }         if (totalCost == 0) {             return 0;         }         if (totalCost % 2 == 1) {             return -1;         }         long cost1 = getCost(nums1, nums2, diff, totalCost / 2);         long cost2 = getCost(nums1, nums2, diff, totalCost / 2 + 1);         return Math.min(cost1, cost2);     }          private long getCost(int[] nums1, int[] nums2, int[] diff, long target) {         int n = nums1.length;         int[] copy = new int[n];         System.arraycopy(nums1, 0, copy, 0, n);         long cost = 0;         PriorityQueue<Integer> queue = new PriorityQueue<>((a, b) -> (diff[b] - diff[a]));         for (int i = 0; i < n; i++) {             if (diff[i] > 0) {                 queue.add(i);             }         }         while (cost < target && !queue.isEmpty()) {             int idx = queue.poll();             cost += diff[idx];             copy[idx]--;             diff[idx] = nums2[idx] - copy[idx];             if (diff[idx] > 0) {                 queue.offer(idx);             }         }         if (cost < target) {             return 2 * target;         }         return cost + calculateSwapCost(copy, nums2);     }          private long calculateSwapCost(int[] nums1, int[] nums2) {         int n = nums1.length;         int[] idx = new int[n + 1];         for (int i = 0; i < n; i++) {             idx[nums1[i]] = i;         }         long cost = 0;         for (int i = 0; i < n; i++) {             if (nums1[i] != nums2[i]) {                 int j = idx[nums2[i]];                 cost += (long) (Math.abs(i - j));             }         }         return cost;     } }",1,"2499-minimum-total-cost-to-make-arrays-unequal/Solution.java:26:	UselessParentheses:	Useless parentheses.
2499-minimum-total-cost-to-make-arrays-unequal/Solution.java:57:	UnnecessaryCast:	Unnecessary cast (long)
2499-minimum-total-cost-to-make-arrays-unequal/Solution.java:57:	UselessParentheses:	Useless parentheses.
",0,0,0
"import java.util.*; class Solution {     public int[] maxPoints(int[][] grid, int[] queries) {         int m = grid.length, n = grid[0].length;         int[][] dirs = {{0,1},{1,0},{0,-1},{-1,0}}; // right, down, left, up         int[][] maxPoints = new int[m][n];         int[] answer = new int[queries.length];                  for (int r = 0; r < m; r++) {             for (int c = 0; c < n; c++) {                 int max = grid[r][c];                 for (int[] dir : dirs) {                     int nr = r + dir[0];                     int nc = c + dir[1];                     if (nr >= 0 && nr < m && nc >= 0 && nc <n) {                         max = Math.max(max, grid[nr][nc]);                     }                 }                 maxPoints[r][c] = max;             }         }                  for (int i = 0; i < queries.length; i++) {             int query = queries[i];             int points = 0;             for (int r = 0; r < m; r++) {                 for (int c = 0; c < n; c++) {                     if (maxPoints[r][c] < query) {                         points++;                         dfs(grid, maxPoints, r, c, query, dirs);                     }                 }             }             answer[i] = points;         }                  return answer;     }          private void dfs(int[][] grid, int[][] maxPoints, int r, int c, int val, int[][] dirs) {         if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length || maxPoints[r][c] >= val) {             return;         }         if (grid[r][c] >= val) {             maxPoints[r][c] = grid[r][c];             return;         }         if (maxPoints[r][c] == val-1) {             maxPoints[r][c] = val;         }         for (int[] dir : dirs) {             dfs(grid, maxPoints, r + dir[0], c + dir[1], val, dirs);         }     } }",1,"2503-maximum-number-of-points-from-grid-queries/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2503-maximum-number-of-points-from-grid-queries/Solution.java:1:	UnnecessaryImport:	Unused import 'java.util.*'
",1,0,0
"import java.util.*;  class Solution {     public boolean isPossible(int n, List<List<Integer>> edges) {         Map<Integer, Set<Integer>> graph = new HashMap<>();         int[] degrees = new int[n + 1];          for (int i = 1; i <= n; i++) {             graph.put(i, new HashSet<>());         }          for (List<Integer> edge : edges) {             int u = edge.get(0);             int v = edge.get(1);              graph.get(u).add(v);             graph.get(v).add(u);              degrees[u]++;             degrees[v]++;         }          int oddDegree = 0;          for (int i = 1; i <= n; i++) {             if (degrees[i] % 2 == 1) {                 oddDegree++;             }         }          if (oddDegree == 0) {             return true;         } else if (oddDegree == 2) {             for (int i = 1; i <= n; i++) {                 if (degrees[i] % 2 == 1) {                     return connect(graph, degrees, i);                 }             }         }          return false;     }      private boolean connect(Map<Integer, Set<Integer>> graph, int[] degrees, int u) {         for (int v : graph.get(u)) {             if (degrees[v] % 2 == 1) {                 graph.get(u).remove(v);                 graph.get(v).remove(u);                  degrees[u]--;                 degrees[v]--;                  if (isEuler(graph, degrees, u)) {                     return true;                 }                  graph.get(u).add(v);                 graph.get(v).add(u);                  degrees[u]++;                 degrees[v]++;             }         }          return false;     }      private boolean isEuler(Map<Integer, Set<Integer>> graph, int[] degrees, int u) {         Stack<Integer> stack = new Stack<>();         Set<Integer> visited = new HashSet<>();          stack.push(u);          while (!stack.isEmpty()) {             int v = stack.pop();              visited.add(v);              for (int neighbor : graph.get(v)) {                 if (!visited.contains(neighbor)) {                     stack.push(neighbor);                 }             }         }          for (int i = 1; i <= graph.size(); i++) {             if (!visited.contains(i)) {                 return false;             }              if (degrees[i] % 2 == 1) {                 return false;             }         }          return true;     } }",1,"2508-add-edges-to-make-degrees-of-all-nodes-even/Solution.java:5:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
2508-add-edges-to-make-degrees-of-all-nodes-even/Solution.java:69:	LooseCoupling:	Avoid using implementation types like 'Stack'; use the interface instead
2508-add-edges-to-make-degrees-of-all-nodes-even/Solution.java:69:	ReplaceVectorWithList:	Consider replacing this Vector with the newer java.util.List
2508-add-edges-to-make-degrees-of-all-nodes-even/Solution.java:69:	ReplaceVectorWithList:	Consider replacing this Vector with the newer java.util.List
",0,0,0
"import java.util.*;  class Solution {     public int[] cycleLengthQueries(int n, int[][] queries) {         int[] ans = new int[queries.length];          for (int i = 0; i < queries.length; i++) {             int a = queries[i][0];             int b = queries[i][1];              // add the edge             int[][] edges = new int[(1 << n) - 1][];             int count = 0;             for (int j = 0; j < edges.length; j++) {                 int left = 2 * j + 1;                 int right = 2 * j + 2;                 if (left < edges.length)                     edges[count++] = new int[] { j, left };                 if (right < edges.length)                     edges[count++] = new int[] { j, right };             }              int[] degree = new int[edges.length];             for (int[] edge : edges) {                 int u = edge[0];                 int v = edge[1];                  if ((u == a - 1 && v == b - 1) || (u == b - 1 && v == a - 1)) {                     degree[u]++;                     degree[v]++;                 }             }              boolean[] visited = new boolean[edges.length];             int curr = -1;             int cycleLength = -1;              for (int j = 0; j < visited.length; j++) {                 if (!visited[j]) {                     int[] cycleInfo = dfs(j, edges, visited, new int[2], a - 1, degree);                     if (cycleInfo != null) {                         curr = cycleInfo[0];                         cycleLength = cycleInfo[1];                         break;                     }                 }             }              ans[i] = cycleLength;              // remove the edge             degree[a-1]--;             degree[b-1]--;         }          return ans;     }      private int[] dfs(int u, int[][] edges, boolean[] visited, int[] tmp, int target, int[] degree) {         Arrays.fill(tmp, -1);          visited[u] = true;          for (int[] edge : edges) {             int v = -1;             if (edge[0] == u) {                 v = edge[1];             } else if (edge[1] == u) {                 v = edge[0];             }              if (v != -1) {                 if (!visited[v]) {                      if (dfs(v, edges, visited, tmp, target, degree) != null) {                         return tmp;                     }                  } else if (v == target && degree[edges.length-1]>1) {                     tmp[0] = u;                     tmp[1] = 1;                     return tmp;                 }             }         }          return null;     } }",1,"2509-cycle-length-queries-in-a-tree/Solution.java:35:	UnusedLocalVariable:	Avoid unused local variables such as 'curr'.
2509-cycle-length-queries-in-a-tree/Solution.java:35:	UnusedAssignment:	The initializer for variable 'curr' is never used (overwritten on line 42)
2509-cycle-length-queries-in-a-tree/Solution.java:42:	UnusedAssignment:	The value assigned to variable 'curr' is never used
2509-cycle-length-queries-in-a-tree/Solution.java:73:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
2509-cycle-length-queries-in-a-tree/Solution.java:87:	ReturnEmptyCollectionRatherThanNull:	Return an empty collection rather than null.
",0,0,0
"class Solution {     public int countAnagrams(String s) {                  int MOD = 1000000007;         Map<String, Integer> map = new HashMap<>();         String[] words = s.split("" "");         for(String word : words) {             char[] chars = word.toCharArray();             Arrays.sort(chars);             String sortedWord = new String(chars);             map.put(sortedWord, map.getOrDefault(sortedWord, 0) + 1);         }                  int ans = 1;         for (Map.Entry<String, Integer> entry : map.entrySet()) {             ans = (int) (((long) ans * (long) factorial(entry.getValue())) % MOD);         }                  return ans;     }          private int factorial(int n) {         int MOD = 1000000007;         int ans = 1;                  for (int i = 1; i <= n; i++) {             ans = (int) (((long) ans * (long) i) % MOD);         }                  return ans;     } }",1,"2514-count-anagrams/Solution.java:10:	StringInstantiation:	Avoid instantiating String objects; this is usually unnecessary.
2514-count-anagrams/Solution.java:16:	UselessParentheses:	Useless parentheses.
2514-count-anagrams/Solution.java:16:	UnnecessaryCast:	Unnecessary cast (long)
2514-count-anagrams/Solution.java:16:	UnnecessaryCast:	Unnecessary cast (long)
2514-count-anagrams/Solution.java:27:	UselessParentheses:	Useless parentheses.
2514-count-anagrams/Solution.java:27:	UnnecessaryCast:	Unnecessary cast (long)
2514-count-anagrams/Solution.java:27:	UnnecessaryCast:	Unnecessary cast (long)
",0,0,0
"class Solution {     public int countPartitions(int[] nums, int k) {         int MOD = 1000000007;         int n = nums.length;         // Calculate cumulative sums from both ends of the array         long[] prefixSum = new long[n];         long[] suffixSum = new long[n];         prefixSum[0] = nums[0];         suffixSum[n-1] = nums[n-1];         for (int i = 1; i < n; i++) {             prefixSum[i] = prefixSum[i-1] + nums[i];             suffixSum[n-i-1] = suffixSum[n-i] + nums[n-i-1];         }         // Count great partitions using the cumulative sums         int count = 0;         int left = 0, right = n-1;         while (left <= right) {             if (prefixSum[left] >= k && suffixSum[right] >= k) {                 if (left == right) count++;                 else {                     // Calculate the sum of the left and right groups                     long leftSum = prefixSum[left], rightSum = suffixSum[right];                     // Check if there are numbers in between that can be added to either group                     int mid = left+1;                     while (mid < right && prefixSum[mid]-prefixSum[left] < k) mid++;                     if (prefixSum[mid]-prefixSum[left] >= k) {                         leftSum = prefixSum[mid];                         mid--;                     }                     while (mid < right && suffixSum[mid+1]-suffixSum[right] < k) mid++;                     if (suffixSum[mid+1]-suffixSum[right] >= k) {                         rightSum = suffixSum[mid+1];                     }                     // Add the number of great partitions that can be formed with the current left and right groups                     int leftCount = 1, rightCount = 1;                     while (left < mid && prefixSum[mid]-prefixSum[left] < rightSum) {                         leftCount++;                         left++;                     }                     while (left < mid && prefixSum[mid]-prefixSum[left] == rightSum) {                         leftCount++;                         left++;                         rightCount++;                     }                     while (right > mid && suffixSum[mid+1]-suffixSum[right] < leftSum) {                         rightCount++;                         right--;                     }                     while (right > mid && suffixSum[mid+1]-suffixSum[right] == leftSum) {                         rightCount++;                         right--;                     }                     count = (int) ((count + (long) leftCount * rightCount) % MOD);                 }                 left++;                 right--;             } else if (prefixSum[left] < suffixSum[right]) {                 left++;             } else {                 right--;             }         }         return count;     } }",1,"2518-number-of-great-partitions/Solution.java:16:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2518-number-of-great-partitions/Solution.java:22:21: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2518-number-of-great-partitions/Solution.java:35:21: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2518-number-of-great-partitions/Solution.java:2:	NPathComplexity:	The method 'countPartitions(int[], int)' has an NPath complexity of 5842, current threshold is 200
",1,0,0
"class Solution {     public long maxPower(int[] stations, int r, int k) {         int n = stations.length;         int[] prefixSum = new int[n];         int[] freq = new int[n + 1];         for (int i = 0; i < n; i++) {             int left = Math.max(0, i - r);             int right = Math.min(n - 1, i + r);             prefixSum[left]++;             if (right + 1 < n) prefixSum[right + 1]--;         }         int powerSum = 0;         for (int i = 0; i < n; i++) {             powerSum += prefixSum[i];             freq[Math.max(stations[i] - powerSum, 0)]++;         }         int currPower = n;         long ans = 0;         for (int i = 0; i <= n; i++) {             while (currPower > i && k >= freq[currPower - 1] * (currPower - i)) {                 k -= freq[currPower - 1] * (currPower - i);                 currPower--;             }             ans = Math.max(ans, (long)i * currPower);         }         return ans;     } }",1,"2528-maximize-the-minimum-powered-city/Solution.java:21:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'k'
",0,1,0
"class Solution {     public int findCrossingTime(int n, int k, int[][] time) {         // Sort the workers based on their efficiency         Arrays.sort(time, (a, b) -> {             if (a[0] + a[2] != b[0] + b[2]) return (a[0] + a[2]) - (b[0] + b[2]);             return a[1] - b[1];         });          // Priority queue to store workers waiting on the right side of the bridge         PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);          int currentTime = 0, availableWorkers = k;         while (n > 0) {             // Remove the workers who are done with crossing the bridge             while (!pq.isEmpty() && pq.peek()[2] <= currentTime) {                 int[] worker = pq.poll();                 availableWorkers++;             }              // Check if there are boxes to be moved and workers are available             if (availableWorkers > 0 && n > 0) {                 // Add the worker with the least efficiency to the bridge                 int[] worker = time[k - availableWorkers];                 pq.offer(new int[]{worker[0], worker[1] + currentTime + worker[0], currentTime + worker[0] + worker[2]});                 availableWorkers--;                 n--;             } else {                 // Else, let the time tick                 currentTime = pq.peek()[2];             }         }          // Return the time at which the last worker reaches the left bank         return pq.peek()[2] + time[k - 1][3];     } }",1,"2532-time-to-cross-a-bridge/Solution.java:12:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2532-time-to-cross-a-bridge/Solution.java:5:	UselessParentheses:	Useless parentheses.
2532-time-to-cross-a-bridge/Solution.java:16:	UnusedLocalVariable:	Avoid unused local variables such as 'worker'.
2532-time-to-cross-a-bridge/Solution.java:26:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'n'
",1,1,0
"class Solution {     public long maxOutput(int n, int[][] edges, int[] price) {         // build the graph         List<Integer>[] graph = new List[n];         for (int i = 0; i < n; i++) {             graph[i] = new ArrayList<>();         }         for (int[] edge : edges) {             int u = edge[0];             int v = edge[1];             graph[u].add(v);             graph[v].add(u);         }          // initialize variables         long maxCost = 0;         long[] maxSum = new long[n];         long[] minSum = new long[n];          // dfs to calculate maxSum and minSum for each node         dfs(0, -1, price, maxSum, minSum, graph);          // calculate the maximum cost for each root node         for (int root = 0; root < n; root++) {             long cost = maxSum[root] - minSum[root];             maxCost = Math.max(maxCost, cost);         }          return maxCost;     }      private void dfs(int node, int parent, int[] price, long[] maxSum, long[] minSum, List<Integer>[] graph) {         maxSum[node] = price[node];         minSum[node] = price[node];          for (int neighbor : graph[node]) {             if (neighbor == parent) {                 continue; // skip the parent node             }             dfs(neighbor, node, price, maxSum, minSum, graph);             maxSum[node] = Math.max(maxSum[node], maxSum[neighbor] + price[node]);             minSum[node] = Math.min(minSum[node], minSum[neighbor] + price[node]);         }     } }",0,,0,0,0
"public class Solution {     public boolean isReachable(int targetX, int targetY) {         return canReach(targetX, targetY, 1, 1);     }      private boolean canReach(int tx, int ty, int x, int y) {         if(tx < x || ty < y) {             return false;         }         if(tx == x && ty == y) {             return true;         }         // Recurse in all possible ways         return canReach(tx - x, ty - y, x, y + x) ||                canReach(tx - x, ty - y, x + y, y) ||                canReach(tx - x, ty - y, x * 2, y) ||                canReach(tx - x, ty - y, x, y * 2);     } }",0,,0,0,0
"class Solution {     public int minCost(int[] nums, int k) {                  int n = nums.length;         int[][] dp = new int[n+1][n+1];                  for(int i=1; i<=n; i++){             for(int j=1; j<=i; j++){                 int freq = 1;                 int[] cnts = new int[n+1];                 int maxCnt = 0;                 for(int k=i-1; k>=j-1; k--){                     cnts[nums[k]]++;                     maxCnt = Math.max(maxCnt, cnts[nums[k]]);                     if(maxCnt > freq+1){                         break;                     } else if(maxCnt == freq+1){                         freq++;                     }                                          int l = k-j+1;                     int trim = l-freq;                     dp[i][j] = (j==1 ? 0 : dp[j-1][j-1]) + k + trim * (k+1);                 }                 if(j>1){                     dp[i][j] = Math.min(dp[i][j], dp[i][j-1]+k);                 }             }         }         return dp[n][n];     } }",0,,0,0,0
"class Solution {     public long putMarbles(int[] weights, int k) {         int n = weights.length;         long[][] dp = new long[k + 1][n + 1];         for (int i = 1; i <= n; i++) {             dp[1][i] = dp[1][i - 1] + weights[i - 1];         }         for (int i = 2; i <= k; i++) {             for (int j = i; j <= n; j++) {                 long maxScore = Long.MIN_VALUE;                 long minCost = 0;                 for (int l = j; l >= i; l--) {                     minCost += weights[l - 1];                     long score = dp[i - 1][l - 1] + minCost;                     maxScore = Math.max(maxScore, score);                 }                 dp[i][j] = maxScore;             }         }         return dp[k][n] - dp[1][n];     } }",0,,0,0,0
class Solution {     public long countQuadruplets(int[] nums) {         int n = nums.length;         long count = 0;          for (int i = 0; i < n - 3; i++) {             for (int j = i + 1; j < n - 2; j++) {                 for (int k = j + 1; k < n - 1; k++) {                     for (int l = k + 1; l < n; l++) {                         if (nums[i] < nums[k] && nums[k] < nums[j] && nums[j] < nums[l]) {                             count++;                         }                     }                 }             }         }         return count;     } },0,,0,0,0
"class Solution {     public long minCost(int[] basket1, int[] basket2) {                  int n = basket1.length;                  // to keep the track of sum of basket1 and basket2         int basket1_sum = 0, basket2_sum = 0;                  // find the total sum of fruits in both baskets         // also check if the cost of fruits in each basket is equal or not         for(int i = 0; i < n; i++){             basket1_sum += basket1[i];             basket2_sum += basket2[i];         }         if((basket1_sum + basket2_sum) % 2 != 0)             return -1;          // find the target cost of each basket         int target = (basket1_sum + basket2_sum) / 2;          // perform swap operation         long cost = 0;         int basket1_big_count = 0, basket2_big_count = 0;         for(int i = 0; i < n; i++){             if(basket1[i] > target && basket2[i] <= target){                 cost = cost + basket1[i] - target;                 basket1[i] = target;                 basket2[i] = basket1[i];             }             else if(basket2[i] > target && basket1[i] <= target){                 cost = cost + basket2[i] - target;                 basket2[i] = target;                 basket1[i] = basket2[i];             }             if(basket1[i] > target)                 basket1_big_count++;             if(basket2[i] > target)                 basket2_big_count++;         }          // if the number of bigger costs in one basket is not equal         // to the number in the other, then it is impossible to swap         if(basket1_big_count != basket2_big_count)             return -1;                  // return the total cost of swaps performed         return cost;     } }",1,"2561-rearranging-fruits/Solution.java:7:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2561-rearranging-fruits/Solution.java:23:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2561-rearranging-fruits/Solution.java:29:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",1,0,0
"class Solution {     public int minimumScore(String s, String t) {         int i = 0, j = 0;         int score = 0;         while (j < t.length()) {             if (s.charAt(i) == t.charAt(j)) {                 i++;                 j++;             } else {                 i++;                 score++;             }             if (i >= s.length() && j < t.length()) {                 return -1; // t is not a subsequence of s             }         }         return score;     } }",1,"2565-subsequence-with-the-minimum-score/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {          public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {         int n = nums1.length;         long[] result = new long[queries.length];                  for (int i = 0; i < queries.length; i++) {             int[] q = queries[i];                          if (q[0] == 1) {                 // query type 1                 int l = q[1];                 int r = q[2];                                  for (int j = l; j <= r; j++) {                     nums1[j] = 1 - nums1[j];                 }             } else if (q[0] == 2) {                 // query type 2                 int p = q[1];                                  for (int j = 0; j < n; j++) {                     nums2[j] += nums1[j] * p;                 }             } else {                 // query type 3                 long sum = 0;                                  for (int j = 0; j < n; j++) {                     sum += nums2[j];                 }                                  result[i] = sum;             }         }                  return result;     } }",0,,0,0,0
"class Solution {     public String findTheString(int[][] lcp) {         int n = lcp.length;         StringBuilder sb = new StringBuilder();         for (int i = 0; i < n; i++) {             sb.append('a');         }         for (int i = 0; i < n; i++) {             for (int j = i + 1; j < n; j++) {                 if (lcp[i][j] != lcp[j][i]) {                     return """";                 }                 if (lcp[i][j] == 0) {                     continue;                 }                 if (sb.charAt(i) == sb.charAt(j)) {                     continue;                 }                 if (sb.charAt(i) > sb.charAt(j)) {                     sb.setCharAt(i, sb.charAt(j));                 } else {                     sb.setCharAt(j, sb.charAt(i));                 }             }         }         return sb.toString();     } }",0,,0,0,0
"class Solution {     public int minimumTime(int[][] grid) {         int m = grid.length;         int n = grid[0].length;                  // initialize the visited array with false         boolean[][] visited = new boolean[m][n];                  // initialize the distance array with maximum value         int[][] dist = new int[m][n];         for(int i=0; i<m; i++) {             Arrays.fill(dist[i], Integer.MAX_VALUE);         }                  // distance to reach start node is 0         dist[0][0] = 0;                  // initialize the priority queue with start node         PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[2] - b[2]));         pq.offer(new int[]{0, 0, 0});                  // create four directions arrays         int[] dx = {-1, 0, 1, 0};         int[] dy = {0, 1, 0, -1};                  // Dijkstra's algorithm         while(!pq.isEmpty()) {             int[] curr = pq.poll();             int x = curr[0];             int y = curr[1];             int d = curr[2];                          // If already visited, continue             if(visited[x][y]) {                 continue;             }                          visited[x][y] = true;                          // if we reach the destination, return the distance             if(x == m-1 && y == n-1) {                 return dist[x][y];             }                          // visit adjacent nodes             for(int i=0; i<4; i++) {                 int nx = x + dx[i];                 int ny = y + dy[i];                 if(nx >= 0 && nx < m && ny >= 0 && ny < n && !visited[nx][ny]) {                     int nd = Math.max(d, grid[nx][ny]);                     if(nd < dist[nx][ny]) {                         dist[nx][ny] = nd;                         pq.offer(new int[]{nx, ny, nd});                     }                 }             }         }                  // if we cannot reach the destination, return -1         return -1;     } }",1,"2577-minimum-time-to-visit-a-cell-in-a-grid/Solution.java:19:	UselessParentheses:	Useless parentheses.
",0,0,0
"import java.util.*;  class Solution {     public int rootCount(int[][] edges, int[][] guesses, int k) {         int n = edges.length + 1;         List<Integer>[] graph = new ArrayList[n];         for (int i = 0; i < n; i++) {             graph[i] = new ArrayList<>();         }         for (int[] e : edges) {             graph[e[0]].add(e[1]);             graph[e[1]].add(e[0]);         }         boolean[] visited = new boolean[n];         Map<Integer, Set<Integer>> map = new HashMap<>();         for (int[] guess : guesses) {             int u = guess[0], v = guess[1];             if (graph[u].contains(v)) {                 int t = u;                 u = v;                 v = t;             }             map.putIfAbsent(v, new HashSet<>());             map.get(v).add(u);         }         int[] count = new int[n];         for (int v : map.keySet()) {             Set<Integer> set = map.get(v);             for (int u : set) {                 count[u]++;             }         }         Queue<Integer> queue = new LinkedList<>();         for (int i = 0; i < n; i++) {             if (count[i] == 0) {                 queue.offer(i);             }         }         int res = 0;         while (!queue.isEmpty()) {             int root = queue.poll();             if (dfs(root, visited, count, map, graph, k)) {                 res++;             }         }         return res;     }     private boolean dfs(int u, boolean[] visited, int[] count, Map<Integer, Set<Integer>> map, List<Integer>[] graph, int k) {         visited[u] = true;         k--;         for (int v : graph[u]) {             if (visited[v]) {                 continue;             }             if (map.containsKey(u) && map.get(u).contains(v)) {                 if (dfs(v, visited, count, map, graph, k)) {                     return true;                 }             } else {                 count[v]--;                 if (count[v] == 0) {                     if (dfs(v, visited, count, map, graph, k)) {                         return true;                     }                 }             }         }         return k <= 0;     } }",1,"2581-count-number-of-possible-root-nodes/Solution.java:17:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2581-count-number-of-possible-root-nodes/Solution.java:4:	NPathComplexity:	The method 'rootCount(int[][], int[][], int)' has an NPath complexity of 324, current threshold is 200
2581-count-number-of-possible-root-nodes/Solution.java:15:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
2581-count-number-of-possible-root-nodes/Solution.java:50:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'k'
2581-count-number-of-possible-root-nodes/Solution.java:62:	CollapsibleIfStatements:	This if statement could be combined with its parent
",1,1,0
"public class Solution {     public int findValidSplit(int[] nums) {         int n = nums.length;         int[] prefix = new int[n];         int[] suffix = new int[n];                  prefix[0] = nums[0];         for (int i = 1; i < n; i++) {             prefix[i] = gcd(prefix[i - 1], nums[i]);         }                  suffix[n - 1] = nums[n - 1];         for (int i = n - 2; i >= 0; i--) {             suffix[i] = gcd(suffix[i + 1], nums[i]);         }                  for (int i = 0; i < n - 1; i++) {             if (gcd(prefix[i], suffix[i + 1]) == 1) {                 return i;             }         }                  return -1;     }          private int gcd(int a, int b) {         if (b == 0) {             return a;         }         return gcd(b, a % b);     } }",0,,0,0,0
"class Solution {     public int waysToReachTarget(int target, int[][] types) {                  int mod = 1000000007;         int[] dp = new int[target + 1];         dp[0] = 1;                  // iterate through each question type         for (int[] type : types) {             int count = type[0];             int marks = type[1];                          // for each question type, iterate through each possible score target             for (int i = target; i >= marks; i--) {                                  // calculate the number of ways to reach the current i using this question type                 for (int j = 1; j <= count; j++) {                     if (i - j * marks < 0) break;                     dp[i] = (dp[i] + dp[i - j * marks]) % mod;                 }             }         }                  return dp[target];     } }",0,,0,0,0
"class Solution {     public int findMinimumTime(int[][] tasks) {         int start = Integer.MAX_VALUE, end = Integer.MIN_VALUE;         // get the earliest start time and latest end time         for (int[] task : tasks) {             start = Math.min(start, task[0]);             end = Math.max(end, task[1]);         }         int minTime = Integer.MAX_VALUE;         // check every possible time slot between start and end time         for (int i = start; i <= end; i++) {             int totalTime = 0;             for (int[] task : tasks) {                 // check if the task can be completed during the current time slot                 if (task[0] <= i && task[1] >= i && totalTime + (i - task[0] + task[2]) <= minTime) {                     totalTime += i - task[0] + task[2];                     if (totalTime >= minTime) {                         break;                     }                 }             }             minTime = Math.min(minTime, totalTime);         }         return minTime;      } }",1,"2589-minimum-time-to-complete-all-tasks/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
2589-minimum-time-to-complete-all-tasks/Solution.java:15:	UselessParentheses:	Useless parentheses.
",1,0,0
"class Solution {     int ans=0;     int[] dp;      public int collectTheCoins(int[] coins, int[][] edges) {         int n=coins.length;         dp=new int[n];                 for(int i=0;i<n;i++) {             if(coins[i]==1) {                 dfs(edges,coins,i,i,-1);             }         }         return ans;     }     void dfs(int[][] edges,int[] coins,int cur,int src,int par) {         dp[cur]=1;         for(int i:edges[cur]) {             if(i==par) continue;             dfs(edges,coins,i,src,cur);             dp[cur]+=dp[i];//Answer from this subtree         }         if(dp[cur]>=2&&((src==cur&&par!=-1)||src!=cur)) {             ans+=2;//If path from source to this vertex contains at least 2 vertex,we have to change vertex to cover these coins,so ans will incrment by 2.             dp[cur]=0;//and we have to return 0,as we have counted ans from this subtree         }             } }",1,"2603-collect-coins-in-a-tree/Solution.java:2:9: Variable 'ans' must be private and have accessor methods. [VisibilityModifier]
2603-collect-coins-in-a-tree/Solution.java:3:11: Variable 'dp' must be private and have accessor methods. [VisibilityModifier]
",0,0,0
"import java.util.*;  class Solution {     public int findShortestCycle(int n, int[][] edges) {         List<List<Integer>> adjList = new ArrayList<>();         for(int i = 0; i < n; i++) {             adjList.add(new ArrayList<>());         }         for(int[] edge : edges) {             int u = edge[0], v = edge[1];             adjList.get(u).add(v);             adjList.get(v).add(u);         }          int shortestCycle = n + 1;         for(int i = 0; i < n; i++) {             int[] distance = new int[n];             Arrays.fill(distance, n + 1);             Queue<Integer> queue = new LinkedList<>();             queue.offer(i);             distance[i] = 0;              while(!queue.isEmpty()) {                 int curr = queue.poll();                 for(int neighbour : adjList.get(curr)) {                     if(distance[neighbour] == n + 1) {                         distance[neighbour] = distance[curr] + 1;                         queue.offer(neighbour);                     } else if(neighbour != i) {                         shortestCycle = Math.min(shortestCycle, distance[curr] + distance[neighbour] + 1);                     }                 }             }         }          return shortestCycle == n + 1 ? -1 : shortestCycle;     } }",1,"2608-shortest-cycle-in-a-graph/Solution.java:10:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int[] minReverseOperations(int n, int p, int[] banned, int k) {         int[] ans = new int[n];         Arrays.fill(ans, -1); // initialize all positions as impossible to reach         ans[p] = 0; // the initial position has 0 reversal operations needed         Set<Integer> bannedSet = new HashSet<>();         for (int b : banned) {             bannedSet.add(b);         }         // If k is n, the whole array can be reversed at once         if (k == n) {             return ans; // the initial state is already optimal         }         // check all possible subarrays of size k that contains p to determine the minimum         // number of reversals needed to reach each position         for (int i = 0; i < n; i++) {             if (ans[i] == -1 && !bannedSet.contains(i)) {                 int intervalStart = Math.max(0, i - k + 1);                 int intervalEnd = Math.min(n - 1, i + k - 1);                 if (p >= intervalStart && p <= intervalEnd) { // p is included in the subarray, can't reverse                     continue;                 }                 int leftReversals = Integer.MAX_VALUE;                 if (intervalStart <= p) {                     int leftEnd = Math.min(p, intervalEnd);                     int leftStart = Math.max(intervalStart, leftEnd - k + 1);                     if (!containsBanned(bannedSet, leftStart, leftEnd)) {                         leftReversals = ans[leftEnd] == -1 ? Integer.MAX_VALUE : ans[leftEnd] + 1;                     }                 }                 int rightReversals = Integer.MAX_VALUE;                 if (intervalEnd >= p) {                     int rightStart = Math.max(p, intervalStart);                     int rightEnd = Math.min(intervalEnd, rightStart + k - 1);                     if (!containsBanned(bannedSet, rightStart, rightEnd)) {                         rightReversals = ans[rightStart] == -1 ? Integer.MAX_VALUE : ans[rightStart] + 1;                     }                 }                 int thisReversals = Math.min(leftReversals, rightReversals);                 if (thisReversals < Integer.MAX_VALUE) {                     ans[i] = thisReversals;                 }             }         }         return ans;     }          // returns true if any of the positions in [start, end] is banned     private boolean containsBanned(Set<Integer> banned, int start, int end) {         for (int i = start; i <= end; i++) {             if (banned.contains(i)) {                 return true;             }         }         return false;     } }",1,"2612-minimum-reverse-operations/Solution.java:2:	NPathComplexity:	The method 'minReverseOperations(int, int, int[], int)' has an NPath complexity of 396, current threshold is 200
2612-minimum-reverse-operations/Solution.java:27:	AvoidDeeplyNestedIfStmts:	Deeply nested if..then statements are hard to read
2612-minimum-reverse-operations/Solution.java:35:	AvoidDeeplyNestedIfStmts:	Deeply nested if..then statements are hard to read
",0,0,0
"class Solution {     public int minimumVisitedCells(int[][] grid) {         int m = grid.length;         int n = grid[0].length;                  // if starting cell and bottom-right cell are the same or the bottom-right cell is blocked, return -1         if ((m == 1 && n == 1) || grid[m-1][n-1] == -1) {             return -1;         }                  boolean[][] visited = new boolean[m][n];         Queue<int[]> queue = new LinkedList<>();         int[][] directions = new int[][] {{0, 1}, {1, 0}};                  // insert starting cell into queue and mark as visited         queue.offer(new int[] {0, 0});         visited[0][0] = true;                  int steps = 0;                  // start BFS         while (!queue.isEmpty()) {             int size = queue.size();             for (int i = 0; i < size; i++) {                 int[] curr = queue.poll();                                  // if reached bottom-right cell, return steps                 if (curr[0] == m-1 && curr[1] == n-1) {                     return steps;                 }                                  // move rightward or downward                 for (int[] dir : directions) {                     int nextRow = curr[0] + (dir[0] * grid[curr[0]][curr[1]]);                     int nextCol = curr[1] + (dir[1] * grid[curr[0]][curr[1]]);                                          // if next cell is within grid and not blocked and not visited, insert into queue and mark as visited                     if (nextRow >= 0 && nextRow < m && nextCol >= 0 && nextCol < n                          && !visited[nextRow][nextCol] && grid[nextRow][nextCol] != -1) {                         queue.offer(new int[] {nextRow, nextCol});                         visited[nextRow][nextCol] = true;                     }                 }             }             steps++;         }                  // if reached here, there is no path to the bottom-right cell         return -1;     } }",0,,0,0,0
"class Solution {     public static final String[] tensNames = {"""", ""Ten"", ""Twenty"", ""Thirty"", ""Forty"", ""Fifty"", ""Sixty"", ""Seventy"", ""Eighty"", ""Ninety""};      public static final String[] numNames = {"""", ""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine"", ""Ten"", ""Eleven"", ""Twelve"", ""Thirteen"", ""Fourteen"", ""Fifteen"", ""Sixteen"", ""Seventeen"", ""Eighteen"", ""Nineteen""};      public String numberToWords(int num) {         if (num == 0) {             return ""Zero"";         }         return helper(num);     }      private String helper(int num) {         String result = """";         if (num < 20) {             result = numNames[num];         } else if (num < 100) {             result = tensNames[num / 10] + "" "" + numNames[num % 10];         } else if (num < 1000) {             result = numNames[num / 100] + "" Hundred "" + helper(num % 100);         } else if (num < 1000000) {             result = helper(num / 1000) + "" Thousand "" + helper(num % 1000);         } else if (num < 1000000000) {             result = helper(num / 1000000) + "" Million "" + helper(num % 1000000);         } else {             result = helper(num / 1000000000) + "" Billion "" + helper(num % 1000000000);         }         return result.trim();     } }",1,"273-integer-to-english-words/Solution.java:14:	UnusedAssignment:	The initializer for variable 'result' is never used (overwritten on lines 16, 18, 20, 22, 24 and 26)
",0,0,0
"import java.util.ArrayList; import java.util.List;  class Solution {     public List<String> addOperators(String num, int target) {         List<String> res = new ArrayList<>();         backtracking(num, target, 0, 0, """", res);         return res;     }      private void backtracking(String num, int target, long prev, long curr, String expression, List<String> res) {         if(num.length() == 0 && curr == target) {             res.add(expression);             return;         }         for(int i=1; i<=num.length(); i++) {             String currentStr = num.substring(0, i);             if(currentStr.length() > 1 && currentStr.charAt(0) == '0') return; // avoid leading zero in operand              Long currentNum = Long.parseLong(currentStr);              String nextStr = num.substring(i);              if(expression.length() > 0) {                 backtracking(nextStr, target, currentNum, curr + currentNum, expression + ""+"" + currentNum, res);                  backtracking(nextStr, target, -currentNum, curr - currentNum, expression + ""-"" + currentNum, res);                  backtracking(nextStr, target, prev * currentNum, (curr - prev) + prev * currentNum, expression + ""*"" + currentNum, res);             } else {                 backtracking(nextStr, target, currentNum, currentNum, currentStr, res);             }         }     } } ",1,"282-expression-add-operators/Solution.java:29:	UselessParentheses:	Useless parentheses.
",0,0,0
import java.util.*;  class MedianFinder {      PriorityQueue<Integer> maxHeap; // to store the smaller half of the numbers     PriorityQueue<Integer> minHeap; // to store the larger half of the numbers          public MedianFinder() {         maxHeap = new PriorityQueue<>(Collections.reverseOrder());         minHeap = new PriorityQueue<>();     }          public void addNum(int num) {         maxHeap.offer(num);         minHeap.offer(maxHeap.poll());         if (maxHeap.size() < minHeap.size()) {             maxHeap.offer(minHeap.poll());         }     }          public double findMedian() {         if (maxHeap.size() == minHeap.size()) {             return (maxHeap.peek() + minHeap.peek()) / 2.0;         } else {             return maxHeap.peek();         }     } }  /**  * Your MedianFinder object will be instantiated and called as such:  * MedianFinder obj = new MedianFinder();  * obj.addNum(num);  * double param_2 = obj.findMedian();  */,1,"295-find-median-from-data-stream/MedianFinder.java:5:28: Variable 'maxHeap' must be private and have accessor methods. [VisibilityModifier]
295-find-median-from-data-stream/MedianFinder.java:6:28: Variable 'minHeap' must be private and have accessor methods. [VisibilityModifier]
295-find-median-from-data-stream/MedianFinder.java:8:5: Redundant 'public' modifier. [RedundantModifier]
295-find-median-from-data-stream/MedianFinder.java:5:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
295-find-median-from-data-stream/MedianFinder.java:6:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
",0,0,0
"import java.util.*;  public class Codec {      // Encodes a tree to a single string.     public String serialize(TreeNode root) {         if (root == null) {             return """";         }         StringBuilder sb = new StringBuilder();         serializeHelper(root, sb);         return sb.toString();     }              private void serializeHelper(TreeNode node, StringBuilder sb) {         if (node == null) {             sb.append(""null,"");             return;         }         sb.append(node.val).append("","");         serializeHelper(node.left, sb);         serializeHelper(node.right, sb);     }      // Decodes your encoded data to tree.     public TreeNode deserialize(String data) {         if (data.isEmpty()) {             return null;         }         String[] tokens = data.split("","");         Queue<String> queue = new LinkedList<>(Arrays.asList(tokens));         return deserializeHelper(queue);     }          private TreeNode deserializeHelper(Queue<String> queue) {         String token = queue.poll();         if (token.equals(""null"")) {             return null;         }         TreeNode node = new TreeNode(Integer.parseInt(token));         node.left = deserializeHelper(queue);         node.right = deserializeHelper(queue);         return node;     } } ",1,"297-serialize-and-deserialize-binary-tree/Codec.java:20:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
297-serialize-and-deserialize-binary-tree/Codec.java:37:	LiteralsFirstInComparisons:	Position literals first in String comparisons
",0,0,0
"import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set; 	 class Solution {     public List<String> removeInvalidParentheses(String s) {         int leftRemove = 0, rightRemove = 0;         for (char c : s.toCharArray()) {             if (c == '(') leftRemove++;             else if (c == ')') {                 if (leftRemove > 0) leftRemove--;                 else rightRemove++;             }         }         Set<String> validExpressions = new HashSet<>();         dfs(s, 0, 0, 0, new StringBuilder(), validExpressions, leftRemove, rightRemove);         return new ArrayList<>(validExpressions);     }      private void dfs(String s, int index, int leftCount, int rightCount, StringBuilder expression, Set<String> validExpressions, int leftRemove, int rightRemove) {         if (index == s.length()) {             if (leftRemove == 0 && rightRemove == 0) {                 validExpressions.add(expression.toString());             }             return;         }         char c = s.charAt(index);         int len = expression.length();         if (c == '(' && leftRemove > 0) {             dfs(s, index + 1, leftCount, rightCount, expression, validExpressions, leftRemove - 1, rightRemove);         }         if (c == ')' && rightRemove > 0) {             dfs(s, index + 1, leftCount, rightCount, expression, validExpressions, leftRemove, rightRemove - 1);         }         expression.append(c);         if (c != '(' && c != ')') {             dfs(s, index + 1, leftCount, rightCount, expression, validExpressions, leftRemove, rightRemove);         } else if (c == '(') {             dfs(s, index + 1, leftCount + 1, rightCount, expression, validExpressions, leftRemove, rightRemove);         } else if (rightCount < leftCount) {             dfs(s, index + 1, leftCount, rightCount + 1, expression, validExpressions, leftRemove, rightRemove);         }         expression.setLength(len);     } }",1,"301-remove-invalid-parentheses/Solution.java:5:1: File contains tab characters (this is the first instance). [FileTabCharacter]
301-remove-invalid-parentheses/Solution.java:8:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
301-remove-invalid-parentheses/Solution.java:21:18: More than 7 parameters (found 8). [ParameterNumber]
301-remove-invalid-parentheses/Solution.java:37:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",1,0,0
"class Solution {     public int maxCoins(int[] nums) {         int n = nums.length;         int[][] dp = new int[n][n];                  // l is the length of the interval         for (int l = 1; l <= n; l++) {             for (int i = 0; i <= n - l; i++) {                 int j = i + l - 1;                 // k is the last balloon to burst in the interval [i, j]                 for (int k = i; k <= j; k++) {                     int leftValue = 1, rightValue = 1;                     if (i != 0) {                         leftValue = nums[i - 1];                     }                     if (j != n - 1) {                         rightValue = nums[j + 1];                     }                     int before = 0, after = 0;                     if (k != i) {                         before = dp[i][k - 1];                     }                     if (k != j) {                         after = dp[k + 1][j];                     }                     dp[i][j] = Math.max(dp[i][j],                             before + after + (leftValue * nums[k] * rightValue));                 }             }         }         return dp[0][n - 1];     } }",1,"312-burst-balloons/Solution.java:12:21: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
312-burst-balloons/Solution.java:19:21: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"import java.util.*;  class Solution {     public List<Integer> countSmaller(int[] nums) {         int n = nums.length;         int[] res = new int[n]; // to store the results         int[] sorted = new int[n]; // to store the sorted array         int[] indexes = new int[n]; // to store the index in the original array          // Initialize the indexes array         for (int i = 0; i < n; i++) {             indexes[i] = i;         }          mergeSort(nums, indexes, 0, n - 1, sorted, res);          // Convert the result array to List         List<Integer> result = new ArrayList<>();         for (int i = 0; i < n; i++) {             result.add(res[i]);         }         return result;     }      private void mergeSort(int[] nums, int[] indexes, int left, int right, int[] sorted, int[] res) {         if (left >= right) {             return;         }         int mid = left + (right - left) / 2;         mergeSort(nums, indexes, left, mid, sorted, res);         mergeSort(nums, indexes, mid + 1, right, sorted, res);         merge(nums, indexes, left, right, sorted, res);     }      private void merge(int[] nums, int[] indexes, int left, int right, int[] sorted, int[] res) {         int mid = left + (right - left) / 2;         int i = left; // index for the left subarray         int j = mid + 1; // index for the right subarray         int k = left; // index for the sorted array          // Count the number of smaller elements for each element in the left subarray         while (i <= mid) {             while (j <= right && nums[indexes[i]] > nums[indexes[j]]) {                 j++;             }             res[indexes[i]] += j - mid - 1; // Update the result             i++;         }          i = left; // Reset the index for the left subarray         j = mid + 1; // Reset the index for the right subarray          // Merge the left and right subarrays         while (i <= mid && j <= right) {             if (nums[indexes[i]] <= nums[indexes[j]]) {                 sorted[k++] = indexes[i++];             } else {                 sorted[k++] = indexes[j++];             }         }          while (i <= mid) {             sorted[k++] = indexes[i++];         }          while (j <= right) {             sorted[k++] = indexes[j++];         }          // Copy the sorted array back to the original array         for (i = left; i <= right; i++) {             indexes[i] = sorted[i];         }     } }",1,"315-count-of-smaller-numbers-after-self/Solution.java:62:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
315-count-of-smaller-numbers-after-self/Solution.java:66:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
315-count-of-smaller-numbers-after-self/Solution.java:71:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
",0,0,0
"class Solution {     public int[] maxNumber(int[] nums1, int[] nums2, int k) {                  int[] res = new int[k];         int m = nums1.length, n = nums2.length;                  for(int i=Math.max(0,k-n); i<=k && i<=m; i++){             int[] candidate = merge(maxArray(nums1, i), maxArray(nums2, k-i));             if(greater(candidate, 0, res, 0))                 res = candidate;         }         return res;     }          private int[] maxArray(int[] nums, int k){         int[] res = new int[k];         int len = 0, n = nums.length;                  for(int i=0; i<n; i++){             while(len > 0 && len + (n-i) > k && res[len-1] < nums[i])                 len--;             if(len < k)                 res[len++] = nums[i];         }         return res;     }          private int[] merge(int[] nums1, int[] nums2){         int m = nums1.length, n = nums2.length;         if(m == 0) return nums2;         if(n == 0) return nums1;                  int[] res = new int[m+n];         int i=0, j=0, p=0;                  while(i<m && j<n){             if(greater(nums1, i, nums2, j))                 res[p++] = nums1[i++];             else                 res[p++] = nums2[j++];         }         while(i < m) res[p++] = nums1[i++];         while(j < n) res[p++] = nums2[j++];         return res;     }          private boolean greater(int[] nums1, int i, int[] nums2, int j){         while(i < nums1.length && j < nums2.length && nums1[i] == nums2[j]){             i++;             j++;         }         return j==nums2.length || (i < nums1.length && nums1[i] > nums2[j]));     } }",1,"321-create-maximum-number/Solution.java	-	ParseException: Parse exception in file '321-create-maximum-number/Solution.java': Encountered "")"" at line 52, column 76.
",0,0,0
"class Solution {     public int countRangeSum(int[] nums, int lower, int upper) {         if(nums == null || nums.length == 0) return 0;         int n = nums.length;         long[] sum = new long[n + 1];         for(int i = 0; i < n; i++) {             sum[i + 1] = sum[i] + nums[i];         }         return countWhileMergeSort(sum, 0, n, lower, upper);     }      private int countWhileMergeSort(long[] sum, int start, int end, int lower, int upper) {         if(start >= end) return 0;         int mid = start + (end - start) / 2;         int n1 = countWhileMergeSort(sum, start, mid, lower, upper);         int n2 = countWhileMergeSort(sum, mid + 1, end, lower, upper);         int ret = n1 + n2;          int i = start, l = mid + 1, r = mid + 1;         while(i <= mid) {             while(l <= end && sum[l] - sum[i] < lower) l++;             while(r <= end && sum[r] - sum[i] <= upper) r++;             ret += r - l;             i++;         }          merge(sum, start, mid, end);         return ret;     }      private void merge(long[] sum, int start, int mid, int end) {         long[] temp = new long[end - start + 1];         int i = start, j = mid + 1, k = 0;         while(i <= mid && j <= end) {             if(sum[i] <= sum[j]) temp[k++] = sum[i++];             else temp[k++] = sum[j++];         }         while(i <= mid) temp[k++] = sum[i++];         while(j <= end) temp[k++] = sum[j++];         for(i = start, k = 0; i <= end; i++, k++) {             sum[i] = temp[k];         }     } }",1,"327-count-of-range-sum/Solution.java:19:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
327-count-of-range-sum/Solution.java:33:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     private int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};          public int longestIncreasingPath(int[][] matrix) {         int rows = matrix.length;         int cols = matrix[0].length;         int[][] memo = new int[rows][cols];         int maxPath = 1;         for (int i = 0; i < rows; i++) {             for (int j = 0; j < cols; j++) {                 maxPath = Math.max(maxPath, dfs(matrix, memo, i, j));             }         }         return maxPath;     }          private int dfs(int[][] matrix, int[][] memo, int row, int col) {         if (memo[row][col] != 0) {             return memo[row][col];         }         int maxPath = 1;         for (int[] direction : directions) {             int newRow = row + direction[0];             int newCol = col + direction[1];             if (newRow >= 0 && newRow < matrix.length && newCol >= 0 && newCol < matrix[0].length && matrix[newRow][newCol] > matrix[row][col]) {                 maxPath = Math.max(maxPath, dfs(matrix, memo, newRow, newCol) + 1);             }         }         memo[row][col] = maxPath;         return maxPath;     } }",0,,0,0,0
"class Solution {     public int minPatches(int[] nums, int n) {         int patches=0, i=0;         long miss=1;          while(miss<=n) {              if(i<nums.length && nums[i]<=miss) {                 miss += nums[i]; //add new miss                 i++;             }             else {                 miss += miss; //add a patch                 patches++;             }         }          return patches;     } } ",1,"330-patching-array/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
330-patching-array/Solution.java:11:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
",1,0,0
"import java.util.*;  class Solution {     public List<String> findItinerary(List<List<String>> tickets) {         Map<String, PriorityQueue<String>> graph = new HashMap<>();         List<String> result = new ArrayList<>();          // build the graph         for (List<String> ticket : tickets) {             String from = ticket.get(0);             String to = ticket.get(1);             // add the destination to the priority queue of the source airport             graph.putIfAbsent(from, new PriorityQueue<>());             graph.get(from).add(to);         }          // DFS to find the itinerary         dfs(""JFK"", graph, result);          // reverse the itinerary and return         Collections.reverse(result);         return result;     }      private void dfs(String airport, Map<String, PriorityQueue<String>> graph, List<String> result) {         PriorityQueue<String> destinations = graph.getOrDefault(airport, new PriorityQueue<>());                  // visit all destinations         while (!destinations.isEmpty()) {             String destination = destinations.poll();             dfs(destination, graph, result);         }                  // add the current airport to the itinerary         result.add(airport);     } }",1,"332-reconstruct-itinerary/Solution.java:5:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
332-reconstruct-itinerary/Solution.java:5:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
332-reconstruct-itinerary/Solution.java:25:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
332-reconstruct-itinerary/Solution.java:26:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
",0,0,0
class Solution {     public boolean isSelfCrossing(int[] distance) {         int n = distance.length;         if (n <= 3) return false;         for (int i = 3; i < n; i++) {             if (distance[i] >= distance[i - 2] && distance[i - 1] <= distance[i - 3])                 return true;             if (i >= 4 && distance[i - 1] == distance[i - 3] &&                  distance[i] + distance[i - 4] >= distance[i - 2])                 return true;             if (i >= 5 && distance[i - 2] >= distance[i - 4] &&                  distance[i - 1] >= distance[i - 3] &&                  distance[i - 1] <= distance[i - 3] + distance[i - 5] &&                  distance[i] + distance[i - 4] >= distance[i - 2] &&                  distance[i - 1] + distance[i - 5] >= distance[i - 3])                 return true;         }         return false;     } },0,,0,0,0
"import java.util.*;  class Solution {     public List<List<Integer>> palindromePairs(String[] words) {         List<List<Integer>> result = new ArrayList<>();         Map<String, Integer> map = new HashMap<>(); // To store the words and their index         int n = words.length;         for (int i = 0; i < n; i++) {             map.put(words[i], i);         }         for (int i = 0; i < n; i++) {             String word = words[i];             for (int j = 0; j <= word.length(); j++) {                 String prefix = word.substring(0, j);                 String suffix = word.substring(j);                 if (isPalindrome(prefix)) {                     String reverseSuffix = new StringBuilder(suffix).reverse().toString();                     if (map.containsKey(reverseSuffix) && map.get(reverseSuffix) != i) {                         result.add(Arrays.asList(map.get(reverseSuffix), i));                     }                 }                 if (isPalindrome(suffix)) {                     String reversePrefix = new StringBuilder(prefix).reverse().toString();                     if (map.containsKey(reversePrefix) && map.get(reversePrefix) != i && suffix.length() != 0) {                         result.add(Arrays.asList(i, map.get(reversePrefix)));                     }                 }             }         }         return result;     }          private boolean isPalindrome(String str) {         int i = 0, j = str.length() - 1;         while (i < j) {             if (str.charAt(i) != str.charAt(j)) {                 return false;             }             i++;             j--;         }         return true;     } }",1,"336-palindrome-pairs/Solution.java:34:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
336-palindrome-pairs/Solution.java:6:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
",1,0,0
"class SummaryRanges {     List<int[]> intervals;      public SummaryRanges() {         this.intervals = new ArrayList<>();     }          public void addNum(int value) {         if (intervals.isEmpty()) {             intervals.add(new int[]{value, value});         } else {             int left = 0;             int right = intervals.size() - 1;             while (left <= right) {                 int mid = left + (right - left) / 2;                 int[] range = intervals.get(mid);                 if (value < range[0] - 1) {                     right = mid - 1;                 } else if (value > range[1] + 1) {                     left = mid + 1;                 } else {                     if (value == range[0] - 1) {                         range[0] = value;                         if (mid > 0 && intervals.get(mid - 1)[1] == value - 1) {                             range[0] = intervals.get(mid - 1)[0];                             intervals.remove(mid - 1);                             mid--;                         }                     }                     if (value == range[1] + 1) {                         range[1] = value;                         if (mid < intervals.size() - 1 && intervals.get(mid + 1)[0] == value + 1) {                             range[1] = intervals.get(mid + 1)[1];                             intervals.remove(mid + 1);                         }                     }                     return;                 }             }             intervals.add(left, new int[]{value, value});         }     }          public int[][] getIntervals() {         int[][] res = new int[intervals.size()][2];         for (int i = 0; i < intervals.size(); i++) {             res[i] = intervals.get(i);         }         return res;     } }",1,"352-data-stream-as-disjoint-intervals/SummaryRanges.java:2:17: Variable 'intervals' must be private and have accessor methods. [VisibilityModifier]
352-data-stream-as-disjoint-intervals/SummaryRanges.java:4:5: Redundant 'public' modifier. [RedundantModifier]
",0,0,0
"class Solution {     public int maxEnvelopes(int[][] envelopes) {                  // Sort the envelopes by width in ascending order         Arrays.sort(envelopes, (a, b) -> a[0] - b[0]);                  int n = envelopes.length;         int[] dp = new int[n];         Arrays.fill(dp, 1);                  // Find the longest increasing subsequence         int maxCount = 1;         for (int i = 1; i < n; i++) {             for (int j = 0; j < i; j++) {                 if (envelopes[i][0] > envelopes[j][0] && envelopes[i][1] > envelopes[j][1]) {                     dp[i] = Math.max(dp[i], dp[j] + 1);                 }             }             maxCount = Math.max(maxCount, dp[i]);         }                  return maxCount;     } }",0,,0,0,0
"class Solution {     public int maxSumSubmatrix(int[][] matrix, int k) {         int m = matrix.length;         int n = matrix[0].length;         int maxSum = Integer.MIN_VALUE;                  for (int left = 0; left < n; left++) {             int[] rowSum = new int[m];             for (int right = left; right < n; right++) {                 for (int i = 0; i < m; i++) {                     rowSum[i] += matrix[i][right];                 }                 maxSum = Math.max(maxSum, getMaxSumInArray(rowSum, k));             }         }                  return maxSum;     }          private int getMaxSumInArray(int[] rowSum, int k) {         int maxSum = Integer.MIN_VALUE;         int prefixSum = 0;         TreeSet<Integer> prefixSums = new TreeSet<>();         prefixSums.add(0);                  for (int sum : rowSum) {             prefixSum += sum;             Integer prefixCeiling = prefixSums.ceiling(prefixSum - k);             if (prefixCeiling != null) {                 maxSum = Math.max(maxSum, prefixSum - prefixCeiling);             }             prefixSums.add(prefixSum);         }                  return maxSum;     } }",0,,0,0,0
"import java.util.*;  class RandomizedCollection {     List<Integer> nums;     Map<Integer, Set<Integer>> index;     Random rand;      public RandomizedCollection() {         nums = new ArrayList<>();         index = new HashMap<>();         rand = new Random();     }      public boolean insert(int val) {         boolean contains = index.containsKey(val);         if (!contains) {             index.put(val, new HashSet<>());         }         index.get(val).add(nums.size());         nums.add(val);         return !contains;     }      public boolean remove(int val) {         if (!index.containsKey(val) || index.get(val).isEmpty()) {             return false;         }         int removeIndex = index.get(val).iterator().next();         index.get(val).remove(removeIndex);         int lastNum = nums.remove(nums.size() - 1);         if (removeIndex < nums.size()) {             index.get(lastNum).remove(nums.size());             index.get(lastNum).add(removeIndex);             nums.set(removeIndex, lastNum);         }         return true;     }      public int getRandom() {         return nums.get(rand.nextInt(nums.size()));     } }  /**  * Your RandomizedCollection object will be instantiated and called as such:  * RandomizedCollection obj = new RandomizedCollection();  * boolean param_1 = obj.insert(val);  * boolean param_2 = obj.remove(val);  * int param_3 = obj.getRandom();  */",1,"381-insert-delete-getrandom-o1-duplicates-allowed/RandomizedCollection.java:4:19: Variable 'nums' must be private and have accessor methods. [VisibilityModifier]
381-insert-delete-getrandom-o1-duplicates-allowed/RandomizedCollection.java:5:32: Variable 'index' must be private and have accessor methods. [VisibilityModifier]
381-insert-delete-getrandom-o1-duplicates-allowed/RandomizedCollection.java:6:12: Variable 'rand' must be private and have accessor methods. [VisibilityModifier]
381-insert-delete-getrandom-o1-duplicates-allowed/RandomizedCollection.java:8:5: Redundant 'public' modifier. [RedundantModifier]
",0,0,0
"class Solution {     public boolean isRectangleCover(int[][] rectangles) {         Set<String> pointsSet = new HashSet<>();         int area = 0;         for(int[] rectangle : rectangles) {             int x1 = rectangle[0];             int y1 = rectangle[1];             int x2 = rectangle[2];             int y2 = rectangle[3];             area += (x2-x1)*(y2-y1);             String topLeft = x1+"" ""+y2;             String topRight = x2+"" ""+y2;             String bottomLeft = x1+"" ""+y1;             String bottomRight = x2+"" ""+y1;             if(!pointsSet.add(topLeft)) pointsSet.remove(topLeft);             if(!pointsSet.add(topRight)) pointsSet.remove(topRight);             if(!pointsSet.add(bottomLeft)) pointsSet.remove(bottomLeft);             if(!pointsSet.add(bottomRight)) pointsSet.remove(bottomRight);         }         if(pointsSet.size() != 4) return false;         String topLeft = rectangles[0][0]+"" ""+rectangles[0][3];         String topRight = rectangles[0][2]+"" ""+rectangles[0][3];         String bottomLeft = rectangles[0][0]+"" ""+rectangles[0][1];         String bottomRight = rectangles[0][2]+"" ""+rectangles[0][1];         if(!pointsSet.contains(topLeft) || !pointsSet.contains(topRight) || !pointsSet.contains(bottomLeft) || !pointsSet.contains(bottomRight)) return false;         int maxX = Integer.MIN_VALUE, minX = Integer.MAX_VALUE, maxY = Integer.MIN_VALUE, minY = Integer.MAX_VALUE;         for(String point : pointsSet) {             String[] pointArr = point.split("" "");             int x = Integer.parseInt(pointArr[0]);             int y = Integer.parseInt(pointArr[1]);             maxX = Math.max(maxX, x);             minX = Math.min(minX, x);             maxY = Math.max(maxY, y);             minY = Math.min(minY, y);         }         int coveredArea = (maxX-minX)*(maxY-minY);         return area == coveredArea;     } }",1,"391-perfect-rectangle/Solution.java:26:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
391-perfect-rectangle/Solution.java:2:	NPathComplexity:	The method 'isRectangleCover(int[][])' has an NPath complexity of 340, current threshold is 200
",1,0,0
"class Solution {     public boolean canCross(int[] stones) {         int n = stones.length;         Map<Integer, Set<Integer>> map = new HashMap<>();         for (int i = 0; i < n; i++) {             map.put(stones[i], new HashSet<Integer>());         }         map.get(stones[0]).add(1);                  for (int i = 0; i < n-1; i++) {             int stone = stones[i];             for (int step : map.get(stone)) {                 int reach = stone + step;                 if (reach == stones[n-1]) {                     return true;                 }                 Set<Integer> set = map.get(reach);                 if (set != null) {                     if (step - 1 > 0) {                         set.add(step - 1);                     }                     set.add(step);                     set.add(step + 1);                 }             }         }                  return false;     } }",0,,0,0,0
"class Solution {     public int trapRainWater(int[][] heightMap) {                  if(heightMap == null || heightMap.length == 0 || heightMap[0].length == 0)             return 0;                  int m = heightMap.length;         int n = heightMap[0].length;                  // create a minheap to store nodes of heightMap with their heights         PriorityQueue<int[]> minHeap = new PriorityQueue<>((a,b) -> a[2] - b[2]);                  // create a visited matrix to keep track of visited nodes         boolean[][] visited = new boolean[m][n];                  // add the border nodes to the minHeap and mark them as visited         for(int i = 0; i < m; i++) {             minHeap.offer(new int[]{i, 0, heightMap[i][0]});             visited[i][0] = true;             minHeap.offer(new int[]{i, n-1, heightMap[i][n-1]});             visited[i][n-1] = true;         }         for(int j = 0; j < n; j++) {             minHeap.offer(new int[]{0, j, heightMap[0][j]});             visited[0][j] = true;             minHeap.offer(new int[]{m-1, j, heightMap[m-1][j]});             visited[m-1][j] = true;         }                  int[][] dirs = {{0,1}, {1,0}, {0,-1}, {-1,0}};         int result = 0;                  // traverse the minHeap to calculate the trapped water         while(!minHeap.isEmpty()) {             int[] curr = minHeap.poll();             for(int[] dir: dirs) {                 int i = curr[0] + dir[0];                 int j = curr[1] + dir[1];                 if(i >= 0 && i < m && j >= 0 && j < n && !visited[i][j]) {                     visited[i][j] = true;                     // add the current node to the minHeap with its new height                     minHeap.offer(new int[]{i, j, Math.max(curr[2], heightMap[i][j])});                     // calculate the trapped water and add it to the result                     result += Math.max(0, curr[2] - heightMap[i][j]);                    }             }         }                  return result;     } }",0,,0,0,0
"class Solution {     public int splitArray(int[] nums, int k) {         int max = 0;         int sum = 0;         for (int num : nums) {             max = Math.max(max, num);             sum += num;         }         if (k == 1) {             return sum;         }         int left = max;         int right = sum;         while (left <= right) {             int mid = (left + right) / 2;             if (valid(nums, k, mid)) {                 //mid is too high, lower it                 right = mid - 1;             } else {                 //mid is too low, raise it                 left = mid + 1;             }         }         return left;     }          public boolean valid(int[] nums, int k, int target) {         int count = 1;         int total = 0;         for (int num : nums) {             total += num;             if (total > target) {                 //we found a subarray with sum > target                 //so we need to create a new subarray                 total = num;                 count++;                 if (count > k) {                     //we have created too many subarrays                     //so this target is invalid                     return false;                 }             }         }         return true;     } }",0,,0,0,0
"class Solution {     public int strongPasswordChecker(String password) {         int n = password.length(); // get the length of password                  //initialize the variables for conditions         boolean hasLower = false;         boolean hasUpper = false;         boolean hasDigit = false;         boolean hasRepeat = false;                  //loop through characters in password to check for the conditions         for (char c : password.toCharArray()) {             if (Character.isLowerCase(c)) {                 hasLower = true;             } else if (Character.isUpperCase(c)) {                 hasUpper = true;             } else if (Character.isDigit(c)) {                 hasDigit = true;             }         }                  // check for three repeating characters         for (int i = 0; i < n - 2; i++) {             if (password.charAt(i) == password.charAt(i + 1) && password.charAt(i) == password.charAt(i + 2)) {                 hasRepeat = true;                 break;             }         }                  int missing = 0; //initialize the variable for number of missing conditions                  // count the number of missing conditions         if (!hasLower) {             missing++;         }         if (!hasUpper) {             missing++;         }         if (!hasDigit) {             missing++;         }                  if (n < 6) { // if password is less than 6 characters             return Math.max(missing, 6 - n);         }                  if (n <= 20) { // if password is between 6 and 20 characters             int count = 0; //initialize the variable for number of replacements needed for three repeating characters             for (int i = 0; i < n; i++) {                 int len = 1;                 while (i < n - 1 && password.charAt(i) == password.charAt(i + 1)) {                     len++;                     i++;                 }                 count += len / 3;             }             return Math.max(missing, count);         }                  int delete = n - 20; //initialize the variable for number of deletions needed         int count = 0; //initialize the variable for number of replacements needed for three repeating characters                  // initialize the array to keep track of lengths of consecutive characters         int[] arr = new int[n];         for (int i = 0; i < n; i++) {             int len = 1;             while (i < n - 1 && password.charAt(i) == password.charAt(i + 1)) {                 len++;                 i++;             }             arr[i] = len;         }                  // check if the password can be made strong by just deleting characters         if (delete <= arr.length) {             /*             loop through the array             count the replacements needed based on the formulae             */             for (int k = 1; k <= delete; k++) {                 int minReplacement = Integer.MAX_VALUE;                 int index = -1;                 for (int i = 0; i < arr.length; i++) {                     if (arr[i] >= 3 && arr[i] % 3 == 2 && arr[i] / 3 + k < minReplacement) {                         minReplacement = arr[i] / 3 + k;                         index = i;                     }                 }                 if (index != -1) {                     arr[index] -= 1;                 }             }             /*             count the replacements needed based on the formulae             on the array with the updated length of repeating characters             */             for (int i = 0; i < arr.length; i++) {                 if (arr[i] >= 3) {                     count += arr[i] / 3;                 }             }             return Math.max(missing, count) + delete;         }                  // calculate the maximum replacements needed for three repeating characters         count = arr.length / 3;                   // reduce the number of replacements needed by replacing characters in the password         return Math.max(missing, count) + n - Math.max(20, n - count * 2);                   // as we can only reduce the number of replacements needed by replacing characters     } }",1,"420-strong-password-checker/Solution.java:2:	NcssCount:	The method 'strongPasswordChecker(String)' has a NCSS line count of 62.
420-strong-password-checker/Solution.java:2:	NPathComplexity:	The method 'strongPasswordChecker(String)' has an NPath complexity of 217600, current threshold is 200
420-strong-password-checker/Solution.java:9:	UnusedLocalVariable:	Avoid unused local variables such as 'hasRepeat'.
420-strong-password-checker/Solution.java:9:	UnusedAssignment:	The initializer for variable 'hasRepeat' is never used (overwritten on line 25)
420-strong-password-checker/Solution.java:25:	UnusedAssignment:	The value assigned to variable 'hasRepeat' is never used
420-strong-password-checker/Solution.java:97:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"import java.util.HashMap; import java.util.HashSet; import java.util.Map; import java.util.Set;  class AllOne {     private Map<String, Integer> countMap;     private Map<Integer, Set<String>> countKeyMap;     private int minCount, maxCount;      /** Initialize your data structure here. */     public AllOne() {         countMap = new HashMap<>();         countKeyMap = new HashMap<>();         minCount = Integer.MAX_VALUE;         maxCount = Integer.MIN_VALUE;     }          /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */     public void inc(String key) {         int count = countMap.getOrDefault(key, 0) + 1;         countMap.put(key, count);                  if (count > maxCount) {             maxCount = count;         }                  if (count == 1) {             minCount = 1;         } else if (count - 1 == minCount) {             Set<String> set = countKeyMap.getOrDefault(count - 1, new HashSet<>());             set.remove(key);             if (set.isEmpty()) {                 countKeyMap.remove(count - 1);                 minCount = count;             } else {                 countKeyMap.put(count - 1, set);             }         } else if (!countKeyMap.containsKey(count - 1)) {             minCount = count;         } else {             Set<String> set = countKeyMap.get(count - 1);             set.remove(key);             if (set.isEmpty()) {                 countKeyMap.remove(count - 1);             } else {                 countKeyMap.put(count - 1, set);             }         }                  Set<String> set = countKeyMap.getOrDefault(count, new HashSet<>());         set.add(key);         countKeyMap.put(count, set);     }          /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */     public void dec(String key) {         int count = countMap.get(key) - 1;         countMap.put(key, count);                  if (count == 0) {             countMap.remove(key);         } else {             if (count < minCount) {                 minCount = count;             }                          if (count == maxCount - 1) {                 Set<String> set = countKeyMap.getOrDefault(maxCount, new HashSet<>());                 set.remove(key);                 if (set.isEmpty()) {                     countKeyMap.remove(maxCount);                     maxCount = count;                 } else {                     countKeyMap.put(maxCount, set);                 }             } else if (!countKeyMap.containsKey(count + 1)) {                 maxCount = count;             } else {                 Set<String> set = countKeyMap.get(count + 1);                 set.remove(key);                 if (set.isEmpty()) {                     countKeyMap.remove(count + 1);                 } else {                     countKeyMap.put(count + 1, set);                 }             }              Set<String> set = countKeyMap.getOrDefault(count, new HashSet<>());             set.add(key);             countKeyMap.put(count, set);         }     }          /** Returns one of the keys with maximal value. */     public String getMaxKey() {         return countKeyMap.containsKey(maxCount) ? countKeyMap.get(maxCount).iterator().next() : """";     }          /** Returns one of the keys with Minimal value. */     public String getMinKey() {         return countKeyMap.containsKey(minCount) ? countKeyMap.get(minCount).iterator().next() : """";     } }",1,"432-all-oone-data-structure/AllOne.java:9:5: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
432-all-oone-data-structure/AllOne.java:12:5: Redundant 'public' modifier. [RedundantModifier]
432-all-oone-data-structure/AllOne.java:39:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
432-all-oone-data-structure/AllOne.java:77:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",1,0,0
"class Solution {     public int findKthNumber(int n, int k) {         int curr = 1;         k--;         while(k>0)         {             long step = 0; // keep count of total steps required to move curr to curr+1             long first = curr, last = curr+1; // start with `curr` and `curr+1`              while(first <= n)             {                 step += Math.min((long) n+1, last) - first;                 first *= 10;                 last *= 10;             }              if(step <= k) // we need to move to the next lexicographically greater number             {                 k -= step;                 curr++;             }             else // the required number is in the sub-tree of current `curr` spanned by `first` and `last`             {                 k--;                 curr *= 10;             }         }         return curr; // kth number is obtained     } }",1,"440-k-th-smallest-in-lexicographical-order/Solution.java:6:9: '{' at column 9 should be on the previous line. [LeftCurly]
440-k-th-smallest-in-lexicographical-order/Solution.java:8:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
440-k-th-smallest-in-lexicographical-order/Solution.java:11:13: '{' at column 13 should be on the previous line. [LeftCurly]
440-k-th-smallest-in-lexicographical-order/Solution.java:18:13: '{' at column 13 should be on the previous line. [LeftCurly]
440-k-th-smallest-in-lexicographical-order/Solution.java:21:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
440-k-th-smallest-in-lexicographical-order/Solution.java:23:13: '{' at column 13 should be on the previous line. [LeftCurly]
440-k-th-smallest-in-lexicographical-order/Solution.java:4:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'k'
",1,1,0
"class Solution {     public int numberOfArithmeticSlices(int[] nums) {         int n = nums.length;         if (n < 3) {             return 0;         }          int ans = 0;         Map<Long, Integer>[] dp = new Map[n];         for (int i = 0; i < n; i++) {             dp[i] = new HashMap<>(i);             for (int j = 0; j < i; j++) {                 long diff = (long) nums[i] - (long) nums[j];                 if (diff > Integer.MAX_VALUE || diff < Integer.MIN_VALUE) {                     continue;                 }                 int count = dp[j].getOrDefault(diff, 0);                 ans += count;                 dp[i].put(diff, dp[i].getOrDefault(diff, 0) + count + 1);             }         }         return ans;     } }",1,"446-arithmetic-slices-ii-subsequence/Solution.java:13:	UnnecessaryCast:	Unnecessary cast (long)
446-arithmetic-slices-ii-subsequence/Solution.java:13:	UnnecessaryCast:	Unnecessary cast (long)
",0,0,0
"class Solution {     public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {         int pigs = 0;         int tests = minutesToTest / minutesToDie + 1;         while (Math.pow(tests, pigs) < buckets) {             pigs++;         }         return pigs;     } }",0,,0,0,0
"import java.util.HashMap; import java.util.LinkedList; import java.util.Map;  class Node {     Node prev;     Node next;     int key;     int value;     int frequency;      public Node(int key, int value) {         this.key = key;         this.value = value;         this.frequency = 1;     } }  class LFUCache {     Map<Integer, Node> cacheMap;     Map<Integer, LinkedList<Node>> frequencyMap;     int size;     int capacity;     int minimumFrequency;      public LFUCache(int capacity) {         this.capacity = capacity;         size = 0;         minimumFrequency = Integer.MAX_VALUE;         cacheMap = new HashMap<>();         frequencyMap = new HashMap<>();     }      public int get(int key) {         Node node = cacheMap.get(key);         if (node == null) {             return -1;         }         updateNode(node);         return node.value;     }      public void put(int key, int value) {         if (capacity == 0) {             return;         }         Node node = cacheMap.get(key);         if (node != null) {             node.value = value;             updateNode(node);         } else {             if (size == capacity) {                 LinkedList<Node> minimumFrequencyList = frequencyMap.get(minimumFrequency);                 Node removeNode = minimumFrequencyList.removeLast();                 cacheMap.remove(removeNode.key);                 size--;             }             Node newNode = new Node(key, value);             cacheMap.put(key, newNode);             LinkedList<Node> linkedList = frequencyMap.getOrDefault(1, new LinkedList<>());             linkedList.addFirst(newNode);             frequencyMap.put(1, linkedList);             minimumFrequency = 1;             size++;         }     }      public void updateNode(Node node) {         LinkedList<Node> linkedList = frequencyMap.get(node.frequency);         linkedList.remove(node);         if (node.frequency == minimumFrequency && linkedList.size() == 0) {             minimumFrequency++;         }         node.frequency++;         LinkedList<Node> list = frequencyMap.getOrDefault(node.frequency, new LinkedList<>());         list.addFirst(node);         frequencyMap.put(node.frequency, list);     } }",1,"460-lfu-cache/Node.java:6:10: Variable 'prev' must be private and have accessor methods. [VisibilityModifier]
460-lfu-cache/Node.java:7:10: Variable 'next' must be private and have accessor methods. [VisibilityModifier]
460-lfu-cache/Node.java:8:9: Variable 'key' must be private and have accessor methods. [VisibilityModifier]
460-lfu-cache/Node.java:9:9: Variable 'value' must be private and have accessor methods. [VisibilityModifier]
460-lfu-cache/Node.java:10:9: Variable 'frequency' must be private and have accessor methods. [VisibilityModifier]
460-lfu-cache/Node.java:12:5: Redundant 'public' modifier. [RedundantModifier]
460-lfu-cache/Node.java:12:21: 'key' hides a field. [HiddenField]
460-lfu-cache/Node.java:12:30: 'value' hides a field. [HiddenField]
460-lfu-cache/Node.java:20:24: Variable 'cacheMap' must be private and have accessor methods. [VisibilityModifier]
460-lfu-cache/Node.java:21:36: Variable 'frequencyMap' must be private and have accessor methods. [VisibilityModifier]
460-lfu-cache/Node.java:22:9: Variable 'size' must be private and have accessor methods. [VisibilityModifier]
460-lfu-cache/Node.java:23:9: Variable 'capacity' must be private and have accessor methods. [VisibilityModifier]
460-lfu-cache/Node.java:24:9: Variable 'minimumFrequency' must be private and have accessor methods. [VisibilityModifier]
460-lfu-cache/Node.java:26:5: Redundant 'public' modifier. [RedundantModifier]
460-lfu-cache/Node.java:26:25: 'capacity' hides a field. [HiddenField]
460-lfu-cache/Node.java:21:	LooseCoupling:	Avoid using implementation types like 'LinkedList'; use the interface instead
460-lfu-cache/Node.java:53:	LooseCoupling:	Avoid using implementation types like 'LinkedList'; use the interface instead
460-lfu-cache/Node.java:60:	LooseCoupling:	Avoid using implementation types like 'LinkedList'; use the interface instead
460-lfu-cache/Node.java:69:	LooseCoupling:	Avoid using implementation types like 'LinkedList'; use the interface instead
460-lfu-cache/Node.java:71:	UseCollectionIsEmpty:	Substitute calls to size() == 0 (or size() != 0, size() > 0, size() < 1) with calls to isEmpty()
460-lfu-cache/Node.java:75:	LooseCoupling:	Avoid using implementation types like 'LinkedList'; use the interface instead
",0,0,0
"class Solution {     public int getMaxRepetitions(String s1, int n1, String s2, int n2) {         int len1 = s1.length();         int len2 = s2.length();         int index = 0; // current index in s2         int count1 = 0; // counter for s1         int count2 = 0; // counter for s2          // Check if we have enough s1 to form enough s2         if (len1 * n1 < len2 * n2) {             return 0;         }          // Maintain an array to store the index in s1 and corresponding count of s2         int[] idx = new int[len2 + 1];         int[] cnt = new int[len2 + 1];         idx[0] = 0;         cnt[0] = 0;          // Iterate over s1 for n1 repetitions         for (int i = 0; i < n1; i++) {             // Inner loop iterating over s1             for (int j = 0; j < len1; j++) {                 if (s1.charAt(j) == s2.charAt(index)) {                     index++;                     // When we reach the end of s2, increment count2 and reset the index                     if (index == len2) {                         index = 0;                         count2++;                     }                 }             }             count1++;             // If we encounter the same index (in s1), we can conclude that we have completed a cycle             if (idx[index] != 0) {                 int cycleLen = count1 - idx[index];                 int cycleCnt = count2 - cnt[index];                 int cycles = (n1 - count1 + idx[index]) / cycleLen;                 count1 += cycles * cycleLen;                 count2 += cycles * cycleCnt;             }             idx[index] = count1;             cnt[index] = count2;         }          return count2 / n2;     } }",1,"466-count-the-repetitions/Solution.java:5:	PrematureDeclaration:	Declaration of 'index' can be moved closer to its usages
466-count-the-repetitions/Solution.java:6:	PrematureDeclaration:	Declaration of 'count1' can be moved closer to its usages
466-count-the-repetitions/Solution.java:7:	PrematureDeclaration:	Declaration of 'count2' can be moved closer to its usages
",0,0,0
"import java.util.*;  class Solution {     public List<String> findAllConcatenatedWordsInADict(String[] words) {         // sort the words by length         Arrays.sort(words, Comparator.comparingInt(String::length));         // create a hashset of shorter words         Set<String> shorterWords = new HashSet<>();         List<String> result = new ArrayList<>();         // iterate through each word in the sorted words array         for (String word : words) {             // if the word can be formed by concatenation of shorter words,             // add it to the result list             if (canFormWord(word, shorterWords)) {                 result.add(word);             }             // add the word to the set of shorter words             shorterWords.add(word);         }         return result;     }          private boolean canFormWord(String word, Set<String> shorterWords) {         if (shorterWords.isEmpty()) {             // return false if there are no shorter words             return false;         }         boolean[] dp = new boolean[word.length() + 1];         // base case: empty string         dp[0] = true;         // iterate through each index of the word         for (int i = 1; i <= word.length(); i++) {             // iterate through each shorter word in the set             for (String shorterWord : shorterWords) {                 // check if the current index is greater than or equal to the length of the shorter word                 // and if the substring before the current index matches the shorter word                 if (i >= shorterWord.length() && word.substring(i - shorterWord.length(), i).equals(shorterWord)) {                     // if the shorter word can form the substring before the current index,                     // and the remaining substring after the shorter word can be formed by concatenation                     // of shorter words, mark the current index as true                     if (dp[i - shorterWord.length()]) {                         dp[i] = true;                         break;                     }                 }             }         }         return dp[word.length()];     } }",1,"472-concatenated-words/Solution.java:18:	UseArraysAsList:	Use asList instead of tight loops
472-concatenated-words/Solution.java:41:	CollapsibleIfStatements:	This if statement could be combined with its parent
",0,0,0
"class Solution {     public int largestPalindrome(int n) {         if(n == 1) return 9;   // Base case         int maxNum = (int)Math.pow(10,n)-1; // Calculate the max value of n-digit number         int minNum = (int)Math.pow(10,n-1); // Calculate the min value of n-digit number         long maxProd = (long)maxNum * (long)maxNum;         int halfLen = maxNum / 10;  // To get half the length of the palindrome         boolean isPalindromeFound=false; // Flag to check if palindrome is found         long palindrome=0;         while(!isPalindromeFound){             // Create the palindrome by combining first half and reversed second half             String strNum = String.valueOf(maxProd);             String strFirstHalf = strNum.substring(0,halfLen);             String strSecondHalf = new StringBuilder(strFirstHalf).reverse().toString();             String strPalindrome = strFirstHalf + strSecondHalf;             palindrome = Long.parseLong(strPalindrome);             // Check if palindrome can be represented as a product of n-digit numbers             for(long i=maxNum; i>=minNum; i--){                 if(palindrome/i > maxNum) break;  // If quotient > maxNum                 if(palindrome%i==0){  // If palindrome can be represented as product of i and (palindrome/i)                     isPalindromeFound=true;                     break;                 }             }             maxProd--;         }         return (int)(palindrome % 1337);     } }",1,"479-largest-palindrome-product/Solution.java:6:	UnnecessaryCast:	Unnecessary cast (long)
479-largest-palindrome-product/Solution.java:6:	UnnecessaryCast:	Unnecessary cast (long)
",0,0,0
"import java.util.*;  class Solution {     public double[] medianSlidingWindow(int[] nums, int k) {         PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());         PriorityQueue<Integer> minHeap = new PriorityQueue<>();         int n = nums.length - k + 1;         if (n <= 0) {             return new double[0];         }         double[] result = new double[n];         int i = 0;         int j = 0;         while (j < nums.length) {             maxHeap.offer(nums[j]);             minHeap.offer(maxHeap.poll());             if (maxHeap.size() < minHeap.size()) {                 maxHeap.offer(minHeap.poll());             }             if (j - i + 1 == k) {                 if (maxHeap.size() == minHeap.size()) {                     result[i] = (double) (maxHeap.peek() + minHeap.peek()) / 2;                 } else {                     result[i] = (double) maxHeap.peek();                 }                 if (!maxHeap.remove(nums[i])) {                     minHeap.remove(nums[i]);                 }                 i++;             }             j++;         }         return result;     } }",1,"480-sliding-window-median/Solution.java:5:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
480-sliding-window-median/Solution.java:6:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
480-sliding-window-median/Solution.java:24:	UnnecessaryCast:	Unnecessary cast (double)
",0,0,0
"class Solution {     public String smallestGoodBase(String n) {         long num = Long.parseLong(n);         long res = Long.MAX_VALUE;          for(int k=2; k<=Math.pow(num, 1.0/(double)(k-1)); k++) {             long l=2, r=num;             while(l<r) {                 long mid = l + (r-l)/2;                 long sum=0;                  for(int i=0; i<k; i++) {                     sum = sum*mid + 1;                 }                 if(sum == num) {                     res = Math.min(res, mid);                     break;                 } else if(sum < num) {                     l = mid+1;                 } else {                     r = mid;                 }             }         }         return """"+res;     } }",1,"483-smallest-good-base/Solution.java:7:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
483-smallest-good-base/Solution.java:6:	UnnecessaryCast:	Unnecessary cast (double)
483-smallest-good-base/Solution.java:25:	AddEmptyString:	Do not add empty strings
",1,0,0
"class Solution {     public int findMinStep(String board, String hand) {         int[] handCount = new int[26]; // count of each ball in hand         for (char c : hand.toCharArray()) {             handCount[c - 'A']++;         }         int res = helper(board + ""#"", handCount); // append ""#"" to avoid special handling of the last group         return res == MAX_STEP ? -1 : res;     }     private static final int MAX_STEP = 6;     private int helper(String board, int[] handCount) {         board = removeConsecutive(board);         if (board.equals(""#"")) return 0; // base case: all removed         int res = MAX_STEP, need;         for (int i = 0, j = 0; j < board.length(); j++) {             if (board.charAt(j) == board.charAt(i)) continue; // skip duplicates             need = 3 - (j - i); // balls need to remove current consecutive balls             if (handCount[board.charAt(i) - 'A'] >= need) {                 handCount[board.charAt(i) - 'A'] -= need;                 res = Math.min(res, need + helper(board.substring(0, i) + board.substring(j), handCount));                 handCount[board.charAt(i) - 'A'] += need;             }             i = j;         }         return res;     }     // remove consecutive balls longer than 3     private String removeConsecutive(String board) {         for (int i = 0, j = 0; j < board.length(); j++) {             if (board.charAt(j) == board.charAt(i)) continue;             if (j - i >= 3) return removeConsecutive(board.substring(0, i) + board.substring(j));             else i = j;         }         return board;     } }",1,"488-zuma-game/Solution.java:14:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
488-zuma-game/Solution.java:10:	FieldDeclarationsShouldBeAtStartOfClass:	Fields should be declared at the top of the class, before any method declarations, constructors, initializers or inner classes.
488-zuma-game/Solution.java:12:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'board'
488-zuma-game/Solution.java:13:	LiteralsFirstInComparisons:	Position literals first in String comparisons
488-zuma-game/Solution.java:15:	ForLoopVariableCount:	Too many control variables in the for statement
488-zuma-game/Solution.java:29:	ForLoopVariableCount:	Too many control variables in the for statement
",1,1,0
"class Solution {     public int reversePairs(int[] nums) {         return mergeSort(nums, 0, nums.length - 1);     }          private int mergeSort(int[] nums, int left, int right) {         if (left >= right) {             return 0;         }                  int mid = (left + right) / 2;         int count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right);         int[] cache = new int[right - left + 1];         int i = left, j = mid + 1, k = 0, p = mid + 1;                  while (i <= mid) {             while (p <= right && nums[i] > (long) 2 * nums[p]) {                 p++;             }             count += p - (mid + 1);             while (j <= right && nums[i] >= nums[j]) {                 cache[k++] = nums[j++];             }             cache[k++] = nums[i++];         }                  while (j <= right) {             cache[k++] = nums[j++];         }                  System.arraycopy(cache, 0, nums, left, right - left + 1);                  return count;     } }",1,"493-reverse-pairs/Solution.java:14:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
493-reverse-pairs/Solution.java:21:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
493-reverse-pairs/Solution.java:27:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
",1,0,0
"class Solution {     public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {         // Create a list of projects with their profits and minimum capital required         List<int[]> projectList = new ArrayList<>();         for (int i = 0; i < profits.length; i++) {             projectList.add(new int[] {capital[i], profits[i]});         }         // Sort the projects based on their minimum capital required         Collections.sort(projectList, (a, b) -> a[0] - b[0]);         // Create a priority queue to store the profits of the projects that we can start         PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());         int index = 0;         while (k > 0) {             // Add the profits of the projects that we can start to the priority queue             while (index < projectList.size() && projectList.get(index)[0] <= w) {                 pq.offer(projectList.get(index)[1]);                 index++;             }             // If there are no projects that we can start, break the loop             if (pq.isEmpty()) {                 break;             }             // Choose the project with the maximum profit and add its profit to our capital             w += pq.poll();             k--;         }         return w;     } }",1,"502-ipo/Solution.java:24:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'w'
502-ipo/Solution.java:25:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'k'
",0,1,0
"class Solution {     public int findRotateSteps(String ring, String key) {         int n = ring.length(), m = key.length();         int[][] dp = new int[m][n];         // Determine the position of each character in the ring         List<Integer>[] pos = new List[26];         for (int i = 0; i < 26; ++i) {             pos[i] = new ArrayList<>();         }         for (int i = 0; i < n; ++i) {             pos[ring.charAt(i) - 'a'].add(i);         }         // Calculate the minimum number of steps to spell the keyword from each character in the ring         for (int i : pos[key.charAt(0) - 'a']) { // The starting character must be aligned with key.charAt(0)             dp[0][i] = Math.min(i, n - i) + 1; // Add 1 for button press         }         for (int i = 1; i < m; ++i) {             for (int j : pos[key.charAt(i) - 'a']) {                 dp[i][j] = Integer.MAX_VALUE;                 for (int k : pos[key.charAt(i - 1) - 'a']) { // Iterate over the positions of the previous character in the keyword                     int steps = Math.min(Math.abs(j - k), n - Math.abs(j - k)) + 1; // Calculate the number of steps to reach this position in the ring                     dp[i][j] = Math.min(dp[i][j], dp[i - 1][k] + steps); // Update the minimum number of steps                 }             }         }         // The answer is the minimum number of steps to spell the last character in the keyword from any position in the ring         return Arrays.stream(dp[m - 1]).min().getAsInt();     } }",1,"514-freedom-trail/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int findMinMoves(int[] machines) {         int n = machines.length;                  // Calculate the total number of dresses in all machines         int sum = 0;         for(int i=0; i<n; i++) {             sum += machines[i];         }                  // If the sum is not divisible by the number of machines, it's impossible to distribute dresses equally         if(sum % n != 0) {             return -1;         }                  // Calculate the target number of dresses in each machine         int target = sum / n;                  int moves = 0, balance = 0, diff = 0;         for(int i=0; i<n; i++) {             diff = machines[i] - target; // Calculate the difference between the current number of dresses and the target             balance += diff; // Update the balance             moves = Math.max(moves, Math.max(Math.abs(balance), diff)); // Calculate the minimum moves required         }          return moves;     } }",1,"517-super-washing-machines/Solution.java:19:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
517-super-washing-machines/Solution.java:19:	UnusedAssignment:	The initializer for variable 'diff' is never used (overwritten on line 21)
",1,0,0
"class Solution {     private int[][][] memo;      public int removeBoxes(int[] boxes) {         int n = boxes.length;         memo = new int[n][n][n];         return removeBoxesHelper(boxes, 0, n - 1, 0);     }      private int removeBoxesHelper(int[] boxes, int i, int j, int k) {         if (i > j) {             return 0;         }         if (memo[i][j][k] > 0) {             return memo[i][j][k];         }         memo[i][j][k] = removeBoxesHelper(boxes, i, j - 1, 0) + (k + 1) * (k + 1);         for (int p = i; p < j; p++) {             if (boxes[p] == boxes[j]) {                 memo[i][j][k] = Math.max(memo[i][j][k], removeBoxesHelper(boxes, i, p, k + 1) +                                                         removeBoxesHelper(boxes, p + 1, j - 1, 0));             }         }         return memo[i][j][k];     } }",0,,0,0,0
class Solution {     public int checkRecord(int n) {         final int MOD = 1000000007;         long dp[][][] = new long[n+1][2][3];         dp[1][0][0] = 1; // 'P'         dp[1][1][0] = 1; // 'A'         dp[1][0][1] = 1; // 'L'         for(int i = 2; i <= n; i++) {             // Present             dp[i][0][0] = (dp[i-1][0][0] + dp[i-1][0][1] + dp[i-1][0][2]) % MOD;             dp[i][1][0] = (dp[i-1][1][0] + dp[i-1][1][1] + dp[i-1][1][2]) % MOD;             // Late             dp[i][0][1] = dp[i-1][0][0]; // No consecutive L's             dp[i][0][2] = dp[i-1][0][1]; // Exactly one consecutive L's             dp[i][1][1] = dp[i-1][1][0]; // No consecutive L's             dp[i][1][2] = dp[i-1][1][1]; // Exactly one consecutive L's         }         long ans = (dp[n][0][0] + dp[n][0][1] + dp[n][0][2] + dp[n][1][0] + dp[n][1][1] + dp[n][1][2]) % MOD;         return (int) ans;     } },1,"552-student-attendance-record-ii/Solution.java:4:16: Array brackets at illegal position. [ArrayTypeStyle]
552-student-attendance-record-ii/Solution.java:4:18: Array brackets at illegal position. [ArrayTypeStyle]
552-student-attendance-record-ii/Solution.java:4:20: Array brackets at illegal position. [ArrayTypeStyle]
",0,0,0
"class Solution {     public String nearestPalindromic(String n) {         long num = Long.parseLong(n);         if(num <= 10 || (num <= 100 && n.charAt(0) == '9')) return String.valueOf(num - 1); // edge cases                  long ans = num - 1;         long diff = num - ans;         if(num % 2 == 0) { // if num is even             for(int i = 0; i < 2; i++) {                 String pal = palindrome(num, i);                 long currDiff = Math.abs(num - Long.parseLong(pal));                 if(currDiff < diff || (currDiff == diff && Long.parseLong(pal) < ans)) {                     ans = Long.parseLong(pal);                     diff = currDiff;                 }             }         } else { // if num is odd             for(int i = 0; i < 3; i++) {                 String pal = palindrome(num, i);                 long currDiff = Math.abs(num - Long.parseLong(pal));                 if(currDiff < diff || (currDiff == diff && Long.parseLong(pal) < ans)) {                     ans = Long.parseLong(pal);                     diff = currDiff;                 }             }         }                  return String.valueOf(ans);     }          private String palindrome(long num, int i) {         String str = String.valueOf(num);         String revStr = new StringBuilder(str).reverse().toString();         if(i == 0) return str.substring(0, str.length() / 2) + revStr.substring(str.length() / 2);         else if(i == 1) {             long left = Long.parseLong(str.substring(0, str.length() / 2));             left++;             return String.valueOf(left) + new StringBuilder(String.valueOf(left)).reverse().toString().substring(1);         } else {             long left = Long.parseLong(str.substring(0, str.length() / 2 + 1));             left--;             return String.valueOf(left) + new StringBuilder(String.valueOf(left)).reverse().toString().substring(1);         }     } }",1,"564-find-the-closest-palindrome/Solution.java:38:	UselessStringValueOf:	No need to call String.valueOf to append to a string.
564-find-the-closest-palindrome/Solution.java:42:	UselessStringValueOf:	No need to call String.valueOf to append to a string.
",0,0,0
"import java.util.*;  class Solution {     public int[][] outerTrees(int[][] trees) {         // Sort the trees by x coordinate and then by y coordinate         Arrays.sort(trees, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);                  // Create a stack to keep track of the outer trees         Stack<int[]> outerTrees = new Stack<>();                  // Traverse through all the trees         for (int i = 0; i < trees.length; i++) {             int[] tree = trees[i];                          // While we have more than two trees in the stack and the current tree is on the wrong side of the line formed by the top two trees in the stack             while (outerTrees.size() >= 2 && crossProduct(outerTrees.get(outerTrees.size() - 2), outerTrees.peek(), tree) < 0) {                 outerTrees.pop(); // Pop the top tree from the stack             }                          outerTrees.push(tree); // Push the current tree onto the stack         }                  outerTrees.pop(); // Pop the last tree, which has been added twice                  // Traverse through all the trees in reverse order         for (int i = trees.length - 1; i >= 0; i--) {             int[] tree = trees[i];                          // While we have more than two trees in the stack and the current tree is on the wrong side of the line formed by the top two trees in the stack             while (outerTrees.size() >= 2 && crossProduct(outerTrees.get(outerTrees.size() - 2), outerTrees.peek(), tree) < 0) {                 outerTrees.pop(); // Pop the top tree from the stack             }                          outerTrees.push(tree); // Push the current tree onto the stack         }                  // Remove duplicates from the stack and convert it to an array         return new HashSet<>(outerTrees).toArray(new int[0][]);     }          // Calculate the cross product of two vectors: AB and BC     private int crossProduct(int[] a, int[] b, int[] c) {         int x1 = b[0] - a[0];         int y1 = b[1] - a[1];         int x2 = c[0] - b[0];         int y2 = c[1] - b[1];         return x1 * y2 - x2 * y1;     } }",1,"587-erect-the-fence/Solution.java:9:	LooseCoupling:	Avoid using implementation types like 'Stack'; use the interface instead
587-erect-the-fence/Solution.java:9:	ReplaceVectorWithList:	Consider replacing this Vector with the newer java.util.List
587-erect-the-fence/Solution.java:9:	ReplaceVectorWithList:	Consider replacing this Vector with the newer java.util.List
587-erect-the-fence/Solution.java:12:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public boolean isValid(String code) {         Stack<String> stack = new Stack<>();         for (int i = 0; i < code.length(); ) {             if (i > 0 && stack.isEmpty()) {                 return false;             }             if (code.startsWith(""<![CDATA["", i)) {                 int j = i + 9;                 i = code.indexOf(""]]>"", j);                 if (i < 0) {                     return false;                 }                 i += 2;             } else if (code.startsWith(""</"", i)) {                 int j = i + 2;                 i = code.indexOf('>', j);                 if (i < 0) {                     return false;                 }                 String tag = code.substring(j, i);                 if (stack.isEmpty() || !stack.pop().equals(tag)) {                     return false;                 }             } else if (code.startsWith(""<"", i)) {                 int j = i + 1;                 i = code.indexOf('>', j);                 if (i < 0) {                     return false;                 }                 String tag = code.substring(j, i++);                 if (tag.startsWith(""/"")) {                     if (stack.isEmpty() || !stack.pop().equals(tag.substring(1))) {                         return false;                     }                 } else {                     if (tag.contains("" "") || tag.length() > 9) {                         return false;                     }                     stack.push(tag);                 }             } else {                 i++;             }         }         return stack.isEmpty();     } }",1,"591-tag-validator/Solution.java:4:44: ';' is followed by whitespace. [EmptyForIteratorPad]
",0,0,0
class Solution {     public int findIntegers(int n) {         // Convert n to binary representation         String binary = Integer.toBinaryString(n);                  // Initialize dp array with two values         int[] dp = new int[binary.length() + 1];         dp[0] = 1; // dp[0] represents single digit binary numbers         dp[1] = 2; // dp[1] represents two digits binary numbers                  // Build the dp array         for (int i = 2; i <= binary.length(); i++) {             dp[i] = dp[i-1] + dp[i-2]; // Fibonacci sum         }                  // Count the numbers without consecutive ones         int count = 0;         int prevBit = 0;         for (int i = binary.length() - 1; i >= 0; i--) {             int currBit = binary.charAt(i) - '0';             if (currBit == 1) {                 count += dp[i+1]; // Add the count for dp[i+1] digits             }             if (prevBit == 1 && currBit == 1) {                 break; // Stop if consecutive ones found             }             prevBit = currBit;             if (i == 0) {                 count++; // Add one for the last digit             }         }                  return count;     } },0,,0,0,0
"class Solution {     public int kInversePairs(int n, int k) {         int MOD = 1000000007;         int[][] dp = new int[n+1][k+1];         dp[1][0] = 1;         for(int i=2; i<=n; i++) {             dp[i][0] = 1;             for(int j=1; j<=Math.min(k, i*(i-1)/2); j++) {                 dp[i][j] = dp[i-1][j] + dp[i][j-1];                 if(j>=i) {                     dp[i][j] -= dp[i-1][j-i];                 }                 dp[i][j] = (dp[i][j]+MOD)%MOD;             }         }         return dp[n][k];     } }",0,,0,0,0
"class Solution {     public int scheduleCourse(int[][] courses) {                  // Sorting the courses in increasing order of their lastDay         Arrays.sort(courses, (a,b) -> a[1] - b[1]);          PriorityQueue<Integer> timeTaken = new PriorityQueue<Integer>((a,b) -> b - a);         int currentTime = 0;                  for (int[] course : courses) {             if (currentTime + course[0] <= course[1]) {                 timeTaken.offer(course[0]);                 currentTime += course[0];             } else if (!timeTaken.isEmpty() && timeTaken.peek() > course[0]) {                 currentTime += course[0] - timeTaken.poll();                 timeTaken.offer(course[0]);             }         }         return timeTaken.size();     } }",0,,0,0,0
"import java.util.*;  class Solution {     public int[] smallestRange(List<List<Integer>> nums) {         int k = nums.size();         int[] pointers = new int[k]; // to keep track of current element in each list         PriorityQueue<Integer> minHeap = new PriorityQueue<>((a, b) -> nums.get(a).get(pointers[a]) - nums.get(b).get(pointers[b]));         int max = Integer.MIN_VALUE;         for (int i = 0; i < k; i++) {             minHeap.offer(i);             max = Math.max(max, nums.get(i).get(0));         }         int rangeStart = -1, rangeEnd = -1, minRange = Integer.MAX_VALUE;         while (minHeap.size() == k) {             int listIndex = minHeap.poll();             if (max - nums.get(listIndex).get(pointers[listIndex]) < minRange) {                 minRange = max - nums.get(listIndex).get(pointers[listIndex]);                 rangeStart = nums.get(listIndex).get(pointers[listIndex]);                 rangeEnd = max;             }             pointers[listIndex]++;             if (pointers[listIndex] < nums.get(listIndex).size()) {                 minHeap.offer(listIndex);                 max = Math.max(max, nums.get(listIndex).get(pointers[listIndex]));             }         }         return new int[]{rangeStart, rangeEnd};     } }",1,"632-smallest-range-covering-elements-from-k-lists/Solution.java:13:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
632-smallest-range-covering-elements-from-k-lists/Solution.java:7:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
",1,0,0
class Solution {     public int numDecodings(String s) {         final int MOD = 1000000007;         int n = s.length();         long[] dp = new long[n+1];         dp[0] = 1;         dp[1] = s.charAt(0) == '*'? 9 : s.charAt(0) == '0'? 0 : 1;         for(int i=2; i<=n; i++){             char first = s.charAt(i-2);             char second = s.charAt(i-1);             if(second == '*'){                 dp[i] = 9 * dp[i-1];             }             else if(second != '0'){                 dp[i] = dp[i-1];             }             if(first == '*'){                 if(second == '*'){                     dp[i] = dp[i] + 15 * dp[i-2];                 }                 else if(second <= '6'){                     dp[i] = dp[i] + 2 * dp[i-2];                 }                 else{                     dp[i] = dp[i] + dp[i-2];                 }             }             else if(first == '1' || first == '2'){                 if(second == '*'){                     if(first == '1'){                         dp[i] = dp[i] + 9 * dp[i-2];                     }                     else{ //'2'                         dp[i] = dp[i] + 6 * dp[i-2];                     }                 }                 else if((first-'0')*10 + (second-'0') <= 26){                     dp[i] = dp[i] + dp[i-2];                 }             }             dp[i] = dp[i] % MOD;         }         return (int) dp[n];     } },1,"639-decode-ways-ii/Solution.java:13:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
639-decode-ways-ii/Solution.java:20:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
639-decode-ways-ii/Solution.java:23:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
639-decode-ways-ii/Solution.java:27:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
639-decode-ways-ii/Solution.java:32:21: '}' at column 21 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
639-decode-ways-ii/Solution.java:36:17: '}' at column 17 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
639-decode-ways-ii/Solution.java:8:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
639-decode-ways-ii/Solution.java:37:	UselessParentheses:	Useless parentheses.
",0,0,0
"class Solution {     public int strangePrinter(String s) {         int n = s.length();         int[][] dp = new int[n][n];         for (int i = n - 1; i >= 0; i--) {             dp[i][i] = 1;             for (int j = i + 1; j < n; j++) {                 if (s.charAt(i) == s.charAt(j)) {                     dp[i][j] = dp[i][j-1];                 } else {                     int min = Integer.MAX_VALUE;                     for (int k = i; k < j; k++) {                         min = Math.min(min, dp[i][k] + dp[k+1][j]);                     }                     dp[i][j] = min;                 }             }         }         return dp[0][n-1];     } }",0,,0,0,0
"class Solution {     public int findKthNumber(int m, int n, int k) {         int low = 1, high = m * n;         while (low < high) {             int mid = low + (high - low) / 2;             int count = count(mid, m, n);             if (count >= k) {                 high = mid;             } else {                 low = mid + 1;             }         }         return low;     }          private int count(int x, int m, int n) {         int res = 0;         for (int i = 1; i <= m; i++) {             res += Math.min(x / i, n);         }         return res;     } }",1,"668-kth-smallest-number-in-multiplication-table/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"import java.util.*;  class Solution {     public int cutOffTree(List<List<Integer>> forest) {         // put all trees in a map with height as key for sorting         Map<Integer, int[]> trees = new TreeMap<>();         int m = forest.size(), n = forest.get(0).size();         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 int h = forest.get(i).get(j);                 if (h > 1)                     trees.put(h, new int[]{i, j});             }         }          // start at (0, 0) and try to reach every tree in order         int[] start = new int[2], end;         int steps = 0;         for (int[] tree : trees.values()) {             end = tree;             int dist = bfs(forest, start, end); // find shortest path with BFS             if (dist == -1) // if cannot reach tree, return -1                 return -1;             steps += dist;             start = end;         }         return steps;     }      private int bfs(List<List<Integer>> forest, int[] start, int[] end) {         int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};         int m = forest.size(), n = forest.get(0).size();         boolean[][] visited = new boolean[m][n];         Queue<int[]> queue = new LinkedList<>();         queue.offer(start);         visited[start[0]][start[1]] = true;         int dist = 0;         while (!queue.isEmpty()) {             int size = queue.size();             for (int i = 0; i < size; i++) {                 int[] curr = queue.poll();                 if (curr[0] == end[0] && curr[1] == end[1])                     return dist;                 for (int[] dir : dirs) {                     int x = curr[0] + dir[0], y = curr[1] + dir[1];                     if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y] || forest.get(x).get(y) == 0)                         continue;                     visited[x][y] = true;                     queue.offer(new int[]{x, y});                 }             }             dist++;         }         return -1; // cannot reach     } }",1,"675-cut-off-trees-for-golf-event/Solution.java:7:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
675-cut-off-trees-for-golf-event/Solution.java:17:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
675-cut-off-trees-for-golf-event/Solution.java:32:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
675-cut-off-trees-for-golf-event/Solution.java:45:21: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
675-cut-off-trees-for-golf-event/Solution.java:6:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
",1,0,0
"class Solution {     public boolean judgePoint24(int[] cards) {         List<Double> list = new ArrayList<>();         for (int card : cards) {             list.add((double) card);         }         return dfs(list);     }          private boolean dfs(List<Double> list) {         if (list.size() == 1) {             return Math.abs(list.get(0) - 24) < 0.001; // check if it's close enough to 24         }         for (int i = 0; i < list.size(); i++) { // pick two numbers to perform operations             for (int j = i + 1; j < list.size(); j++) {                 for (double c : generate(list.get(i), list.get(j))) {                     List<Double> next = new ArrayList<>();                     next.add(c);                     for (int k = 0; k < list.size(); k++) {                         if (k == i || k == j) {                             continue;                         }                         next.add(list.get(k));                     }                     if (dfs(next)) {                         return true;                     }                 }             }         }         return false;     }          private List<Double> generate(double a, double b) { // generate possible results after operations         List<Double> res = new ArrayList<>();         res.add(a + b);         res.add(a - b);         res.add(b - a);         res.add(a * b);         if (b != 0) {             res.add(a / b);         }         if (a != 0) {             res.add(b / a);         }         return res;     } }",0,,0,0,0
"class Solution {     public int[] findRedundantDirectedConnection(int[][] edges) {         int n = edges.length;                  int[] parent = new int[n+1];         Arrays.fill(parent, -1);         int conflict = -1;         int cycle = -1;         for(int i=0;i<n;i++){             int u = edges[i][0];             int v = edges[i][1];             if(parent[v]!=-1){                 conflict = i;                 continue;             }             parent[v] = u;             int x = find(parent, u);             int y = find(parent, v);             if(x==y){                 cycle = i;             }             else{                 parent[x] = y;             }         }                  if(conflict<0){             return new int[]{edges[cycle][0], edges[cycle][1]};         }         else{             int[] conflictEdge = edges[conflict];             if(cycle>=0){                 return new int[]{parent[conflictEdge[1]], conflictEdge[1]};             }             else{                 return new int[]{conflictEdge[0], conflictEdge[1]};             }         }     }          private int find(int[] parent, int u){         if(parent[u]==-1){             return u;         }         return parent[u] = find(parent, parent[u]);     } }",1,"685-redundant-connection-ii/Solution.java:21:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
685-redundant-connection-ii/Solution.java:29:9: '}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
685-redundant-connection-ii/Solution.java:34:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
685-redundant-connection-ii/Solution.java:45:26: Inner assignments should be avoided. [InnerAssignment]
",0,0,0
"class Solution {     public int[] maxSumOfThreeSubarrays(int[] nums, int k) {         int n = nums.length;         int[] sum = new int[n + 1]; // prefix sum array         for(int i = 1; i <= n; i++){             sum[i] = sum[i - 1] + nums[i - 1];         }          // dp[i][j] = max subarray sum of length k in nums[0...j] with i subarrays         int[][] dp = new int[4][n + 1];         int[][] index = new int[4][n + 1]; // stores the starting index of subarray with max sum         for(int i = 1; i <= 3; i++){ // i subarrays             for(int j = i * k; j <= n; j++){ // j elements                 int currSum = sum[j] - sum[j - k] + dp[i - 1][j - k];                 if(currSum > dp[i][j - 1]){                     dp[i][j] = currSum;                     index[i][j] = j - k; // update the starting index of subarray                 } else {                     dp[i][j] = dp[i][j - 1];                     index[i][j] = index[i][j - 1];                 }             }         }          int[] result = new int[3];         result[2] = index[3][n]; // last subarray          result[1] = index[2][result[2] / k]; // second subarray         int sum2 = dp[2][result[2] / k + k];         for(int j = k; j <= result[2] / k; j++){             if(dp[1][j * k - 1] + sum2 > dp[2][j * k] + dp[1][j * k - 1]){                 sum2 = dp[1][j * k - 1] + sum2;                 result[1] = index[1][j * k - 1];             }         }          result[0] = index[1][result[1] / k];         int sum1 = dp[1][result[0] / k + k];         for(int j = k; j <= result[0] / k; j++){             if(dp[1][j * k - 1] + sum1 > dp[1][result[0]]){                 sum1 = dp[1][j * k - 1] + sum1;                 result[0] = index[1][j * k - 1];             }         }          return result;     } }",0,,0,0,0
"class Solution {     public int minStickers(String[] stickers, String target) {         int n = stickers.length;         int[][] stickerChars = new int[n][26];                  // count the frequency of characters in each sticker         for (int i = 0; i < n; i++) {             for (char c : stickers[i].toCharArray()) {                 stickerChars[i][c - 'a']++;             }         }                  // use bitmask to represent the stickers used to create each state         Map<String, Integer> dp = new HashMap<>();         dp.put("""", 0); // initialize the start state         return helper(dp, stickerChars, target);     }          private int helper(Map<String, Integer> dp, int[][] stickerChars, String target) {         if (dp.containsKey(target)) {             return dp.get(target);         }                  int n = stickerChars.length;         int[] targetChars = new int[26];                  // count the frequency of characters in the target         for (char c : target.toCharArray()) {             targetChars[c - 'a']++;         }                  int ans = Integer.MAX_VALUE;                  // search for states that can be reached from the current state         for (int i = 0; i < n; i++) {             if (stickerChars[i][target.charAt(0) - 'a'] == 0) {                 continue;             }                          StringBuilder sb = new StringBuilder();                          // create the next state by removing characters of the chosen sticker from target             for (int j = 0; j < 26; j++) {                 if (targetChars[j] > stickerChars[i][j]) {                     for (int k = 0; k < targetChars[j] - stickerChars[i][j]; k++) {                         sb.append((char)('a' + j));                     }                 }             }                          String nextState = sb.toString();                          // recursive call to get the minimum number of stickers needed for the next state             int subAns = helper(dp, stickerChars, nextState);                          // update the answer if the next state is valid             if (subAns != -1) {                 ans = Math.min(ans, subAns + 1);             }         }                  dp.put(target, ans == Integer.MAX_VALUE ? -1 : ans);         return dp.get(target);     } }",0,,0,0,0
"import java.util.*;  class Solution {     public List<Integer> fallingSquares(int[][] positions) {         List<Integer> heights = new ArrayList<>(); // list to store heights of the tallest stack         List<Square> squares = new ArrayList<>(); // list to store squares                  int maxHeight = 0; // variable to store the height of the tallest stack so far                  for(int[] position : positions) {             Square square = new Square(position[0], position[1]); // create new square                          int height = getHeight(square, squares); // get height of the square                          squares.add(square); // add the square to the list                          maxHeight = Math.max(maxHeight, height); // update the maxHeight variable                          heights.add(maxHeight); // add the maxHeight to the list         }                  return heights;     }          private int getHeight(Square currentSquare, List<Square> squares) {         int maxHeight = 0;                  for(Square square : squares) {             if(square.left + square.length <= currentSquare.left || square.left >= currentSquare.left + currentSquare.length) { // the squares do not overlap horizontally                 continue;             }                          maxHeight = Math.max(maxHeight, square.height);         }                  currentSquare.height += maxHeight;                  return currentSquare.height;     } }  class Square {     int left;     int length;     int height;          public Square(int left, int length) {         this.left = left;         this.length = length;         this.height = length;     } }",1,"699-falling-squares/Solution.java:43:9: Variable 'left' must be private and have accessor methods. [VisibilityModifier]
699-falling-squares/Solution.java:44:9: Variable 'length' must be private and have accessor methods. [VisibilityModifier]
699-falling-squares/Solution.java:45:9: Variable 'height' must be private and have accessor methods. [VisibilityModifier]
699-falling-squares/Solution.java:47:5: Redundant 'public' modifier. [RedundantModifier]
699-falling-squares/Solution.java:47:23: 'left' hides a field. [HiddenField]
699-falling-squares/Solution.java:47:33: 'length' hides a field. [HiddenField]
",0,0,0
"import java.util.*;  class Solution {     private int n;     private Set<Integer> set;     private Random random;          public Solution(int n, int[] blacklist) {         this.n = n;         this.set = new HashSet<>();         for (int num : blacklist) {             set.add(num);         }         this.random = new Random();     }          public int pick() {         int r = random.nextInt(n - set.size());         if (set.contains(r)) {             return pick();         }         int count = 0;         for (int num : set) {             if (num <= r + count) {                 count++;             } else {                 break;             }         }         return r + count;     } }",1,"710-random-pick-with-blacklist/Solution.java:8:5: Redundant 'public' modifier. [RedundantModifier]
710-random-pick-with-blacklist/Solution.java:8:25: 'n' hides a field. [HiddenField]
",0,0,0
"import java.util.*;  class RangeModule {      List<int[]> ranges;          public RangeModule() {       // Initialize ranges as an empty list of integer arrays         ranges = new ArrayList<>();     }          public void addRange(int left, int right) {         // Create a new range         int[] newRange = {left, right};         // Create a new list to hold the new range and all ranges it overlaps with         List<int[]> overlappingRanges = new ArrayList<>();         // Loop through all existing ranges         for (int[] range : ranges) {             // If the new range doesn't overlap with the current range, add the current range to the overlappingRanges list and continue             if (newRange[1] <= range[0] || newRange[0] >= range[1]) {                 overlappingRanges.add(range);                 continue;             }             // If there is an overlap, update the new range to include current range             newRange[0] = Math.min(newRange[0], range[0]);             newRange[1] = Math.max(newRange[1], range[1]);         }         // Add the new range to the overlappingRanges list         overlappingRanges.add(newRange);         // Set the ranges list to overlappingRanges         ranges = overlappingRanges;     }          public boolean queryRange(int left, int right) {         // Loop through all existing ranges         for (int[] range : ranges) {             // If the query range doesn't overlap with the current range, continue             if (right <= range[0] || left >= range[1]) {                 continue;             }             // If there is an overlap, return true only if the current range fully covers the query range             return range[0] <= left && range[1] >= right;         }         // If the loop finishes without finding an overlapping range, return false         return false;     }          public void removeRange(int left, int right) {         // Create a new list to hold ranges that don't overlap with the range to be removed         List<int[]> newRanges = new ArrayList<>();         // Loop through all existing ranges         for (int[] range : ranges) {             // If the range to be removed doesn't overlap with the current range, add the current range to the newRanges list and continue             if (right <= range[0] || left >= range[1]) {                 newRanges.add(range);                 continue;             }             // If there is an overlap, split the current range into any non-overlapping parts and add them to the newRanges list             if (range[0] < left) {                 newRanges.add(new int[]{range[0], left});             }             if (range[1] > right) {                 newRanges.add(new int[]{right, range[1]});             }         }         // Set the ranges list to newRanges         ranges = newRanges;     } }  /**  * Your RangeModule object will be instantiated and called as such:  * RangeModule obj = new RangeModule();  * obj.addRange(left,right);  * boolean param_2 = obj.queryRange(left,right);  * obj.removeRange(left,right);  */",1,"715-range-module/RangeModule.java:5:17: Variable 'ranges' must be private and have accessor methods. [VisibilityModifier]
715-range-module/RangeModule.java:7:5: Redundant 'public' modifier. [RedundantModifier]
715-range-module/RangeModule.java:42:	AvoidBranchingStatementAsLastInLoop:	Avoid using a branching statement as the last in a loop.
",0,0,0
"class Solution {     public int smallestDistancePair(int[] nums, int k) {         Arrays.sort(nums); // Sort the array in ascending order                  int low = 0; // Initialize lower limit for binary search         int high = nums[nums.length-1]-nums[0]; // Initialize upper limit for binary search                  while(low<high) {             int mid = low + (high-low)/2; // Calculate the middle distance             int count = getSmallerPairs(nums, mid); // Get number of pairs with smaller distance than mid             if(count<k) {                 low = mid+1; // If number of pairs is less than k, increase the lower limit             } else {                 high = mid; // If number of pairs is greater or equal to k, update the upper limit             }         }                  return low; // Return the final smallest distance     }          private int getSmallerPairs(int[] nums, int target) {         int count = 0; // Initialize the count to 0         int left = 0; // Initialize left pointer to 0                  for(int right=0; right<nums.length; right++) {             while(nums[right]-nums[left]>target) { // If the difference is greater than target, move the left pointer                 left++;             }             count += right - left; // Add the number of indices between right and left pointer to the count         }                  return count; // Return the final count     } }",0,,0,0,0
"class Solution {     public String countOfAtoms(String formula) {         Map<String, Integer> map = getCounts(formula);         StringBuilder sb = new StringBuilder();         List<String> atoms = new ArrayList<>(map.keySet());         Collections.sort(atoms);         for (String atom : atoms) {             sb.append(atom);             int count = map.get(atom);             if (count > 1) {                 sb.append(count);             }         }         return sb.toString();     }      private Map<String, Integer> getCounts(String formula) {         Map<String, Integer> countMap = new HashMap<>();         Stack<Map<String, Integer>> stack = new Stack<>();         stack.push(countMap);         int i = 0;         while (i < formula.length()) {             char ch = formula.charAt(i);             if (ch == '(') {                 Map<String, Integer> innerCountMap = new HashMap<>();                 stack.push(innerCountMap);                 i++;             } else if (ch == ')') {                 Map<String, Integer> innerCountMap = stack.pop();                 i++;                 int countStart = i;                 while (i < formula.length() && Character.isDigit(formula.charAt(i))) {                     i++;                 }                 int count = 1;                 if (countStart < i) {                     count = Integer.parseInt(formula.substring(countStart, i));                 }                 for (String atom : innerCountMap.keySet()) {                     int innerCount = innerCountMap.get(atom);                     stack.peek().put(atom, stack.peek().getOrDefault(atom, 0) + innerCount * count);                 }             } else {                 int nameStart = i;                 i++;                 while (i < formula.length() && Character.isLowerCase(formula.charAt(i))) {                     i++;                 }                 String atom = formula.substring(nameStart, i);                 int countStart = i;                 while (i < formula.length() && Character.isDigit(formula.charAt(i))) {                     i++;                 }                 int count = 1;                 if (countStart < i) {                     count = Integer.parseInt(formula.substring(countStart, i));                 }                 stack.peek().put(atom, stack.peek().getOrDefault(atom, 0) + count);             }         }         return countMap;     } }",0,,0,0,0
"class Solution {     public int countPalindromicSubsequences(String s) {         int n = s.length();         int[][] dp = new int[n][n];         int mod = 1000000007;                  for(int i = n - 1; i >= 0; i--){             for(int j = i; j < n; j++){                 if(i == j){                     dp[i][j] = 1;                 }else if(s.charAt(i) != s.charAt(j)){                     dp[i][j] = (dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]) % mod;                     if(dp[i][j] < 0){                         dp[i][j] += mod; //taking modulo with negative numbers gives negative modulo, we need to handle it                     }                 }else{                     dp[i][j] = dp[i+1][j-1] % mod;                     int lo = i+1;                     int hi = j-1;                     while(lo <= hi && s.charAt(lo) != s.charAt(i)){                         lo++;                     }                     while(lo <= hi && s.charAt(hi) != s.charAt(i)){                         hi--;                     }                     if(lo > hi){                         dp[i][j] = (dp[i][j] + 2) % mod; // 2 new palindromes are found                     }else if(lo == hi){                         dp[i][j] = (dp[i][j] + 1) % mod; // 1 new palindrome is found - ""a"" from ""aba""                     }else {                         dp[i][j] = (dp[i][j] - dp[lo+1][hi-1] + mod) % mod; //dp[lo+1][hi-1] was added twice                      }                 }             }         }         return dp[0][n-1];     } }",1,"730-count-different-palindromic-subsequences/Solution.java:11:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",0,0,0
"import java.util.*;  class MyCalendarThree {     TreeMap<Integer, Integer> bookings;      public MyCalendarThree() {         bookings = new TreeMap<>();     }          public int book(int start, int end) {         bookings.put(start, bookings.getOrDefault(start, 0) + 1);         bookings.put(end, bookings.getOrDefault(end, 0) - 1);         int count = 0, maxCount = 0;         for (int k : bookings.values()) {             count += k;             if (count > maxCount) {                 maxCount = count;             }         }         return maxCount;     } }",1,"732-my-calendar-iii/MyCalendarThree.java:4:31: Variable 'bookings' must be private and have accessor methods. [VisibilityModifier]
732-my-calendar-iii/MyCalendarThree.java:6:5: Redundant 'public' modifier. [RedundantModifier]
732-my-calendar-iii/MyCalendarThree.java:13:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
732-my-calendar-iii/MyCalendarThree.java:4:	LooseCoupling:	Avoid using implementation types like 'TreeMap'; use the interface instead
",1,0,0
"import java.util.*;  class Solution {     public int evaluate(String expression) {          // Initialize the scope with empty map         Map<String, Integer> scope = new HashMap<>();          // Call the evaluate function on the expression with scope and depth of 0         return evaluate(expression, scope, 0);     }          // Recursive function to evaluate the expression     private int evaluate(String expression, Map<String, Integer> scope, int depth) {          // If the expression starts with '('         if (expression.charAt(0) == '(') {              // Remove the opeing and closing paranthesis             expression = expression.substring(1, expression.length() - 1);              // Create a list with tokens separated by space             List<String> tokens = parse(expression);              // Check if the first token is 'add' or 'mult'             if (tokens.get(0).equals(""add"")) {                 // Evaluate the first and second expressions and return their sum                 return evaluate(tokens.get(1), scope, depth + 1) + evaluate(tokens.get(2), scope, depth + 1);             } else if (tokens.get(0).equals(""mult"")) {                 // Evaluate the first and second expressions and return their product                 return evaluate(tokens.get(1), scope, depth + 1) * evaluate(tokens.get(2), scope, depth + 1);             } else if (tokens.get(0).equals(""let"")) {                 // Create a new scope and add the current scope as its parent                 Map<String, Integer> newScope = new HashMap<>();                 newScope.putAll(scope);                  // Evaluate each variable expression pair and store the result in the new scope                 for (int i = 1; i < tokens.size() - 2; i += 2) {                     newScope.put(tokens.get(i), evaluate(tokens.get(i + 1), newScope, depth + 1));                 }                  // Evaluate the final expression with the new scope and return the result                 return evaluate(tokens.get(tokens.size() - 1), newScope, depth + 1);             } else {                 // This is an expression containing an assigned variable.                 // Evaluate the expression and store the result in the current scope.                 String varName = tokens.get(0);                 int val = evaluate(tokens.get(1), scope, depth + 1);                 scope.put(varName, val);                 return val;             }         } else {             // If the expression is just an integer or a variable, return its value             if (Character.isDigit(expression.charAt(0)) || expression.charAt(0) == '-') {                 // Return integer value                 return Integer.parseInt(expression);             } else {                 // Return variable value, start from current scope and check in outer scopes                 for (int i = depth; i >= 0; i--) {                     if (scope.containsKey(expression)) {                         return scope.get(expression);                     }                     scope = new HashMap<>(scope);                 }             }         }         return 0;     }          // Helper function to split the expression into tokens by space     private List<String> parse(String exp) {         List<String> tokens = new ArrayList<>();         int count = 0;         StringBuilder sb = new StringBuilder();         for (char c : exp.toCharArray()) {             if (c == '(') {                 count++;             } else if (c == ')') {                 count--;             }             if (count == 0 && c == ' ') {                 tokens.add(sb.toString());                 sb = new StringBuilder();             } else {                 sb.append(c);             }         }         if (sb.length() > 0) {             tokens.add(sb.toString());         }         return tokens;     } }",1,"736-parse-lisp-expression/Solution.java:7:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
736-parse-lisp-expression/Solution.java:20:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'expression'
736-parse-lisp-expression/Solution.java:26:	LiteralsFirstInComparisons:	Position literals first in String comparisons
736-parse-lisp-expression/Solution.java:29:	LiteralsFirstInComparisons:	Position literals first in String comparisons
736-parse-lisp-expression/Solution.java:32:	LiteralsFirstInComparisons:	Position literals first in String comparisons
736-parse-lisp-expression/Solution.java:34:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
736-parse-lisp-expression/Solution.java:63:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'scope'
",0,1,0
"class Solution {     public int cherryPickup(int[][] grid) {         int n = grid.length;         // dp table to store maximum cherries at each position         int[][] dp = new int[n][n];         // fill the dp table for the first row and first column         dp[0][0] = grid[0][0];         for (int i = 1; i < n; i++) {             dp[i][0] = dp[i-1][0] + grid[i][0];             dp[0][i] = dp[0][i-1] + grid[0][i];         }         // fill the rest of the dp table         for (int i = 1; i < n; i++) {             for (int j = 1; j < n; j++) {                 if (grid[i][j] == -1) {                     dp[i][j] = 0;                 } else {                     int max = Math.max(dp[i-1][j], dp[i][j-1]);                     dp[i][j] = max + grid[i][j];                 }             }         }         // if there is no valid path to (n-1,n-1), return 0         if (dp[n-1][n-1] == 0) {             return 0;         }         // reset the dp table and fill it in the opposite direction (from bottom right to top left)         dp[n-1][n-1] = 0;         for (int i = n-2; i >= 0; i--) {             for (int j = n-2; j >= 0; j--) {                 if (grid[i][j] == -1) {                     dp[i][j] = 0;                 } else {                     int max = Math.max(dp[i+1][j], dp[i][j+1]);                     dp[i][j] += max + grid[i][j];                 }             }         }         return dp[0][0];     } }",0,,0,0,0
"class WordFilter {     Map<String, Integer> map;     public WordFilter(String[] words) {         map = new HashMap<>();         for (int i = 0; i < words.length; i++) {             String word = words[i];             for (int j = 0; j <= word.length(); j++) {                 for (int k = 0; k <= word.length(); k++) {                     String key = word.substring(0, j) + ""#"" + word.substring(word.length()-k);                     map.put(key, i);                 }             }         }     }          public int f(String pref, String suff) {         String key = pref + ""#"" + suff;         if (map.containsKey(key)) return map.get(key);         return -1;     } }  /**  * Your WordFilter object will be instantiated and called as such:  * WordFilter obj = new WordFilter(words);  * int param_1 = obj.f(pref,suff);  */",1,"745-prefix-and-suffix-search/WordFilter.java:2:26: Variable 'map' must be private and have accessor methods. [VisibilityModifier]
745-prefix-and-suffix-search/WordFilter.java:3:5: Redundant 'public' modifier. [RedundantModifier]
745-prefix-and-suffix-search/WordFilter.java:16:	ShortMethodName:	Avoid using short method names
",0,0,0
"class Solution {     int[][] dirs = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};      public int containVirus(int[][] isInfected) {         int m = isInfected.length;         int n = isInfected[0].length;         int walls = 0;         while (true) {             List<Map<Integer, List<int[]>>> regions = getVirusRegions(isInfected);             if (regions.isEmpty()) {                 break;             }             Map<Integer, List<int[]>> largestRegion = null;             int maxUninfected = 0;             for (Map<Integer, List<int[]>> region : regions) {                 int uninfected = getUninfectedCount(isInfected, region);                 if (uninfected > maxUninfected) {                     maxUninfected = uninfected;                     largestRegion = region;                 }             }             walls += installWalls(isInfected, largestRegion);             propagateVirus(isInfected);         }         return walls;     }      private List<Map<Integer, List<int[]>>> getVirusRegions(int[][] isInfected) {         int m = isInfected.length;         int n = isInfected[0].length;         List<Map<Integer, List<int[]>>> regions = new ArrayList<>();         boolean[][] visited = new boolean[m][n];         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 if (isInfected[i][j] == 1 && !visited[i][j]) {                     Map<Integer, List<int[]>> region = new HashMap<>();                     dfs(isInfected, i, j, region, visited);                     regions.add(region);                 }             }         }         return regions;     }      private void dfs(int[][] isInfected, int i, int j, Map<Integer, List<int[]>> region, boolean[][] visited) {         int m = isInfected.length;         int n = isInfected[0].length;         visited[i][j] = true;         int id = region.size();         if (!region.containsKey(id)) {             region.put(id, new ArrayList<>());         }         region.get(id).add(new int[]{i, j});         for (int[] dir : dirs) {             int ni = i + dir[0];             int nj = j + dir[1];             if (ni >= 0 && ni < m && nj >= 0 && nj < n && isInfected[ni][nj] == 1 && !visited[ni][nj]) {                 dfs(isInfected, ni, nj, region, visited);             }         }     }      private int getUninfectedCount(int[][] isInfected, Map<Integer, List<int[]>> region) {         int m = isInfected.length;         int n = isInfected[0].length;         Set<Integer> set = new HashSet<>();         for (List<int[]> subRegion : region.values()) {             for (int[] pos : subRegion) {                 int i = pos[0];                 int j = pos[1];                 for (int[] dir : dirs) {                     int ni = i + dir[0];                     int nj = j + dir[1];                     if (ni >= 0 && ni < m && nj >= 0 && nj < n && isInfected[ni][nj] == 0) {                         int index = ni * n + nj;                         set.add(index);                     }                 }             }         }         return set.size();     }      private int installWalls(int[][] isInfected, Map<Integer, List<int[]>> region) {         int m = isInfected.length;         int n = isInfected[0].length;         Set<Integer> set = new HashSet<>();         for (List<int[]> subRegion : region.values()) {             for (int[] pos : subRegion) {                 int i = pos[0];                 int j = pos[1];                 for (int[] dir : dirs) {                     int ni = i + dir[0];                     int nj = j + dir[1];                     if (ni >= 0 && ni < m && nj >= 0 && nj < n && isInfected[ni][nj] == 0) {                         int index = ni * n + nj;                         set.add(index);                     }                 }             }         }         for (int index : set) {             int i = index / n;             int j = index % n;             isInfected[i][j] = -1;         }         return set.size();     }      private void propagateVirus(int[][] isInfected) {         int m = isInfected.length;         int n = isInfected[0].length;         int[][] temp = new int[m][n];         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 temp[i][j] = isInfected[i][j];             }         }         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 if (isInfected[i][j] == 1) {                     for (int[] dir : dirs) {                         int ni = i + dir[0];                         int nj = j + dir[1];                         if (ni >= 0 && ni < m && nj >= 0 && nj < n && isInfected[ni][nj] == 0) {                             temp[ni][nj] = 1;                         }                     }                 }             }         }         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 if (temp[i][j] == -1) {                     isInfected[i][j] = 0;                 } else {                     isInfected[i][j] = temp[i][j];                 }             }         }     } }",1,"749-contain-virus/Solution.java:2:13: Variable 'dirs' must be private and have accessor methods. [VisibilityModifier]
749-contain-virus/Solution.java:5:	UnusedLocalVariable:	Avoid unused local variables such as 'm'.
749-contain-virus/Solution.java:6:	UnusedLocalVariable:	Avoid unused local variables such as 'n'.
",0,0,0
"class Solution {     public String crackSafe(int n, int k) {         StringBuilder sb = new StringBuilder();         int totalPasswords = (int) Math.pow(k, n); // total possible passwords                  // Create set to keep track of visited passwords         Set<String> visited = new HashSet<>();         for (int i = 0; i < n; i++) {             sb.append(""0""); // initialize with all zeros         }         visited.add(sb.toString());                  dfs(sb, visited, totalPasswords, n, k);         return sb.toString();     }          private boolean dfs(StringBuilder sb, Set<String> visited, int totalPasswords, int n, int k) {         if (visited.size() == totalPasswords) {             return true; // all passwords have been visited         }                  // get the last n-1 digits of the current combination         String prevComb = sb.substring(sb.length() - n + 1);                  // try all possible next digits         for (int i = 0; i < k; i++) {             String newComb = prevComb + i;             // check if this combination has already been visited             if (!visited.contains(newComb)) {                 visited.add(newComb);                 sb.append(i);                 if (dfs(sb, visited, totalPasswords, n, k)) {                     return true; // found a solution                 }                 visited.remove(newComb);                 sb.deleteCharAt(sb.length() - 1);             }         }         return false;     } }",1,"753-cracking-the-safe/Solution.java:9:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
",0,0,0
"class Solution {     public int intersectionSizeTwo(int[][] intervals) {         Arrays.sort(intervals, (a, b) -> a[1] != b[1] ? a[1] - b[1] : b[0] - a[0]); // Sort intervals based on the ending point in increasing order, if multiple intervals have the same ending point, then sort them based on their starting point in decreasing order.          int count = 0;         int p1 = -1; // Last index of the containing set         int p2 = -1; // Second last index of the containing set                  for (int[] interval : intervals) {             int start = interval[0];             int end = interval[1];              if (p1 < start) { // If the current interval doesn't intersect with any previous intervals                 count += 2; // Add two new numbers to the containing set                 p2 = end - 1;                 p1 = end;             } else if (p2 < start) { // If the current interval only intersects with the last number of the containing set                 count++;                 p2 = p1;                 p1 = end;             }         }          return count;     } }",1,"757-set-intersection-size-at-least-two/Solution.java:3:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",0,0,0
"class Solution {     public int intersectionSizeTwo(int[][] intervals) {         Arrays.sort(intervals, (a, b) -> a[1] != b[1] ? a[1] - b[1] : b[0] - a[0]); // Sort intervals based on the ending point in increasing order, if multiple intervals have the same ending point, then sort them based on their starting point in decreasing order.          int count = 0;         int p1 = -1; // Last index of the containing set         int p2 = -1; // Second last index of the containing set                  for (int[] interval : intervals) {             int start = interval[0];             int end = interval[1];              if (p1 < start) { // If the current interval doesn't intersect with any previous intervals                 count += 2; // Add two new numbers to the containing set                 p2 = end - 1;                 p1 = end;             } else if (p2 < start) { // If the current interval only intersects with the last number of the containing set                 count++;                 p2 = p1;                 p1 = end;             }         }          return count;     } }",0,,0,0,0
"class Solution {          public int minSwapsCouples(int[] row) {         int n = row.length;         int ans = 0;         for (int i = 0; i < n; i += 2) {             int pair = findPartner(row[i]);             if (row[i + 1] != pair) {                 swap(row, i + 1, indexOf(row, pair));                 ans++;             }         }         return ans;     }          private int findPartner(int x) {         return x % 2 == 0 ? x + 1 : x - 1;     }          private void swap(int[] row, int i, int j) {         int temp = row[i];         row[i] = row[j];         row[j] = temp;     }          private int indexOf(int[] row, int x) {         for (int i = 0; i < row.length; i++) {             if (row[i] == x) {                 return i;             }         }         return -1;     } }",0,,0,0,0
"class Solution {     public int maxChunksToSorted(int[] arr) {         int ans = 0;         int max = 0;         for(int i = 0; i < arr.length; i++){             max = Math.max(max, arr[i]);             if(max == i) ans++;          }         return ans;     } }",0,,0,0,0
"import java.util.*;  class Solution {     public List<String> basicCalculatorIV(String expression, String[] evalvars, int[] evalints) {         // Create a map to store the variable values         Map<String, Integer> evalMap = new HashMap<>();         for (int i = 0; i < evalvars.length; i++) {             evalMap.put(evalvars[i], evalints[i]);         }         // Evaluate the expression         Map<List<String>, Integer> resMap = evaluateExpression(expression, evalMap);         // Convert the result map to a list of strings         List<String> resList = new ArrayList<>();         for (List<String> term : sortTerms(resMap)) {             int coeff = resMap.get(term);             if (coeff == 0) {                 continue;             }             StringBuilder sb = new StringBuilder();             sb.append(coeff);             for (String var : term) {                 sb.append(""*"").append(var);             }             resList.add(sb.toString());         }         return resList;     }      private Map<List<String>, Integer> evaluateExpression(String expression, Map<String, Integer> evalMap) {         List<String> tokens = parseExpression(expression);         Deque<Map<List<String>, Integer>> stack = new ArrayDeque<>();         stack.push(new HashMap<>());         stack.peek().put(Collections.emptyList(), 1);         char prevOp = '+';         for (String token : tokens) {             if (token.equals(""("")) {                 stack.push(new HashMap<>());                 stack.peek().put(Collections.emptyList(), 1);                 prevOp = '+';             } else if (token.equals("")"")) {                 Map<List<String>, Integer> termMap = stack.pop();                 evaluateTerm(termMap, stack.peek(), prevOp);                 prevOp = '+';             } else if (token.equals(""+"") || token.equals(""-"") || token.equals(""*"")) {                 prevOp = token.charAt(0);             } else {                 Map<List<String>, Integer> termMap = new HashMap<>();                 List<String> vars = new ArrayList<>();                 int val = 0;                 if (Character.isDigit(token.charAt(0))) {                     val = Integer.parseInt(token);                     termMap.put(Collections.emptyList(), val);                 } else {                     vars.add(token);                     val = evalMap.getOrDefault(token, 0);                     if (val != 0) {                         termMap.put(vars, val);                     }                 }                 evaluateTerm(termMap, stack.peek(), prevOp);                 prevOp = '+';             }         }         return stack.peek();     }      private List<String> parseExpression(String expression) {         List<String> tokens = new ArrayList<>();         int i = 0;         while (i < expression.length()) {             char c = expression.charAt(i);             if (c == '+' || c == '-' || c == '*' || c == '(' || c == ')') {                 tokens.add(Character.toString(c));                 i++;             } else if (Character.isDigit(c)) {                 int j = i;                 while (j < expression.length() && Character.isDigit(expression.charAt(j))) {                     j++;                 }                 tokens.add(expression.substring(i, j));                 i = j;             } else if (Character.isLetter(c)) {                 int j = i;                 while (j < expression.length() && Character.isLetter(expression.charAt(j))) {                     j++;                 }                 tokens.add(expression.substring(i, j));                 i = j;             } else {                 i++;             }         }         return tokens;     }      private void evaluateTerm(Map<List<String>, Integer> termMap, Map<List<String>, Integer> resMap, char op) {         if (op == '+') {             for (List<String> term : termMap.keySet()) {                 resMap.put(term, resMap.getOrDefault(term, 0) + termMap.get(term));             }         } else if (op == '-') {             for (List<String> term : termMap.keySet()) {                 resMap.put(term, resMap.getOrDefault(term, 0) - termMap.get(term));             }         } else { // op == '*'             Map<List<String>, Integer> newTermMap = new HashMap<>();             for (List<String> term1 : resMap.keySet()) {                 for (List<String> term2 : termMap.keySet()) {                     List<String> newTerm = new ArrayList<>(term1);                     newTerm.addAll(term2);                     Collections.sort(newTerm);                     int coeff = resMap.get(term1) * termMap.get(term2);                     newTermMap.put(newTerm, newTermMap.getOrDefault(newTerm, 0) + coeff);                 }             }             resMap.clear();             for (List<String> term : newTermMap.keySet()) {                 int coeff = newTermMap.get(term);                 if (coeff != 0) {                     resMap.put(term, coeff);                 }             }         }     }      private List<List<String>> sortTerms(Map<List<String>, Integer> termMap) {         List<List<String>> terms = new ArrayList<>(termMap.keySet());         Collections.sort(terms, new Comparator<List<String>>() {             public int compare(List<String> term1, List<String> term2) {                 if (term1.size() != term2.size()) {                     return term2.size() - term1.size();                 } else {                     for (int i = 0; i < term1.size(); i++) {                         if (!term1.get(i).equals(term2.get(i))) {                             return term1.get(i).compareTo(term2.get(i));                         }                     }                     return 0;                 }             }         });         return terms;     } } ",1,"770-basic-calculator-iv/Solution.java:6:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
770-basic-calculator-iv/Solution.java:22:	AppendCharacterWithChar:	Avoid appending characters as strings in StringBuffer.append.
770-basic-calculator-iv/Solution.java:36:	LiteralsFirstInComparisons:	Position literals first in String comparisons
770-basic-calculator-iv/Solution.java:40:	LiteralsFirstInComparisons:	Position literals first in String comparisons
770-basic-calculator-iv/Solution.java:44:	LiteralsFirstInComparisons:	Position literals first in String comparisons
770-basic-calculator-iv/Solution.java:44:	LiteralsFirstInComparisons:	Position literals first in String comparisons
770-basic-calculator-iv/Solution.java:44:	LiteralsFirstInComparisons:	Position literals first in String comparisons
770-basic-calculator-iv/Solution.java:47:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
770-basic-calculator-iv/Solution.java:49:	UnusedAssignment:	The initializer for variable 'val' is never used (overwritten on lines 51 and 55)
770-basic-calculator-iv/Solution.java:106:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
770-basic-calculator-iv/Solution.java:128:	UseDiamondOperator:	Explicit type arguments can be replaced by a diamond: `new Comparator<>()`
770-basic-calculator-iv/Solution.java:129:	MissingOverride:	The method 'compare(List<String>, List<String>)' is missing an @Override annotation.
770-basic-calculator-iv/Solution.java:130:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",0,0,0
"class Solution {     public int slidingPuzzle(int[][] board) {         int[][] moves = new int[][]{{1,3},{0,2,4},{1,5},{0,4},{1,3,5},{2,4}};         String target = ""123450"";         String initial = """";         for(int i=0; i<2; i++){             for(int j=0; j<3; j++){                 initial += board[i][j];             }         }         Queue<String> q = new LinkedList<>();         HashSet<String> visited = new HashSet<>();         q.add(initial);         visited.add(initial);         int movesCount = 0;         while(!q.isEmpty()){             int size = q.size();             for(int i=0; i<size; i++){                 String curr = q.poll();                 if(curr.equals(target)) return movesCount;                 int index = curr.indexOf('0');                 for(int j=0; j<moves[index].length; j++){                     String next = swap(curr, index, moves[index][j]);                     if(!visited.contains(next)){                         q.offer(next);                         visited.add(next);                     }                 }             }             movesCount++;         }         return -1;     }          private String swap(String str, int i, int j){         StringBuilder sb = new StringBuilder(str);         sb.setCharAt(i, str.charAt(j));         sb.setCharAt(j, str.charAt(i));         return sb.toString();     } }",1,"773-sliding-puzzle/Solution.java:8:	UseStringBufferForStringAppends:	Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings
",0,0,0
"class Solution {     public int swimInWater(int[][] grid) {         int n = grid.length;          // define the directions         int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};          // initialize the queue for BFS         Queue<int[]> queue = new PriorityQueue<>((a, b) -> (grid[a[0]][a[1]] - grid[b[0]][b[1]]));         queue.offer(new int[]{0, 0});          // initialize the visited array         boolean[][] visited = new boolean[n][n];         visited[0][0] = true;          int maxElevation = 0;         while (!queue.isEmpty()) {             int[] curr = queue.poll();             int row = curr[0];             int col = curr[1];              // update the max elevation seen so far             maxElevation = Math.max(maxElevation, grid[row][col]);              // check if we have reached the bottom right corner             if (row == n - 1 && col == n - 1) {                 return maxElevation;             }              // explore the 4-directionally adjacent squares             for (int[] dir : directions) {                 int newRow = row + dir[0];                 int newCol = col + dir[1];                  // check if the square is within the boundaries of the grid                 if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && !visited[newRow][newCol]) {                      // check if the elevation of the square is less than or equal to the max elevation seen so far                     if (grid[newRow][newCol] <= maxElevation) {                         queue.offer(new int[]{newRow, newCol});                         visited[newRow][newCol] = true;                     }                 }             }         }          return -1; // if we cannot reach the bottom right corner     } }",1,"778-swim-in-rising-water/Solution.java:9:	UselessParentheses:	Useless parentheses.
778-swim-in-rising-water/Solution.java:39:	CollapsibleIfStatements:	This if statement could be combined with its parent
",0,0,0
"class Solution {     public boolean reachingPoints(int sx, int sy, int tx, int ty) {         while(tx>=sx && ty>=sy) {             if (tx == ty) break;             if(tx>ty){                 if(ty>sy) tx = tx%ty;                 else return (tx - sx) % ty == 0;             }             else{                 if(tx>sx) ty = ty%tx;                 else return (ty - sy) % tx == 0;             }         }         return (tx == sx && ty == sy);     } }",1,"780-reaching-points/Solution.java:8:13: '}' at column 13 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
780-reaching-points/Solution.java:6:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'tx'
780-reaching-points/Solution.java:10:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'ty'
780-reaching-points/Solution.java:14:	UselessParentheses:	Useless parentheses.
",0,1,0
"class Solution {     public int movesToChessboard(int[][] board) {         int n = board.length;                  // Check if board can be a valid chessboard         int rowSum = 0, colSum = 0, rowSwap = 0, colSwap = 0;         for (int i = 0; i < n; i++) {             for (int j = 0; j < n; j++) {                 if ((board[0][0]^board[0][j]^board[i][0]^board[i][j]) == 1) {                     return -1;                 }             }         }         for (int i = 0; i < n; i++) {             rowSum += board[0][i];             colSum += board[i][0];             if (board[i][0] == i % 2) {                 rowSwap++;             }             if (board[0][i] == i % 2) {                 colSwap++;             }         }         if (rowSum != n/2 && rowSum != (n+1)/2) {             return -1;         }         if (colSum != n/2 && colSum != (n+1)/2) {             return -1;         }         if (n % 2 == 1) {             if (colSwap % 2 == 1) {                 colSwap = n - colSwap;             }             if (rowSwap % 2 == 1) {                 rowSwap = n - rowSwap;             }         } else {             colSwap = Math.min(n - colSwap, colSwap);             rowSwap = Math.min(n - rowSwap, rowSwap);         }         return (colSwap + rowSwap) / 2;     } }",1,"782-transform-to-chessboard/Solution.java:6:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
782-transform-to-chessboard/Solution.java:2:	NPathComplexity:	The method 'movesToChessboard(int[][])' has an NPath complexity of 900, current threshold is 200
782-transform-to-chessboard/Solution.java:6:	PrematureDeclaration:	Declaration of 'colSum' can be moved closer to its usages
782-transform-to-chessboard/Solution.java:6:	PrematureDeclaration:	Declaration of 'colSwap' can be moved closer to its usages
782-transform-to-chessboard/Solution.java:6:	PrematureDeclaration:	Declaration of 'rowSum' can be moved closer to its usages
782-transform-to-chessboard/Solution.java:6:	PrematureDeclaration:	Declaration of 'rowSwap' can be moved closer to its usages
",1,0,0
"class Solution {     public int preimageSizeFZF(int k) {         long lo = 0, hi = 5L * (k + 1); // use long to avoid integer overflow         while (lo <= hi) {             long mid = lo + (hi - lo) / 2;             int numTrailingZeros = countTrailingZeros(mid);             if (numTrailingZeros < k) {                 lo = mid + 1;             } else if (numTrailingZeros > k) {                 hi = mid - 1;             } else {                 return 5;             }         }         return 0;     }      // helper method to count the number of trailing zeros in n!     private int countTrailingZeros(long n) {         int count = 0;         for (long i = 5; n / i >= 1; i *= 5) {             count += n / i;         }         return count;     } }",1,"793-preimage-size-of-factorial-zeroes-function/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
class Solution {     public int bestRotation(int[] nums) {         int n = nums.length;         int[] bad = new int[n];         for (int i = 0; i < n; ++i) {             int left = (i - nums[i] + 1 + n) % n;             int right = i + 1;             bad[left] -= 1;             bad[right] += 1;             if (left > right) {                 bad[0] -= 1;             }         }         int bestScore = -n;         int ans = 0;         int score = 0;         for (int i = 0; i < n; ++i) {             score += bad[i];             if (score > bestScore) {                 bestScore = score;                 ans = i;             }         }         return ans;     } },0,,0,0,0
"class Solution {     public int minSwap(int[] nums1, int[] nums2) {         int n = nums1.length;         int[] swap = new int[n]; // minimum number of swaps to make nums1 and nums2 strictly increasing if ith element is swapped         int[] keep = new int[n]; // minimum number of swaps to make nums1 and nums2 strictly increasing if ith element is kept                  // initialize arrays         Arrays.fill(swap, n);         Arrays.fill(keep, n);         swap[0] = 1;         keep[0] = 0;                  // loop through arrays starting at index 1         for (int i = 1; i < n; i++) {             // case 1: both nums1 and nums2 are strictly increasing if ith element is swapped             if (nums1[i] > nums2[i-1] && nums2[i] > nums1[i-1]) {                 swap[i] = swap[i-1] + 1;                 keep[i] = keep[i-1];             }             // case 2: both nums1 and nums2 are strictly increasing if ith element is kept             if (nums1[i] > nums1[i-1] && nums2[i] > nums2[i-1]) {                 keep[i] = Math.min(keep[i], keep[i-1]);                 swap[i] = Math.min(swap[i], swap[i-1] + 1);             }         }                  return Math.min(keep[n-1], swap[n-1]); // return the minimum number of swaps needed     } }",1,"801-minimum-swaps-to-make-sequences-increasing/Solution.java:14:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
",0,0,0
"import java.util.Arrays;  class Solution {     int n, m;     final int[][] DIRECTIONS = {{1,0}, {-1,0}, {0,1}, {0,-1}};      public int[] hitBricks(int[][] grid, int[][] hits) {         n = grid.length;         m = grid[0].length;          int[][] copy = new int[n][m];         for (int i = 0; i < n; i++) {             copy[i] = Arrays.copyOf(grid[i], m);         }          // marking non-hit bricks as initially connected to the top         for (int[] hit : hits) {             copy[hit[0]][hit[1]] = 0;         }         for (int i = 0; i < m; i++) {             dfs(copy, 0, i);         }          int[] result = new int[hits.length];         for (int i = hits.length - 1; i >= 0; i--) {             int x = hits[i][0], y = hits[i][1];             if (grid[x][y] == 0) {                 continue;             }             grid[x][y] = 0;             if (!isConnectedToTop(copy, x, y)) {                 result[i] = 0;                 continue;             }             for (int[] direction : DIRECTIONS) {                 int newX = x + direction[0], newY = y + direction[1];                 if (newX >= 0 && newX < n && newY >= 0 && newY < m) {                     if (copy[newX][newY] > 0 && isConnectedToTop(copy, newX, newY)) {                         dfs(grid, newX, newY);                     }                 }             }             result[i] = countDisconnected(copy, x, y) - 1;         }         return result;     }      private boolean isConnectedToTop(int[][] grid, int i, int j) {         if (i == 0) {             return true;         }         for (int[] direction : DIRECTIONS) {             int newI = i + direction[0], newJ = j + direction[1];             if (newI >= 0 && newI < n && newJ >= 0 && newJ < m && grid[newI][newJ] == 2) {                 return true;             }         }         return false;     }      private int countDisconnected(int[][] grid, int i, int j) {         if (i < 0 || i >= n || j < 0 || j >= m || grid[i][j] != 1) {             return 0;         }         grid[i][j] = 2;         return 1 + countDisconnected(grid, i - 1, j) + countDisconnected(grid, i + 1, j)                 + countDisconnected(grid, i, j - 1) + countDisconnected(grid, i, j + 1);     }      private void dfs(int[][] grid, int i, int j) {         if (i < 0 || i >= n || j < 0 || j >= m || grid[i][j] != 1) {             return;         }         grid[i][j] = 2;         for (int[] direction : DIRECTIONS) {             dfs(grid, i + direction[0], j + direction[1]);         }     } }",1,"803-bricks-falling-when-hit/Solution.java:4:5: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
803-bricks-falling-when-hit/Solution.java:4:9: Variable 'n' must be private and have accessor methods. [VisibilityModifier]
803-bricks-falling-when-hit/Solution.java:4:12: Variable 'm' must be private and have accessor methods. [VisibilityModifier]
803-bricks-falling-when-hit/Solution.java:5:19: Variable 'DIRECTIONS' must be private and have accessor methods. [VisibilityModifier]
803-bricks-falling-when-hit/Solution.java:26:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
803-bricks-falling-when-hit/Solution.java:36:17: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
803-bricks-falling-when-hit/Solution.java:53:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
803-bricks-falling-when-hit/Solution.java:7:	NPathComplexity:	The method 'hitBricks(int[][], int[][])' has an NPath complexity of 264, current threshold is 200
803-bricks-falling-when-hit/Solution.java:38:	CollapsibleIfStatements:	This if statement could be combined with its parent
",1,0,0
"class Solution {     public boolean splitArraySameAverage(int[] nums) {         int n = nums.length;         if (n == 1) {  // if only 1 element, it is not possible to split             return false;         }         int sum = 0; // finding sum of all elements         for (int num : nums) {             sum += num;         }         Arrays.sort(nums); // sorting the array in ascending order         for (int lenA = 1; lenA <= n / 2; lenA++) { // iterating through all possible lengths of array A             if (sum * lenA % n != 0) { // if sum * lenA is not divisible by n, then it is not possible to split the array                 continue;             }             int target = sum * lenA / n; // finding the target average value             if (knapsack(nums, target, lenA, n)) { // calling knapsack function to check if it is possible to achieve target in array A                 return true;             }         }         return false;     }          private boolean knapsack(int[] nums, int target, int lenA, int n) {         boolean[][] dp = new boolean[lenA + 1][target + 1]; // initializing dp array         dp[0][0] = true;         for (int i = 0; i < n; i++) {             for (int j = lenA; j >= 1; j--) {                 for (int k = target; k >= nums[i]; k--) {                     dp[j][k] |= dp[j - 1][k - nums[i]]; // updating dp array                 }             }         }         for (int i = 1; i <= lenA; i++) { // checking if there exists a subset with lenA elements whose sum is equal to target             if (target * i % n == 0 && dp[i][target * i / n]) {                 return true;             }         }         return false;     } }",0,,0,0,0
class Solution {     public boolean xorGame(int[] nums) {         int xor = 0;         for (int num : nums) {             xor ^= num;         }         return xor == 0 || nums.length % 2 == 0;     } },0,,0,0,0
"class Solution {     public int numBusesToDestination(int[][] routes, int source, int target) {         // Create a map where the key is the bus stop and the value is a list of bus routes it belongs to         Map<Integer, List<Integer>> map = new HashMap<>();         for (int i = 0; i < routes.length; i++) {             for (int j = 0; j < routes[i].length; j++) {                 if (!map.containsKey(routes[i][j])) {                     map.put(routes[i][j], new ArrayList<>());                 }                 map.get(routes[i][j]).add(i);             }         }                  // Create a boolean array to keep track of the bus routes visited         boolean[] visited = new boolean[routes.length];                  // Create a queue to perform BFS         Queue<Integer> queue = new LinkedList<>();         queue.offer(source);                  // Create a variable to keep track of the number of buses taken         int count = 0;                  while (!queue.isEmpty()) {             int size = queue.size();                          while (size-- > 0) {                 int curr = queue.poll();                                  // If we have reached the target bus stop, return the number of buses taken                 if (curr == target) {                     return count;                 }                                  // Get the list of bus routes that pass through the current bus stop                 List<Integer> buses = map.get(curr);                                  // Visit all the bus routes that pass through the current bus stop                 for (int bus : buses) {                     if (visited[bus]) {                         continue;                     }                     visited[bus] = true;                                          // Add all the bus stops in the current bus route to the queue                     for (int i = 0; i < routes[bus].length; i++) {                         queue.offer(routes[bus][i]);                     }                 }             }                          // Increment the number of buses taken for every level in BFS             count++;         }                  return -1; // If we couldn't reach the target bus stop, return -1     } }",0,,0,0,0
"class Solution {     public int racecar(int target) {         Set<String> visited = new HashSet<>();         Queue<int[]> queue = new LinkedList<>();         queue.offer(new int[]{0, 1}); //initial position and speed         visited.add(""0-1"");         int steps = 0;                  while (!queue.isEmpty()){             int size = queue.size();             for (int i = 0; i < size; i++){                 int[] cur = queue.poll();                 int pos = cur[0];                 int speed = cur[1];                                  if (pos == target) return steps;                                  String key = pos + ""-"" + speed;                 //instruction A                 int newPos = pos + speed;                 int newSpeed = speed * 2;                 String newKey = newPos + ""-"" + newSpeed;                 if (!visited.contains(newKey) && newPos > 0 && newPos < 2 * target){                     visited.add(newKey);                     queue.offer(new int[]{newPos, newSpeed});                 }                                  //instruction R                 int newSpeed2 = speed > 0 ? -1 : 1;                 String newKey2 = pos + ""-"" + newSpeed2;                 if (!visited.contains(newKey2) && pos > 0 && pos < 2 * target){                     visited.add(newKey2);                     queue.offer(new int[]{pos, newSpeed2});                 }             }             steps++;         }         return -1; //no answer found     } }",1,"818-race-car/Solution.java:14:	PrematureDeclaration:	Declaration of 'speed' can be moved closer to its usages
818-race-car/Solution.java:18:	UnusedLocalVariable:	Avoid unused local variables such as 'key'.
",0,0,0
"class Solution {     public int largestIsland(int[][] grid) {         int rows = grid.length;         int cols = grid[0].length;         int maxArea = 0;         boolean hasZero = false;          // Case 1: If the grid has all 1's and no 0's         // the max size of island will be equal to the total number of cells         // in the grid         boolean[][] visited = new boolean[rows][cols];         for (int i = 0; i < rows; i++) {             for (int j = 0; j < cols; j++) {                 if (grid[i][j] == 1 && !visited[i][j]) {                     int area = dfs(grid, visited, i, j);                     maxArea = Math.max(maxArea, area);                 }                 if (grid[i][j] == 0) {                     hasZero = true;                 }             }         }         if (!hasZero) {             return maxArea;         }          // Case 2: If the grid has atleast one 0, then we try to flip it to 1         // and calculate the max size of island possible with one 0 flip         for (int i = 0; i < rows; i++) {             for (int j = 0; j < cols; j++) {                 if (grid[i][j] == 0) {                     grid[i][j] = 1;                     visited = new boolean[rows][cols];                     int area = dfs(grid, visited, i, j);                     maxArea = Math.max(maxArea, area);                     grid[i][j] = 0;                     hasZero = true;                 }             }         }          // Case 3: If there is no 0 in the grid, then max size of island         // will be equal to the size of the grid         if (!hasZero) {             return rows * cols;         }          return maxArea;     }      private int dfs(int[][] grid, boolean[][] visited, int i, int j) {         if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || visited[i][j] || grid[i][j] == 0) {             return 0;         }         visited[i][j] = true;         return 1 + dfs(grid, visited, i - 1, j) + dfs(grid, visited, i + 1, j)                 + dfs(grid, visited, i, j - 1) + dfs(grid, visited, i, j + 1);     } }",0,,0,0,0
"class Solution {     public int countUniqueChars(String s) {         int[] count = new int[26];         int res = 0, sum = 0;         for (int i = 0; i < s.length(); ++i) {             int c = s.charAt(i) - 'A';             res += (i - count[c]) * (sum - count[c]); // calculate the contribution of s[i]             sum += i + 1 - count[c]; // calculate the total number of substrings so far             count[c] = i + 1; // update the last valid position of c.         }         for (int i = 0; i < 26; ++i) {             res += (s.length() - count[i]) * (sum - count[i]); // calculate the contribution of the remaining characters         }         return res;     } }",1,"828-count-unique-characters-of-all-substrings-of-a-given-string/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
class Solution {     public int consecutiveNumbersSum(int n) {         int count = 0;         for (int start = 1; start <= n; start++) {             int sum = 0;             for (int j = start; j <= n; j++) {                 sum += j;                 if (sum == n) {                     count++;                     break;                 }                 if (sum > n) {                     break;                 }             }         }         return count;     } },0,,0,0,0
"class Solution {     int[] res, count;     List<List<Integer>> graph;     public int[] sumOfDistancesInTree(int n, int[][] edges) {         graph = new ArrayList<>();         res = new int[n];         count = new int[n];         for (int i = 0; i < n; ++i) {             graph.add(new ArrayList<>());         }         for (int[] edge : edges) {             graph.get(edge[0]).add(edge[1]);             graph.get(edge[1]).add(edge[0]);         }         dfs(0, -1);         dfs2(0, -1);         return res;     }     public void dfs(int node, int parent) {         for (int child : graph.get(node)) {             if (child != parent) {                 dfs(child, node);                 count[node] += count[child];                 res[node] += res[child] + count[child];             }         }         count[node]++;     }     public void dfs2(int node, int parent) {         for (int child : graph.get(node)) {             if (child != parent) {                 res[child] = res[node] - count[child] + count.length - count[child];                 dfs2(child, node);             }         }     } }",1,"834-sum-of-distances-in-tree/Solution.java:2:5: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
834-sum-of-distances-in-tree/Solution.java:2:11: Variable 'res' must be private and have accessor methods. [VisibilityModifier]
834-sum-of-distances-in-tree/Solution.java:2:16: Variable 'count' must be private and have accessor methods. [VisibilityModifier]
834-sum-of-distances-in-tree/Solution.java:3:25: Variable 'graph' must be private and have accessor methods. [VisibilityModifier]
834-sum-of-distances-in-tree/Solution.java:17:	MethodReturnsInternalArray:	Returning 'res' may expose an internal array.
",1,0,0
"class Solution {     public int numSimilarGroups(String[] strs) {         // Create a set to keep track of visited words         Set<String> visited = new HashSet<>();         // Initialize a count variable to keep track of groups         int count = 0;         // Loop through all words in the input array         for (String word : strs) {             // If the word has not been visited yet             if (!visited.contains(word)) {                 // Mark the word as visited                 visited.add(word);                 // Increment the count of groups                 count++;                 // Perform a depth-first search to find all similar words                 dfs(word, visited, strs);             }         }         // Return the final count of groups         return count;     }          private void dfs(String word, Set<String> visited, String[] strs) {         // Loop through all words in the input array         for (String next : strs) {             // If the next word has not been visited yet             if (!visited.contains(next)) {                 // Check if the next word is similar to the current word                 if (isSimilar(word, next)) {                     // Mark the next word as visited                     visited.add(next);                     // Perform a depth-first search on the next word                     dfs(next, visited, strs);                 }             }         }     }          private boolean isSimilar(String word1, String word2) {         // If the words are equal, they are similar         if (word1.equals(word2)) {             return true;         }         // If the words have different lengths, they are not similar         if (word1.length() != word2.length()) {             return false;         }         // Count the number of different characters in the words         int diffCount = 0;         for (int i = 0; i < word1.length(); i++) {             if (word1.charAt(i) != word2.charAt(i)) {                 diffCount++;             }         }         // If there are more than two differences, the words are not similar         if (diffCount > 2) {             return false;         }         // Otherwise, the words are similar         return true;     } } ",1,"839-similar-string-groups/Solution.java:29:	CollapsibleIfStatements:	This if statement could be combined with its parent
839-similar-string-groups/Solution.java:56:	SimplifyBooleanReturns:	This if statement can be replaced by `return !{condition};`
",0,0,0
"/**  * // This is the Master's API interface.  * // You should not implement it, or speculate about its implementation  * interface Master {  *     public int guess(String word) {}  * }  */ class Solution {     public void findSecretWord(String[] words, Master master) {         int allowedGuesses = 10;          while (allowedGuesses > 0) {             // Pick a random word from the remaining words             String guessWord = words[(int)(Math.random() * words.length)];              // Ask the master for the count of matching characters             int matchCount = master.guess(guessWord);              // If the guess is correct, we're done             if (matchCount == guessWord.length()) {                 return;             }              // Filter out words that don't have the same number of matches as the guess             List<String> possibleWords = new ArrayList<>();             for (String word : words) {                 if (getMatchCount(guessWord, word) == matchCount) {                     possibleWords.add(word);                 }             }              // Reduce the set of possible words in the next iteration             words = possibleWords.toArray(new String[0]);              allowedGuesses--;         }          // If we reach this point, we have taken too many guesses         System.out.println(""Either you took too many guesses, or you did not find the secret word."");     }      // Helper function to count the number of matching characters in two words     private int getMatchCount(String word1, String word2) {         int count = 0;         for (int i = 0; i < word1.length(); i++) {             if (word1.charAt(i) == word2.charAt(i)) {                 count++;             }         }         return count;     } }",1,"843-guess-the-word/Solution.java:33:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'words'
",0,1,0
"import java.util.*;  class Solution {     public int shortestPathLength(int[][] graph) {         int n = graph.length;         // Use a bitmask to keep track of the nodes we've visited so far         // The state is (current node, bitmask of visited nodes)         Queue<int[]> queue = new LinkedList<>();         Set<String> visited = new HashSet<>();         for (int i = 0; i < n; i++) {             queue.offer(new int[]{i, 1 << i, 0});             visited.add(i + ""|"" + (1 << i));         }         while (!queue.isEmpty()) {             int[] curr = queue.poll();             int node = curr[0];             int state = curr[1];             int steps = curr[2];             if (state == (1 << n) - 1) { // Visited all nodes                 return steps;             }             for (int neighbor : graph[node]) {                 int nextState = state | (1 << neighbor);                 String key = neighbor + ""|"" + nextState;                 if (visited.contains(key)) {                     continue;                 }                 visited.add(key);                 queue.offer(new int[]{neighbor, nextState, steps + 1});             }         }         return -1; // Should never happen since the graph is connected     } }",1,"847-shortest-path-visiting-all-nodes/Solution.java:16:	PrematureDeclaration:	Declaration of 'node' can be moved closer to its usages
",0,0,0
"class Solution {     public int rectangleArea(int[][] rectangles) {         // Constant for modular arithmetic         int MOD = 1_000_000_007;                  // Storing all x-coordinates and y-coordinates separately         Set<Integer> xSet = new HashSet<>();         Set<Integer> ySet = new HashSet<>();                  for (int[] rectangle : rectangles) {             xSet.add(rectangle[0]);             xSet.add(rectangle[2]);             ySet.add(rectangle[1]);             ySet.add(rectangle[3]);         }                  // Storing all distinct x-coordinates and y-coordinates in sorted order         List<Integer> xList = new ArrayList<>(xSet);         List<Integer> yList = new ArrayList<>(ySet);         Collections.sort(xList);         Collections.sort(yList);                  // Mapping all x-coordinates and y-coordinates to indices         Map<Integer, Integer> xIndexMap = new HashMap<>();         Map<Integer, Integer> yIndexMap = new HashMap<>();         int xIndex = 0;         int yIndex = 0;         for (int x : xList) {             xIndexMap.put(x, xIndex++);         }         for (int y : yList) {             yIndexMap.put(y, yIndex++);         }                  // Initializing a 2D boolean array to mark the occupied areas         boolean[][] occupied = new boolean[xIndexMap.size()][yIndexMap.size()];                  // Marking the occupied areas         for (int[] rectangle : rectangles) {             for (int x = xIndexMap.get(rectangle[0]); x < xIndexMap.get(rectangle[2]); x++) {                 for (int y = yIndexMap.get(rectangle[1]); y < yIndexMap.get(rectangle[3]); y++) {                     occupied[x][y] = true;                 }             }         }                  // Calculating the total area         long totalArea = 0;         for (int x = 0; x < xIndexMap.size(); x++) {             for (int y = 0; y < yIndexMap.size(); y++) {                 if (occupied[x][y]) {                     long cellArea = (long) (xList.get(x + 1) - xList.get(x)) * (yList.get(y + 1) - yList.get(y));                     totalArea += cellArea;                 }             }         }                  return (int) (totalArea % MOD);     } }",0,,0,0,0
"import java.util.*;  class Solution {     public int kSimilarity(String s1, String s2) {         if (s1.equals(s2)) return 0;                  Queue<String> queue = new LinkedList<>();         Set<String> visited = new HashSet<>();                  queue.offer(s1);         visited.add(s1);                          int k = 0;         while (!queue.isEmpty()) {             int size = queue.size();             for (int i = 0; i < size; i++) {                 String curr = queue.poll();                                  if (curr.equals(s2)) return k;                                  int j = 0;                 while (curr.charAt(j) == s2.charAt(j)) j++;                                  for (int p = j + 1; p < curr.length(); p++) {                     if (curr.charAt(p) == s2.charAt(j) && curr.charAt(p) != s2.charAt(p)) {                         String next = swap(curr, j, p);                                                  if (!visited.contains(next)) {                             queue.offer(next);                             visited.add(next);                         }                     }                 }             }                          k++;         }                  return -1;     }          public String swap(String s, int i, int j) {         char[] c = s.toCharArray();         char tmp = c[i];         c[i] = c[j];         c[j] = tmp;         return new String(c);     } }",1,"854-k-similar-strings/Solution.java:47:	StringInstantiation:	Avoid instantiating String objects; this is usually unnecessary.
",0,0,0
"class Solution {     public double mincostToHireWorkers(int[] quality, int[] wage, int k) {         int n = quality.length;         double[][] workers = new double[n][2];          // create a 2D array to store the quality and wage ratio of workers         for (int i = 0; i < n; i++) {             workers[i][0] = (double) wage[i] / quality[i];             workers[i][1] = (double) quality[i];         }          // sort the workers array based on the wage to quality ratio         Arrays.sort(workers, (a, b) -> Double.compare(a[0], b[0]));          PriorityQueue<Double> heap = new PriorityQueue<>(k, Collections.reverseOrder());         double totalQuality = 0;                  // iterate over the workers and calculate the total quality of k workers         for (double[] worker : workers) {             heap.offer(worker[1]);             totalQuality += worker[1];              if (heap.size() > k) {                 totalQuality -= heap.poll();             }              if (heap.size() == k) {                 double ratio = heap.peek() * worker[0];                 if (ratio < totalQuality) {                     totalQuality -= heap.poll();                     heap.offer(worker[1]);                     totalQuality += worker[1];                 }             }         }          double minCost = 0;         // calculate the minimum cost to hire a group of k workers         for (Double qualityValue : heap) {             minCost += qualityValue * workers[0][0];         }          return minCost;     } }",1,"857-minimum-cost-to-hire-k-workers/Solution.java:9:	UnnecessaryCast:	Unnecessary cast (double)
",0,0,0
"class Solution {     public int shortestSubarray(int[] nums, int k) {         int n = nums.length;         int[] prefixSum = new int[n+1];         int minLength = n+1;                  // Calculate the prefix sum         for(int i=1; i<=n; i++) {             prefixSum[i] = prefixSum[i-1] + nums[i-1];         }                  // Create a deque to store the indices         Deque<Integer> deque = new ArrayDeque<>();                  // Traverse through the prefix sum array         for(int i=0; i<=n; i++) {             // Remove the indices from the deque where (current prefix sum - deque value) is greater than or equal to k             while(!deque.isEmpty() && prefixSum[i]-prefixSum[deque.peekFirst()]>=k) {                 minLength = Math.min(minLength, i-deque.pollFirst());             }             // Remove the indices from deque where the prefix sum values are greater than the current prefix sum value             while(!deque.isEmpty() && prefixSum[i]<=prefixSum[deque.peekLast()]) {                 deque.pollLast();             }             deque.offerLast(i);         }         return (minLength==n+1) ? -1 : minLength;     } }",0,,0,0,0
"import java.util.*;  class Solution {     public int shortestPathAllKeys(String[] grid) {         int m = grid.length;         int n = grid[0].length();         int endState = 0;         int allKeys = 0;         int startX = 0, startY = 0;         int[][] directions = new int[][]{{-1,0},{1,0},{0,-1},{0,1}};         boolean[][][] visited = new boolean[m][n][64];         Queue<int[]> queue = new LinkedList<>();                  // Find the starting point and record the state of keys and locks         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 char c = grid[i].charAt(j);                 if (c == '@') {                     startX = i;                     startY = j;                 } else if (c >= 'a' && c <= 'f') {                     allKeys |= (1 << (c - 'a'));  // Record the state of all keys                 } else if (c >= 'A' && c <= 'F') {                     endState |= (1 << (c - 'A'));  // Record the state of all locks                 }             }         }                  queue.offer(new int[]{startX, startY, 0});         visited[startX][startY][0] = true;         int step = 0;                  while (!queue.isEmpty()) {             int size = queue.size();             for (int i = 0; i < size; i++) {                 int[] curr = queue.poll();                 int x = curr[0];                 int y = curr[1];                 int state = curr[2];                                  if (state == endState) {                     return step;                 }                                  for (int[] d : directions) {                     int newX = x + d[0];                     int newY = y + d[1];                     int newState = state;                     if (newX < 0 || newX >= m || newY < 0 || newY >= n) {                         continue;                     }                                          char c = grid[newX].charAt(newY);                     if (c == '#') {                         continue;                     }                                          if (c >= 'a' && c <= 'f') {                         newState |= (1 << (c - 'a'));  // Pick up the key                     } else if (c >= 'A' && c <= 'F' && (newState & (1 << (c - 'A'))) == 0) {                         continue;  // Cannot open the lock                     }                                          if (visited[newX][newY][newState]) {                         continue;                     }                                          visited[newX][newY][newState] = true;                     queue.offer(new int[]{newX, newY, newState});                 }             }             step++;         }                  return -1;     } }",1,"864-shortest-path-to-get-all-keys/Solution.java:9:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
864-shortest-path-to-get-all-keys/Solution.java:4:	NPathComplexity:	The method 'shortestPathAllKeys(String[])' has an NPath complexity of 1952, current threshold is 200
864-shortest-path-to-get-all-keys/Solution.java:8:	UnusedLocalVariable:	Avoid unused local variables such as 'allKeys'.
864-shortest-path-to-get-all-keys/Solution.java:37:	PrematureDeclaration:	Declaration of 'x' can be moved closer to its usages
864-shortest-path-to-get-all-keys/Solution.java:38:	PrematureDeclaration:	Declaration of 'y' can be moved closer to its usages
",1,0,0
"import java.util.PriorityQueue;  class Solution {     public int minRefuelStops(int target, int startFuel, int[][] stations) {                  //Initialize variables         int currentPosition = 0;         int refuelCount = 0;         int currentFuel = startFuel;         PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);                  //Loop through all stations         for(int i=0;i<stations.length;i++){                          int distToNext = stations[i][0] - currentPosition;             while(currentFuel < distToNext){                 //If there is not enough fuel to reach next station, use gas from the furthest station that                 //we passed earlier.                 if(pq.isEmpty()){                     return -1;                 }                 currentFuel += pq.poll();                 refuelCount++;             }                          //Go to the next station             currentFuel -= distToNext;             currentPosition = stations[i][0];             pq.offer(stations[i][1]);         }                  //After the last station, keep going until we reach the destination         while(currentPosition + currentFuel < target){             //If there is not enough fuel to reach destination, use gas from the furthest station that             //we passed earlier.             if(pq.isEmpty()){                 return -1;             }             currentFuel += pq.poll();             refuelCount++;         }                  return refuelCount;     } }",1,"871-minimum-number-of-refueling-stops/Solution.java:10:	LooseCoupling:	Avoid using implementation types like 'PriorityQueue'; use the interface instead
871-minimum-number-of-refueling-stops/Solution.java:13:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int nthMagicalNumber(int n, int a, int b) {         int mod = (int)1e9 + 7;         int l = 0, r = Integer.MAX_VALUE;         long lcm = 1L*a*b/gcd(a, b);         while(l + 1 < r){             int mid = (l+r)/2;             if((mid/a + mid/b - mid/lcm) < n) l = mid;             else r = mid;         }         if(l/a + l/b - l/lcm < n) return (int)(((long)l + 1L)*Math.max(a, b)%mod);         return (int)(((long)r + 1L)*Math.max(a, b)%mod);     }          public int gcd(int a, int b){         return b==0 ? a : gcd(b, a%b);     } }",1,"878-nth-magical-number/Solution.java:4:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
878-nth-magical-number/Solution.java:11:	UnnecessaryCast:	Unnecessary cast (long)
878-nth-magical-number/Solution.java:12:	UnnecessaryCast:	Unnecessary cast (long)
",1,0,0
"class Solution {     public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) {         int mod = 1000000007;         int[][] dp = new int[n+1][minProfit+1];         dp[0][0] = 1;         int res = 0;         for (int k = 0; k < group.length; k++) {             int g = group[k], p = profit[k];             for (int i = n; i >= g; i--) {                 for (int j = minProfit; j >= 0; j--) {                     int currProfit = Math.min(j + p, minProfit);                     dp[i][currProfit] += dp[i-g][j];                     dp[i][currProfit] %= mod;                 }             }         }         for (int x : dp[n]) {             res += x;             res %= mod;         }         return res;     } }",1,"879-profitable-schemes/Solution.java:8:13: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int reachableNodes(int[][] edges, int maxMoves, int n) {         // Create adjacency matrix for the original graph         int[][] graph = new int[n][n];         for (int i = 0; i < edges.length; i++) {             int u = edges[i][0];             int v = edges[i][1];             int cnt = edges[i][2];             graph[u][v] = cnt + 1;             graph[v][u] = cnt + 1;         }          // Dijkstra's algorithm to find shortest paths from node 0         int[] dist = new int[n];         Arrays.fill(dist, Integer.MAX_VALUE);         dist[0] = 0;         PriorityQueue<Integer> pq = new PriorityQueue<>((u, v) -> dist[u] - dist[v]);         pq.offer(0);         while (!pq.isEmpty()) {             int u = pq.poll();             for (int v = 0; v < n; v++) {                 if (graph[u][v] > 0) { // Edge exists                     int w = graph[u][v];                     int steps = Math.max(0, maxMoves - dist[u]); // Remaining steps                     int reachable = Math.min(steps, w - 1); // Nodes reachable on this edge                     graph[u][v] -= reachable + 1;                     graph[v][u] -= reachable + 1;                     dist[v] = Math.min(dist[v], dist[u] + w);                     if (dist[v] <= maxMoves && !pq.contains(v)) {                         pq.offer(v);                     }                 }             }         }          // Count reachable nodes in the new graph         int count = 0;         for (int i = 0; i < n; i++) {             if (dist[i] <= maxMoves) {                 count++;             }             for (int j = i+1; j < n; j++) {                 if (graph[i][j] > 0 && dist[i] + dist[j] + graph[i][j] <= 2 * maxMoves) {                     count++;                 }             }         }         return count;     } }",1,"882-reachable-nodes-in-subdivided-graph/Solution.java:5:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
",0,0,1
"class Solution {     public int superEggDrop(int K, int N) {         int[][] dp = new int[K + 1][N + 1];         for (int i = 1; i <= N; i++) {             dp[1][i] = i;         }         for (int i = 2; i <= K; i++) {             for (int j = 1; j <= N; j++) {                 dp[i][j] = Integer.MAX_VALUE;                 for (int x = 1; x <= j; x++) {                     int res = 1 + Math.max(dp[i - 1][x - 1], dp[i][j - x]);                     dp[i][j] = Math.min(dp[i][j], res);                 }             }         }         return dp[K][N];     } }",0,,0,0,0
class Solution {          public int sumSubseqWidths(int[] nums) {         int MOD = 1000000007;                  Arrays.sort(nums);                  long sum = 0;         long mul = 1;         for(int i=0; i<nums.length; i++){             sum = (sum + (nums[i]*mul) - (nums[nums.length-i-1]*mul))%MOD;             mul = (mul*2)%MOD;         }                  return (int)((sum + MOD) % MOD);     } },1,"891-sum-of-subsequence-widths/Solution.java:12:	UselessParentheses:	Useless parentheses.
",0,0,0
"import java.util.*;  class FreqStack {     Map<Integer, Integer> freqMap;     Map<Integer, Stack<Integer>> stackMap;     int maxFreq;      public FreqStack() {         freqMap = new HashMap<>();         stackMap = new HashMap<>();         maxFreq = 0;     }      public void push(int val) {         int freq = freqMap.getOrDefault(val, 0) + 1;         freqMap.put(val, freq);          if (freq > maxFreq) {             maxFreq = freq;         }          stackMap.computeIfAbsent(freq, k -> new Stack<>()).push(val);     }      public int pop() {         int val = stackMap.get(maxFreq).pop();         freqMap.put(val, maxFreq - 1);          if (stackMap.get(maxFreq).isEmpty()) {             maxFreq--;         }          return val;     } }",1,"895-maximum-frequency-stack/FreqStack.java:4:27: Variable 'freqMap' must be private and have accessor methods. [VisibilityModifier]
895-maximum-frequency-stack/FreqStack.java:5:34: Variable 'stackMap' must be private and have accessor methods. [VisibilityModifier]
895-maximum-frequency-stack/FreqStack.java:6:9: Variable 'maxFreq' must be private and have accessor methods. [VisibilityModifier]
895-maximum-frequency-stack/FreqStack.java:8:5: Redundant 'public' modifier. [RedundantModifier]
895-maximum-frequency-stack/FreqStack.java:5:	LooseCoupling:	Avoid using implementation types like 'Stack'; use the interface instead
895-maximum-frequency-stack/FreqStack.java:5:	ReplaceVectorWithList:	Consider replacing this Vector with the newer java.util.List
895-maximum-frequency-stack/FreqStack.java:22:	ReplaceVectorWithList:	Consider replacing this Vector with the newer java.util.List
",0,0,0
"class Solution {     public String orderlyQueue(String s, int k) {         if (k > 1) {             // If k > 1, we can simply sort the characters of the string             char[] sArr = s.toCharArray();             Arrays.sort(sArr);             return new String(sArr);         } else {             // If k = 1, we need to try all possible rotations and find the lexicographically smallest one             String res = s;             for (int i = 0; i < s.length(); i++) {                 String temp = s.substring(i) + s.substring(0, i);                 if (temp.compareTo(res) < 0) {                     res = temp;                 }             }             return res;         }     } }",1,"899-orderly-queue/Solution.java:7:	StringInstantiation:	Avoid instantiating String objects; this is usually unnecessary.
",0,0,0
"class Solution {     public int atMostNGivenDigitSet(String[] digits, int n) {         String strN = String.valueOf(n);         int nDigits = strN.length();         int ans = 0;         for (int i = 1; i < nDigits; i++) {             ans += Math.pow(digits.length, i);         }         for (int i = 0; i < nDigits; i++) {             boolean haveSameNum = false;             for (String digit : digits) {                 if (digit.charAt(0) < strN.charAt(i)) {                     ans += Math.pow(digits.length, nDigits - i - 1);                 } else if (digit.charAt(0) == strN.charAt(i)) {                     haveSameNum = true;                 }             }             if (!haveSameNum) {                 return ans;             }         }         return ans + 1;     } }",0,,0,0,0
class Solution {     public int numPermsDISequence(String s) {         int n = s.length();         int mod = (int)1e9 + 7;         int[][] dp = new int[n+1][n+1];         for (int i = 0; i <= n; i++) {             dp[0][i] = 1;         }         for (int i = 0; i < n; i++) {             if (s.charAt(i) == 'D') {                 int sum = 0;                 for (int j = n-i-1; j >= 0; j--) {                     sum = (sum + dp[i][j+1]) % mod;                     dp[i+1][j] = sum;                 }             } else {                 int sum = 0;                 for (int j = 0; j <= i+1; j++) {                     sum = (sum + dp[i][j]) % mod;                     dp[i+1][j] = sum;                 }             }          }         return dp[n][0];     } },0,,0,0,0
"class Solution {     public int superpalindromesInRange(String left, String right) {         long l = Long.parseLong(left);         long r = Long.parseLong(right);         int ans = 0;          for (int i = 1; i < 10; i++) {             if (isPalindrome(i * i) && i * i >= l && i * i <= r) {                 ans += 1;             }         }         for (int i = 1; i < 10000; i++) {             String s = Integer.toString(i);             StringBuilder rev = new StringBuilder(s).reverse();             long num = Long.parseLong(s + rev.toString());             long square = num * num;             if (square > r) {                 break;             }             if (square >= l && isPalindrome(square)) {                 ans += 1;             }         }         for (int i = 1; i < 10000; i++) {             String s = Integer.toString(i);             StringBuilder rev = new StringBuilder(s).reverse();             long num = Long.parseLong(s + rev.toString().substring(1));             long square = num * num;             if (square > r) {                 break;             }             if (square >= l && isPalindrome(square)) {                 ans += 1;             }         }          return ans;     }      public boolean isPalindrome(long n) {         String s = Long.toString(n);         String rev = new StringBuilder(s).reverse().toString();         return s.equals(rev);     } }",1,"906-super-palindromes/Solution.java:2:	NPathComplexity:	The method 'superpalindromesInRange(String, String)' has an NPath complexity of 245, current threshold is 200
",0,0,0
"class Solution {     public int catMouseGame(int[][] graph) {         int n = graph.length;         int[][][] dp = new int[n][n][2];                  // Initialization         for (int i = 0; i < n; i++) {             for (int j = 0; j < n; j++) {                 dp[i][j][0] = 2;                 dp[i][j][1] = 2;                 // There is only one way to win - (m, c, t) = (0, 0, 1) - when Mouse is at the Hole                 if (i == 0) {                     dp[i][j][0] = 0;                     dp[i][j][1] = 0;                 }                 // If Mouse and Cat are in the same position, Cat wins                 if (i == j) {                     dp[i][j][0] = 1;                     dp[i][j][1] = 1;                 }             }         }                  // The first move should be forced - Mouse goes to 0 and Cat can't go to 0         for (int j = 1; j < n; j++) {             dp[0][j][1] = 0;             dp[0][j][0] = 0;         }                  // DP loop         boolean hasChanged = true;         while (hasChanged) {             hasChanged = false;             for (int m = 1; m < n; m++) {                 for (int c = 1; c < n; c++) {                     for (int t = 0; t < 2; t++) {                         // Skip positions that have already been determined                         if (dp[m][c][t] != 2) continue;                                                  // Check if there is a winning strategy for Mouse                         boolean mouseWin = false;                         for (int next : graph[m]) {                             if (dp[next][c][t] == 0) {                                 // If Mouse can go to a winning position, Mouse wins                                 dp[m][c][t] = 0;                                 hasChanged = true;                                 mouseWin = true;                                 break;                             } else if (dp[next][c][t] == 2) {                                 // If Mouse can go to an undecided position, needs further check                                 mouseWin = true;                             }                         }                         // Check if there is a winning strategy for Cat                         boolean catWin = false;                         for (int next : graph[c]) {                             // Cat can't go to 0                             if (next == 0) continue;                             if (dp[m][next][t ^ 1] == 1) {                                 // If Cat can go to a losing position, Cat wins                                 dp[m][c][t] = 1;                                 hasChanged = true;                                 catWin = true;                                 break;                             } else if (dp[m][next][t ^ 1] == 2) {                                 catWin = true;                             }                         }                         // If there is no winning strategy for either player, it's a draw                         if (!mouseWin) {                             dp[m][c][t] = 1;                             hasChanged = true;                         } else if (!catWin) {                             dp[m][c][t] = 0;                             hasChanged = true;                         }                     }                 }             }         }                  return dp[1][2][0];     } }",1,"913-cat-and-mouse/Solution.java:2:	NPathComplexity:	The method 'catMouseGame(int[][])' has an NPath complexity of 2064, current threshold is 200
913-cat-and-mouse/Solution.java:70:	ConfusingTernary:	Avoid if (x != y) ..; else ..;
",0,0,0
"class Solution {     public int numMusicPlaylists(int n, int goal, int k) {         int mod = 1000000007;                  long[][] dp = new long[goal + 1][n + 1];         dp[0][0] = 1;                  for (int i = 1; i <= goal; i++) {             for (int j = 1; j <= n; j++) {                 dp[i][j] += dp[i - 1][j - 1] * (n - j + 1);                 dp[i][j] += dp[i - 1][j] * Math.max(j - k, 0);                 dp[i][j] %= mod;             }         }                  return (int) dp[goal][n];     } }",0,,0,0,0
"class Solution {     public int minMalwareSpread(int[][] graph, int[] initial) {         int n = graph.length;                  // Use the upper bound for initial count of affected nodes         // Set infected[i] to 0 if it is not in initial, to 1 if it is         int[] infected = new int[n];         for(int i: initial) infected[i] = 1;                  // Use dfs to traverse the graph and count the number of connected infected nodes         int[] count = new int[n];         for(int i: initial) {             boolean[] visited = new boolean[n];             dfs(graph, i, visited, count, infected);         }                  // Find the node that will minimize M(initial)         int minNode = initial[0];         int maxCount = 0;         for(int i: initial) {             if(count[i] == 1 && infected[i] == 1) { // If the node is only infected by one initial node                 return i;             } else if(count[i] > maxCount) {                 maxCount = count[i];                 minNode = i;             }         }         return minNode;     }          private void dfs(int[][] graph, int node, boolean[] visited, int[] count, int[] infected) {         if(visited[node]) return;         visited[node] = true;                  for(int i = 0; i < graph[node].length; i++) {             if(graph[node][i] == 1) {                 count[i]++;                 if(infected[i] == 1) dfs(graph, i, visited, count, infected);             }         }     } }",0,,0,0,0
"class Solution {     public int[] threeEqualParts(int[] arr) {         int[] result = {-1,-1};                  // Get the count of 1's in the given array         int totalOnes = 0;         for(int i=0;i<arr.length;i++){             if(arr[i] == 1){                 totalOnes += 1;             }         }                  // If there are no 1's or number of 1's is not divisible by 3 then cannot be divided into 3 parts         if(totalOnes == 0){             return new int[]{0,arr.length-1};         }         else if(totalOnes % 3 != 0){             return result;         }                  // Get the number of 1's in each part         int onesInEachPart = totalOnes / 3;                  // Find the positions of the first and second part         int firstPartEnd = getPartEnd(arr, onesInEachPart, 0);         int secondPartEnd = getPartEnd(arr, onesInEachPart, firstPartEnd+1);                  // If the third part doesn't end at the end of the array, not possible to divide into three parts         if(thirdPartEnd(arr, onesInEachPart, secondPartEnd+1) != arr.length-1){             return result;         }                  // Skip the leading zeros for all 3 parts         int i = skipLeadingZeros(arr, 0, firstPartEnd);         int j = skipLeadingZeros(arr, firstPartEnd+1, secondPartEnd);         int k = skipLeadingZeros(arr, secondPartEnd+1, arr.length-1);                  // Compare the three parts to see if they are equal         while(i <= firstPartEnd && j <= secondPartEnd && k <= arr.length-1){             if(arr[i] != arr[j] || arr[j] != arr[k]){                 return result;             }             i++;             j++;             k++;         }                  return new int[]{firstPartEnd, secondPartEnd+1};     }          // Returns the index of the end of the current part with onesInEachPart number of 1's     public int getPartEnd(int[] arr, int onesInEachPart, int startIndex){         int countOnes = 0;         for(int i=startIndex;i<arr.length;i++){             if(arr[i] == 1){                 countOnes += 1;             }             if(countOnes == onesInEachPart){                 return i;             }         }         return -1;     }          // Returns the index of the end of the third part with onesInEachPart number of 1's     public int thirdPartEnd(int[] arr, int onesInEachPart, int startIndex){         return getPartEnd(arr, onesInEachPart, startIndex);     }          // Skips the leading zeros and returns the index of the first non-zero element     public int skipLeadingZeros(int[] arr, int startIndex, int endIndex){         while(startIndex <= endIndex && arr[startIndex] == 0){             startIndex++;         }         return startIndex;     } }",1,"927-three-equal-parts/Solution.java:16:9: '}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
927-three-equal-parts/Solution.java:7:	ForLoopCanBeForeach:	This for loop can be replaced by a foreach loop
927-three-equal-parts/Solution.java:73:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'startIndex'
",0,1,1
"class Solution {     public int minMalwareSpread(int[][] graph, int[] initial) {         int n = graph.length;         Set<Integer> initialSet = new HashSet<>(); // To have a constant time check for initial nodes         for(int node : initial) initialSet.add(node);                  int minNode = -1, minInfect = n;         for(int node : initial) {             int count = 0;             boolean[] visited = new boolean[n];             for(int i = 0; i < n; i++) { // Remove the node and connections                 if(i == node || !initialSet.contains(i)) continue;                 if(graph[node][i] == 1) {                     graph[node][i] = 0;                     graph[i][node] = 0;                 }             }             for(int i = 0; i < n; i++) { // Count the total infection from the nodes                 if(!initialSet.contains(i)) continue;                 if(!visited[i]) {                     count++;                     dfs(i, graph, visited);                 }             }             if(count < minInfect || (count == minInfect && node < minNode)) {                 minNode = node;                 minInfect = count;             }             for(int i = 0; i < n; i++) { // Restore the connections again                 if(i == node || !initialSet.contains(i)) continue;                 if(graph[node][i] == 0) {                     graph[node][i] = 1;                     graph[i][node] = 1;                 }             }         }         return minNode;     }          private void dfs(int curr, int[][] graph, boolean[] visited) {         visited[curr] = true;         for(int i = 0; i < graph.length; i++) {             if(graph[curr][i] == 1 && !visited[i]) {                 dfs(i, graph, visited);             }         }     } }",1,"928-minimize-malware-spread-ii/Solution.java:7:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
928-minimize-malware-spread-ii/Solution.java:2:	NPathComplexity:	The method 'minMalwareSpread(int[][], int[])' has an NPath complexity of 1962, current threshold is 200
",1,0,0
"class Solution {     public int[] movesToStamp(String stamp, String target) {         int sLen = stamp.length(), tLen = target.length();         boolean[] visited = new boolean[tLen];         int[] ans = new int[tLen];         List<Integer> stamped = new ArrayList<>();         int stampedCount = 0;         while (stampedCount < tLen) {             boolean doneStamping = false;             for (int i = 0; i <= tLen - sLen; i++) {                 if (!visited[i] && canStamp(target, i, stamp)) {                     stampedCount = doStamp(target, i, sLen, stampedCount, visited);                     ans[stampedCount - 1] = i;                     doneStamping = true;                     if (stampedCount == tLen) break;                 }             }             if (!doneStamping) return new int[0];         }         reverse(ans, 0, stampedCount);         return ans;     }      private boolean canStamp(String target, int startIdx, String stamp) {         for (int i = 0; i < stamp.length(); i++) {             if (target.charAt(startIdx + i) != '*' && target.charAt(startIdx + i) != stamp.charAt(i)) {                 return false;             }         }         return true;     }      private int doStamp(StringBuilder target, int startIdx, int sLen, int stampedCount, boolean[] visited) {         for (int i = 0; i < sLen; i++) {             if (target.charAt(startIdx + i) != '*') {                 target.setCharAt(startIdx + i, '*');                 stampedCount++;                 visited[startIdx + i] = true;             }         }         return stampedCount;     }      private void reverse(int[] ans, int start, int end) {         for (int i = start, j = end - 1; i < j; i++, j--) {             int temp = ans[i];             ans[i] = ans[j];             ans[j] = temp;         }     } }",1,"936-stamping-the-sequence/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
936-stamping-the-sequence/Solution.java:6:	UnusedLocalVariable:	Avoid unused local variables such as 'stamped'.
936-stamping-the-sequence/Solution.java:33:	UnusedPrivateMethod:	Avoid unused private methods such as 'doStamp(StringBuilder, int, int, int, boolean[])'.
936-stamping-the-sequence/Solution.java:37:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'stampedCount'
936-stamping-the-sequence/Solution.java:45:	ForLoopVariableCount:	Too many control variables in the for statement
",1,1,0
"class Solution {     public int distinctSubseqII(String s) {         int n = s.length();         int[] dp = new int[n+1];   // dp[i] stores the number of distinct subsequences of s[0:i-1]         int[] last = new int[26];  // last[i] stores the index of the last occurrence of character ('a'+i) in s                  Arrays.fill(last, -1);         dp[0] = 1;  // empty sequence                  int MOD = (int) 1e9 + 7;         for (int i = 1; i <= n; i++) {             dp[i] = (2 * dp[i-1]) % MOD;  // the two cases: include s[i-1] or not             int j = last[s.charAt(i-1) - 'a'];             if (j != -1) {                 dp[i] = (dp[i] - dp[j-1] + MOD) % MOD;  // subtract the subsequences that contain duplicates             }             last[s.charAt(i-1) - 'a'] = i-1;  // update the index of the last occurrence of s[i-1]         }                  return dp[n] - 1;   // exclude the empty sequence     } }",1,"940-distinct-subsequences-ii/Solution.java:12:	UselessParentheses:	Useless parentheses.
",0,0,0
"class Solution {     public String shortestSuperstring(String[] words) {         int n = words.length;         String[] dp = new String[1 << n];         Arrays.fill(dp, """");                  for (int i = 0; i < n; i++) {             dp[1 << i] = words[i]; // each string itself can be the smallest string         }                  for (int mask = 1; mask < (1 << n); mask++) {             if (dp[mask].equals("""")) { // check if the string for the mask is not set previously                 for (int i = 0; i < n; i++) {                     if (((mask >> i) & 1) == 1) { // check if the current word is already present in the mask                         continue;                     }                                          String curr = words[i];                     String prev = dp[mask ^ (1 << i)]; // get the previously computed string for the mask without the current word                                          int overlap = getOverlap(curr, prev);                     if (dp[mask].equals("""") || dp[mask].length() > prev.length() + curr.length() - overlap) {                         dp[mask] = prev + curr.substring(overlap);                     }                 }             }         }                  return dp[(1 << n) - 1];     }          private int getOverlap(String a, String b) {         int n = a.length();         int m = b.length();                  for (int i = Math.max(1, n - m); i < n; i++) {             boolean flag = true;             for (int j = 0; j < n - i; j++) {                 if (a.charAt(j + i) != b.charAt(j)) {                     flag = false;                     break;                 }             }             if (flag) {                 return n - i;             }         }                  return 0;     } }",1,"943-find-the-shortest-superstring/Solution.java:7:	AvoidArrayLoops:	Arrays.copyOf or System.arraycopy are more efficient
943-find-the-shortest-superstring/Solution.java:12:	LiteralsFirstInComparisons:	Position literals first in String comparisons
943-find-the-shortest-superstring/Solution.java:22:	LiteralsFirstInComparisons:	Position literals first in String comparisons
",0,0,0
"class Solution {     public int largestComponentSize(int[] nums) {         int maxNum = 0;         for (int num : nums) {             maxNum = Math.max(maxNum, num);         }         int[] parent = new int[maxNum + 1];         for (int i = 1; i <= maxNum; i++) {             parent[i] = i;         }         for (int num : nums) {             int root = (int) Math.sqrt(num);             for (int i = 2; i <= root; i++) {                 if (num % i == 0) {                     union(parent, num, i);                     union(parent, num, num / i);                 }             }         }         Map<Integer, Integer> count = new HashMap<>();         int max = 1;         for (int num : nums) {             int root = find(parent, num);             int value = count.compute(root, (k, v) -> v == null ? 1 : v + 1);             max = Math.max(max, value);         }         return max;     }          private void union(int[] parent, int x, int y) {         parent[find(parent, x)] = parent[find(parent, y)];     }          private int find(int[] parent, int x) {         if (parent[x] == x) {             return x;         }         parent[x] = find(parent, parent[x]);         return parent[x];     } }",0,,0,0,0
"class Solution {     public int tallestBillboard(int[] rods) {         int n = rods.length;         int[] dp = new int[5001];         Arrays.fill(dp, -1000);         dp[0] = 0;         for(int i=0; i<n; i++) {             int[] cur = dp.clone();             for(int j=0; j<=5000; j++) {                 if(dp[j] == -1000) continue;                 cur[j + rods[i]] = Math.max(cur[j + rods[i]], dp[j]);                 cur[Math.abs(j-rods[i])] = Math.max(cur[Math.abs(j-rods[i])], dp[j] + Math.min(j, rods[i]));             }             dp = cur;         }         return dp[0];     } }",0,,0,0,0
class Solution {     public int minDeletionSize(String[] strs) {         int deletionSize = 0;         for (int i = 0; i < strs[0].length(); i++) {             for (int j = 1; j < strs.length; j++) {                 if (strs[j-1].charAt(i) > strs[j].charAt(i)) {                     deletionSize++;                     break;                 }             }         }         return deletionSize;     } },0,,0,0,0
"class Solution {     public int leastOpsExpressTarget(int x, int target) {         int pos = 0, neg = 0, k = 0, pos_prev, neg_prev;         while (target > 0) {             int q = target % x;             target /= x;             if (k > 0) {                 pos_prev = Math.min(q * k + pos, (q + 1) * k + neg);                 neg_prev = Math.min((x - q) * k + pos, (x - q - 1) * k + neg);                 pos = pos_prev;                 neg = neg_prev;             } else {                 pos = q * 2;                 neg = (x - q) * 2;             }             k++;         }         return Math.min(pos, k + neg - 1);     } }",1,"964-least-operators-to-express-number/Solution.java:3:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
964-least-operators-to-express-number/Solution.java:6:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'target'
",1,1,0
"/**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     private int count = 0;     public int minCameraCover(TreeNode root) {         if (dfs(root) == 0) count++;         return count;     }          private int dfs(TreeNode root) {         if (root == null) return 2;         int left = dfs(root.left);         int right = dfs(root.right);         if (left == 0 || right == 0) {             count++;             return 1;         }         if (left == 1 || right == 1) {             return 2;         } else {             return 0;         }     } }",0,,0,0,0
"import java.math.BigDecimal;  class Solution {     public boolean isRationalEqual(String s, String t) {         BigDecimal num1 = convertToDecimal(s);         BigDecimal num2 = convertToDecimal(t);         return num1.compareTo(num2) == 0;     }          private BigDecimal convertToDecimal(String s) {         if (s.indexOf('(') == -1) {             return new BigDecimal(s);         }         String[] parts = s.split(""\\(|\\)"");         String nonRepeatingPart = parts[0] + (parts.length == 2 ? parts[1] : """");         String repeatingPart = parts.length == 3 ? parts[2] : """";         String fullNumber = nonRepeatingPart + repeatingPart.repeat(20 / repeatingPart.length() + 1);         BigDecimal result = new BigDecimal(fullNumber.substring(0, 20 + nonRepeatingPart.length()) + "".""                                              + fullNumber.substring(20 + nonRepeatingPart.length()));         return result.stripTrailingZeros();     } }",0,,0,0,0
"import java.util.TreeMap;  class Solution {     public int oddEvenJumps(int[] arr) {         int n = arr.length;         boolean[] oddJumps = new boolean[n];         boolean[] evenJumps = new boolean[n];         oddJumps[n-1] = true;         evenJumps[n-1] = true;         int result = 1;         TreeMap<Integer, Integer> treeMap = new TreeMap<>();         treeMap.put(arr[n-1], n-1);         for (int i = n - 2; i >= 0; i--) {             Integer ceiling = treeMap.ceilingKey(arr[i]);             Integer floor = treeMap.floorKey(arr[i]);             if (ceiling != null) {                 oddJumps[i] = evenJumps[treeMap.get(ceiling)];             }             if (floor != null) {                 evenJumps[i] = oddJumps[treeMap.get(floor)];             }             treeMap.put(arr[i], i);             if (oddJumps[i]) {                 result++;             }         }         return result;     } }",1,"975-odd-even-jump/Solution.java:11:	LooseCoupling:	Avoid using implementation types like 'TreeMap'; use the interface instead
",0,0,0
"class Solution {     int[][] grid;     int rows, cols;     int startX, startY, endX, endY;     int[][] directions = new int[][]{{0,1}, {0,-1}, {1,0}, {-1,0}};          public int uniquePathsIII(int[][] grid) {         this.grid = grid;         rows = grid.length;         cols = grid[0].length;         int emptySquares = 0;                  // Find the start and end square coordinates         for (int i = 0; i < rows; i++) {             for (int j = 0; j < cols; j++) {                 if (grid[i][j] == 1) {                     startX = i;                     startY = j;                 } else if (grid[i][j] == 2) {                     endX = i;                     endY = j;                 } else if (grid[i][j] == 0) {                     emptySquares++;                 }             }         }                  // Perform depth-first search         return dfs(startX, startY, emptySquares);     }          private int dfs(int i, int j, int emptySquares) {         // Return 0 if the current square is out of bounds, is an obstacle or is already visited         if (i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] == -1) {             return 0;         }                  // If we have reached the end square and all non-obstacle squares are visited, return 1         if (grid[i][j] == 2) {             return emptySquares == 0 ? 1 : 0;         }                  // Visit the current square and mark it as visited         grid[i][j] = -1;         emptySquares--;                  // Explore all 4 directions         int totalPaths = 0;         for (int[] dir : directions) {             int nextI = i + dir[0];             int nextJ = j + dir[1];             totalPaths += dfs(nextI, nextJ, emptySquares);         }                  // Unmark the current square and mark it as unvisited         grid[i][j] = 0;         emptySquares++;                  return totalPaths;     } }",1,"980-unique-paths-iii/Solution.java:2:13: Variable 'grid' must be private and have accessor methods. [VisibilityModifier]
980-unique-paths-iii/Solution.java:3:5: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
980-unique-paths-iii/Solution.java:3:9: Variable 'rows' must be private and have accessor methods. [VisibilityModifier]
980-unique-paths-iii/Solution.java:3:15: Variable 'cols' must be private and have accessor methods. [VisibilityModifier]
980-unique-paths-iii/Solution.java:4:5: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
980-unique-paths-iii/Solution.java:4:9: Variable 'startX' must be private and have accessor methods. [VisibilityModifier]
980-unique-paths-iii/Solution.java:4:17: Variable 'startY' must be private and have accessor methods. [VisibilityModifier]
980-unique-paths-iii/Solution.java:4:25: Variable 'endX' must be private and have accessor methods. [VisibilityModifier]
980-unique-paths-iii/Solution.java:4:31: Variable 'endY' must be private and have accessor methods. [VisibilityModifier]
980-unique-paths-iii/Solution.java:5:13: Variable 'directions' must be private and have accessor methods. [VisibilityModifier]
980-unique-paths-iii/Solution.java:7:39: 'grid' hides a field. [HiddenField]
980-unique-paths-iii/Solution.java:8:	ArrayIsStoredDirectly:	The user-supplied array 'grid' is stored directly.
980-unique-paths-iii/Solution.java:20:	UnusedAssignment:	The value assigned to field 'endX' is never used (reassigned every iteration)
980-unique-paths-iii/Solution.java:21:	UnusedAssignment:	The value assigned to field 'endY' is never used (reassigned every iteration)
980-unique-paths-iii/Solution.java:45:	AvoidReassigningParameters:	Avoid reassigning parameters such as 'emptySquares'
980-unique-paths-iii/Solution.java:57:	UnusedAssignment:	The updated value of variable 'emptySquares' is never used
",1,1,0
class Solution {     public int countTriplets(int[] nums) {         int n = nums.length;         int count = 0;          for (int i = 0; i < n; i++) {             for (int j = 0; j < n; j++) {                 for (int k = 0; k < n; k++) {                     if ((nums[i] & nums[j] & nums[k]) == 0) {                         count++;                     }                 }             }         }          return count;     } },0,,0,0,0
"import java.util.*;  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {     public List<List<Integer>> verticalTraversal(TreeNode root) {         // Create a map to store the columns and their nodes         Map<Integer, List<TreeNode>> columnMap = new HashMap<>();         // Create a queue for BFS         Queue<TreeNode> queue = new LinkedList<>();         // Create a map to store the column of each node         Map<TreeNode, Integer> columnOfNode = new HashMap<>();         // Initialize the queue and the maps         queue.add(root);         columnOfNode.put(root, 0);         // Create variables to keep track of the leftmost and rightmost columns         int leftmost = 0;         int rightmost = 0;         // Perform BFS         while (!queue.isEmpty()) {             TreeNode node = queue.poll();             int column = columnOfNode.get(node);             columnMap.putIfAbsent(column, new ArrayList<>());             columnMap.get(column).add(node);             if (node.left != null) {                 queue.add(node.left);                 columnOfNode.put(node.left, column - 1);                 leftmost = Math.min(leftmost, column - 1);             }             if (node.right != null) {                 queue.add(node.right);                 columnOfNode.put(node.right, column + 1);                 rightmost = Math.max(rightmost, column + 1);             }         }         // Create the result list         List<List<Integer>> result = new ArrayList<>();         // Traverse the columns and their nodes in order         for (int column = leftmost; column <= rightmost; column++) {             List<TreeNode> nodes = columnMap.get(column);             nodes.sort((a, b) -> a.val - b.val);             List<Integer> values = new ArrayList<>();             for (TreeNode node : nodes) {                 values.add(node.val);             }             result.add(values);         }         // Return the result         return result;     } }",1,"987-vertical-order-traversal-of-a-binary-tree/TreeNode.java:21:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
987-vertical-order-traversal-of-a-binary-tree/TreeNode.java:25:	UseConcurrentHashMap:	If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation
",0,0,0
"class Solution {     public int subarraysWithKDistinct(int[] nums, int k) {         int n = nums.length;         int ans = 0;                  // Store the frequency of each element in the array         int[] freq = new int[n+1];         int left1 = 0, left2 = 0, distinct1 = 0, distinct2 = 0;                  for (int right = 0; right < n; right++) {             // Update frequency of the current element             freq[nums[right]]++;                          // If a new element is added to subarray, update distinct count             if (freq[nums[right]] == 1) {                 distinct1++;                 distinct2++;             }                          // If distinct count is greater than k, slide the window             while (distinct1 > k) {                 freq[nums[left1]]--;                 if (freq[nums[left1]] == 0) {                     distinct1--;                 }                 left1++;             }                          // If distinct count is greater than or equal to k, count subarrays             while (distinct2 >= k) {                 freq[nums[left2]]--;                 if (freq[nums[left2]] == 0) {                     distinct2--;                 }                 left2++;             }                          ans += left2 - left1;         }         return ans;     } }",1,"992-subarrays-with-k-different-integers/Solution.java:8:9: Each variable declaration must be in its own statement. [MultipleVariableDeclarations]
",1,0,0
"class Solution {     public int minKBitFlips(int[] nums, int k) {         int n = nums.length;         int[] diff = new int[n+1]; // array to keep track of number of differences observed         int ans = 0; // number of flips required                   int revCount = 0; // reverse count, to keep track of odd number of flips required                  for(int i=0; i<n; i++) {             revCount += diff[i]; // update reverse count             if((nums[i] + revCount) % 2 == 0) { // if current number needs to be flipped                 if(i + k > n) return -1; // if not enough elements left to flip, return -1                 ans++; // increment flip count                 revCount++; // update reverse count                 diff[i+k]--; // decrement difference count for future             }         }                  return ans;     } }",0,,0,0,0
"class Solution {     public int numSquarefulPerms(int[] nums) {         // Sort the input array to optimize computations of the permutations         Arrays.sort(nums);         return dfs(nums, 0, 0, new boolean[nums.length]);     }          private int dfs(int[] nums, int index, int prev, boolean[] used) {         // If we have reached the last index of the array, check if the previous sum is a perfect square         if (index == nums.length) return 1;                  int count = 0;         for (int i = 0; i < nums.length; i++) {             // If the current element has not been used and either it is the first index or the sum with the previous index is a perfect square             if (!used[i] && (i == 0 || nums[i] != nums[i-1] || used[i-1] || isSquare(prev + nums[i]))) {                 used[i] = true;                 count += dfs(nums, index+1, nums[i], used);                 used[i] = false;             }         }         return count;     }          private boolean isSquare(int num) {         int root = (int)Math.sqrt(num);         return root*root == num;     } }",0,,0,0,0
